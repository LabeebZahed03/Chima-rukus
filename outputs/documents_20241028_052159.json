[
  {
    "metadata": {
      "description": "A new concept was introduced in React - Hooks. Hooks are an alternative to classes. If you've used React before, you'll be familiar with…",
      "url": "https://www.taniarascia.com/crud-app-in-react-with-hooks/",
      "title": "Build a CRUD App in React with Hooks | Tania Rascia's Personal Website",
      "source_type": "web",
      "crawl_time": 1730107197.131661,
      "keywords": [
        "sql",
        "web",
        "article",
        "extract",
        "development",
        "information",
        "react"
      ]
    },
    "relevance_score": 1.026,
    "chunks": [
      {
        "content": "Build a CRUD App in React with HooksA new concept was introduced in React -Hooks. Hooks are an alternative to classes. If you've used React before, you'll be familiar withsimple (functional) componentsandclass components.Simple componentconstExample=()=>{return<div>I'm a simple component</div>} lass componentclassExampleextendsComponent{render(){return<div>I'm a class component</div>}} any of the features available to classes - such aslifecycle methodsandstate- have not been available to simple components, until now. The new Hooks proposal adds all that functionality and more.I wanted to try out Hooks and see how an app might look without any classes, but I didn't see any examples yet, so I decided to make one myself. I created a simple CRUD (create, read, update, delete) app that utilizes Hooks and no classes, and I created this tutorial for anyone else who wants to learn how to use them as well.If you don't know how to make a simple CRUD app in React, regardless of whether you use classes or hooks, this article will be good for you as well.View Demo AppView SourcePrerequisitesIn order to follow along with this tutorial, you'll need a basic knowledge of HTML, CSS, and JavaScript/ES6. You should also know the fundamentals of React, which you can learn by readingGetting Started with React.GoalsIn this tutorial, we'll make asimple CRUD app. It will have users, and you'll be able to add, update, or delete users. We won't use any React classes, and instead we'll utilize State Hooks and Effect Hooks on functional components. If you get lost along the way, be sure to check outthe source of the completed project.Create React AppWe'll start by installing the project withcreate-react-app(CRA).npx create-react-app react-hooksThen runnpm i.Now you're all set with the React.Initial SetupLet's start off by clearing out all the files from the boilerplate we don't need. Delete everything from the/srcfolder exceptApp.js,index.js, andindex.css.Forindex.css, I just copy and paste the CSS fromPrimitive, a simple CSS boilerplate I made, as the point of this app is to work on React and not care about design. This CSS boilerplate just adds some sensible defaults and a simple grid so we can start prototyping.Inindex.js, we'll simplify it by removing the references to Service Workers.index.jsimportReactfrom'react'importReactDOMfrom'react-dom'import'./index.css'importAppfrom'./App'ReactDOM.render(<App/>,document.getElementById('root'))And inApp.js, I'll make a simple, functional component forAppinstead of a class.App.jsimportReactfrom'react'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2></div></div></div>)} xportdefaultAppNow we have the initial setup and skeleton for the app.State vs. Hook StateIf we look at a very simple example of a class component with state and a functional component with Hook state, we can see the similarities and differences. With class state, you get one main state object, and you update using methods on the class andsetState().I'll make some quick example code, as if it were a library and you have books that have state.Class Component State ExampleclassAppextendsComponent{initialState={title:'',available:false,} tate=initialStateupdateBook=(book)=>{this.setState({title:book.title,available:book.available})}} ith Hook state, there's a getter and setter for each type of state (you can have as many as you want), and we obviously create functions instead of methods.Hook State ExampleconstApp=()=>{constinitialBookState={title:'',available:false,} onst[book,setBook]=useState(initialBookState)constupdateBook=(book)=>{setBook({title:book.title,available:book.available})}} 'm not going to get deep into the rationale behind hooks vs. class components, as you can readall about it on React's Hooks introduction. I'm just going to show you how to work with them to create a functional app.Setting up the ViewThe first thing we'll do is make some sample data and a table to display it, for the view. Create a new directory calledtablesinsrc, and a file within calledUserTable.js. We'll make the skeleton for a table.tables/UserTable.jsimportReactfrom'react'constUserTable=()=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody><tr><td>Name data</td><td>Username data</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr></tbody></table>)exportdefaultUserTableNow just import the file and add in the new component.App.jsimportReactfrom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTable/></div></div></div>)} xportdefaultAppLet's bring in some random dummy data and theuseStateimport from React.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppProps works just as it did before. We'll map through the user data we sent through and display the properties for each user, or display a message if there are no users. The edit and delete buttons aren't hooked up to anything yet, so they won't do anything.UserTable.jsimportReactfrom'react'constUserTable=(props)=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody>{props.users.length>0?(props.users.map((user)=>(<trkey={user.id}><td>{user.name}</td><td>{user.username}</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr>))):(<tr><tdcolSpan={3}>No users</td></tr>)}</tbody></table>)exportdefaultUserTableWe'll get to the edit and delete buttons in a moment. Now that the basic view is set up, let's get the adding functionality working.Adding a new userWe're going to set up the form to add a new user.The very first thing we can do is create the actual function that will add the new user to state. We have thesetUsersfunction automatically fromuseState, so that's what we'll use to update the user state.Since we're not using a real API and database, which would probably have an auto-incrementing ID, I'm going to increment the ID of the new user manually. This function will take auserobject as a parameter, and add them to theusersarray of objects. The...userscode ensures that all the previous users remain in the array.App.jsconstaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} e're going to make a component for this, so I'll just go ahead and add the reference to the component at the top, and insert the component below the \"Add user\" header. We can pass theaddUser()through as a prop. Make sure not to include the parentheses when we pass it through as a reference -<AddUserForm addUser={addUser} />, not<AddUserForm addUser={addUser()} />.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'importAddUserFormfrom'./forms/AddUserForm'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)constaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} eturn(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2><AddUserFormaddUser={addUser}/></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppNow we have to create a form that you can use to add the new user. Let's create aformssubdirectory with a file inside calledAddUserForm.js.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{return(<form><label>Name</label><inputtype=\"text\"name=\"name\"value=\"\"/><label>Username</label><inputtype=\"text\"name=\"username\"value=\"\"/><button>Add new user</button></form>)} xportdefaultAddUserFormRight now, the form is empty, and you cannot add any values to it due to our empty value strings, nor does the submit button do anything.Just like before, we'll want to make some state, except this state will just be temporary, for keeping track of what's currently in the add user form.I'm going to create an initial state with those empty values, and set the user state to the empty values. Having initial state in a variable is useful, because after we submit the form, we can return it to the initial, empty value.AddUserForm.jsconstinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)Now we'll create a function to update the state within the form.eventalways gets passed through to anyonevent in the DOM, so you'll see that as the parameter of the function.",
        "chunk_type": "code_class",
        "tag": "main",
        "score": 1.1219999999999999,
        "word_count": 990,
        "chunk_id": "7dde3fbe0c54b3d7b39138af01f25bdd",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Object destructuring will allow us to easily get thename(key) andvaluefrom the form. Finally, we'll set the user much like we did on theAppcomponent, except this time we're using computed property names to dynamically set the name (using[name]) and value.consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} f you don't understand what's being passed through, try playing around withconsole.log(event)in the input handling function.Now we extract the values from the state object, and reference our function in theonChangeevent.<form><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>The last thing to take care of is actually submitting the form back to theAppcomponent. As we passed the function down withprops, we're going to use props to access the function. I'm going to write anonSubmitfunction, and we'll prevent the default form submission from firing. I added a small bit of validation to make sure empty values cannot be submitted, and sent the user through to the add function. Finally, I'm using the setter to reset the form to its initial value after successful submission.<formonSubmit={event=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}>Fortunately this code is pretty simple, as we don't have to worry about asynchronous API calls.Here is our fullAddUserFormcomponent.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{constinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>)} xportdefaultAddUserFormCool.Deleting a userThe next one we'll tackle is deleting a user, which is the easiest functionality to take care of.BelowaddUserinApp.js, we'll createdeleteUser, which will take the ID of the user and filter them out of the user array.constdeleteUser=(id)=>{setUsers(users.filter((user)=>user.id!==id))} e pass that function through props toUserTable.<UserTableusers={users} eleteUser={deleteUser}/>Now all we need to do inUserTable.jsis make sure the delete button calls that function.<buttononClick={()=>props.deleteUser(user.id)} lassName=\"button muted-button\">Delete</button>Now you can delete some or all of the users.Updating a userThe final piece of the puzzle is introducing the ability to update existing users. This will be similar to adding a user, except we'll have to be able to identify which user is being edited. In class components, we would use thecomponentDidUpdatelifecycle method to achieve this, but now we'll use anEffect Hook. TheEffect Hookis likecomponentDidMountandcomponentDidUpdatecombined.The way we're going to structure this is when the Edit action is selected for a user, the \"Add user\" form will become an \"Edit user\" form, and it will be pre-populated with the data from the selected user. You can either cancel edit mode, or submit the change, which will update the selected user and close out of edit mode.Let's begin. InApp.js, the first thing we'll want to do is make state for whether or not edit mode is turned on. It will begin as false.App.jsconst[editing,setEditing]=useState(false)Since we don't know who is being edited until it's selected, we'll create initial empty state for the form, like we did with the add form.constinitialFormState={id:null,name:'',username:''} e'll want a way to see and update who the current user being edited is, so we'll apply that empty user to acurrentUserstate.const[currentUser,setCurrentUser]=useState(initialFormState)When Edit is selected on a user, it should turn on edit mode, and set the current user, which we'll do in thiseditRowfunction.consteditRow=(user)=>{setEditing(true)setCurrentUser({id:user.id,name:user.name,username:user.username})} ow just pass that function toUserTablelike we did withdeleteUser.<UserTableusers={users} ditRow={editRow} eleteUser={deleteUser}/>Over inUserTable.js, we send theuserobject over.UserTable.js<buttononClick={()=>{props.editRow(user)}} lassName=\"button muted-button\">Edit</button>Now we've got all the setup - there's a switch for edit mode, and a button that will pass the current user into state while flipping the edit mode switch.Let's create the actual function that will get called when the edit form is submitted. Unlike delete (which filters a user out by ID) or add (which appends a user to the array), the update function needs to map through the array, and update the user that matches the ID passed through.This means we'll be taking two parameters - the updated user object, and the id - and we'll use a ternary operation to map through the users and find the one we want to update.App.jsconstupdateUser=(id,updatedUser)=>{setEditing(false)setUsers(users.map((user)=>(user.id===id?updatedUser:user)))} e just need to make the edit form itself.Createforms/EditUserForm.js. Most of it will be the same as the add form. The only difference so far is that we'll set the state directly fromcurrentUservia props. There is also a cancel button that will simply switch off edit mode.EditUserForm.jsimportReact,{useState} rom'react'constEditUserForm=(props)=>{const[user,setUser]=useState(props.currentUser)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()props.updateUser(user.id,user)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Update user</button><buttononClick={()=>props.setEditing(false)} lassName=\"button muted-button\">Cancel</button></form>)} xportdefaultEditUserFormNow we have to bring the edit form intoApp.js, as well as creating a toggle for displaying the add or edit form.First, bring in the component.App.jsimportEditUserFormfrom'./forms/EditUserForm'Then create the toggle. We'll use a ternary operation to check if theeditingstate is true or not. If true, show the edit form. If false, show the add form. Make sure to pass all the functions we created down to the editing component.App.js<divclassName=\"flex-large\">{editing?(<div><h2>Edit user</h2><EditUserFormsetEditing={setEditing} urrentUser={currentUser} pdateUser={updateUser}/></div>):(<div><h2>Add user</h2><AddUserFormaddUser={addUser}/></div>)}</div>Okay, so at this point clicking on the Edit button should toggle edit mode, and you should be able to update a user. But are we done?Using the Effect HookIf you play around with this a little, you mat notice an issue. Two, actually. If you start editing one user, then try to switch to another user, nothing will happen. Why? Well, the component is already open, and although the state on the parent has changed, it's not registered down to the props.This is where the Effect Hook comes into place. We want to let theEditUserFormcomponent know the props have changed, which we would have done before withcomponentDidUpdate.First step is to bring inuseEffect.EditUserForm.jsimportReact,{useState,useEffect} rom'react'EditUserForm.jsuseEffect(()=>{setUser(props.currentUser)},[props])In the Effect Hook, we create a callback function that updates theuserstate with the new prop that's being sent through. Before, we needed to compareif (prevProps.currentUser !== this.state.currentUser), but with the Effect Hook we can just pass[props]through to let it know we're watching props.Using the[props]array is similar to usingcomponentDidUpdate. If you're doing a one-time event likecomponentDidMount, you can pass an empty array ([]) instead.Now if you try to change the user you're editing, it will work correctly!I said there were two issues here, and the other issue is that you can delete a user while it is currently being edited. We can fix this issue by addingsetEditing(false)to thedeleteUserfunction inApp.js.And that's it. We have a complete CRUD app utilizing React State and Effect hooks.ConclusionI didn't cover every use case for Hooks, or all functionality in-depth, but I tried to provide a working example of a complete, albeit simple, React program.",
        "chunk_type": "code_class",
        "tag": "main",
        "score": 1.1219999999999999,
        "word_count": 984,
        "chunk_id": "01db1189459f3f062f332a7661bf86c2",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "extract",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "For a complete FAQ on all things relating to hooks, check out theHooks FAQ.If you got lost anywhere along the way, don't forget to check out the demo and source.View Demo AppView SourceThe next thing to be on the lookout for is theSuspense API.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:November 07, 2018Category:TechnicalTagsjavascriptreactNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "main",
        "score": 1.1219999999999999,
        "word_count": 97,
        "chunk_id": "f216b0cfb411e6939266779e74dfb4e2",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "Build a CRUD App in React with HooksA new concept was introduced in React -Hooks. Hooks are an alternative to classes. If you've used React before, you'll be familiar withsimple (functional) componentsandclass components.Simple componentconstExample=()=>{return<div>I'm a simple component</div>} lass componentclassExampleextendsComponent{render(){return<div>I'm a class component</div>}} any of the features available to classes - such aslifecycle methodsandstate- have not been available to simple components, until now. The new Hooks proposal adds all that functionality and more.I wanted to try out Hooks and see how an app might look without any classes, but I didn't see any examples yet, so I decided to make one myself. I created a simple CRUD (create, read, update, delete) app that utilizes Hooks and no classes, and I created this tutorial for anyone else who wants to learn how to use them as well.If you don't know how to make a simple CRUD app in React, regardless of whether you use classes or hooks, this article will be good for you as well.View Demo AppView SourcePrerequisitesIn order to follow along with this tutorial, you'll need a basic knowledge of HTML, CSS, and JavaScript/ES6. You should also know the fundamentals of React, which you can learn by readingGetting Started with React.GoalsIn this tutorial, we'll make asimple CRUD app. It will have users, and you'll be able to add, update, or delete users. We won't use any React classes, and instead we'll utilize State Hooks and Effect Hooks on functional components. If you get lost along the way, be sure to check outthe source of the completed project.Create React AppWe'll start by installing the project withcreate-react-app(CRA).npx create-react-app react-hooksThen runnpm i.Now you're all set with the React.Initial SetupLet's start off by clearing out all the files from the boilerplate we don't need. Delete everything from the/srcfolder exceptApp.js,index.js, andindex.css.Forindex.css, I just copy and paste the CSS fromPrimitive, a simple CSS boilerplate I made, as the point of this app is to work on React and not care about design. This CSS boilerplate just adds some sensible defaults and a simple grid so we can start prototyping.Inindex.js, we'll simplify it by removing the references to Service Workers.index.jsimportReactfrom'react'importReactDOMfrom'react-dom'import'./index.css'importAppfrom'./App'ReactDOM.render(<App/>,document.getElementById('root'))And inApp.js, I'll make a simple, functional component forAppinstead of a class.App.jsimportReactfrom'react'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2></div></div></div>)} xportdefaultAppNow we have the initial setup and skeleton for the app.State vs. Hook StateIf we look at a very simple example of a class component with state and a functional component with Hook state, we can see the similarities and differences. With class state, you get one main state object, and you update using methods on the class andsetState().I'll make some quick example code, as if it were a library and you have books that have state.Class Component State ExampleclassAppextendsComponent{initialState={title:'',available:false,} tate=initialStateupdateBook=(book)=>{this.setState({title:book.title,available:book.available})}} ith Hook state, there's a getter and setter for each type of state (you can have as many as you want), and we obviously create functions instead of methods.Hook State ExampleconstApp=()=>{constinitialBookState={title:'',available:false,} onst[book,setBook]=useState(initialBookState)constupdateBook=(book)=>{setBook({title:book.title,available:book.available})}} 'm not going to get deep into the rationale behind hooks vs. class components, as you can readall about it on React's Hooks introduction. I'm just going to show you how to work with them to create a functional app.Setting up the ViewThe first thing we'll do is make some sample data and a table to display it, for the view. Create a new directory calledtablesinsrc, and a file within calledUserTable.js. We'll make the skeleton for a table.tables/UserTable.jsimportReactfrom'react'constUserTable=()=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody><tr><td>Name data</td><td>Username data</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr></tbody></table>)exportdefaultUserTableNow just import the file and add in the new component.App.jsimportReactfrom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTable/></div></div></div>)} xportdefaultAppLet's bring in some random dummy data and theuseStateimport from React.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppProps works just as it did before. We'll map through the user data we sent through and display the properties for each user, or display a message if there are no users. The edit and delete buttons aren't hooked up to anything yet, so they won't do anything.UserTable.jsimportReactfrom'react'constUserTable=(props)=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody>{props.users.length>0?(props.users.map((user)=>(<trkey={user.id}><td>{user.name}</td><td>{user.username}</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr>))):(<tr><tdcolSpan={3}>No users</td></tr>)}</tbody></table>)exportdefaultUserTableWe'll get to the edit and delete buttons in a moment. Now that the basic view is set up, let's get the adding functionality working.Adding a new userWe're going to set up the form to add a new user.The very first thing we can do is create the actual function that will add the new user to state. We have thesetUsersfunction automatically fromuseState, so that's what we'll use to update the user state.Since we're not using a real API and database, which would probably have an auto-incrementing ID, I'm going to increment the ID of the new user manually. This function will take auserobject as a parameter, and add them to theusersarray of objects. The...userscode ensures that all the previous users remain in the array.App.jsconstaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} e're going to make a component for this, so I'll just go ahead and add the reference to the component at the top, and insert the component below the \"Add user\" header. We can pass theaddUser()through as a prop. Make sure not to include the parentheses when we pass it through as a reference -<AddUserForm addUser={addUser} />, not<AddUserForm addUser={addUser()} />.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'importAddUserFormfrom'./forms/AddUserForm'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)constaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} eturn(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2><AddUserFormaddUser={addUser}/></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppNow we have to create a form that you can use to add the new user. Let's create aformssubdirectory with a file inside calledAddUserForm.js.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{return(<form><label>Name</label><inputtype=\"text\"name=\"name\"value=\"\"/><label>Username</label><inputtype=\"text\"name=\"username\"value=\"\"/><button>Add new user</button></form>)} xportdefaultAddUserFormRight now, the form is empty, and you cannot add any values to it due to our empty value strings, nor does the submit button do anything.Just like before, we'll want to make some state, except this state will just be temporary, for keeping track of what's currently in the add user form.I'm going to create an initial state with those empty values, and set the user state to the empty values. Having initial state in a variable is useful, because after we submit the form, we can return it to the initial, empty value.AddUserForm.jsconstinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)Now we'll create a function to update the state within the form.eventalways gets passed through to anyonevent in the DOM, so you'll see that as the parameter of the function.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 990,
        "chunk_id": "7dde3fbe0c54b3d7b39138af01f25bdd",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Object destructuring will allow us to easily get thename(key) andvaluefrom the form. Finally, we'll set the user much like we did on theAppcomponent, except this time we're using computed property names to dynamically set the name (using[name]) and value.consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} f you don't understand what's being passed through, try playing around withconsole.log(event)in the input handling function.Now we extract the values from the state object, and reference our function in theonChangeevent.<form><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>The last thing to take care of is actually submitting the form back to theAppcomponent. As we passed the function down withprops, we're going to use props to access the function. I'm going to write anonSubmitfunction, and we'll prevent the default form submission from firing. I added a small bit of validation to make sure empty values cannot be submitted, and sent the user through to the add function. Finally, I'm using the setter to reset the form to its initial value after successful submission.<formonSubmit={event=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}>Fortunately this code is pretty simple, as we don't have to worry about asynchronous API calls.Here is our fullAddUserFormcomponent.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{constinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>)} xportdefaultAddUserFormCool.Deleting a userThe next one we'll tackle is deleting a user, which is the easiest functionality to take care of.BelowaddUserinApp.js, we'll createdeleteUser, which will take the ID of the user and filter them out of the user array.constdeleteUser=(id)=>{setUsers(users.filter((user)=>user.id!==id))} e pass that function through props toUserTable.<UserTableusers={users} eleteUser={deleteUser}/>Now all we need to do inUserTable.jsis make sure the delete button calls that function.<buttononClick={()=>props.deleteUser(user.id)} lassName=\"button muted-button\">Delete</button>Now you can delete some or all of the users.Updating a userThe final piece of the puzzle is introducing the ability to update existing users. This will be similar to adding a user, except we'll have to be able to identify which user is being edited. In class components, we would use thecomponentDidUpdatelifecycle method to achieve this, but now we'll use anEffect Hook. TheEffect Hookis likecomponentDidMountandcomponentDidUpdatecombined.The way we're going to structure this is when the Edit action is selected for a user, the \"Add user\" form will become an \"Edit user\" form, and it will be pre-populated with the data from the selected user. You can either cancel edit mode, or submit the change, which will update the selected user and close out of edit mode.Let's begin. InApp.js, the first thing we'll want to do is make state for whether or not edit mode is turned on. It will begin as false.App.jsconst[editing,setEditing]=useState(false)Since we don't know who is being edited until it's selected, we'll create initial empty state for the form, like we did with the add form.constinitialFormState={id:null,name:'',username:''} e'll want a way to see and update who the current user being edited is, so we'll apply that empty user to acurrentUserstate.const[currentUser,setCurrentUser]=useState(initialFormState)When Edit is selected on a user, it should turn on edit mode, and set the current user, which we'll do in thiseditRowfunction.consteditRow=(user)=>{setEditing(true)setCurrentUser({id:user.id,name:user.name,username:user.username})} ow just pass that function toUserTablelike we did withdeleteUser.<UserTableusers={users} ditRow={editRow} eleteUser={deleteUser}/>Over inUserTable.js, we send theuserobject over.UserTable.js<buttononClick={()=>{props.editRow(user)}} lassName=\"button muted-button\">Edit</button>Now we've got all the setup - there's a switch for edit mode, and a button that will pass the current user into state while flipping the edit mode switch.Let's create the actual function that will get called when the edit form is submitted. Unlike delete (which filters a user out by ID) or add (which appends a user to the array), the update function needs to map through the array, and update the user that matches the ID passed through.This means we'll be taking two parameters - the updated user object, and the id - and we'll use a ternary operation to map through the users and find the one we want to update.App.jsconstupdateUser=(id,updatedUser)=>{setEditing(false)setUsers(users.map((user)=>(user.id===id?updatedUser:user)))} e just need to make the edit form itself.Createforms/EditUserForm.js. Most of it will be the same as the add form. The only difference so far is that we'll set the state directly fromcurrentUservia props. There is also a cancel button that will simply switch off edit mode.EditUserForm.jsimportReact,{useState} rom'react'constEditUserForm=(props)=>{const[user,setUser]=useState(props.currentUser)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()props.updateUser(user.id,user)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Update user</button><buttononClick={()=>props.setEditing(false)} lassName=\"button muted-button\">Cancel</button></form>)} xportdefaultEditUserFormNow we have to bring the edit form intoApp.js, as well as creating a toggle for displaying the add or edit form.First, bring in the component.App.jsimportEditUserFormfrom'./forms/EditUserForm'Then create the toggle. We'll use a ternary operation to check if theeditingstate is true or not. If true, show the edit form. If false, show the add form. Make sure to pass all the functions we created down to the editing component.App.js<divclassName=\"flex-large\">{editing?(<div><h2>Edit user</h2><EditUserFormsetEditing={setEditing} urrentUser={currentUser} pdateUser={updateUser}/></div>):(<div><h2>Add user</h2><AddUserFormaddUser={addUser}/></div>)}</div>Okay, so at this point clicking on the Edit button should toggle edit mode, and you should be able to update a user. But are we done?Using the Effect HookIf you play around with this a little, you mat notice an issue. Two, actually. If you start editing one user, then try to switch to another user, nothing will happen. Why? Well, the component is already open, and although the state on the parent has changed, it's not registered down to the props.This is where the Effect Hook comes into place. We want to let theEditUserFormcomponent know the props have changed, which we would have done before withcomponentDidUpdate.First step is to bring inuseEffect.EditUserForm.jsimportReact,{useState,useEffect} rom'react'EditUserForm.jsuseEffect(()=>{setUser(props.currentUser)},[props])In the Effect Hook, we create a callback function that updates theuserstate with the new prop that's being sent through. Before, we needed to compareif (prevProps.currentUser !== this.state.currentUser), but with the Effect Hook we can just pass[props]through to let it know we're watching props.Using the[props]array is similar to usingcomponentDidUpdate. If you're doing a one-time event likecomponentDidMount, you can pass an empty array ([]) instead.Now if you try to change the user you're editing, it will work correctly!I said there were two issues here, and the other issue is that you can delete a user while it is currently being edited. We can fix this issue by addingsetEditing(false)to thedeleteUserfunction inApp.js.And that's it. We have a complete CRUD app utilizing React State and Effect hooks.ConclusionI didn't cover every use case for Hooks, or all functionality in-depth, but I tried to provide a working example of a complete, albeit simple, React program.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 984,
        "chunk_id": "01db1189459f3f062f332a7661bf86c2",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "extract",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "For a complete FAQ on all things relating to hooks, check out theHooks FAQ.If you got lost anywhere along the way, don't forget to check out the demo and source.View Demo AppView SourceThe next thing to be on the lookout for is theSuspense API.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:November 07, 2018Category:TechnicalTagsjavascriptreactNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 97,
        "chunk_id": "f216b0cfb411e6939266779e74dfb4e2",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "Build a CRUD App in React with HooksA new concept was introduced in React -Hooks. Hooks are an alternative to classes. If you've used React before, you'll be familiar withsimple (functional) componentsandclass components.Simple componentconstExample=()=>{return<div>I'm a simple component</div>} lass componentclassExampleextendsComponent{render(){return<div>I'm a class component</div>}} any of the features available to classes - such aslifecycle methodsandstate- have not been available to simple components, until now. The new Hooks proposal adds all that functionality and more.I wanted to try out Hooks and see how an app might look without any classes, but I didn't see any examples yet, so I decided to make one myself. I created a simple CRUD (create, read, update, delete) app that utilizes Hooks and no classes, and I created this tutorial for anyone else who wants to learn how to use them as well.If you don't know how to make a simple CRUD app in React, regardless of whether you use classes or hooks, this article will be good for you as well.View Demo AppView SourcePrerequisitesIn order to follow along with this tutorial, you'll need a basic knowledge of HTML, CSS, and JavaScript/ES6. You should also know the fundamentals of React, which you can learn by readingGetting Started with React.GoalsIn this tutorial, we'll make asimple CRUD app. It will have users, and you'll be able to add, update, or delete users. We won't use any React classes, and instead we'll utilize State Hooks and Effect Hooks on functional components. If you get lost along the way, be sure to check outthe source of the completed project.Create React AppWe'll start by installing the project withcreate-react-app(CRA).npx create-react-app react-hooksThen runnpm i.Now you're all set with the React.Initial SetupLet's start off by clearing out all the files from the boilerplate we don't need. Delete everything from the/srcfolder exceptApp.js,index.js, andindex.css.Forindex.css, I just copy and paste the CSS fromPrimitive, a simple CSS boilerplate I made, as the point of this app is to work on React and not care about design. This CSS boilerplate just adds some sensible defaults and a simple grid so we can start prototyping.Inindex.js, we'll simplify it by removing the references to Service Workers.index.jsimportReactfrom'react'importReactDOMfrom'react-dom'import'./index.css'importAppfrom'./App'ReactDOM.render(<App/>,document.getElementById('root'))And inApp.js, I'll make a simple, functional component forAppinstead of a class.App.jsimportReactfrom'react'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2></div></div></div>)} xportdefaultAppNow we have the initial setup and skeleton for the app.State vs. Hook StateIf we look at a very simple example of a class component with state and a functional component with Hook state, we can see the similarities and differences. With class state, you get one main state object, and you update using methods on the class andsetState().I'll make some quick example code, as if it were a library and you have books that have state.Class Component State ExampleclassAppextendsComponent{initialState={title:'',available:false,} tate=initialStateupdateBook=(book)=>{this.setState({title:book.title,available:book.available})}} ith Hook state, there's a getter and setter for each type of state (you can have as many as you want), and we obviously create functions instead of methods.Hook State ExampleconstApp=()=>{constinitialBookState={title:'',available:false,} onst[book,setBook]=useState(initialBookState)constupdateBook=(book)=>{setBook({title:book.title,available:book.available})}} 'm not going to get deep into the rationale behind hooks vs. class components, as you can readall about it on React's Hooks introduction. I'm just going to show you how to work with them to create a functional app.Setting up the ViewThe first thing we'll do is make some sample data and a table to display it, for the view. Create a new directory calledtablesinsrc, and a file within calledUserTable.js. We'll make the skeleton for a table.tables/UserTable.jsimportReactfrom'react'constUserTable=()=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody><tr><td>Name data</td><td>Username data</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr></tbody></table>)exportdefaultUserTableNow just import the file and add in the new component.App.jsimportReactfrom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTable/></div></div></div>)} xportdefaultAppLet's bring in some random dummy data and theuseStateimport from React.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppProps works just as it did before. We'll map through the user data we sent through and display the properties for each user, or display a message if there are no users. The edit and delete buttons aren't hooked up to anything yet, so they won't do anything.UserTable.jsimportReactfrom'react'constUserTable=(props)=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody>{props.users.length>0?(props.users.map((user)=>(<trkey={user.id}><td>{user.name}</td><td>{user.username}</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr>))):(<tr><tdcolSpan={3}>No users</td></tr>)}</tbody></table>)exportdefaultUserTableWe'll get to the edit and delete buttons in a moment. Now that the basic view is set up, let's get the adding functionality working.Adding a new userWe're going to set up the form to add a new user.The very first thing we can do is create the actual function that will add the new user to state. We have thesetUsersfunction automatically fromuseState, so that's what we'll use to update the user state.Since we're not using a real API and database, which would probably have an auto-incrementing ID, I'm going to increment the ID of the new user manually. This function will take auserobject as a parameter, and add them to theusersarray of objects. The...userscode ensures that all the previous users remain in the array.App.jsconstaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} e're going to make a component for this, so I'll just go ahead and add the reference to the component at the top, and insert the component below the \"Add user\" header. We can pass theaddUser()through as a prop. Make sure not to include the parentheses when we pass it through as a reference -<AddUserForm addUser={addUser} />, not<AddUserForm addUser={addUser()} />.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'importAddUserFormfrom'./forms/AddUserForm'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)constaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} eturn(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2><AddUserFormaddUser={addUser}/></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppNow we have to create a form that you can use to add the new user. Let's create aformssubdirectory with a file inside calledAddUserForm.js.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{return(<form><label>Name</label><inputtype=\"text\"name=\"name\"value=\"\"/><label>Username</label><inputtype=\"text\"name=\"username\"value=\"\"/><button>Add new user</button></form>)} xportdefaultAddUserFormRight now, the form is empty, and you cannot add any values to it due to our empty value strings, nor does the submit button do anything.Just like before, we'll want to make some state, except this state will just be temporary, for keeping track of what's currently in the add user form.I'm going to create an initial state with those empty values, and set the user state to the empty values. Having initial state in a variable is useful, because after we submit the form, we can return it to the initial, empty value.AddUserForm.jsconstinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)Now we'll create a function to update the state within the form.eventalways gets passed through to anyonevent in the DOM, so you'll see that as the parameter of the function.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 990,
        "chunk_id": "7dde3fbe0c54b3d7b39138af01f25bdd",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Object destructuring will allow us to easily get thename(key) andvaluefrom the form. Finally, we'll set the user much like we did on theAppcomponent, except this time we're using computed property names to dynamically set the name (using[name]) and value.consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} f you don't understand what's being passed through, try playing around withconsole.log(event)in the input handling function.Now we extract the values from the state object, and reference our function in theonChangeevent.<form><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>The last thing to take care of is actually submitting the form back to theAppcomponent. As we passed the function down withprops, we're going to use props to access the function. I'm going to write anonSubmitfunction, and we'll prevent the default form submission from firing. I added a small bit of validation to make sure empty values cannot be submitted, and sent the user through to the add function. Finally, I'm using the setter to reset the form to its initial value after successful submission.<formonSubmit={event=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}>Fortunately this code is pretty simple, as we don't have to worry about asynchronous API calls.Here is our fullAddUserFormcomponent.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{constinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>)} xportdefaultAddUserFormCool.Deleting a userThe next one we'll tackle is deleting a user, which is the easiest functionality to take care of.BelowaddUserinApp.js, we'll createdeleteUser, which will take the ID of the user and filter them out of the user array.constdeleteUser=(id)=>{setUsers(users.filter((user)=>user.id!==id))} e pass that function through props toUserTable.<UserTableusers={users} eleteUser={deleteUser}/>Now all we need to do inUserTable.jsis make sure the delete button calls that function.<buttononClick={()=>props.deleteUser(user.id)} lassName=\"button muted-button\">Delete</button>Now you can delete some or all of the users.Updating a userThe final piece of the puzzle is introducing the ability to update existing users. This will be similar to adding a user, except we'll have to be able to identify which user is being edited. In class components, we would use thecomponentDidUpdatelifecycle method to achieve this, but now we'll use anEffect Hook. TheEffect Hookis likecomponentDidMountandcomponentDidUpdatecombined.The way we're going to structure this is when the Edit action is selected for a user, the \"Add user\" form will become an \"Edit user\" form, and it will be pre-populated with the data from the selected user. You can either cancel edit mode, or submit the change, which will update the selected user and close out of edit mode.Let's begin. InApp.js, the first thing we'll want to do is make state for whether or not edit mode is turned on. It will begin as false.App.jsconst[editing,setEditing]=useState(false)Since we don't know who is being edited until it's selected, we'll create initial empty state for the form, like we did with the add form.constinitialFormState={id:null,name:'',username:''} e'll want a way to see and update who the current user being edited is, so we'll apply that empty user to acurrentUserstate.const[currentUser,setCurrentUser]=useState(initialFormState)When Edit is selected on a user, it should turn on edit mode, and set the current user, which we'll do in thiseditRowfunction.consteditRow=(user)=>{setEditing(true)setCurrentUser({id:user.id,name:user.name,username:user.username})} ow just pass that function toUserTablelike we did withdeleteUser.<UserTableusers={users} ditRow={editRow} eleteUser={deleteUser}/>Over inUserTable.js, we send theuserobject over.UserTable.js<buttononClick={()=>{props.editRow(user)}} lassName=\"button muted-button\">Edit</button>Now we've got all the setup - there's a switch for edit mode, and a button that will pass the current user into state while flipping the edit mode switch.Let's create the actual function that will get called when the edit form is submitted. Unlike delete (which filters a user out by ID) or add (which appends a user to the array), the update function needs to map through the array, and update the user that matches the ID passed through.This means we'll be taking two parameters - the updated user object, and the id - and we'll use a ternary operation to map through the users and find the one we want to update.App.jsconstupdateUser=(id,updatedUser)=>{setEditing(false)setUsers(users.map((user)=>(user.id===id?updatedUser:user)))} e just need to make the edit form itself.Createforms/EditUserForm.js. Most of it will be the same as the add form. The only difference so far is that we'll set the state directly fromcurrentUservia props. There is also a cancel button that will simply switch off edit mode.EditUserForm.jsimportReact,{useState} rom'react'constEditUserForm=(props)=>{const[user,setUser]=useState(props.currentUser)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()props.updateUser(user.id,user)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Update user</button><buttononClick={()=>props.setEditing(false)} lassName=\"button muted-button\">Cancel</button></form>)} xportdefaultEditUserFormNow we have to bring the edit form intoApp.js, as well as creating a toggle for displaying the add or edit form.First, bring in the component.App.jsimportEditUserFormfrom'./forms/EditUserForm'Then create the toggle. We'll use a ternary operation to check if theeditingstate is true or not. If true, show the edit form. If false, show the add form. Make sure to pass all the functions we created down to the editing component.App.js<divclassName=\"flex-large\">{editing?(<div><h2>Edit user</h2><EditUserFormsetEditing={setEditing} urrentUser={currentUser} pdateUser={updateUser}/></div>):(<div><h2>Add user</h2><AddUserFormaddUser={addUser}/></div>)}</div>Okay, so at this point clicking on the Edit button should toggle edit mode, and you should be able to update a user. But are we done?Using the Effect HookIf you play around with this a little, you mat notice an issue. Two, actually. If you start editing one user, then try to switch to another user, nothing will happen. Why? Well, the component is already open, and although the state on the parent has changed, it's not registered down to the props.This is where the Effect Hook comes into place. We want to let theEditUserFormcomponent know the props have changed, which we would have done before withcomponentDidUpdate.First step is to bring inuseEffect.EditUserForm.jsimportReact,{useState,useEffect} rom'react'EditUserForm.jsuseEffect(()=>{setUser(props.currentUser)},[props])In the Effect Hook, we create a callback function that updates theuserstate with the new prop that's being sent through. Before, we needed to compareif (prevProps.currentUser !== this.state.currentUser), but with the Effect Hook we can just pass[props]through to let it know we're watching props.Using the[props]array is similar to usingcomponentDidUpdate. If you're doing a one-time event likecomponentDidMount, you can pass an empty array ([]) instead.Now if you try to change the user you're editing, it will work correctly!I said there were two issues here, and the other issue is that you can delete a user while it is currently being edited. We can fix this issue by addingsetEditing(false)to thedeleteUserfunction inApp.js.And that's it. We have a complete CRUD app utilizing React State and Effect hooks.ConclusionI didn't cover every use case for Hooks, or all functionality in-depth, but I tried to provide a working example of a complete, albeit simple, React program.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 984,
        "chunk_id": "01db1189459f3f062f332a7661bf86c2",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "extract",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "For a complete FAQ on all things relating to hooks, check out theHooks FAQ.If you got lost anywhere along the way, don't forget to check out the demo and source.View Demo AppView SourceThe next thing to be on the lookout for is theSuspense API.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:November 07, 2018Category:TechnicalTagsjavascriptreactNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 97,
        "chunk_id": "f216b0cfb411e6939266779e74dfb4e2",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "Build a CRUD App in React with HooksA new concept was introduced in React -Hooks. Hooks are an alternative to classes. If you've used React before, you'll be familiar withsimple (functional) componentsandclass components.Simple componentconstExample=()=>{return<div>I'm a simple component</div>} lass componentclassExampleextendsComponent{render(){return<div>I'm a class component</div>}} any of the features available to classes - such aslifecycle methodsandstate- have not been available to simple components, until now. The new Hooks proposal adds all that functionality and more.I wanted to try out Hooks and see how an app might look without any classes, but I didn't see any examples yet, so I decided to make one myself. I created a simple CRUD (create, read, update, delete) app that utilizes Hooks and no classes, and I created this tutorial for anyone else who wants to learn how to use them as well.If you don't know how to make a simple CRUD app in React, regardless of whether you use classes or hooks, this article will be good for you as well.View Demo AppView SourcePrerequisitesIn order to follow along with this tutorial, you'll need a basic knowledge of HTML, CSS, and JavaScript/ES6. You should also know the fundamentals of React, which you can learn by readingGetting Started with React.GoalsIn this tutorial, we'll make asimple CRUD app. It will have users, and you'll be able to add, update, or delete users. We won't use any React classes, and instead we'll utilize State Hooks and Effect Hooks on functional components. If you get lost along the way, be sure to check outthe source of the completed project.Create React AppWe'll start by installing the project withcreate-react-app(CRA).npx create-react-app react-hooksThen runnpm i.Now you're all set with the React.Initial SetupLet's start off by clearing out all the files from the boilerplate we don't need. Delete everything from the/srcfolder exceptApp.js,index.js, andindex.css.Forindex.css, I just copy and paste the CSS fromPrimitive, a simple CSS boilerplate I made, as the point of this app is to work on React and not care about design. This CSS boilerplate just adds some sensible defaults and a simple grid so we can start prototyping.Inindex.js, we'll simplify it by removing the references to Service Workers.index.jsimportReactfrom'react'importReactDOMfrom'react-dom'import'./index.css'importAppfrom'./App'ReactDOM.render(<App/>,document.getElementById('root'))And inApp.js, I'll make a simple, functional component forAppinstead of a class.App.jsimportReactfrom'react'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2></div></div></div>)} xportdefaultAppNow we have the initial setup and skeleton for the app.State vs. Hook StateIf we look at a very simple example of a class component with state and a functional component with Hook state, we can see the similarities and differences. With class state, you get one main state object, and you update using methods on the class andsetState().I'll make some quick example code, as if it were a library and you have books that have state.Class Component State ExampleclassAppextendsComponent{initialState={title:'',available:false,} tate=initialStateupdateBook=(book)=>{this.setState({title:book.title,available:book.available})}} ith Hook state, there's a getter and setter for each type of state (you can have as many as you want), and we obviously create functions instead of methods.Hook State ExampleconstApp=()=>{constinitialBookState={title:'',available:false,} onst[book,setBook]=useState(initialBookState)constupdateBook=(book)=>{setBook({title:book.title,available:book.available})}} 'm not going to get deep into the rationale behind hooks vs. class components, as you can readall about it on React's Hooks introduction. I'm just going to show you how to work with them to create a functional app.Setting up the ViewThe first thing we'll do is make some sample data and a table to display it, for the view. Create a new directory calledtablesinsrc, and a file within calledUserTable.js. We'll make the skeleton for a table.tables/UserTable.jsimportReactfrom'react'constUserTable=()=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody><tr><td>Name data</td><td>Username data</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr></tbody></table>)exportdefaultUserTableNow just import the file and add in the new component.App.jsimportReactfrom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTable/></div></div></div>)} xportdefaultAppLet's bring in some random dummy data and theuseStateimport from React.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppProps works just as it did before. We'll map through the user data we sent through and display the properties for each user, or display a message if there are no users. The edit and delete buttons aren't hooked up to anything yet, so they won't do anything.UserTable.jsimportReactfrom'react'constUserTable=(props)=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody>{props.users.length>0?(props.users.map((user)=>(<trkey={user.id}><td>{user.name}</td><td>{user.username}</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr>))):(<tr><tdcolSpan={3}>No users</td></tr>)}</tbody></table>)exportdefaultUserTableWe'll get to the edit and delete buttons in a moment. Now that the basic view is set up, let's get the adding functionality working.Adding a new userWe're going to set up the form to add a new user.The very first thing we can do is create the actual function that will add the new user to state. We have thesetUsersfunction automatically fromuseState, so that's what we'll use to update the user state.Since we're not using a real API and database, which would probably have an auto-incrementing ID, I'm going to increment the ID of the new user manually. This function will take auserobject as a parameter, and add them to theusersarray of objects. The...userscode ensures that all the previous users remain in the array.App.jsconstaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} e're going to make a component for this, so I'll just go ahead and add the reference to the component at the top, and insert the component below the \"Add user\" header. We can pass theaddUser()through as a prop. Make sure not to include the parentheses when we pass it through as a reference -<AddUserForm addUser={addUser} />, not<AddUserForm addUser={addUser()} />.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'importAddUserFormfrom'./forms/AddUserForm'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)constaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} eturn(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2><AddUserFormaddUser={addUser}/></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppNow we have to create a form that you can use to add the new user. Let's create aformssubdirectory with a file inside calledAddUserForm.js.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{return(<form><label>Name</label><inputtype=\"text\"name=\"name\"value=\"\"/><label>Username</label><inputtype=\"text\"name=\"username\"value=\"\"/><button>Add new user</button></form>)} xportdefaultAddUserFormRight now, the form is empty, and you cannot add any values to it due to our empty value strings, nor does the submit button do anything.Just like before, we'll want to make some state, except this state will just be temporary, for keeping track of what's currently in the add user form.I'm going to create an initial state with those empty values, and set the user state to the empty values. Having initial state in a variable is useful, because after we submit the form, we can return it to the initial, empty value.AddUserForm.jsconstinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)Now we'll create a function to update the state within the form.eventalways gets passed through to anyonevent in the DOM, so you'll see that as the parameter of the function.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 990,
        "chunk_id": "7dde3fbe0c54b3d7b39138af01f25bdd",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Object destructuring will allow us to easily get thename(key) andvaluefrom the form. Finally, we'll set the user much like we did on theAppcomponent, except this time we're using computed property names to dynamically set the name (using[name]) and value.consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} f you don't understand what's being passed through, try playing around withconsole.log(event)in the input handling function.Now we extract the values from the state object, and reference our function in theonChangeevent.<form><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>The last thing to take care of is actually submitting the form back to theAppcomponent. As we passed the function down withprops, we're going to use props to access the function. I'm going to write anonSubmitfunction, and we'll prevent the default form submission from firing. I added a small bit of validation to make sure empty values cannot be submitted, and sent the user through to the add function. Finally, I'm using the setter to reset the form to its initial value after successful submission.<formonSubmit={event=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}>Fortunately this code is pretty simple, as we don't have to worry about asynchronous API calls.Here is our fullAddUserFormcomponent.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{constinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>)} xportdefaultAddUserFormCool.Deleting a userThe next one we'll tackle is deleting a user, which is the easiest functionality to take care of.BelowaddUserinApp.js, we'll createdeleteUser, which will take the ID of the user and filter them out of the user array.constdeleteUser=(id)=>{setUsers(users.filter((user)=>user.id!==id))} e pass that function through props toUserTable.<UserTableusers={users} eleteUser={deleteUser}/>Now all we need to do inUserTable.jsis make sure the delete button calls that function.<buttononClick={()=>props.deleteUser(user.id)} lassName=\"button muted-button\">Delete</button>Now you can delete some or all of the users.Updating a userThe final piece of the puzzle is introducing the ability to update existing users. This will be similar to adding a user, except we'll have to be able to identify which user is being edited. In class components, we would use thecomponentDidUpdatelifecycle method to achieve this, but now we'll use anEffect Hook. TheEffect Hookis likecomponentDidMountandcomponentDidUpdatecombined.The way we're going to structure this is when the Edit action is selected for a user, the \"Add user\" form will become an \"Edit user\" form, and it will be pre-populated with the data from the selected user. You can either cancel edit mode, or submit the change, which will update the selected user and close out of edit mode.Let's begin. InApp.js, the first thing we'll want to do is make state for whether or not edit mode is turned on. It will begin as false.App.jsconst[editing,setEditing]=useState(false)Since we don't know who is being edited until it's selected, we'll create initial empty state for the form, like we did with the add form.constinitialFormState={id:null,name:'',username:''} e'll want a way to see and update who the current user being edited is, so we'll apply that empty user to acurrentUserstate.const[currentUser,setCurrentUser]=useState(initialFormState)When Edit is selected on a user, it should turn on edit mode, and set the current user, which we'll do in thiseditRowfunction.consteditRow=(user)=>{setEditing(true)setCurrentUser({id:user.id,name:user.name,username:user.username})} ow just pass that function toUserTablelike we did withdeleteUser.<UserTableusers={users} ditRow={editRow} eleteUser={deleteUser}/>Over inUserTable.js, we send theuserobject over.UserTable.js<buttononClick={()=>{props.editRow(user)}} lassName=\"button muted-button\">Edit</button>Now we've got all the setup - there's a switch for edit mode, and a button that will pass the current user into state while flipping the edit mode switch.Let's create the actual function that will get called when the edit form is submitted. Unlike delete (which filters a user out by ID) or add (which appends a user to the array), the update function needs to map through the array, and update the user that matches the ID passed through.This means we'll be taking two parameters - the updated user object, and the id - and we'll use a ternary operation to map through the users and find the one we want to update.App.jsconstupdateUser=(id,updatedUser)=>{setEditing(false)setUsers(users.map((user)=>(user.id===id?updatedUser:user)))} e just need to make the edit form itself.Createforms/EditUserForm.js. Most of it will be the same as the add form. The only difference so far is that we'll set the state directly fromcurrentUservia props. There is also a cancel button that will simply switch off edit mode.EditUserForm.jsimportReact,{useState} rom'react'constEditUserForm=(props)=>{const[user,setUser]=useState(props.currentUser)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()props.updateUser(user.id,user)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Update user</button><buttononClick={()=>props.setEditing(false)} lassName=\"button muted-button\">Cancel</button></form>)} xportdefaultEditUserFormNow we have to bring the edit form intoApp.js, as well as creating a toggle for displaying the add or edit form.First, bring in the component.App.jsimportEditUserFormfrom'./forms/EditUserForm'Then create the toggle. We'll use a ternary operation to check if theeditingstate is true or not. If true, show the edit form. If false, show the add form. Make sure to pass all the functions we created down to the editing component.App.js<divclassName=\"flex-large\">{editing?(<div><h2>Edit user</h2><EditUserFormsetEditing={setEditing} urrentUser={currentUser} pdateUser={updateUser}/></div>):(<div><h2>Add user</h2><AddUserFormaddUser={addUser}/></div>)}</div>Okay, so at this point clicking on the Edit button should toggle edit mode, and you should be able to update a user. But are we done?Using the Effect HookIf you play around with this a little, you mat notice an issue. Two, actually. If you start editing one user, then try to switch to another user, nothing will happen. Why? Well, the component is already open, and although the state on the parent has changed, it's not registered down to the props.This is where the Effect Hook comes into place. We want to let theEditUserFormcomponent know the props have changed, which we would have done before withcomponentDidUpdate.First step is to bring inuseEffect.EditUserForm.jsimportReact,{useState,useEffect} rom'react'EditUserForm.jsuseEffect(()=>{setUser(props.currentUser)},[props])In the Effect Hook, we create a callback function that updates theuserstate with the new prop that's being sent through. Before, we needed to compareif (prevProps.currentUser !== this.state.currentUser), but with the Effect Hook we can just pass[props]through to let it know we're watching props.Using the[props]array is similar to usingcomponentDidUpdate. If you're doing a one-time event likecomponentDidMount, you can pass an empty array ([]) instead.Now if you try to change the user you're editing, it will work correctly!I said there were two issues here, and the other issue is that you can delete a user while it is currently being edited. We can fix this issue by addingsetEditing(false)to thedeleteUserfunction inApp.js.And that's it. We have a complete CRUD app utilizing React State and Effect hooks.ConclusionI didn't cover every use case for Hooks, or all functionality in-depth, but I tried to provide a working example of a complete, albeit simple, React program.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 984,
        "chunk_id": "01db1189459f3f062f332a7661bf86c2",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "extract",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "For a complete FAQ on all things relating to hooks, check out theHooks FAQ.If you got lost anywhere along the way, don't forget to check out the demo and source.View Demo AppView SourceThe next thing to be on the lookout for is theSuspense API.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:November 07, 2018Category:TechnicalTagsjavascriptreactNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 97,
        "chunk_id": "f216b0cfb411e6939266779e74dfb4e2",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "Build a CRUD App in React with HooksA new concept was introduced in React -Hooks. Hooks are an alternative to classes. If you've used React before, you'll be familiar withsimple (functional) componentsandclass components.Simple componentconstExample=()=>{return<div>I'm a simple component</div>} lass componentclassExampleextendsComponent{render(){return<div>I'm a class component</div>}} any of the features available to classes - such aslifecycle methodsandstate- have not been available to simple components, until now. The new Hooks proposal adds all that functionality and more.I wanted to try out Hooks and see how an app might look without any classes, but I didn't see any examples yet, so I decided to make one myself. I created a simple CRUD (create, read, update, delete) app that utilizes Hooks and no classes, and I created this tutorial for anyone else who wants to learn how to use them as well.If you don't know how to make a simple CRUD app in React, regardless of whether you use classes or hooks, this article will be good for you as well.View Demo AppView SourcePrerequisitesIn order to follow along with this tutorial, you'll need a basic knowledge of HTML, CSS, and JavaScript/ES6. You should also know the fundamentals of React, which you can learn by readingGetting Started with React.GoalsIn this tutorial, we'll make asimple CRUD app. It will have users, and you'll be able to add, update, or delete users. We won't use any React classes, and instead we'll utilize State Hooks and Effect Hooks on functional components. If you get lost along the way, be sure to check outthe source of the completed project.Create React AppWe'll start by installing the project withcreate-react-app(CRA).npx create-react-app react-hooksThen runnpm i.Now you're all set with the React.Initial SetupLet's start off by clearing out all the files from the boilerplate we don't need. Delete everything from the/srcfolder exceptApp.js,index.js, andindex.css.Forindex.css, I just copy and paste the CSS fromPrimitive, a simple CSS boilerplate I made, as the point of this app is to work on React and not care about design. This CSS boilerplate just adds some sensible defaults and a simple grid so we can start prototyping.Inindex.js, we'll simplify it by removing the references to Service Workers.index.jsimportReactfrom'react'importReactDOMfrom'react-dom'import'./index.css'importAppfrom'./App'ReactDOM.render(<App/>,document.getElementById('root'))And inApp.js, I'll make a simple, functional component forAppinstead of a class.App.jsimportReactfrom'react'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2></div></div></div>)} xportdefaultAppNow we have the initial setup and skeleton for the app.State vs. Hook StateIf we look at a very simple example of a class component with state and a functional component with Hook state, we can see the similarities and differences. With class state, you get one main state object, and you update using methods on the class andsetState().I'll make some quick example code, as if it were a library and you have books that have state.Class Component State ExampleclassAppextendsComponent{initialState={title:'',available:false,} tate=initialStateupdateBook=(book)=>{this.setState({title:book.title,available:book.available})}} ith Hook state, there's a getter and setter for each type of state (you can have as many as you want), and we obviously create functions instead of methods.Hook State ExampleconstApp=()=>{constinitialBookState={title:'',available:false,} onst[book,setBook]=useState(initialBookState)constupdateBook=(book)=>{setBook({title:book.title,available:book.available})}} 'm not going to get deep into the rationale behind hooks vs. class components, as you can readall about it on React's Hooks introduction. I'm just going to show you how to work with them to create a functional app.Setting up the ViewThe first thing we'll do is make some sample data and a table to display it, for the view. Create a new directory calledtablesinsrc, and a file within calledUserTable.js. We'll make the skeleton for a table.tables/UserTable.jsimportReactfrom'react'constUserTable=()=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody><tr><td>Name data</td><td>Username data</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr></tbody></table>)exportdefaultUserTableNow just import the file and add in the new component.App.jsimportReactfrom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTable/></div></div></div>)} xportdefaultAppLet's bring in some random dummy data and theuseStateimport from React.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppProps works just as it did before. We'll map through the user data we sent through and display the properties for each user, or display a message if there are no users. The edit and delete buttons aren't hooked up to anything yet, so they won't do anything.UserTable.jsimportReactfrom'react'constUserTable=(props)=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody>{props.users.length>0?(props.users.map((user)=>(<trkey={user.id}><td>{user.name}</td><td>{user.username}</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr>))):(<tr><tdcolSpan={3}>No users</td></tr>)}</tbody></table>)exportdefaultUserTableWe'll get to the edit and delete buttons in a moment. Now that the basic view is set up, let's get the adding functionality working.Adding a new userWe're going to set up the form to add a new user.The very first thing we can do is create the actual function that will add the new user to state. We have thesetUsersfunction automatically fromuseState, so that's what we'll use to update the user state.Since we're not using a real API and database, which would probably have an auto-incrementing ID, I'm going to increment the ID of the new user manually. This function will take auserobject as a parameter, and add them to theusersarray of objects. The...userscode ensures that all the previous users remain in the array.App.jsconstaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} e're going to make a component for this, so I'll just go ahead and add the reference to the component at the top, and insert the component below the \"Add user\" header. We can pass theaddUser()through as a prop. Make sure not to include the parentheses when we pass it through as a reference -<AddUserForm addUser={addUser} />, not<AddUserForm addUser={addUser()} />.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'importAddUserFormfrom'./forms/AddUserForm'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)constaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} eturn(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2><AddUserFormaddUser={addUser}/></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppNow we have to create a form that you can use to add the new user. Let's create aformssubdirectory with a file inside calledAddUserForm.js.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{return(<form><label>Name</label><inputtype=\"text\"name=\"name\"value=\"\"/><label>Username</label><inputtype=\"text\"name=\"username\"value=\"\"/><button>Add new user</button></form>)} xportdefaultAddUserFormRight now, the form is empty, and you cannot add any values to it due to our empty value strings, nor does the submit button do anything.Just like before, we'll want to make some state, except this state will just be temporary, for keeping track of what's currently in the add user form.I'm going to create an initial state with those empty values, and set the user state to the empty values. Having initial state in a variable is useful, because after we submit the form, we can return it to the initial, empty value.AddUserForm.jsconstinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)Now we'll create a function to update the state within the form.eventalways gets passed through to anyonevent in the DOM, so you'll see that as the parameter of the function.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 990,
        "chunk_id": "7dde3fbe0c54b3d7b39138af01f25bdd",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Object destructuring will allow us to easily get thename(key) andvaluefrom the form. Finally, we'll set the user much like we did on theAppcomponent, except this time we're using computed property names to dynamically set the name (using[name]) and value.consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} f you don't understand what's being passed through, try playing around withconsole.log(event)in the input handling function.Now we extract the values from the state object, and reference our function in theonChangeevent.<form><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>The last thing to take care of is actually submitting the form back to theAppcomponent. As we passed the function down withprops, we're going to use props to access the function. I'm going to write anonSubmitfunction, and we'll prevent the default form submission from firing. I added a small bit of validation to make sure empty values cannot be submitted, and sent the user through to the add function. Finally, I'm using the setter to reset the form to its initial value after successful submission.<formonSubmit={event=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}>Fortunately this code is pretty simple, as we don't have to worry about asynchronous API calls.Here is our fullAddUserFormcomponent.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{constinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>)} xportdefaultAddUserFormCool.Deleting a userThe next one we'll tackle is deleting a user, which is the easiest functionality to take care of.BelowaddUserinApp.js, we'll createdeleteUser, which will take the ID of the user and filter them out of the user array.constdeleteUser=(id)=>{setUsers(users.filter((user)=>user.id!==id))} e pass that function through props toUserTable.<UserTableusers={users} eleteUser={deleteUser}/>Now all we need to do inUserTable.jsis make sure the delete button calls that function.<buttononClick={()=>props.deleteUser(user.id)} lassName=\"button muted-button\">Delete</button>Now you can delete some or all of the users.Updating a userThe final piece of the puzzle is introducing the ability to update existing users. This will be similar to adding a user, except we'll have to be able to identify which user is being edited. In class components, we would use thecomponentDidUpdatelifecycle method to achieve this, but now we'll use anEffect Hook. TheEffect Hookis likecomponentDidMountandcomponentDidUpdatecombined.The way we're going to structure this is when the Edit action is selected for a user, the \"Add user\" form will become an \"Edit user\" form, and it will be pre-populated with the data from the selected user. You can either cancel edit mode, or submit the change, which will update the selected user and close out of edit mode.Let's begin. InApp.js, the first thing we'll want to do is make state for whether or not edit mode is turned on. It will begin as false.App.jsconst[editing,setEditing]=useState(false)Since we don't know who is being edited until it's selected, we'll create initial empty state for the form, like we did with the add form.constinitialFormState={id:null,name:'',username:''} e'll want a way to see and update who the current user being edited is, so we'll apply that empty user to acurrentUserstate.const[currentUser,setCurrentUser]=useState(initialFormState)When Edit is selected on a user, it should turn on edit mode, and set the current user, which we'll do in thiseditRowfunction.consteditRow=(user)=>{setEditing(true)setCurrentUser({id:user.id,name:user.name,username:user.username})} ow just pass that function toUserTablelike we did withdeleteUser.<UserTableusers={users} ditRow={editRow} eleteUser={deleteUser}/>Over inUserTable.js, we send theuserobject over.UserTable.js<buttononClick={()=>{props.editRow(user)}} lassName=\"button muted-button\">Edit</button>Now we've got all the setup - there's a switch for edit mode, and a button that will pass the current user into state while flipping the edit mode switch.Let's create the actual function that will get called when the edit form is submitted. Unlike delete (which filters a user out by ID) or add (which appends a user to the array), the update function needs to map through the array, and update the user that matches the ID passed through.This means we'll be taking two parameters - the updated user object, and the id - and we'll use a ternary operation to map through the users and find the one we want to update.App.jsconstupdateUser=(id,updatedUser)=>{setEditing(false)setUsers(users.map((user)=>(user.id===id?updatedUser:user)))} e just need to make the edit form itself.Createforms/EditUserForm.js. Most of it will be the same as the add form. The only difference so far is that we'll set the state directly fromcurrentUservia props. There is also a cancel button that will simply switch off edit mode.EditUserForm.jsimportReact,{useState} rom'react'constEditUserForm=(props)=>{const[user,setUser]=useState(props.currentUser)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()props.updateUser(user.id,user)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Update user</button><buttononClick={()=>props.setEditing(false)} lassName=\"button muted-button\">Cancel</button></form>)} xportdefaultEditUserFormNow we have to bring the edit form intoApp.js, as well as creating a toggle for displaying the add or edit form.First, bring in the component.App.jsimportEditUserFormfrom'./forms/EditUserForm'Then create the toggle. We'll use a ternary operation to check if theeditingstate is true or not. If true, show the edit form. If false, show the add form. Make sure to pass all the functions we created down to the editing component.App.js<divclassName=\"flex-large\">{editing?(<div><h2>Edit user</h2><EditUserFormsetEditing={setEditing} urrentUser={currentUser} pdateUser={updateUser}/></div>):(<div><h2>Add user</h2><AddUserFormaddUser={addUser}/></div>)}</div>Okay, so at this point clicking on the Edit button should toggle edit mode, and you should be able to update a user. But are we done?Using the Effect HookIf you play around with this a little, you mat notice an issue. Two, actually. If you start editing one user, then try to switch to another user, nothing will happen. Why? Well, the component is already open, and although the state on the parent has changed, it's not registered down to the props.This is where the Effect Hook comes into place. We want to let theEditUserFormcomponent know the props have changed, which we would have done before withcomponentDidUpdate.First step is to bring inuseEffect.EditUserForm.jsimportReact,{useState,useEffect} rom'react'EditUserForm.jsuseEffect(()=>{setUser(props.currentUser)},[props])In the Effect Hook, we create a callback function that updates theuserstate with the new prop that's being sent through. Before, we needed to compareif (prevProps.currentUser !== this.state.currentUser), but with the Effect Hook we can just pass[props]through to let it know we're watching props.Using the[props]array is similar to usingcomponentDidUpdate. If you're doing a one-time event likecomponentDidMount, you can pass an empty array ([]) instead.Now if you try to change the user you're editing, it will work correctly!I said there were two issues here, and the other issue is that you can delete a user while it is currently being edited. We can fix this issue by addingsetEditing(false)to thedeleteUserfunction inApp.js.And that's it. We have a complete CRUD app utilizing React State and Effect hooks.ConclusionI didn't cover every use case for Hooks, or all functionality in-depth, but I tried to provide a working example of a complete, albeit simple, React program.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 984,
        "chunk_id": "01db1189459f3f062f332a7661bf86c2",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "extract",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "For a complete FAQ on all things relating to hooks, check out theHooks FAQ.If you got lost anywhere along the way, don't forget to check out the demo and source.View Demo AppView SourceThe next thing to be on the lookout for is theSuspense API.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:November 07, 2018Category:TechnicalTagsjavascriptreactNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 97,
        "chunk_id": "f216b0cfb411e6939266779e74dfb4e2",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "A new concept was introduced in React -Hooks. Hooks are an alternative to classes. If you've used React before, you'll be familiar withsimple (functional) componentsandclass components.Simple componentconstExample=()=>{return<div>I'm a simple component</div>} lass componentclassExampleextendsComponent{render(){return<div>I'm a class component</div>}} any of the features available to classes - such aslifecycle methodsandstate- have not been available to simple components, until now. The new Hooks proposal adds all that functionality and more.I wanted to try out Hooks and see how an app might look without any classes, but I didn't see any examples yet, so I decided to make one myself. I created a simple CRUD (create, read, update, delete) app that utilizes Hooks and no classes, and I created this tutorial for anyone else who wants to learn how to use them as well.If you don't know how to make a simple CRUD app in React, regardless of whether you use classes or hooks, this article will be good for you as well.View Demo AppView SourcePrerequisitesIn order to follow along with this tutorial, you'll need a basic knowledge of HTML, CSS, and JavaScript/ES6. You should also know the fundamentals of React, which you can learn by readingGetting Started with React.GoalsIn this tutorial, we'll make asimple CRUD app. It will have users, and you'll be able to add, update, or delete users. We won't use any React classes, and instead we'll utilize State Hooks and Effect Hooks on functional components. If you get lost along the way, be sure to check outthe source of the completed project.Create React AppWe'll start by installing the project withcreate-react-app(CRA).npx create-react-app react-hooksThen runnpm i.Now you're all set with the React.Initial SetupLet's start off by clearing out all the files from the boilerplate we don't need. Delete everything from the/srcfolder exceptApp.js,index.js, andindex.css.Forindex.css, I just copy and paste the CSS fromPrimitive, a simple CSS boilerplate I made, as the point of this app is to work on React and not care about design. This CSS boilerplate just adds some sensible defaults and a simple grid so we can start prototyping.Inindex.js, we'll simplify it by removing the references to Service Workers.index.jsimportReactfrom'react'importReactDOMfrom'react-dom'import'./index.css'importAppfrom'./App'ReactDOM.render(<App/>,document.getElementById('root'))And inApp.js, I'll make a simple, functional component forAppinstead of a class.App.jsimportReactfrom'react'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2></div></div></div>)} xportdefaultAppNow we have the initial setup and skeleton for the app.State vs. Hook StateIf we look at a very simple example of a class component with state and a functional component with Hook state, we can see the similarities and differences. With class state, you get one main state object, and you update using methods on the class andsetState().I'll make some quick example code, as if it were a library and you have books that have state.Class Component State ExampleclassAppextendsComponent{initialState={title:'',available:false,} tate=initialStateupdateBook=(book)=>{this.setState({title:book.title,available:book.available})}} ith Hook state, there's a getter and setter for each type of state (you can have as many as you want), and we obviously create functions instead of methods.Hook State ExampleconstApp=()=>{constinitialBookState={title:'',available:false,} onst[book,setBook]=useState(initialBookState)constupdateBook=(book)=>{setBook({title:book.title,available:book.available})}} 'm not going to get deep into the rationale behind hooks vs. class components, as you can readall about it on React's Hooks introduction. I'm just going to show you how to work with them to create a functional app.Setting up the ViewThe first thing we'll do is make some sample data and a table to display it, for the view. Create a new directory calledtablesinsrc, and a file within calledUserTable.js. We'll make the skeleton for a table.tables/UserTable.jsimportReactfrom'react'constUserTable=()=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody><tr><td>Name data</td><td>Username data</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr></tbody></table>)exportdefaultUserTableNow just import the file and add in the new component.App.jsimportReactfrom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTable/></div></div></div>)} xportdefaultAppLet's bring in some random dummy data and theuseStateimport from React.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppProps works just as it did before. We'll map through the user data we sent through and display the properties for each user, or display a message if there are no users. The edit and delete buttons aren't hooked up to anything yet, so they won't do anything.UserTable.jsimportReactfrom'react'constUserTable=(props)=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody>{props.users.length>0?(props.users.map((user)=>(<trkey={user.id}><td>{user.name}</td><td>{user.username}</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr>))):(<tr><tdcolSpan={3}>No users</td></tr>)}</tbody></table>)exportdefaultUserTableWe'll get to the edit and delete buttons in a moment. Now that the basic view is set up, let's get the adding functionality working.Adding a new userWe're going to set up the form to add a new user.The very first thing we can do is create the actual function that will add the new user to state. We have thesetUsersfunction automatically fromuseState, so that's what we'll use to update the user state.Since we're not using a real API and database, which would probably have an auto-incrementing ID, I'm going to increment the ID of the new user manually. This function will take auserobject as a parameter, and add them to theusersarray of objects. The...userscode ensures that all the previous users remain in the array.App.jsconstaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} e're going to make a component for this, so I'll just go ahead and add the reference to the component at the top, and insert the component below the \"Add user\" header. We can pass theaddUser()through as a prop. Make sure not to include the parentheses when we pass it through as a reference -<AddUserForm addUser={addUser} />, not<AddUserForm addUser={addUser()} />.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'importAddUserFormfrom'./forms/AddUserForm'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)constaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} eturn(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2><AddUserFormaddUser={addUser}/></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppNow we have to create a form that you can use to add the new user. Let's create aformssubdirectory with a file inside calledAddUserForm.js.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{return(<form><label>Name</label><inputtype=\"text\"name=\"name\"value=\"\"/><label>Username</label><inputtype=\"text\"name=\"username\"value=\"\"/><button>Add new user</button></form>)} xportdefaultAddUserFormRight now, the form is empty, and you cannot add any values to it due to our empty value strings, nor does the submit button do anything.Just like before, we'll want to make some state, except this state will just be temporary, for keeping track of what's currently in the add user form.I'm going to create an initial state with those empty values, and set the user state to the empty values. Having initial state in a variable is useful, because after we submit the form, we can return it to the initial, empty value.AddUserForm.jsconstinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)Now we'll create a function to update the state within the form.eventalways gets passed through to anyonevent in the DOM, so you'll see that as the parameter of the function. Object destructuring will allow us to easily get thename(key) andvaluefrom the form.",
        "chunk_type": "code_class",
        "tag": "section",
        "score": 1.0030000000000001,
        "word_count": 995,
        "chunk_id": "73649abf087e343535dd6e71b7c8c11b",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Finally, we'll set the user much like we did on theAppcomponent, except this time we're using computed property names to dynamically set the name (using[name]) and value.consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} f you don't understand what's being passed through, try playing around withconsole.log(event)in the input handling function.Now we extract the values from the state object, and reference our function in theonChangeevent.<form><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>The last thing to take care of is actually submitting the form back to theAppcomponent. As we passed the function down withprops, we're going to use props to access the function. I'm going to write anonSubmitfunction, and we'll prevent the default form submission from firing. I added a small bit of validation to make sure empty values cannot be submitted, and sent the user through to the add function. Finally, I'm using the setter to reset the form to its initial value after successful submission.<formonSubmit={event=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}>Fortunately this code is pretty simple, as we don't have to worry about asynchronous API calls.Here is our fullAddUserFormcomponent.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{constinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>)} xportdefaultAddUserFormCool.Deleting a userThe next one we'll tackle is deleting a user, which is the easiest functionality to take care of.BelowaddUserinApp.js, we'll createdeleteUser, which will take the ID of the user and filter them out of the user array.constdeleteUser=(id)=>{setUsers(users.filter((user)=>user.id!==id))} e pass that function through props toUserTable.<UserTableusers={users} eleteUser={deleteUser}/>Now all we need to do inUserTable.jsis make sure the delete button calls that function.<buttononClick={()=>props.deleteUser(user.id)} lassName=\"button muted-button\">Delete</button>Now you can delete some or all of the users.Updating a userThe final piece of the puzzle is introducing the ability to update existing users. This will be similar to adding a user, except we'll have to be able to identify which user is being edited. In class components, we would use thecomponentDidUpdatelifecycle method to achieve this, but now we'll use anEffect Hook. TheEffect Hookis likecomponentDidMountandcomponentDidUpdatecombined.The way we're going to structure this is when the Edit action is selected for a user, the \"Add user\" form will become an \"Edit user\" form, and it will be pre-populated with the data from the selected user. You can either cancel edit mode, or submit the change, which will update the selected user and close out of edit mode.Let's begin. InApp.js, the first thing we'll want to do is make state for whether or not edit mode is turned on. It will begin as false.App.jsconst[editing,setEditing]=useState(false)Since we don't know who is being edited until it's selected, we'll create initial empty state for the form, like we did with the add form.constinitialFormState={id:null,name:'',username:''} e'll want a way to see and update who the current user being edited is, so we'll apply that empty user to acurrentUserstate.const[currentUser,setCurrentUser]=useState(initialFormState)When Edit is selected on a user, it should turn on edit mode, and set the current user, which we'll do in thiseditRowfunction.consteditRow=(user)=>{setEditing(true)setCurrentUser({id:user.id,name:user.name,username:user.username})} ow just pass that function toUserTablelike we did withdeleteUser.<UserTableusers={users} ditRow={editRow} eleteUser={deleteUser}/>Over inUserTable.js, we send theuserobject over.UserTable.js<buttononClick={()=>{props.editRow(user)}} lassName=\"button muted-button\">Edit</button>Now we've got all the setup - there's a switch for edit mode, and a button that will pass the current user into state while flipping the edit mode switch.Let's create the actual function that will get called when the edit form is submitted. Unlike delete (which filters a user out by ID) or add (which appends a user to the array), the update function needs to map through the array, and update the user that matches the ID passed through.This means we'll be taking two parameters - the updated user object, and the id - and we'll use a ternary operation to map through the users and find the one we want to update.App.jsconstupdateUser=(id,updatedUser)=>{setEditing(false)setUsers(users.map((user)=>(user.id===id?updatedUser:user)))} e just need to make the edit form itself.Createforms/EditUserForm.js. Most of it will be the same as the add form. The only difference so far is that we'll set the state directly fromcurrentUservia props. There is also a cancel button that will simply switch off edit mode.EditUserForm.jsimportReact,{useState} rom'react'constEditUserForm=(props)=>{const[user,setUser]=useState(props.currentUser)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()props.updateUser(user.id,user)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Update user</button><buttononClick={()=>props.setEditing(false)} lassName=\"button muted-button\">Cancel</button></form>)} xportdefaultEditUserFormNow we have to bring the edit form intoApp.js, as well as creating a toggle for displaying the add or edit form.First, bring in the component.App.jsimportEditUserFormfrom'./forms/EditUserForm'Then create the toggle. We'll use a ternary operation to check if theeditingstate is true or not. If true, show the edit form. If false, show the add form. Make sure to pass all the functions we created down to the editing component.App.js<divclassName=\"flex-large\">{editing?(<div><h2>Edit user</h2><EditUserFormsetEditing={setEditing} urrentUser={currentUser} pdateUser={updateUser}/></div>):(<div><h2>Add user</h2><AddUserFormaddUser={addUser}/></div>)}</div>Okay, so at this point clicking on the Edit button should toggle edit mode, and you should be able to update a user. But are we done?Using the Effect HookIf you play around with this a little, you mat notice an issue. Two, actually. If you start editing one user, then try to switch to another user, nothing will happen. Why? Well, the component is already open, and although the state on the parent has changed, it's not registered down to the props.This is where the Effect Hook comes into place. We want to let theEditUserFormcomponent know the props have changed, which we would have done before withcomponentDidUpdate.First step is to bring inuseEffect.EditUserForm.jsimportReact,{useState,useEffect} rom'react'EditUserForm.jsuseEffect(()=>{setUser(props.currentUser)},[props])In the Effect Hook, we create a callback function that updates theuserstate with the new prop that's being sent through. Before, we needed to compareif (prevProps.currentUser !== this.state.currentUser), but with the Effect Hook we can just pass[props]through to let it know we're watching props.Using the[props]array is similar to usingcomponentDidUpdate. If you're doing a one-time event likecomponentDidMount, you can pass an empty array ([]) instead.Now if you try to change the user you're editing, it will work correctly!I said there were two issues here, and the other issue is that you can delete a user while it is currently being edited. We can fix this issue by addingsetEditing(false)to thedeleteUserfunction inApp.js.And that's it. We have a complete CRUD app utilizing React State and Effect hooks.ConclusionI didn't cover every use case for Hooks, or all functionality in-depth, but I tried to provide a working example of a complete, albeit simple, React program.",
        "chunk_type": "code_class",
        "tag": "section",
        "score": 1.0030000000000001,
        "word_count": 972,
        "chunk_id": "762de1842cd2fe8b66270858c513d0e5",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "extract",
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "For a complete FAQ on all things relating to hooks, check out theHooks FAQ.If you got lost anywhere along the way, don't forget to check out the demo and source.View Demo AppView SourceThe next thing to be on the lookout for is theSuspense API.",
        "chunk_type": "technical_content",
        "tag": "section",
        "score": 1.0030000000000001,
        "word_count": 44,
        "chunk_id": "3af2838a8d29cf503be4495dc7a1b140",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "A new concept was introduced in React -Hooks. Hooks are an alternative to classes. If you've used React before, you'll be familiar withsimple (functional) componentsandclass components.Simple componentconstExample=()=>{return<div>I'm a simple component</div>} lass componentclassExampleextendsComponent{render(){return<div>I'm a class component</div>}} any of the features available to classes - such aslifecycle methodsandstate- have not been available to simple components, until now. The new Hooks proposal adds all that functionality and more.I wanted to try out Hooks and see how an app might look without any classes, but I didn't see any examples yet, so I decided to make one myself. I created a simple CRUD (create, read, update, delete) app that utilizes Hooks and no classes, and I created this tutorial for anyone else who wants to learn how to use them as well.If you don't know how to make a simple CRUD app in React, regardless of whether you use classes or hooks, this article will be good for you as well.View Demo AppView SourcePrerequisitesIn order to follow along with this tutorial, you'll need a basic knowledge of HTML, CSS, and JavaScript/ES6. You should also know the fundamentals of React, which you can learn by readingGetting Started with React.GoalsIn this tutorial, we'll make asimple CRUD app. It will have users, and you'll be able to add, update, or delete users. We won't use any React classes, and instead we'll utilize State Hooks and Effect Hooks on functional components. If you get lost along the way, be sure to check outthe source of the completed project.Create React AppWe'll start by installing the project withcreate-react-app(CRA).npx create-react-app react-hooksThen runnpm i.Now you're all set with the React.Initial SetupLet's start off by clearing out all the files from the boilerplate we don't need. Delete everything from the/srcfolder exceptApp.js,index.js, andindex.css.Forindex.css, I just copy and paste the CSS fromPrimitive, a simple CSS boilerplate I made, as the point of this app is to work on React and not care about design. This CSS boilerplate just adds some sensible defaults and a simple grid so we can start prototyping.Inindex.js, we'll simplify it by removing the references to Service Workers.index.jsimportReactfrom'react'importReactDOMfrom'react-dom'import'./index.css'importAppfrom'./App'ReactDOM.render(<App/>,document.getElementById('root'))And inApp.js, I'll make a simple, functional component forAppinstead of a class.App.jsimportReactfrom'react'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2></div></div></div>)} xportdefaultAppNow we have the initial setup and skeleton for the app.State vs. Hook StateIf we look at a very simple example of a class component with state and a functional component with Hook state, we can see the similarities and differences. With class state, you get one main state object, and you update using methods on the class andsetState().I'll make some quick example code, as if it were a library and you have books that have state.Class Component State ExampleclassAppextendsComponent{initialState={title:'',available:false,} tate=initialStateupdateBook=(book)=>{this.setState({title:book.title,available:book.available})}} ith Hook state, there's a getter and setter for each type of state (you can have as many as you want), and we obviously create functions instead of methods.Hook State ExampleconstApp=()=>{constinitialBookState={title:'',available:false,} onst[book,setBook]=useState(initialBookState)constupdateBook=(book)=>{setBook({title:book.title,available:book.available})}} 'm not going to get deep into the rationale behind hooks vs. class components, as you can readall about it on React's Hooks introduction. I'm just going to show you how to work with them to create a functional app.Setting up the ViewThe first thing we'll do is make some sample data and a table to display it, for the view. Create a new directory calledtablesinsrc, and a file within calledUserTable.js. We'll make the skeleton for a table.tables/UserTable.jsimportReactfrom'react'constUserTable=()=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody><tr><td>Name data</td><td>Username data</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr></tbody></table>)exportdefaultUserTableNow just import the file and add in the new component.App.jsimportReactfrom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTable/></div></div></div>)} xportdefaultAppLet's bring in some random dummy data and theuseStateimport from React.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppProps works just as it did before. We'll map through the user data we sent through and display the properties for each user, or display a message if there are no users. The edit and delete buttons aren't hooked up to anything yet, so they won't do anything.UserTable.jsimportReactfrom'react'constUserTable=(props)=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody>{props.users.length>0?(props.users.map((user)=>(<trkey={user.id}><td>{user.name}</td><td>{user.username}</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr>))):(<tr><tdcolSpan={3}>No users</td></tr>)}</tbody></table>)exportdefaultUserTableWe'll get to the edit and delete buttons in a moment. Now that the basic view is set up, let's get the adding functionality working.Adding a new userWe're going to set up the form to add a new user.The very first thing we can do is create the actual function that will add the new user to state. We have thesetUsersfunction automatically fromuseState, so that's what we'll use to update the user state.Since we're not using a real API and database, which would probably have an auto-incrementing ID, I'm going to increment the ID of the new user manually. This function will take auserobject as a parameter, and add them to theusersarray of objects. The...userscode ensures that all the previous users remain in the array.App.jsconstaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} e're going to make a component for this, so I'll just go ahead and add the reference to the component at the top, and insert the component below the \"Add user\" header. We can pass theaddUser()through as a prop. Make sure not to include the parentheses when we pass it through as a reference -<AddUserForm addUser={addUser} />, not<AddUserForm addUser={addUser()} />.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'importAddUserFormfrom'./forms/AddUserForm'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)constaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} eturn(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2><AddUserFormaddUser={addUser}/></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppNow we have to create a form that you can use to add the new user. Let's create aformssubdirectory with a file inside calledAddUserForm.js.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{return(<form><label>Name</label><inputtype=\"text\"name=\"name\"value=\"\"/><label>Username</label><inputtype=\"text\"name=\"username\"value=\"\"/><button>Add new user</button></form>)} xportdefaultAddUserFormRight now, the form is empty, and you cannot add any values to it due to our empty value strings, nor does the submit button do anything.Just like before, we'll want to make some state, except this state will just be temporary, for keeping track of what's currently in the add user form.I'm going to create an initial state with those empty values, and set the user state to the empty values. Having initial state in a variable is useful, because after we submit the form, we can return it to the initial, empty value.AddUserForm.jsconstinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)Now we'll create a function to update the state within the form.eventalways gets passed through to anyonevent in the DOM, so you'll see that as the parameter of the function. Object destructuring will allow us to easily get thename(key) andvaluefrom the form.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.0030000000000001,
        "word_count": 995,
        "chunk_id": "73649abf087e343535dd6e71b7c8c11b",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "id": "/crud-app-in-react-with-hooks/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Finally, we'll set the user much like we did on theAppcomponent, except this time we're using computed property names to dynamically set the name (using[name]) and value.consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} f you don't understand what's being passed through, try playing around withconsole.log(event)in the input handling function.Now we extract the values from the state object, and reference our function in theonChangeevent.<form><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>The last thing to take care of is actually submitting the form back to theAppcomponent. As we passed the function down withprops, we're going to use props to access the function. I'm going to write anonSubmitfunction, and we'll prevent the default form submission from firing. I added a small bit of validation to make sure empty values cannot be submitted, and sent the user through to the add function. Finally, I'm using the setter to reset the form to its initial value after successful submission.<formonSubmit={event=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}>Fortunately this code is pretty simple, as we don't have to worry about asynchronous API calls.Here is our fullAddUserFormcomponent.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{constinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>)} xportdefaultAddUserFormCool.Deleting a userThe next one we'll tackle is deleting a user, which is the easiest functionality to take care of.BelowaddUserinApp.js, we'll createdeleteUser, which will take the ID of the user and filter them out of the user array.constdeleteUser=(id)=>{setUsers(users.filter((user)=>user.id!==id))} e pass that function through props toUserTable.<UserTableusers={users} eleteUser={deleteUser}/>Now all we need to do inUserTable.jsis make sure the delete button calls that function.<buttononClick={()=>props.deleteUser(user.id)} lassName=\"button muted-button\">Delete</button>Now you can delete some or all of the users.Updating a userThe final piece of the puzzle is introducing the ability to update existing users. This will be similar to adding a user, except we'll have to be able to identify which user is being edited. In class components, we would use thecomponentDidUpdatelifecycle method to achieve this, but now we'll use anEffect Hook. TheEffect Hookis likecomponentDidMountandcomponentDidUpdatecombined.The way we're going to structure this is when the Edit action is selected for a user, the \"Add user\" form will become an \"Edit user\" form, and it will be pre-populated with the data from the selected user. You can either cancel edit mode, or submit the change, which will update the selected user and close out of edit mode.Let's begin. InApp.js, the first thing we'll want to do is make state for whether or not edit mode is turned on. It will begin as false.App.jsconst[editing,setEditing]=useState(false)Since we don't know who is being edited until it's selected, we'll create initial empty state for the form, like we did with the add form.constinitialFormState={id:null,name:'',username:''} e'll want a way to see and update who the current user being edited is, so we'll apply that empty user to acurrentUserstate.const[currentUser,setCurrentUser]=useState(initialFormState)When Edit is selected on a user, it should turn on edit mode, and set the current user, which we'll do in thiseditRowfunction.consteditRow=(user)=>{setEditing(true)setCurrentUser({id:user.id,name:user.name,username:user.username})} ow just pass that function toUserTablelike we did withdeleteUser.<UserTableusers={users} ditRow={editRow} eleteUser={deleteUser}/>Over inUserTable.js, we send theuserobject over.UserTable.js<buttononClick={()=>{props.editRow(user)}} lassName=\"button muted-button\">Edit</button>Now we've got all the setup - there's a switch for edit mode, and a button that will pass the current user into state while flipping the edit mode switch.Let's create the actual function that will get called when the edit form is submitted. Unlike delete (which filters a user out by ID) or add (which appends a user to the array), the update function needs to map through the array, and update the user that matches the ID passed through.This means we'll be taking two parameters - the updated user object, and the id - and we'll use a ternary operation to map through the users and find the one we want to update.App.jsconstupdateUser=(id,updatedUser)=>{setEditing(false)setUsers(users.map((user)=>(user.id===id?updatedUser:user)))} e just need to make the edit form itself.Createforms/EditUserForm.js. Most of it will be the same as the add form. The only difference so far is that we'll set the state directly fromcurrentUservia props. There is also a cancel button that will simply switch off edit mode.EditUserForm.jsimportReact,{useState} rom'react'constEditUserForm=(props)=>{const[user,setUser]=useState(props.currentUser)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()props.updateUser(user.id,user)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Update user</button><buttononClick={()=>props.setEditing(false)} lassName=\"button muted-button\">Cancel</button></form>)} xportdefaultEditUserFormNow we have to bring the edit form intoApp.js, as well as creating a toggle for displaying the add or edit form.First, bring in the component.App.jsimportEditUserFormfrom'./forms/EditUserForm'Then create the toggle. We'll use a ternary operation to check if theeditingstate is true or not. If true, show the edit form. If false, show the add form. Make sure to pass all the functions we created down to the editing component.App.js<divclassName=\"flex-large\">{editing?(<div><h2>Edit user</h2><EditUserFormsetEditing={setEditing} urrentUser={currentUser} pdateUser={updateUser}/></div>):(<div><h2>Add user</h2><AddUserFormaddUser={addUser}/></div>)}</div>Okay, so at this point clicking on the Edit button should toggle edit mode, and you should be able to update a user. But are we done?Using the Effect HookIf you play around with this a little, you mat notice an issue. Two, actually. If you start editing one user, then try to switch to another user, nothing will happen. Why? Well, the component is already open, and although the state on the parent has changed, it's not registered down to the props.This is where the Effect Hook comes into place. We want to let theEditUserFormcomponent know the props have changed, which we would have done before withcomponentDidUpdate.First step is to bring inuseEffect.EditUserForm.jsimportReact,{useState,useEffect} rom'react'EditUserForm.jsuseEffect(()=>{setUser(props.currentUser)},[props])In the Effect Hook, we create a callback function that updates theuserstate with the new prop that's being sent through. Before, we needed to compareif (prevProps.currentUser !== this.state.currentUser), but with the Effect Hook we can just pass[props]through to let it know we're watching props.Using the[props]array is similar to usingcomponentDidUpdate. If you're doing a one-time event likecomponentDidMount, you can pass an empty array ([]) instead.Now if you try to change the user you're editing, it will work correctly!I said there were two issues here, and the other issue is that you can delete a user while it is currently being edited. We can fix this issue by addingsetEditing(false)to thedeleteUserfunction inApp.js.And that's it. We have a complete CRUD app utilizing React State and Effect hooks.ConclusionI didn't cover every use case for Hooks, or all functionality in-depth, but I tried to provide a working example of a complete, albeit simple, React program.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.0030000000000001,
        "word_count": 972,
        "chunk_id": "762de1842cd2fe8b66270858c513d0e5",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "extract",
            "react"
          ],
          "attributes": {
            "id": "/crud-app-in-react-with-hooks/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "For a complete FAQ on all things relating to hooks, check out theHooks FAQ.If you got lost anywhere along the way, don't forget to check out the demo and source.View Demo AppView SourceThe next thing to be on the lookout for is theSuspense API.",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.0030000000000001,
        "word_count": 44,
        "chunk_id": "3af2838a8d29cf503be4495dc7a1b140",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [],
          "attributes": {
            "id": "/crud-app-in-react-with-hooks/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:November 07, 2018Category:TechnicalTagsjavascriptreactNewsletterSubscribe to the Newsletter",
        "chunk_type": "text",
        "tag": "aside",
        "score": 0.42600000000000005,
        "word_count": 54,
        "chunk_id": "973ee56a68d870b0028a270bd0111d30",
        "metadata": {
          "source_tag": "aside",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "post-sidebar"
            ]
          },
          "technical_indicators": [
            "javascript"
          ]
        }
      },
      {
        "content": "If you don't know how to make a simple CRUD app in React, regardless of whether you use classes or hooks, this article will be good for you as well.",
        "chunk_type": "technical_content",
        "tag": "p",
        "score": 0.324,
        "word_count": 30,
        "chunk_id": "589aa3f75705797837a3f77884329779",
        "metadata": {
          "source_tag": "p",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react"
          ]
        }
      }
    ],
    "chunk_count": 23,
    "content_types": [
      "code_class",
      "text",
      "technical_content"
    ],
    "technical_concepts": [
      "javascript",
      "sql",
      "data",
      "api",
      "react"
    ],
    "crawl_metadata": {},
    "technical_content": [
      {
        "id": "10ff59d921b1eede5c089d3fdd766a86",
        "content": "const Example = () => { return <div>I'm a simple component</div> }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "10ff59d921b1eede5c089d3fdd766a86",
        "content": "const Example = () => { return <div>I'm a simple component</div> }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "d52a68d6cd36d57bccbd0a6cedab2bbb",
        "content": "class Example extends Component { render() { return <div>I'm a class component</div> } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8052631578947369
      },
      {
        "id": "d52a68d6cd36d57bccbd0a6cedab2bbb",
        "content": "class Example extends Component { render() { return <div>I'm a class component</div> } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8052631578947369
      },
      {
        "id": "64cec1d55a6cfa382b4bea8d3337c13a",
        "content": "npx create-react-app react-hooks",
        "type": "code",
        "language": "shell",
        "relevance": 0.5105263157894737
      },
      {
        "id": "64cec1d55a6cfa382b4bea8d3337c13a",
        "content": "npx create-react-app react-hooks",
        "type": "code",
        "language": "shell",
        "relevance": 0.5105263157894737
      },
      {
        "id": "7d1654a2281de41eb75e98be8d776d2f",
        "content": "npm i",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f8087e59fd95af1ae29e8fcb7ff1a3dc",
        "content": "/src",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "958f6f56cd42c904603d226cd36a57b6",
        "content": "App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "bca1542f88ef8253c16b452e9ad09f98",
        "content": "index.css",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "bca1542f88ef8253c16b452e9ad09f98",
        "content": "index.css",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "445f950662b27353b8b8ddb92fa243a3",
        "content": "import React from 'react' import ReactDOM from 'react-dom' import './index.css' import App from './App' ReactDOM.render(<App />, document.getElementById('root'))",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "445f950662b27353b8b8ddb92fa243a3",
        "content": "import React from 'react' import ReactDOM from 'react-dom' import './index.css' import App from './App' ReactDOM.render(<App />, document.getElementById('root'))",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "958f6f56cd42c904603d226cd36a57b6",
        "content": "App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "ac863f346e618f9a959b5c95d5d28941",
        "content": "App",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d904b2282352169d3e57e87d65ebb504",
        "content": "import React from 'react' const App = () => { return ( <div className=\"container\"> <h1>CRUD App with Hooks</h1> <div className=\"flex-row\"> <div className=\"flex-large\"> <h2>Add user</h2> </div> <div className=\"flex-large\"> <h2>View users</h2> </div> </div> </div> ) } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "d904b2282352169d3e57e87d65ebb504",
        "content": "import React from 'react' const App = () => { return ( <div className=\"container\"> <h1>CRUD App with Hooks</h1> <div className=\"flex-row\"> <div className=\"flex-large\"> <h2>Add user</h2> </div> <div className=\"flex-large\"> <h2>View users</h2> </div> </div> </div> ) } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "99057c7bcc765423105744aebe81baec",
        "content": "setState()",
        "type": "code",
        "language": "text",
        "relevance": 0.605263157894737
      },
      {
        "id": "07b5354bf759404820d105a07e897c73",
        "content": "class App extends Component { initialState = { title: '', available: false, } state = initialState updateBook = (book) => { this.setState({ title: book.title, available: book.available }) } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8157894736842106
      },
      {
        "id": "07b5354bf759404820d105a07e897c73",
        "content": "class App extends Component { initialState = { title: '', available: false, } state = initialState updateBook = (book) => { this.setState({ title: book.title, available: book.available }) } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8157894736842106
      },
      {
        "id": "29d5f8752774f590fb7ed94061b562d7",
        "content": "const App = () => { const initialBookState = { title: '', available: false, } const [book, setBook] = useState(initialBookState) const updateBook = (book) => { setBook({ title: book.title, available: book.available }) } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "29d5f8752774f590fb7ed94061b562d7",
        "content": "const App = () => { const initialBookState = { title: '', available: false, } const [book, setBook] = useState(initialBookState) const updateBook = (book) => { setBook({ title: book.title, available: book.available }) } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "9ab2ec7ea4a2041306f7bdf150fcd453",
        "content": "tables",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "25d902c24283ab8cfbac54dfa101ad31",
        "content": "src",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "eb92172f851ce243ee7be1ef371623d5",
        "content": "UserTable.js",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "35e5edcee92215421da7c4ffbde33424",
        "content": "import React from 'react' const UserTable = () => ( <table> <thead> <tr> <th>Name</th> <th>Username</th> <th>Actions</th> </tr> </thead> <tbody> <tr> <td>Name data</td> <td>Username data</td> <td> <button className=\"button muted-button\">Edit</button> <button className=\"button muted-button\">Delete</button> </td> </tr> </tbody> </table> ) export default UserTable",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "35e5edcee92215421da7c4ffbde33424",
        "content": "import React from 'react' const UserTable = () => ( <table> <thead> <tr> <th>Name</th> <th>Username</th> <th>Actions</th> </tr> </thead> <tbody> <tr> <td>Name data</td> <td>Username data</td> <td> <button className=\"button muted-button\">Edit</button> <button className=\"button muted-button\">Delete</button> </td> </tr> </tbody> </table> ) export default UserTable",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "9988615c627abfef2c9fb66e7016d3d0",
        "content": "import React from 'react' import UserTable from './tables/UserTable' const App = () => { return ( <div className=\"container\"> <h1>CRUD App with Hooks</h1> <div className=\"flex-row\"> <div className=\"flex-large\"> <h2>Add user</h2> </div> <div className=\"flex-large\"> <h2>View users</h2> <UserTable /> </div> </div> </div> ) } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8157894736842106
      },
      {
        "id": "9988615c627abfef2c9fb66e7016d3d0",
        "content": "import React from 'react' import UserTable from './tables/UserTable' const App = () => { return ( <div className=\"container\"> <h1>CRUD App with Hooks</h1> <div className=\"flex-row\"> <div className=\"flex-large\"> <h2>Add user</h2> </div> <div className=\"flex-large\"> <h2>View users</h2> <UserTable /> </div> </div> </div> ) } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8157894736842106
      },
      {
        "id": "5dd7ac3770aaf6a4c6944ab4ce95f50c",
        "content": "useState",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "1552b9d0db143f3ccc38aa0d12042133",
        "content": "import React, { useState } from 'react' import UserTable from './tables/UserTable' const App = () => { const usersData = [ { id: 1, name: 'Tania', username: 'floppydiskette' }, { id: 2, name: 'Craig', username: 'siliconeidolon' }, { id: 3, name: 'Ben', username: 'benisphere' }, ] const [users, setUsers] = useState(usersData) return ( <div className=\"container\"> <h1>CRUD App with Hooks</h1> <div className=\"flex-row\"> <div className=\"flex-large\"> <h2>Add user</h2> </div> <div className=\"flex-large\"> <h2>View users</h2> <UserTable users={users} /> </div> </div> </div> ) } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "1552b9d0db143f3ccc38aa0d12042133",
        "content": "import React, { useState } from 'react' import UserTable from './tables/UserTable' const App = () => { const usersData = [ { id: 1, name: 'Tania', username: 'floppydiskette' }, { id: 2, name: 'Craig', username: 'siliconeidolon' }, { id: 3, name: 'Ben', username: 'benisphere' }, ] const [users, setUsers] = useState(usersData) return ( <div className=\"container\"> <h1>CRUD App with Hooks</h1> <div className=\"flex-row\"> <div className=\"flex-large\"> <h2>Add user</h2> </div> <div className=\"flex-large\"> <h2>View users</h2> <UserTable users={users} /> </div> </div> </div> ) } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "49b00599d8b74ddc7a151446c313c687",
        "content": "import React from 'react' const UserTable = (props) => ( <table> <thead> <tr> <th>Name</th> <th>Username</th> <th>Actions</th> </tr> </thead> <tbody> {props.users.length > 0 ? ( props.users.map((user) => ( <tr key={user.id}> <td>{user.name}</td> <td>{user.username}</td> <td> <button className=\"button muted-button\">Edit</button> <button className=\"button muted-button\">Delete</button> </td> </tr> )) ) : ( <tr> <td colSpan={3}>No users</td> </tr> )} </tbody> </table> ) export default UserTable",
        "type": "code",
        "language": "jsx",
        "relevance": 0.9157894736842105
      },
      {
        "id": "49b00599d8b74ddc7a151446c313c687",
        "content": "import React from 'react' const UserTable = (props) => ( <table> <thead> <tr> <th>Name</th> <th>Username</th> <th>Actions</th> </tr> </thead> <tbody> {props.users.length > 0 ? ( props.users.map((user) => ( <tr key={user.id}> <td>{user.name}</td> <td>{user.username}</td> <td> <button className=\"button muted-button\">Edit</button> <button className=\"button muted-button\">Delete</button> </td> </tr> )) ) : ( <tr> <td colSpan={3}>No users</td> </tr> )} </tbody> </table> ) export default UserTable",
        "type": "code",
        "language": "jsx",
        "relevance": 0.9157894736842105
      },
      {
        "id": "99c291f7d4466b3e848f8d7b9060f92f",
        "content": "setUsers",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5dd7ac3770aaf6a4c6944ab4ce95f50c",
        "content": "useState",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "ee11cbb19052e40b07aac0ca060c23ee",
        "content": "user",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9bc65c2abec141778ffaa729489f3e87",
        "content": "users",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "10d757b65a53df3747f046e683cc99a7",
        "content": "...users",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "17805b52f9e90a2f6d55b9a9ca960c00",
        "content": "const addUser = (user) => { user.id = users.length + 1 setUsers([...users, user]) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.30000000000000004
      },
      {
        "id": "17805b52f9e90a2f6d55b9a9ca960c00",
        "content": "const addUser = (user) => { user.id = users.length + 1 setUsers([...users, user]) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2cc531364c948c0cbf1df523dd08a94f",
        "content": "addUser()",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "3152fc4bda1f2e0ee553617c033e7039",
        "content": "<AddUserForm addUser={addUser} />",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "0696a1a11e137f04cbe6459dceb10e6a",
        "content": "<AddUserForm addUser={addUser()} />",
        "type": "code",
        "language": "text",
        "relevance": 0.7
      },
      {
        "id": "f7fb9c739129421568c63cb96308a571",
        "content": "import React, { useState } from 'react' import UserTable from './tables/UserTable' import AddUserForm from './forms/AddUserForm' const App = () => { const usersData = [ { id: 1, name: 'Tania', username: 'floppydiskette' }, { id: 2, name: 'Craig', username: 'siliconeidolon' }, { id: 3, name: 'Ben', username: 'benisphere' }, ] const [users, setUsers] = useState(usersData) const addUser = (user) => { user.id = users.length + 1 setUsers([...users, user]) } return ( <div className=\"container\"> <h1>CRUD App with Hooks</h1> <div className=\"flex-row\"> <div className=\"flex-large\"> <h2>Add user</h2> <AddUserForm addUser={addUser} /> </div> <div className=\"flex-large\"> <h2>View users</h2> <UserTable users={users} /> </div> </div> </div> ) } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "f7fb9c739129421568c63cb96308a571",
        "content": "import React, { useState } from 'react' import UserTable from './tables/UserTable' import AddUserForm from './forms/AddUserForm' const App = () => { const usersData = [ { id: 1, name: 'Tania', username: 'floppydiskette' }, { id: 2, name: 'Craig', username: 'siliconeidolon' }, { id: 3, name: 'Ben', username: 'benisphere' }, ] const [users, setUsers] = useState(usersData) const addUser = (user) => { user.id = users.length + 1 setUsers([...users, user]) } return ( <div className=\"container\"> <h1>CRUD App with Hooks</h1> <div className=\"flex-row\"> <div className=\"flex-large\"> <h2>Add user</h2> <AddUserForm addUser={addUser} /> </div> <div className=\"flex-large\"> <h2>View users</h2> <UserTable users={users} /> </div> </div> </div> ) } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "ac68b62abfd6a9fe26e8ac4236c8ce0c",
        "content": "forms",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5dc7f93ff9aebabb99b657aaa78a0e70",
        "content": "AddUserForm.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e11487e3a03d8220903c4444df608291",
        "content": "import React, { useState } from 'react' const AddUserForm = (props) => { return ( <form> <label>Name</label> <input type=\"text\" name=\"name\" value=\"\" /> <label>Username</label> <input type=\"text\" name=\"username\" value=\"\" /> <button>Add new user</button> </form> ) } export default AddUserForm",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8157894736842106
      },
      {
        "id": "e11487e3a03d8220903c4444df608291",
        "content": "import React, { useState } from 'react' const AddUserForm = (props) => { return ( <form> <label>Name</label> <input type=\"text\" name=\"name\" value=\"\" /> <label>Username</label> <input type=\"text\" name=\"username\" value=\"\" /> <button>Add new user</button> </form> ) } export default AddUserForm",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8157894736842106
      },
      {
        "id": "f6e01675079da78302c11cecfef68e14",
        "content": "const initialFormState = { id: null, name: '', username: '' } const [user, setUser] = useState(initialFormState)",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "f6e01675079da78302c11cecfef68e14",
        "content": "const initialFormState = { id: null, name: '', username: '' } const [user, setUser] = useState(initialFormState)",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "4119639092e62c55ea8be348e4d9260d",
        "content": "event",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "ed2b5c0139cec8ad2873829dc1117d50",
        "content": "on",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b068931cc450442b63f5b3d276ea4297",
        "content": "name",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2063c1608d6e0baf80249c42e2be5804",
        "content": "value",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "ac863f346e618f9a959b5c95d5d28941",
        "content": "App",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1615d6e9208767c1a2094f184225294b",
        "content": "[name]",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1f88a5a0445383f2d09f9483afbca15f",
        "content": "const handleInputChange = (event) => { const { name, value } = event.target setUser({ ...user, [name]: value }) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1f88a5a0445383f2d09f9483afbca15f",
        "content": "const handleInputChange = (event) => { const { name, value } = event.target setUser({ ...user, [name]: value }) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.30000000000000004
      },
      {
        "id": "8645cc15904dc29644b9f7887fffce3e",
        "content": "console.log(event)",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "ec11d8e248160aceed4b88aafec7274e",
        "content": "onChange",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "79558185509746bda33fdc656f7796a4",
        "content": "<form> <label>Name</label> <input type=\"text\" name=\"name\" value={user.name} onChange={handleInputChange} /> <label>Username</label> <input type=\"text\" name=\"username\" value={user.username} onChange={handleInputChange} /> <button>Add new user</button> </form>",
        "type": "code",
        "language": "jsx",
        "relevance": 0.5
      },
      {
        "id": "79558185509746bda33fdc656f7796a4",
        "content": "<form> <label>Name</label> <input type=\"text\" name=\"name\" value={user.name} onChange={handleInputChange} /> <label>Username</label> <input type=\"text\" name=\"username\" value={user.username} onChange={handleInputChange} /> <button>Add new user</button> </form>",
        "type": "code",
        "language": "jsx",
        "relevance": 0.5
      },
      {
        "id": "ac863f346e618f9a959b5c95d5d28941",
        "content": "App",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "50fe03ab7bf37089a7e88da9b31ffb3b",
        "content": "props",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "e7f332a88955d3c0540bb7639f463e74",
        "content": "onSubmit",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4ababe846c531b00848319e17712a393",
        "content": "<form onSubmit={event => { event.preventDefault() if (!user.name !user.username) return props.addUser(user) setUser(initialFormState) }} >",
        "type": "code",
        "language": "jsx",
        "relevance": 0.9105263157894736
      },
      {
        "id": "4ababe846c531b00848319e17712a393",
        "content": "<form onSubmit={event => { event.preventDefault() if (!user.name !user.username) return props.addUser(user) setUser(initialFormState) }} >",
        "type": "code",
        "language": "jsx",
        "relevance": 0.9105263157894736
      },
      {
        "id": "833bd9724cdb69c177c2abfd5c4f062e",
        "content": "AddUserForm",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "300d0f35b5efb6ef62c6098de707576f",
        "content": "import React, { useState } from 'react' const AddUserForm = (props) => { const initialFormState = { id: null, name: '', username: '' } const [user, setUser] = useState(initialFormState) const handleInputChange = (event) => { const { name, value } = event.target setUser({ ...user, [name]: value }) } return ( <form onSubmit={(event) => { event.preventDefault() if (!user.name !user.username) return props.addUser(user) setUser(initialFormState) }} > <label>Name</label> <input type=\"text\" name=\"name\" value={user.name} onChange={handleInputChange} /> <label>Username</label> <input type=\"text\" name=\"username\" value={user.username} onChange={handleInputChange} /> <button>Add new user</button> </form> ) } export default AddUserForm",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "300d0f35b5efb6ef62c6098de707576f",
        "content": "import React, { useState } from 'react' const AddUserForm = (props) => { const initialFormState = { id: null, name: '', username: '' } const [user, setUser] = useState(initialFormState) const handleInputChange = (event) => { const { name, value } = event.target setUser({ ...user, [name]: value }) } return ( <form onSubmit={(event) => { event.preventDefault() if (!user.name !user.username) return props.addUser(user) setUser(initialFormState) }} > <label>Name</label> <input type=\"text\" name=\"name\" value={user.name} onChange={handleInputChange} /> <label>Username</label> <input type=\"text\" name=\"username\" value={user.username} onChange={handleInputChange} /> <button>Add new user</button> </form> ) } export default AddUserForm",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "9b03dbb48f164dbe8565fa5511d77894",
        "content": "addUser",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "958f6f56cd42c904603d226cd36a57b6",
        "content": "App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "bf1562b8d814fc7f03da3bc52737cf50",
        "content": "deleteUser",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c78b5278f7fb344250f47f81e5bb4b07",
        "content": "const deleteUser = (id) => { setUsers(users.filter((user) => user.id !== id)) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c78b5278f7fb344250f47f81e5bb4b07",
        "content": "const deleteUser = (id) => { setUsers(users.filter((user) => user.id !== id)) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.30000000000000004
      },
      {
        "id": "df8d4fc072a5d1dbaaac0dbd50bdb4a3",
        "content": "UserTable",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "b6463891c9cbb0886c209fa378232a00",
        "content": "<UserTable users={users} deleteUser={deleteUser} />",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "b6463891c9cbb0886c209fa378232a00",
        "content": "<UserTable users={users} deleteUser={deleteUser} />",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "eb92172f851ce243ee7be1ef371623d5",
        "content": "UserTable.js",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "0b430007c04a7b3a53682183c0a1d9e6",
        "content": "<button onClick={() => props.deleteUser(user.id)} className=\"button muted-button\" > Delete </button>",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "0b430007c04a7b3a53682183c0a1d9e6",
        "content": "<button onClick={() => props.deleteUser(user.id)} className=\"button muted-button\" > Delete </button>",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "063dd7a0e999a76e5be61e7c9874d549",
        "content": "componentDidUpdate",
        "type": "code",
        "language": "text",
        "relevance": 0.5105263157894737
      },
      {
        "id": "a5bfcf7e4fe575c28923c968c46eadc2",
        "content": "componentDidMount",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "063dd7a0e999a76e5be61e7c9874d549",
        "content": "componentDidUpdate",
        "type": "code",
        "language": "text",
        "relevance": 0.5105263157894737
      },
      {
        "id": "958f6f56cd42c904603d226cd36a57b6",
        "content": "App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "23ad78b776809b39768f765d12bb509a",
        "content": "const [editing, setEditing] = useState(false)",
        "type": "code",
        "language": "jsx",
        "relevance": 0.4052631578947369
      },
      {
        "id": "23ad78b776809b39768f765d12bb509a",
        "content": "const [editing, setEditing] = useState(false)",
        "type": "code",
        "language": "jsx",
        "relevance": 0.4052631578947369
      },
      {
        "id": "dc963aba29c38f6ab5f5ba6afbd3f6b0",
        "content": "const initialFormState = { id: null, name: '', username: '' }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "dc963aba29c38f6ab5f5ba6afbd3f6b0",
        "content": "const initialFormState = { id: null, name: '', username: '' }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "cdd638e00095e76c42db80d69dfdec30",
        "content": "currentUser",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "31d91ba11a2472f6cd7b2ebaaaf3e3ae",
        "content": "const [currentUser, setCurrentUser] = useState(initialFormState)",
        "type": "code",
        "language": "jsx",
        "relevance": 0.4052631578947369
      },
      {
        "id": "31d91ba11a2472f6cd7b2ebaaaf3e3ae",
        "content": "const [currentUser, setCurrentUser] = useState(initialFormState)",
        "type": "code",
        "language": "jsx",
        "relevance": 0.4052631578947369
      },
      {
        "id": "09e3b63e5227d093d1690fc9f3bd6df2",
        "content": "editRow",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "30102b1ba8b5dea7b14a61f9a3eb4b18",
        "content": "const editRow = (user) => { setEditing(true) setCurrentUser({ id: user.id, name: user.name, username: user.username }) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.5
      },
      {
        "id": "30102b1ba8b5dea7b14a61f9a3eb4b18",
        "content": "const editRow = (user) => { setEditing(true) setCurrentUser({ id: user.id, name: user.name, username: user.username }) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.5
      },
      {
        "id": "df8d4fc072a5d1dbaaac0dbd50bdb4a3",
        "content": "UserTable",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "bf1562b8d814fc7f03da3bc52737cf50",
        "content": "deleteUser",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7b79f11fce62a329c272421d1acd453c",
        "content": "<UserTable users={users} editRow={editRow} deleteUser={deleteUser} />",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "7b79f11fce62a329c272421d1acd453c",
        "content": "<UserTable users={users} editRow={editRow} deleteUser={deleteUser} />",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "eb92172f851ce243ee7be1ef371623d5",
        "content": "UserTable.js",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "ee11cbb19052e40b07aac0ca060c23ee",
        "content": "user",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "bef3f5873090ada42db3e4dba9114385",
        "content": "<button onClick={() => { props.editRow(user) }} className=\"button muted-button\" > Edit </button>",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "bef3f5873090ada42db3e4dba9114385",
        "content": "<button onClick={() => { props.editRow(user) }} className=\"button muted-button\" > Edit </button>",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "35639183f80204106964d2661258f886",
        "content": "const updateUser = (id, updatedUser) => { setEditing(false) setUsers(users.map((user) => (user.id === id ? updatedUser : user))) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.4052631578947369
      },
      {
        "id": "35639183f80204106964d2661258f886",
        "content": "const updateUser = (id, updatedUser) => { setEditing(false) setUsers(users.map((user) => (user.id === id ? updatedUser : user))) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.4052631578947369
      },
      {
        "id": "ca61c958842f728d25ea6aaff1f999a3",
        "content": "forms/EditUserForm.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cdd638e00095e76c42db80d69dfdec30",
        "content": "currentUser",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7715f951abde8ac7dcce280ec7e57edb",
        "content": "import React, { useState } from 'react' const EditUserForm = (props) => { const [user, setUser] = useState(props.currentUser) const handleInputChange = (event) => { const { name, value } = event.target setUser({ ...user, [name]: value }) } return ( <form onSubmit={(event) => { event.preventDefault() props.updateUser(user.id, user) }} > <label>Name</label> <input type=\"text\" name=\"name\" value={user.name} onChange={handleInputChange} /> <label>Username</label> <input type=\"text\" name=\"username\" value={user.username} onChange={handleInputChange} /> <button>Update user</button> <button onClick={() => props.setEditing(false)} className=\"button muted-button\" > Cancel </button> </form> ) } export default EditUserForm",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "7715f951abde8ac7dcce280ec7e57edb",
        "content": "import React, { useState } from 'react' const EditUserForm = (props) => { const [user, setUser] = useState(props.currentUser) const handleInputChange = (event) => { const { name, value } = event.target setUser({ ...user, [name]: value }) } return ( <form onSubmit={(event) => { event.preventDefault() props.updateUser(user.id, user) }} > <label>Name</label> <input type=\"text\" name=\"name\" value={user.name} onChange={handleInputChange} /> <label>Username</label> <input type=\"text\" name=\"username\" value={user.username} onChange={handleInputChange} /> <button>Update user</button> <button onClick={() => props.setEditing(false)} className=\"button muted-button\" > Cancel </button> </form> ) } export default EditUserForm",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "958f6f56cd42c904603d226cd36a57b6",
        "content": "App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c85cfc460ea795dd62c378783a9f49e6",
        "content": "import EditUserForm from './forms/EditUserForm'",
        "type": "code",
        "language": "jsx",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c85cfc460ea795dd62c378783a9f49e6",
        "content": "import EditUserForm from './forms/EditUserForm'",
        "type": "code",
        "language": "jsx",
        "relevance": 0.30000000000000004
      },
      {
        "id": "3f86cc36e1df1334da973da6771b8160",
        "content": "editing",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a4518d1253882c93dd39a5238871d314",
        "content": "<div className=\"flex-large\"> {editing ? ( <div> <h2>Edit user</h2> <EditUserForm setEditing={setEditing} currentUser={currentUser} updateUser={updateUser} /> </div> ) : ( <div> <h2>Add user</h2> <AddUserForm addUser={addUser} /> </div> )} </div>",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "a4518d1253882c93dd39a5238871d314",
        "content": "<div className=\"flex-large\"> {editing ? ( <div> <h2>Edit user</h2> <EditUserForm setEditing={setEditing} currentUser={currentUser} updateUser={updateUser} /> </div> ) : ( <div> <h2>Add user</h2> <AddUserForm addUser={addUser} /> </div> )} </div>",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "8966777e5a311a9f852d7782cd2503df",
        "content": "EditUserForm",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "063dd7a0e999a76e5be61e7c9874d549",
        "content": "componentDidUpdate",
        "type": "code",
        "language": "text",
        "relevance": 0.5105263157894737
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7ec0c27feca9ee1d8bd4c6072e7b9a26",
        "content": "import React, { useState, useEffect } from 'react'",
        "type": "code",
        "language": "jsx",
        "relevance": 0.5105263157894737
      },
      {
        "id": "7ec0c27feca9ee1d8bd4c6072e7b9a26",
        "content": "import React, { useState, useEffect } from 'react'",
        "type": "code",
        "language": "jsx",
        "relevance": 0.5105263157894737
      },
      {
        "id": "939c1c1a184bcc12c9940714bfe8d32a",
        "content": "useEffect(() => { setUser(props.currentUser) }, [props])",
        "type": "code",
        "language": "jsx",
        "relevance": 0.4052631578947369
      },
      {
        "id": "939c1c1a184bcc12c9940714bfe8d32a",
        "content": "useEffect(() => { setUser(props.currentUser) }, [props])",
        "type": "code",
        "language": "jsx",
        "relevance": 0.4052631578947369
      },
      {
        "id": "ee11cbb19052e40b07aac0ca060c23ee",
        "content": "user",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1eadfb737bbee28074f629b06a9b26e4",
        "content": "if (prevProps.currentUser !== this.state.currentUser)",
        "type": "code",
        "language": "text",
        "relevance": 0.5105263157894737
      },
      {
        "id": "f003264b25df0346113b455ba65d744a",
        "content": "[props]",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "f003264b25df0346113b455ba65d744a",
        "content": "[props]",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "063dd7a0e999a76e5be61e7c9874d549",
        "content": "componentDidUpdate",
        "type": "code",
        "language": "text",
        "relevance": 0.5105263157894737
      },
      {
        "id": "a5bfcf7e4fe575c28923c968c46eadc2",
        "content": "componentDidMount",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "d751713988987e9331980363e24189ce",
        "content": "[]",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "814629207397d08801bc034a267a198b",
        "content": "setEditing(false)",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "bf1562b8d814fc7f03da3bc52737cf50",
        "content": "deleteUser",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "958f6f56cd42c904603d226cd36a57b6",
        "content": "App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      }
    ]
  },
  {
    "metadata": {
      "description": "A new concept was introduced in React - Hooks. Hooks are an alternative to classes. If you've used React before, you'll be familiar with…",
      "url": "https://www.taniarascia.com/crud-app-in-react-with-hooks",
      "title": "Build a CRUD App in React with Hooks | Tania Rascia's Personal Website",
      "source_type": "web",
      "crawl_time": 1730107281.1472619,
      "keywords": [
        "sql",
        "web",
        "article",
        "extract",
        "development",
        "information",
        "react"
      ]
    },
    "relevance_score": 1.026,
    "chunks": [
      {
        "content": "Build a CRUD App in React with HooksA new concept was introduced in React -Hooks. Hooks are an alternative to classes. If you've used React before, you'll be familiar withsimple (functional) componentsandclass components.Simple componentconstExample=()=>{return<div>I'm a simple component</div>} lass componentclassExampleextendsComponent{render(){return<div>I'm a class component</div>}} any of the features available to classes - such aslifecycle methodsandstate- have not been available to simple components, until now. The new Hooks proposal adds all that functionality and more.I wanted to try out Hooks and see how an app might look without any classes, but I didn't see any examples yet, so I decided to make one myself. I created a simple CRUD (create, read, update, delete) app that utilizes Hooks and no classes, and I created this tutorial for anyone else who wants to learn how to use them as well.If you don't know how to make a simple CRUD app in React, regardless of whether you use classes or hooks, this article will be good for you as well.View Demo AppView SourcePrerequisitesIn order to follow along with this tutorial, you'll need a basic knowledge of HTML, CSS, and JavaScript/ES6. You should also know the fundamentals of React, which you can learn by readingGetting Started with React.GoalsIn this tutorial, we'll make asimple CRUD app. It will have users, and you'll be able to add, update, or delete users. We won't use any React classes, and instead we'll utilize State Hooks and Effect Hooks on functional components. If you get lost along the way, be sure to check outthe source of the completed project.Create React AppWe'll start by installing the project withcreate-react-app(CRA).npx create-react-app react-hooksThen runnpm i.Now you're all set with the React.Initial SetupLet's start off by clearing out all the files from the boilerplate we don't need. Delete everything from the/srcfolder exceptApp.js,index.js, andindex.css.Forindex.css, I just copy and paste the CSS fromPrimitive, a simple CSS boilerplate I made, as the point of this app is to work on React and not care about design. This CSS boilerplate just adds some sensible defaults and a simple grid so we can start prototyping.Inindex.js, we'll simplify it by removing the references to Service Workers.index.jsimportReactfrom'react'importReactDOMfrom'react-dom'import'./index.css'importAppfrom'./App'ReactDOM.render(<App/>,document.getElementById('root'))And inApp.js, I'll make a simple, functional component forAppinstead of a class.App.jsimportReactfrom'react'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2></div></div></div>)} xportdefaultAppNow we have the initial setup and skeleton for the app.State vs. Hook StateIf we look at a very simple example of a class component with state and a functional component with Hook state, we can see the similarities and differences. With class state, you get one main state object, and you update using methods on the class andsetState().I'll make some quick example code, as if it were a library and you have books that have state.Class Component State ExampleclassAppextendsComponent{initialState={title:'',available:false,} tate=initialStateupdateBook=(book)=>{this.setState({title:book.title,available:book.available})}} ith Hook state, there's a getter and setter for each type of state (you can have as many as you want), and we obviously create functions instead of methods.Hook State ExampleconstApp=()=>{constinitialBookState={title:'',available:false,} onst[book,setBook]=useState(initialBookState)constupdateBook=(book)=>{setBook({title:book.title,available:book.available})}} 'm not going to get deep into the rationale behind hooks vs. class components, as you can readall about it on React's Hooks introduction. I'm just going to show you how to work with them to create a functional app.Setting up the ViewThe first thing we'll do is make some sample data and a table to display it, for the view. Create a new directory calledtablesinsrc, and a file within calledUserTable.js. We'll make the skeleton for a table.tables/UserTable.jsimportReactfrom'react'constUserTable=()=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody><tr><td>Name data</td><td>Username data</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr></tbody></table>)exportdefaultUserTableNow just import the file and add in the new component.App.jsimportReactfrom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTable/></div></div></div>)} xportdefaultAppLet's bring in some random dummy data and theuseStateimport from React.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppProps works just as it did before. We'll map through the user data we sent through and display the properties for each user, or display a message if there are no users. The edit and delete buttons aren't hooked up to anything yet, so they won't do anything.UserTable.jsimportReactfrom'react'constUserTable=(props)=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody>{props.users.length>0?(props.users.map((user)=>(<trkey={user.id}><td>{user.name}</td><td>{user.username}</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr>))):(<tr><tdcolSpan={3}>No users</td></tr>)}</tbody></table>)exportdefaultUserTableWe'll get to the edit and delete buttons in a moment. Now that the basic view is set up, let's get the adding functionality working.Adding a new userWe're going to set up the form to add a new user.The very first thing we can do is create the actual function that will add the new user to state. We have thesetUsersfunction automatically fromuseState, so that's what we'll use to update the user state.Since we're not using a real API and database, which would probably have an auto-incrementing ID, I'm going to increment the ID of the new user manually. This function will take auserobject as a parameter, and add them to theusersarray of objects. The...userscode ensures that all the previous users remain in the array.App.jsconstaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} e're going to make a component for this, so I'll just go ahead and add the reference to the component at the top, and insert the component below the \"Add user\" header. We can pass theaddUser()through as a prop. Make sure not to include the parentheses when we pass it through as a reference -<AddUserForm addUser={addUser} />, not<AddUserForm addUser={addUser()} />.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'importAddUserFormfrom'./forms/AddUserForm'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)constaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} eturn(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2><AddUserFormaddUser={addUser}/></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppNow we have to create a form that you can use to add the new user. Let's create aformssubdirectory with a file inside calledAddUserForm.js.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{return(<form><label>Name</label><inputtype=\"text\"name=\"name\"value=\"\"/><label>Username</label><inputtype=\"text\"name=\"username\"value=\"\"/><button>Add new user</button></form>)} xportdefaultAddUserFormRight now, the form is empty, and you cannot add any values to it due to our empty value strings, nor does the submit button do anything.Just like before, we'll want to make some state, except this state will just be temporary, for keeping track of what's currently in the add user form.I'm going to create an initial state with those empty values, and set the user state to the empty values. Having initial state in a variable is useful, because after we submit the form, we can return it to the initial, empty value.AddUserForm.jsconstinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)Now we'll create a function to update the state within the form.eventalways gets passed through to anyonevent in the DOM, so you'll see that as the parameter of the function.",
        "chunk_type": "code_class",
        "tag": "main",
        "score": 1.1219999999999999,
        "word_count": 990,
        "chunk_id": "7dde3fbe0c54b3d7b39138af01f25bdd",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Object destructuring will allow us to easily get thename(key) andvaluefrom the form. Finally, we'll set the user much like we did on theAppcomponent, except this time we're using computed property names to dynamically set the name (using[name]) and value.consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} f you don't understand what's being passed through, try playing around withconsole.log(event)in the input handling function.Now we extract the values from the state object, and reference our function in theonChangeevent.<form><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>The last thing to take care of is actually submitting the form back to theAppcomponent. As we passed the function down withprops, we're going to use props to access the function. I'm going to write anonSubmitfunction, and we'll prevent the default form submission from firing. I added a small bit of validation to make sure empty values cannot be submitted, and sent the user through to the add function. Finally, I'm using the setter to reset the form to its initial value after successful submission.<formonSubmit={event=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}>Fortunately this code is pretty simple, as we don't have to worry about asynchronous API calls.Here is our fullAddUserFormcomponent.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{constinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>)} xportdefaultAddUserFormCool.Deleting a userThe next one we'll tackle is deleting a user, which is the easiest functionality to take care of.BelowaddUserinApp.js, we'll createdeleteUser, which will take the ID of the user and filter them out of the user array.constdeleteUser=(id)=>{setUsers(users.filter((user)=>user.id!==id))} e pass that function through props toUserTable.<UserTableusers={users} eleteUser={deleteUser}/>Now all we need to do inUserTable.jsis make sure the delete button calls that function.<buttononClick={()=>props.deleteUser(user.id)} lassName=\"button muted-button\">Delete</button>Now you can delete some or all of the users.Updating a userThe final piece of the puzzle is introducing the ability to update existing users. This will be similar to adding a user, except we'll have to be able to identify which user is being edited. In class components, we would use thecomponentDidUpdatelifecycle method to achieve this, but now we'll use anEffect Hook. TheEffect Hookis likecomponentDidMountandcomponentDidUpdatecombined.The way we're going to structure this is when the Edit action is selected for a user, the \"Add user\" form will become an \"Edit user\" form, and it will be pre-populated with the data from the selected user. You can either cancel edit mode, or submit the change, which will update the selected user and close out of edit mode.Let's begin. InApp.js, the first thing we'll want to do is make state for whether or not edit mode is turned on. It will begin as false.App.jsconst[editing,setEditing]=useState(false)Since we don't know who is being edited until it's selected, we'll create initial empty state for the form, like we did with the add form.constinitialFormState={id:null,name:'',username:''} e'll want a way to see and update who the current user being edited is, so we'll apply that empty user to acurrentUserstate.const[currentUser,setCurrentUser]=useState(initialFormState)When Edit is selected on a user, it should turn on edit mode, and set the current user, which we'll do in thiseditRowfunction.consteditRow=(user)=>{setEditing(true)setCurrentUser({id:user.id,name:user.name,username:user.username})} ow just pass that function toUserTablelike we did withdeleteUser.<UserTableusers={users} ditRow={editRow} eleteUser={deleteUser}/>Over inUserTable.js, we send theuserobject over.UserTable.js<buttononClick={()=>{props.editRow(user)}} lassName=\"button muted-button\">Edit</button>Now we've got all the setup - there's a switch for edit mode, and a button that will pass the current user into state while flipping the edit mode switch.Let's create the actual function that will get called when the edit form is submitted. Unlike delete (which filters a user out by ID) or add (which appends a user to the array), the update function needs to map through the array, and update the user that matches the ID passed through.This means we'll be taking two parameters - the updated user object, and the id - and we'll use a ternary operation to map through the users and find the one we want to update.App.jsconstupdateUser=(id,updatedUser)=>{setEditing(false)setUsers(users.map((user)=>(user.id===id?updatedUser:user)))} e just need to make the edit form itself.Createforms/EditUserForm.js. Most of it will be the same as the add form. The only difference so far is that we'll set the state directly fromcurrentUservia props. There is also a cancel button that will simply switch off edit mode.EditUserForm.jsimportReact,{useState} rom'react'constEditUserForm=(props)=>{const[user,setUser]=useState(props.currentUser)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()props.updateUser(user.id,user)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Update user</button><buttononClick={()=>props.setEditing(false)} lassName=\"button muted-button\">Cancel</button></form>)} xportdefaultEditUserFormNow we have to bring the edit form intoApp.js, as well as creating a toggle for displaying the add or edit form.First, bring in the component.App.jsimportEditUserFormfrom'./forms/EditUserForm'Then create the toggle. We'll use a ternary operation to check if theeditingstate is true or not. If true, show the edit form. If false, show the add form. Make sure to pass all the functions we created down to the editing component.App.js<divclassName=\"flex-large\">{editing?(<div><h2>Edit user</h2><EditUserFormsetEditing={setEditing} urrentUser={currentUser} pdateUser={updateUser}/></div>):(<div><h2>Add user</h2><AddUserFormaddUser={addUser}/></div>)}</div>Okay, so at this point clicking on the Edit button should toggle edit mode, and you should be able to update a user. But are we done?Using the Effect HookIf you play around with this a little, you mat notice an issue. Two, actually. If you start editing one user, then try to switch to another user, nothing will happen. Why? Well, the component is already open, and although the state on the parent has changed, it's not registered down to the props.This is where the Effect Hook comes into place. We want to let theEditUserFormcomponent know the props have changed, which we would have done before withcomponentDidUpdate.First step is to bring inuseEffect.EditUserForm.jsimportReact,{useState,useEffect} rom'react'EditUserForm.jsuseEffect(()=>{setUser(props.currentUser)},[props])In the Effect Hook, we create a callback function that updates theuserstate with the new prop that's being sent through. Before, we needed to compareif (prevProps.currentUser !== this.state.currentUser), but with the Effect Hook we can just pass[props]through to let it know we're watching props.Using the[props]array is similar to usingcomponentDidUpdate. If you're doing a one-time event likecomponentDidMount, you can pass an empty array ([]) instead.Now if you try to change the user you're editing, it will work correctly!I said there were two issues here, and the other issue is that you can delete a user while it is currently being edited. We can fix this issue by addingsetEditing(false)to thedeleteUserfunction inApp.js.And that's it. We have a complete CRUD app utilizing React State and Effect hooks.ConclusionI didn't cover every use case for Hooks, or all functionality in-depth, but I tried to provide a working example of a complete, albeit simple, React program.",
        "chunk_type": "code_class",
        "tag": "main",
        "score": 1.1219999999999999,
        "word_count": 984,
        "chunk_id": "01db1189459f3f062f332a7661bf86c2",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "extract",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "For a complete FAQ on all things relating to hooks, check out theHooks FAQ.If you got lost anywhere along the way, don't forget to check out the demo and source.View Demo AppView SourceThe next thing to be on the lookout for is theSuspense API.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:November 07, 2018Category:TechnicalTagsjavascriptreactNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "main",
        "score": 1.1219999999999999,
        "word_count": 97,
        "chunk_id": "f216b0cfb411e6939266779e74dfb4e2",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "Build a CRUD App in React with HooksA new concept was introduced in React -Hooks. Hooks are an alternative to classes. If you've used React before, you'll be familiar withsimple (functional) componentsandclass components.Simple componentconstExample=()=>{return<div>I'm a simple component</div>} lass componentclassExampleextendsComponent{render(){return<div>I'm a class component</div>}} any of the features available to classes - such aslifecycle methodsandstate- have not been available to simple components, until now. The new Hooks proposal adds all that functionality and more.I wanted to try out Hooks and see how an app might look without any classes, but I didn't see any examples yet, so I decided to make one myself. I created a simple CRUD (create, read, update, delete) app that utilizes Hooks and no classes, and I created this tutorial for anyone else who wants to learn how to use them as well.If you don't know how to make a simple CRUD app in React, regardless of whether you use classes or hooks, this article will be good for you as well.View Demo AppView SourcePrerequisitesIn order to follow along with this tutorial, you'll need a basic knowledge of HTML, CSS, and JavaScript/ES6. You should also know the fundamentals of React, which you can learn by readingGetting Started with React.GoalsIn this tutorial, we'll make asimple CRUD app. It will have users, and you'll be able to add, update, or delete users. We won't use any React classes, and instead we'll utilize State Hooks and Effect Hooks on functional components. If you get lost along the way, be sure to check outthe source of the completed project.Create React AppWe'll start by installing the project withcreate-react-app(CRA).npx create-react-app react-hooksThen runnpm i.Now you're all set with the React.Initial SetupLet's start off by clearing out all the files from the boilerplate we don't need. Delete everything from the/srcfolder exceptApp.js,index.js, andindex.css.Forindex.css, I just copy and paste the CSS fromPrimitive, a simple CSS boilerplate I made, as the point of this app is to work on React and not care about design. This CSS boilerplate just adds some sensible defaults and a simple grid so we can start prototyping.Inindex.js, we'll simplify it by removing the references to Service Workers.index.jsimportReactfrom'react'importReactDOMfrom'react-dom'import'./index.css'importAppfrom'./App'ReactDOM.render(<App/>,document.getElementById('root'))And inApp.js, I'll make a simple, functional component forAppinstead of a class.App.jsimportReactfrom'react'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2></div></div></div>)} xportdefaultAppNow we have the initial setup and skeleton for the app.State vs. Hook StateIf we look at a very simple example of a class component with state and a functional component with Hook state, we can see the similarities and differences. With class state, you get one main state object, and you update using methods on the class andsetState().I'll make some quick example code, as if it were a library and you have books that have state.Class Component State ExampleclassAppextendsComponent{initialState={title:'',available:false,} tate=initialStateupdateBook=(book)=>{this.setState({title:book.title,available:book.available})}} ith Hook state, there's a getter and setter for each type of state (you can have as many as you want), and we obviously create functions instead of methods.Hook State ExampleconstApp=()=>{constinitialBookState={title:'',available:false,} onst[book,setBook]=useState(initialBookState)constupdateBook=(book)=>{setBook({title:book.title,available:book.available})}} 'm not going to get deep into the rationale behind hooks vs. class components, as you can readall about it on React's Hooks introduction. I'm just going to show you how to work with them to create a functional app.Setting up the ViewThe first thing we'll do is make some sample data and a table to display it, for the view. Create a new directory calledtablesinsrc, and a file within calledUserTable.js. We'll make the skeleton for a table.tables/UserTable.jsimportReactfrom'react'constUserTable=()=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody><tr><td>Name data</td><td>Username data</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr></tbody></table>)exportdefaultUserTableNow just import the file and add in the new component.App.jsimportReactfrom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTable/></div></div></div>)} xportdefaultAppLet's bring in some random dummy data and theuseStateimport from React.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppProps works just as it did before. We'll map through the user data we sent through and display the properties for each user, or display a message if there are no users. The edit and delete buttons aren't hooked up to anything yet, so they won't do anything.UserTable.jsimportReactfrom'react'constUserTable=(props)=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody>{props.users.length>0?(props.users.map((user)=>(<trkey={user.id}><td>{user.name}</td><td>{user.username}</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr>))):(<tr><tdcolSpan={3}>No users</td></tr>)}</tbody></table>)exportdefaultUserTableWe'll get to the edit and delete buttons in a moment. Now that the basic view is set up, let's get the adding functionality working.Adding a new userWe're going to set up the form to add a new user.The very first thing we can do is create the actual function that will add the new user to state. We have thesetUsersfunction automatically fromuseState, so that's what we'll use to update the user state.Since we're not using a real API and database, which would probably have an auto-incrementing ID, I'm going to increment the ID of the new user manually. This function will take auserobject as a parameter, and add them to theusersarray of objects. The...userscode ensures that all the previous users remain in the array.App.jsconstaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} e're going to make a component for this, so I'll just go ahead and add the reference to the component at the top, and insert the component below the \"Add user\" header. We can pass theaddUser()through as a prop. Make sure not to include the parentheses when we pass it through as a reference -<AddUserForm addUser={addUser} />, not<AddUserForm addUser={addUser()} />.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'importAddUserFormfrom'./forms/AddUserForm'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)constaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} eturn(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2><AddUserFormaddUser={addUser}/></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppNow we have to create a form that you can use to add the new user. Let's create aformssubdirectory with a file inside calledAddUserForm.js.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{return(<form><label>Name</label><inputtype=\"text\"name=\"name\"value=\"\"/><label>Username</label><inputtype=\"text\"name=\"username\"value=\"\"/><button>Add new user</button></form>)} xportdefaultAddUserFormRight now, the form is empty, and you cannot add any values to it due to our empty value strings, nor does the submit button do anything.Just like before, we'll want to make some state, except this state will just be temporary, for keeping track of what's currently in the add user form.I'm going to create an initial state with those empty values, and set the user state to the empty values. Having initial state in a variable is useful, because after we submit the form, we can return it to the initial, empty value.AddUserForm.jsconstinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)Now we'll create a function to update the state within the form.eventalways gets passed through to anyonevent in the DOM, so you'll see that as the parameter of the function.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 990,
        "chunk_id": "7dde3fbe0c54b3d7b39138af01f25bdd",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Object destructuring will allow us to easily get thename(key) andvaluefrom the form. Finally, we'll set the user much like we did on theAppcomponent, except this time we're using computed property names to dynamically set the name (using[name]) and value.consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} f you don't understand what's being passed through, try playing around withconsole.log(event)in the input handling function.Now we extract the values from the state object, and reference our function in theonChangeevent.<form><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>The last thing to take care of is actually submitting the form back to theAppcomponent. As we passed the function down withprops, we're going to use props to access the function. I'm going to write anonSubmitfunction, and we'll prevent the default form submission from firing. I added a small bit of validation to make sure empty values cannot be submitted, and sent the user through to the add function. Finally, I'm using the setter to reset the form to its initial value after successful submission.<formonSubmit={event=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}>Fortunately this code is pretty simple, as we don't have to worry about asynchronous API calls.Here is our fullAddUserFormcomponent.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{constinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>)} xportdefaultAddUserFormCool.Deleting a userThe next one we'll tackle is deleting a user, which is the easiest functionality to take care of.BelowaddUserinApp.js, we'll createdeleteUser, which will take the ID of the user and filter them out of the user array.constdeleteUser=(id)=>{setUsers(users.filter((user)=>user.id!==id))} e pass that function through props toUserTable.<UserTableusers={users} eleteUser={deleteUser}/>Now all we need to do inUserTable.jsis make sure the delete button calls that function.<buttononClick={()=>props.deleteUser(user.id)} lassName=\"button muted-button\">Delete</button>Now you can delete some or all of the users.Updating a userThe final piece of the puzzle is introducing the ability to update existing users. This will be similar to adding a user, except we'll have to be able to identify which user is being edited. In class components, we would use thecomponentDidUpdatelifecycle method to achieve this, but now we'll use anEffect Hook. TheEffect Hookis likecomponentDidMountandcomponentDidUpdatecombined.The way we're going to structure this is when the Edit action is selected for a user, the \"Add user\" form will become an \"Edit user\" form, and it will be pre-populated with the data from the selected user. You can either cancel edit mode, or submit the change, which will update the selected user and close out of edit mode.Let's begin. InApp.js, the first thing we'll want to do is make state for whether or not edit mode is turned on. It will begin as false.App.jsconst[editing,setEditing]=useState(false)Since we don't know who is being edited until it's selected, we'll create initial empty state for the form, like we did with the add form.constinitialFormState={id:null,name:'',username:''} e'll want a way to see and update who the current user being edited is, so we'll apply that empty user to acurrentUserstate.const[currentUser,setCurrentUser]=useState(initialFormState)When Edit is selected on a user, it should turn on edit mode, and set the current user, which we'll do in thiseditRowfunction.consteditRow=(user)=>{setEditing(true)setCurrentUser({id:user.id,name:user.name,username:user.username})} ow just pass that function toUserTablelike we did withdeleteUser.<UserTableusers={users} ditRow={editRow} eleteUser={deleteUser}/>Over inUserTable.js, we send theuserobject over.UserTable.js<buttononClick={()=>{props.editRow(user)}} lassName=\"button muted-button\">Edit</button>Now we've got all the setup - there's a switch for edit mode, and a button that will pass the current user into state while flipping the edit mode switch.Let's create the actual function that will get called when the edit form is submitted. Unlike delete (which filters a user out by ID) or add (which appends a user to the array), the update function needs to map through the array, and update the user that matches the ID passed through.This means we'll be taking two parameters - the updated user object, and the id - and we'll use a ternary operation to map through the users and find the one we want to update.App.jsconstupdateUser=(id,updatedUser)=>{setEditing(false)setUsers(users.map((user)=>(user.id===id?updatedUser:user)))} e just need to make the edit form itself.Createforms/EditUserForm.js. Most of it will be the same as the add form. The only difference so far is that we'll set the state directly fromcurrentUservia props. There is also a cancel button that will simply switch off edit mode.EditUserForm.jsimportReact,{useState} rom'react'constEditUserForm=(props)=>{const[user,setUser]=useState(props.currentUser)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()props.updateUser(user.id,user)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Update user</button><buttononClick={()=>props.setEditing(false)} lassName=\"button muted-button\">Cancel</button></form>)} xportdefaultEditUserFormNow we have to bring the edit form intoApp.js, as well as creating a toggle for displaying the add or edit form.First, bring in the component.App.jsimportEditUserFormfrom'./forms/EditUserForm'Then create the toggle. We'll use a ternary operation to check if theeditingstate is true or not. If true, show the edit form. If false, show the add form. Make sure to pass all the functions we created down to the editing component.App.js<divclassName=\"flex-large\">{editing?(<div><h2>Edit user</h2><EditUserFormsetEditing={setEditing} urrentUser={currentUser} pdateUser={updateUser}/></div>):(<div><h2>Add user</h2><AddUserFormaddUser={addUser}/></div>)}</div>Okay, so at this point clicking on the Edit button should toggle edit mode, and you should be able to update a user. But are we done?Using the Effect HookIf you play around with this a little, you mat notice an issue. Two, actually. If you start editing one user, then try to switch to another user, nothing will happen. Why? Well, the component is already open, and although the state on the parent has changed, it's not registered down to the props.This is where the Effect Hook comes into place. We want to let theEditUserFormcomponent know the props have changed, which we would have done before withcomponentDidUpdate.First step is to bring inuseEffect.EditUserForm.jsimportReact,{useState,useEffect} rom'react'EditUserForm.jsuseEffect(()=>{setUser(props.currentUser)},[props])In the Effect Hook, we create a callback function that updates theuserstate with the new prop that's being sent through. Before, we needed to compareif (prevProps.currentUser !== this.state.currentUser), but with the Effect Hook we can just pass[props]through to let it know we're watching props.Using the[props]array is similar to usingcomponentDidUpdate. If you're doing a one-time event likecomponentDidMount, you can pass an empty array ([]) instead.Now if you try to change the user you're editing, it will work correctly!I said there were two issues here, and the other issue is that you can delete a user while it is currently being edited. We can fix this issue by addingsetEditing(false)to thedeleteUserfunction inApp.js.And that's it. We have a complete CRUD app utilizing React State and Effect hooks.ConclusionI didn't cover every use case for Hooks, or all functionality in-depth, but I tried to provide a working example of a complete, albeit simple, React program.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 984,
        "chunk_id": "01db1189459f3f062f332a7661bf86c2",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "extract",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "For a complete FAQ on all things relating to hooks, check out theHooks FAQ.If you got lost anywhere along the way, don't forget to check out the demo and source.View Demo AppView SourceThe next thing to be on the lookout for is theSuspense API.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:November 07, 2018Category:TechnicalTagsjavascriptreactNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 97,
        "chunk_id": "f216b0cfb411e6939266779e74dfb4e2",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "Build a CRUD App in React with HooksA new concept was introduced in React -Hooks. Hooks are an alternative to classes. If you've used React before, you'll be familiar withsimple (functional) componentsandclass components.Simple componentconstExample=()=>{return<div>I'm a simple component</div>} lass componentclassExampleextendsComponent{render(){return<div>I'm a class component</div>}} any of the features available to classes - such aslifecycle methodsandstate- have not been available to simple components, until now. The new Hooks proposal adds all that functionality and more.I wanted to try out Hooks and see how an app might look without any classes, but I didn't see any examples yet, so I decided to make one myself. I created a simple CRUD (create, read, update, delete) app that utilizes Hooks and no classes, and I created this tutorial for anyone else who wants to learn how to use them as well.If you don't know how to make a simple CRUD app in React, regardless of whether you use classes or hooks, this article will be good for you as well.View Demo AppView SourcePrerequisitesIn order to follow along with this tutorial, you'll need a basic knowledge of HTML, CSS, and JavaScript/ES6. You should also know the fundamentals of React, which you can learn by readingGetting Started with React.GoalsIn this tutorial, we'll make asimple CRUD app. It will have users, and you'll be able to add, update, or delete users. We won't use any React classes, and instead we'll utilize State Hooks and Effect Hooks on functional components. If you get lost along the way, be sure to check outthe source of the completed project.Create React AppWe'll start by installing the project withcreate-react-app(CRA).npx create-react-app react-hooksThen runnpm i.Now you're all set with the React.Initial SetupLet's start off by clearing out all the files from the boilerplate we don't need. Delete everything from the/srcfolder exceptApp.js,index.js, andindex.css.Forindex.css, I just copy and paste the CSS fromPrimitive, a simple CSS boilerplate I made, as the point of this app is to work on React and not care about design. This CSS boilerplate just adds some sensible defaults and a simple grid so we can start prototyping.Inindex.js, we'll simplify it by removing the references to Service Workers.index.jsimportReactfrom'react'importReactDOMfrom'react-dom'import'./index.css'importAppfrom'./App'ReactDOM.render(<App/>,document.getElementById('root'))And inApp.js, I'll make a simple, functional component forAppinstead of a class.App.jsimportReactfrom'react'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2></div></div></div>)} xportdefaultAppNow we have the initial setup and skeleton for the app.State vs. Hook StateIf we look at a very simple example of a class component with state and a functional component with Hook state, we can see the similarities and differences. With class state, you get one main state object, and you update using methods on the class andsetState().I'll make some quick example code, as if it were a library and you have books that have state.Class Component State ExampleclassAppextendsComponent{initialState={title:'',available:false,} tate=initialStateupdateBook=(book)=>{this.setState({title:book.title,available:book.available})}} ith Hook state, there's a getter and setter for each type of state (you can have as many as you want), and we obviously create functions instead of methods.Hook State ExampleconstApp=()=>{constinitialBookState={title:'',available:false,} onst[book,setBook]=useState(initialBookState)constupdateBook=(book)=>{setBook({title:book.title,available:book.available})}} 'm not going to get deep into the rationale behind hooks vs. class components, as you can readall about it on React's Hooks introduction. I'm just going to show you how to work with them to create a functional app.Setting up the ViewThe first thing we'll do is make some sample data and a table to display it, for the view. Create a new directory calledtablesinsrc, and a file within calledUserTable.js. We'll make the skeleton for a table.tables/UserTable.jsimportReactfrom'react'constUserTable=()=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody><tr><td>Name data</td><td>Username data</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr></tbody></table>)exportdefaultUserTableNow just import the file and add in the new component.App.jsimportReactfrom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTable/></div></div></div>)} xportdefaultAppLet's bring in some random dummy data and theuseStateimport from React.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppProps works just as it did before. We'll map through the user data we sent through and display the properties for each user, or display a message if there are no users. The edit and delete buttons aren't hooked up to anything yet, so they won't do anything.UserTable.jsimportReactfrom'react'constUserTable=(props)=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody>{props.users.length>0?(props.users.map((user)=>(<trkey={user.id}><td>{user.name}</td><td>{user.username}</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr>))):(<tr><tdcolSpan={3}>No users</td></tr>)}</tbody></table>)exportdefaultUserTableWe'll get to the edit and delete buttons in a moment. Now that the basic view is set up, let's get the adding functionality working.Adding a new userWe're going to set up the form to add a new user.The very first thing we can do is create the actual function that will add the new user to state. We have thesetUsersfunction automatically fromuseState, so that's what we'll use to update the user state.Since we're not using a real API and database, which would probably have an auto-incrementing ID, I'm going to increment the ID of the new user manually. This function will take auserobject as a parameter, and add them to theusersarray of objects. The...userscode ensures that all the previous users remain in the array.App.jsconstaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} e're going to make a component for this, so I'll just go ahead and add the reference to the component at the top, and insert the component below the \"Add user\" header. We can pass theaddUser()through as a prop. Make sure not to include the parentheses when we pass it through as a reference -<AddUserForm addUser={addUser} />, not<AddUserForm addUser={addUser()} />.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'importAddUserFormfrom'./forms/AddUserForm'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)constaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} eturn(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2><AddUserFormaddUser={addUser}/></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppNow we have to create a form that you can use to add the new user. Let's create aformssubdirectory with a file inside calledAddUserForm.js.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{return(<form><label>Name</label><inputtype=\"text\"name=\"name\"value=\"\"/><label>Username</label><inputtype=\"text\"name=\"username\"value=\"\"/><button>Add new user</button></form>)} xportdefaultAddUserFormRight now, the form is empty, and you cannot add any values to it due to our empty value strings, nor does the submit button do anything.Just like before, we'll want to make some state, except this state will just be temporary, for keeping track of what's currently in the add user form.I'm going to create an initial state with those empty values, and set the user state to the empty values. Having initial state in a variable is useful, because after we submit the form, we can return it to the initial, empty value.AddUserForm.jsconstinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)Now we'll create a function to update the state within the form.eventalways gets passed through to anyonevent in the DOM, so you'll see that as the parameter of the function.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 990,
        "chunk_id": "7dde3fbe0c54b3d7b39138af01f25bdd",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Object destructuring will allow us to easily get thename(key) andvaluefrom the form. Finally, we'll set the user much like we did on theAppcomponent, except this time we're using computed property names to dynamically set the name (using[name]) and value.consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} f you don't understand what's being passed through, try playing around withconsole.log(event)in the input handling function.Now we extract the values from the state object, and reference our function in theonChangeevent.<form><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>The last thing to take care of is actually submitting the form back to theAppcomponent. As we passed the function down withprops, we're going to use props to access the function. I'm going to write anonSubmitfunction, and we'll prevent the default form submission from firing. I added a small bit of validation to make sure empty values cannot be submitted, and sent the user through to the add function. Finally, I'm using the setter to reset the form to its initial value after successful submission.<formonSubmit={event=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}>Fortunately this code is pretty simple, as we don't have to worry about asynchronous API calls.Here is our fullAddUserFormcomponent.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{constinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>)} xportdefaultAddUserFormCool.Deleting a userThe next one we'll tackle is deleting a user, which is the easiest functionality to take care of.BelowaddUserinApp.js, we'll createdeleteUser, which will take the ID of the user and filter them out of the user array.constdeleteUser=(id)=>{setUsers(users.filter((user)=>user.id!==id))} e pass that function through props toUserTable.<UserTableusers={users} eleteUser={deleteUser}/>Now all we need to do inUserTable.jsis make sure the delete button calls that function.<buttononClick={()=>props.deleteUser(user.id)} lassName=\"button muted-button\">Delete</button>Now you can delete some or all of the users.Updating a userThe final piece of the puzzle is introducing the ability to update existing users. This will be similar to adding a user, except we'll have to be able to identify which user is being edited. In class components, we would use thecomponentDidUpdatelifecycle method to achieve this, but now we'll use anEffect Hook. TheEffect Hookis likecomponentDidMountandcomponentDidUpdatecombined.The way we're going to structure this is when the Edit action is selected for a user, the \"Add user\" form will become an \"Edit user\" form, and it will be pre-populated with the data from the selected user. You can either cancel edit mode, or submit the change, which will update the selected user and close out of edit mode.Let's begin. InApp.js, the first thing we'll want to do is make state for whether or not edit mode is turned on. It will begin as false.App.jsconst[editing,setEditing]=useState(false)Since we don't know who is being edited until it's selected, we'll create initial empty state for the form, like we did with the add form.constinitialFormState={id:null,name:'',username:''} e'll want a way to see and update who the current user being edited is, so we'll apply that empty user to acurrentUserstate.const[currentUser,setCurrentUser]=useState(initialFormState)When Edit is selected on a user, it should turn on edit mode, and set the current user, which we'll do in thiseditRowfunction.consteditRow=(user)=>{setEditing(true)setCurrentUser({id:user.id,name:user.name,username:user.username})} ow just pass that function toUserTablelike we did withdeleteUser.<UserTableusers={users} ditRow={editRow} eleteUser={deleteUser}/>Over inUserTable.js, we send theuserobject over.UserTable.js<buttononClick={()=>{props.editRow(user)}} lassName=\"button muted-button\">Edit</button>Now we've got all the setup - there's a switch for edit mode, and a button that will pass the current user into state while flipping the edit mode switch.Let's create the actual function that will get called when the edit form is submitted. Unlike delete (which filters a user out by ID) or add (which appends a user to the array), the update function needs to map through the array, and update the user that matches the ID passed through.This means we'll be taking two parameters - the updated user object, and the id - and we'll use a ternary operation to map through the users and find the one we want to update.App.jsconstupdateUser=(id,updatedUser)=>{setEditing(false)setUsers(users.map((user)=>(user.id===id?updatedUser:user)))} e just need to make the edit form itself.Createforms/EditUserForm.js. Most of it will be the same as the add form. The only difference so far is that we'll set the state directly fromcurrentUservia props. There is also a cancel button that will simply switch off edit mode.EditUserForm.jsimportReact,{useState} rom'react'constEditUserForm=(props)=>{const[user,setUser]=useState(props.currentUser)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()props.updateUser(user.id,user)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Update user</button><buttononClick={()=>props.setEditing(false)} lassName=\"button muted-button\">Cancel</button></form>)} xportdefaultEditUserFormNow we have to bring the edit form intoApp.js, as well as creating a toggle for displaying the add or edit form.First, bring in the component.App.jsimportEditUserFormfrom'./forms/EditUserForm'Then create the toggle. We'll use a ternary operation to check if theeditingstate is true or not. If true, show the edit form. If false, show the add form. Make sure to pass all the functions we created down to the editing component.App.js<divclassName=\"flex-large\">{editing?(<div><h2>Edit user</h2><EditUserFormsetEditing={setEditing} urrentUser={currentUser} pdateUser={updateUser}/></div>):(<div><h2>Add user</h2><AddUserFormaddUser={addUser}/></div>)}</div>Okay, so at this point clicking on the Edit button should toggle edit mode, and you should be able to update a user. But are we done?Using the Effect HookIf you play around with this a little, you mat notice an issue. Two, actually. If you start editing one user, then try to switch to another user, nothing will happen. Why? Well, the component is already open, and although the state on the parent has changed, it's not registered down to the props.This is where the Effect Hook comes into place. We want to let theEditUserFormcomponent know the props have changed, which we would have done before withcomponentDidUpdate.First step is to bring inuseEffect.EditUserForm.jsimportReact,{useState,useEffect} rom'react'EditUserForm.jsuseEffect(()=>{setUser(props.currentUser)},[props])In the Effect Hook, we create a callback function that updates theuserstate with the new prop that's being sent through. Before, we needed to compareif (prevProps.currentUser !== this.state.currentUser), but with the Effect Hook we can just pass[props]through to let it know we're watching props.Using the[props]array is similar to usingcomponentDidUpdate. If you're doing a one-time event likecomponentDidMount, you can pass an empty array ([]) instead.Now if you try to change the user you're editing, it will work correctly!I said there were two issues here, and the other issue is that you can delete a user while it is currently being edited. We can fix this issue by addingsetEditing(false)to thedeleteUserfunction inApp.js.And that's it. We have a complete CRUD app utilizing React State and Effect hooks.ConclusionI didn't cover every use case for Hooks, or all functionality in-depth, but I tried to provide a working example of a complete, albeit simple, React program.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 984,
        "chunk_id": "01db1189459f3f062f332a7661bf86c2",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "extract",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "For a complete FAQ on all things relating to hooks, check out theHooks FAQ.If you got lost anywhere along the way, don't forget to check out the demo and source.View Demo AppView SourceThe next thing to be on the lookout for is theSuspense API.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:November 07, 2018Category:TechnicalTagsjavascriptreactNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 97,
        "chunk_id": "f216b0cfb411e6939266779e74dfb4e2",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "Build a CRUD App in React with HooksA new concept was introduced in React -Hooks. Hooks are an alternative to classes. If you've used React before, you'll be familiar withsimple (functional) componentsandclass components.Simple componentconstExample=()=>{return<div>I'm a simple component</div>} lass componentclassExampleextendsComponent{render(){return<div>I'm a class component</div>}} any of the features available to classes - such aslifecycle methodsandstate- have not been available to simple components, until now. The new Hooks proposal adds all that functionality and more.I wanted to try out Hooks and see how an app might look without any classes, but I didn't see any examples yet, so I decided to make one myself. I created a simple CRUD (create, read, update, delete) app that utilizes Hooks and no classes, and I created this tutorial for anyone else who wants to learn how to use them as well.If you don't know how to make a simple CRUD app in React, regardless of whether you use classes or hooks, this article will be good for you as well.View Demo AppView SourcePrerequisitesIn order to follow along with this tutorial, you'll need a basic knowledge of HTML, CSS, and JavaScript/ES6. You should also know the fundamentals of React, which you can learn by readingGetting Started with React.GoalsIn this tutorial, we'll make asimple CRUD app. It will have users, and you'll be able to add, update, or delete users. We won't use any React classes, and instead we'll utilize State Hooks and Effect Hooks on functional components. If you get lost along the way, be sure to check outthe source of the completed project.Create React AppWe'll start by installing the project withcreate-react-app(CRA).npx create-react-app react-hooksThen runnpm i.Now you're all set with the React.Initial SetupLet's start off by clearing out all the files from the boilerplate we don't need. Delete everything from the/srcfolder exceptApp.js,index.js, andindex.css.Forindex.css, I just copy and paste the CSS fromPrimitive, a simple CSS boilerplate I made, as the point of this app is to work on React and not care about design. This CSS boilerplate just adds some sensible defaults and a simple grid so we can start prototyping.Inindex.js, we'll simplify it by removing the references to Service Workers.index.jsimportReactfrom'react'importReactDOMfrom'react-dom'import'./index.css'importAppfrom'./App'ReactDOM.render(<App/>,document.getElementById('root'))And inApp.js, I'll make a simple, functional component forAppinstead of a class.App.jsimportReactfrom'react'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2></div></div></div>)} xportdefaultAppNow we have the initial setup and skeleton for the app.State vs. Hook StateIf we look at a very simple example of a class component with state and a functional component with Hook state, we can see the similarities and differences. With class state, you get one main state object, and you update using methods on the class andsetState().I'll make some quick example code, as if it were a library and you have books that have state.Class Component State ExampleclassAppextendsComponent{initialState={title:'',available:false,} tate=initialStateupdateBook=(book)=>{this.setState({title:book.title,available:book.available})}} ith Hook state, there's a getter and setter for each type of state (you can have as many as you want), and we obviously create functions instead of methods.Hook State ExampleconstApp=()=>{constinitialBookState={title:'',available:false,} onst[book,setBook]=useState(initialBookState)constupdateBook=(book)=>{setBook({title:book.title,available:book.available})}} 'm not going to get deep into the rationale behind hooks vs. class components, as you can readall about it on React's Hooks introduction. I'm just going to show you how to work with them to create a functional app.Setting up the ViewThe first thing we'll do is make some sample data and a table to display it, for the view. Create a new directory calledtablesinsrc, and a file within calledUserTable.js. We'll make the skeleton for a table.tables/UserTable.jsimportReactfrom'react'constUserTable=()=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody><tr><td>Name data</td><td>Username data</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr></tbody></table>)exportdefaultUserTableNow just import the file and add in the new component.App.jsimportReactfrom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTable/></div></div></div>)} xportdefaultAppLet's bring in some random dummy data and theuseStateimport from React.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppProps works just as it did before. We'll map through the user data we sent through and display the properties for each user, or display a message if there are no users. The edit and delete buttons aren't hooked up to anything yet, so they won't do anything.UserTable.jsimportReactfrom'react'constUserTable=(props)=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody>{props.users.length>0?(props.users.map((user)=>(<trkey={user.id}><td>{user.name}</td><td>{user.username}</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr>))):(<tr><tdcolSpan={3}>No users</td></tr>)}</tbody></table>)exportdefaultUserTableWe'll get to the edit and delete buttons in a moment. Now that the basic view is set up, let's get the adding functionality working.Adding a new userWe're going to set up the form to add a new user.The very first thing we can do is create the actual function that will add the new user to state. We have thesetUsersfunction automatically fromuseState, so that's what we'll use to update the user state.Since we're not using a real API and database, which would probably have an auto-incrementing ID, I'm going to increment the ID of the new user manually. This function will take auserobject as a parameter, and add them to theusersarray of objects. The...userscode ensures that all the previous users remain in the array.App.jsconstaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} e're going to make a component for this, so I'll just go ahead and add the reference to the component at the top, and insert the component below the \"Add user\" header. We can pass theaddUser()through as a prop. Make sure not to include the parentheses when we pass it through as a reference -<AddUserForm addUser={addUser} />, not<AddUserForm addUser={addUser()} />.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'importAddUserFormfrom'./forms/AddUserForm'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)constaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} eturn(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2><AddUserFormaddUser={addUser}/></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppNow we have to create a form that you can use to add the new user. Let's create aformssubdirectory with a file inside calledAddUserForm.js.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{return(<form><label>Name</label><inputtype=\"text\"name=\"name\"value=\"\"/><label>Username</label><inputtype=\"text\"name=\"username\"value=\"\"/><button>Add new user</button></form>)} xportdefaultAddUserFormRight now, the form is empty, and you cannot add any values to it due to our empty value strings, nor does the submit button do anything.Just like before, we'll want to make some state, except this state will just be temporary, for keeping track of what's currently in the add user form.I'm going to create an initial state with those empty values, and set the user state to the empty values. Having initial state in a variable is useful, because after we submit the form, we can return it to the initial, empty value.AddUserForm.jsconstinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)Now we'll create a function to update the state within the form.eventalways gets passed through to anyonevent in the DOM, so you'll see that as the parameter of the function.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 990,
        "chunk_id": "7dde3fbe0c54b3d7b39138af01f25bdd",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Object destructuring will allow us to easily get thename(key) andvaluefrom the form. Finally, we'll set the user much like we did on theAppcomponent, except this time we're using computed property names to dynamically set the name (using[name]) and value.consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} f you don't understand what's being passed through, try playing around withconsole.log(event)in the input handling function.Now we extract the values from the state object, and reference our function in theonChangeevent.<form><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>The last thing to take care of is actually submitting the form back to theAppcomponent. As we passed the function down withprops, we're going to use props to access the function. I'm going to write anonSubmitfunction, and we'll prevent the default form submission from firing. I added a small bit of validation to make sure empty values cannot be submitted, and sent the user through to the add function. Finally, I'm using the setter to reset the form to its initial value after successful submission.<formonSubmit={event=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}>Fortunately this code is pretty simple, as we don't have to worry about asynchronous API calls.Here is our fullAddUserFormcomponent.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{constinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>)} xportdefaultAddUserFormCool.Deleting a userThe next one we'll tackle is deleting a user, which is the easiest functionality to take care of.BelowaddUserinApp.js, we'll createdeleteUser, which will take the ID of the user and filter them out of the user array.constdeleteUser=(id)=>{setUsers(users.filter((user)=>user.id!==id))} e pass that function through props toUserTable.<UserTableusers={users} eleteUser={deleteUser}/>Now all we need to do inUserTable.jsis make sure the delete button calls that function.<buttononClick={()=>props.deleteUser(user.id)} lassName=\"button muted-button\">Delete</button>Now you can delete some or all of the users.Updating a userThe final piece of the puzzle is introducing the ability to update existing users. This will be similar to adding a user, except we'll have to be able to identify which user is being edited. In class components, we would use thecomponentDidUpdatelifecycle method to achieve this, but now we'll use anEffect Hook. TheEffect Hookis likecomponentDidMountandcomponentDidUpdatecombined.The way we're going to structure this is when the Edit action is selected for a user, the \"Add user\" form will become an \"Edit user\" form, and it will be pre-populated with the data from the selected user. You can either cancel edit mode, or submit the change, which will update the selected user and close out of edit mode.Let's begin. InApp.js, the first thing we'll want to do is make state for whether or not edit mode is turned on. It will begin as false.App.jsconst[editing,setEditing]=useState(false)Since we don't know who is being edited until it's selected, we'll create initial empty state for the form, like we did with the add form.constinitialFormState={id:null,name:'',username:''} e'll want a way to see and update who the current user being edited is, so we'll apply that empty user to acurrentUserstate.const[currentUser,setCurrentUser]=useState(initialFormState)When Edit is selected on a user, it should turn on edit mode, and set the current user, which we'll do in thiseditRowfunction.consteditRow=(user)=>{setEditing(true)setCurrentUser({id:user.id,name:user.name,username:user.username})} ow just pass that function toUserTablelike we did withdeleteUser.<UserTableusers={users} ditRow={editRow} eleteUser={deleteUser}/>Over inUserTable.js, we send theuserobject over.UserTable.js<buttononClick={()=>{props.editRow(user)}} lassName=\"button muted-button\">Edit</button>Now we've got all the setup - there's a switch for edit mode, and a button that will pass the current user into state while flipping the edit mode switch.Let's create the actual function that will get called when the edit form is submitted. Unlike delete (which filters a user out by ID) or add (which appends a user to the array), the update function needs to map through the array, and update the user that matches the ID passed through.This means we'll be taking two parameters - the updated user object, and the id - and we'll use a ternary operation to map through the users and find the one we want to update.App.jsconstupdateUser=(id,updatedUser)=>{setEditing(false)setUsers(users.map((user)=>(user.id===id?updatedUser:user)))} e just need to make the edit form itself.Createforms/EditUserForm.js. Most of it will be the same as the add form. The only difference so far is that we'll set the state directly fromcurrentUservia props. There is also a cancel button that will simply switch off edit mode.EditUserForm.jsimportReact,{useState} rom'react'constEditUserForm=(props)=>{const[user,setUser]=useState(props.currentUser)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()props.updateUser(user.id,user)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Update user</button><buttononClick={()=>props.setEditing(false)} lassName=\"button muted-button\">Cancel</button></form>)} xportdefaultEditUserFormNow we have to bring the edit form intoApp.js, as well as creating a toggle for displaying the add or edit form.First, bring in the component.App.jsimportEditUserFormfrom'./forms/EditUserForm'Then create the toggle. We'll use a ternary operation to check if theeditingstate is true or not. If true, show the edit form. If false, show the add form. Make sure to pass all the functions we created down to the editing component.App.js<divclassName=\"flex-large\">{editing?(<div><h2>Edit user</h2><EditUserFormsetEditing={setEditing} urrentUser={currentUser} pdateUser={updateUser}/></div>):(<div><h2>Add user</h2><AddUserFormaddUser={addUser}/></div>)}</div>Okay, so at this point clicking on the Edit button should toggle edit mode, and you should be able to update a user. But are we done?Using the Effect HookIf you play around with this a little, you mat notice an issue. Two, actually. If you start editing one user, then try to switch to another user, nothing will happen. Why? Well, the component is already open, and although the state on the parent has changed, it's not registered down to the props.This is where the Effect Hook comes into place. We want to let theEditUserFormcomponent know the props have changed, which we would have done before withcomponentDidUpdate.First step is to bring inuseEffect.EditUserForm.jsimportReact,{useState,useEffect} rom'react'EditUserForm.jsuseEffect(()=>{setUser(props.currentUser)},[props])In the Effect Hook, we create a callback function that updates theuserstate with the new prop that's being sent through. Before, we needed to compareif (prevProps.currentUser !== this.state.currentUser), but with the Effect Hook we can just pass[props]through to let it know we're watching props.Using the[props]array is similar to usingcomponentDidUpdate. If you're doing a one-time event likecomponentDidMount, you can pass an empty array ([]) instead.Now if you try to change the user you're editing, it will work correctly!I said there were two issues here, and the other issue is that you can delete a user while it is currently being edited. We can fix this issue by addingsetEditing(false)to thedeleteUserfunction inApp.js.And that's it. We have a complete CRUD app utilizing React State and Effect hooks.ConclusionI didn't cover every use case for Hooks, or all functionality in-depth, but I tried to provide a working example of a complete, albeit simple, React program.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 984,
        "chunk_id": "01db1189459f3f062f332a7661bf86c2",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "extract",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "For a complete FAQ on all things relating to hooks, check out theHooks FAQ.If you got lost anywhere along the way, don't forget to check out the demo and source.View Demo AppView SourceThe next thing to be on the lookout for is theSuspense API.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:November 07, 2018Category:TechnicalTagsjavascriptreactNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 97,
        "chunk_id": "f216b0cfb411e6939266779e74dfb4e2",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "Build a CRUD App in React with HooksA new concept was introduced in React -Hooks. Hooks are an alternative to classes. If you've used React before, you'll be familiar withsimple (functional) componentsandclass components.Simple componentconstExample=()=>{return<div>I'm a simple component</div>} lass componentclassExampleextendsComponent{render(){return<div>I'm a class component</div>}} any of the features available to classes - such aslifecycle methodsandstate- have not been available to simple components, until now. The new Hooks proposal adds all that functionality and more.I wanted to try out Hooks and see how an app might look without any classes, but I didn't see any examples yet, so I decided to make one myself. I created a simple CRUD (create, read, update, delete) app that utilizes Hooks and no classes, and I created this tutorial for anyone else who wants to learn how to use them as well.If you don't know how to make a simple CRUD app in React, regardless of whether you use classes or hooks, this article will be good for you as well.View Demo AppView SourcePrerequisitesIn order to follow along with this tutorial, you'll need a basic knowledge of HTML, CSS, and JavaScript/ES6. You should also know the fundamentals of React, which you can learn by readingGetting Started with React.GoalsIn this tutorial, we'll make asimple CRUD app. It will have users, and you'll be able to add, update, or delete users. We won't use any React classes, and instead we'll utilize State Hooks and Effect Hooks on functional components. If you get lost along the way, be sure to check outthe source of the completed project.Create React AppWe'll start by installing the project withcreate-react-app(CRA).npx create-react-app react-hooksThen runnpm i.Now you're all set with the React.Initial SetupLet's start off by clearing out all the files from the boilerplate we don't need. Delete everything from the/srcfolder exceptApp.js,index.js, andindex.css.Forindex.css, I just copy and paste the CSS fromPrimitive, a simple CSS boilerplate I made, as the point of this app is to work on React and not care about design. This CSS boilerplate just adds some sensible defaults and a simple grid so we can start prototyping.Inindex.js, we'll simplify it by removing the references to Service Workers.index.jsimportReactfrom'react'importReactDOMfrom'react-dom'import'./index.css'importAppfrom'./App'ReactDOM.render(<App/>,document.getElementById('root'))And inApp.js, I'll make a simple, functional component forAppinstead of a class.App.jsimportReactfrom'react'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2></div></div></div>)} xportdefaultAppNow we have the initial setup and skeleton for the app.State vs. Hook StateIf we look at a very simple example of a class component with state and a functional component with Hook state, we can see the similarities and differences. With class state, you get one main state object, and you update using methods on the class andsetState().I'll make some quick example code, as if it were a library and you have books that have state.Class Component State ExampleclassAppextendsComponent{initialState={title:'',available:false,} tate=initialStateupdateBook=(book)=>{this.setState({title:book.title,available:book.available})}} ith Hook state, there's a getter and setter for each type of state (you can have as many as you want), and we obviously create functions instead of methods.Hook State ExampleconstApp=()=>{constinitialBookState={title:'',available:false,} onst[book,setBook]=useState(initialBookState)constupdateBook=(book)=>{setBook({title:book.title,available:book.available})}} 'm not going to get deep into the rationale behind hooks vs. class components, as you can readall about it on React's Hooks introduction. I'm just going to show you how to work with them to create a functional app.Setting up the ViewThe first thing we'll do is make some sample data and a table to display it, for the view. Create a new directory calledtablesinsrc, and a file within calledUserTable.js. We'll make the skeleton for a table.tables/UserTable.jsimportReactfrom'react'constUserTable=()=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody><tr><td>Name data</td><td>Username data</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr></tbody></table>)exportdefaultUserTableNow just import the file and add in the new component.App.jsimportReactfrom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTable/></div></div></div>)} xportdefaultAppLet's bring in some random dummy data and theuseStateimport from React.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppProps works just as it did before. We'll map through the user data we sent through and display the properties for each user, or display a message if there are no users. The edit and delete buttons aren't hooked up to anything yet, so they won't do anything.UserTable.jsimportReactfrom'react'constUserTable=(props)=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody>{props.users.length>0?(props.users.map((user)=>(<trkey={user.id}><td>{user.name}</td><td>{user.username}</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr>))):(<tr><tdcolSpan={3}>No users</td></tr>)}</tbody></table>)exportdefaultUserTableWe'll get to the edit and delete buttons in a moment. Now that the basic view is set up, let's get the adding functionality working.Adding a new userWe're going to set up the form to add a new user.The very first thing we can do is create the actual function that will add the new user to state. We have thesetUsersfunction automatically fromuseState, so that's what we'll use to update the user state.Since we're not using a real API and database, which would probably have an auto-incrementing ID, I'm going to increment the ID of the new user manually. This function will take auserobject as a parameter, and add them to theusersarray of objects. The...userscode ensures that all the previous users remain in the array.App.jsconstaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} e're going to make a component for this, so I'll just go ahead and add the reference to the component at the top, and insert the component below the \"Add user\" header. We can pass theaddUser()through as a prop. Make sure not to include the parentheses when we pass it through as a reference -<AddUserForm addUser={addUser} />, not<AddUserForm addUser={addUser()} />.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'importAddUserFormfrom'./forms/AddUserForm'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)constaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} eturn(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2><AddUserFormaddUser={addUser}/></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppNow we have to create a form that you can use to add the new user. Let's create aformssubdirectory with a file inside calledAddUserForm.js.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{return(<form><label>Name</label><inputtype=\"text\"name=\"name\"value=\"\"/><label>Username</label><inputtype=\"text\"name=\"username\"value=\"\"/><button>Add new user</button></form>)} xportdefaultAddUserFormRight now, the form is empty, and you cannot add any values to it due to our empty value strings, nor does the submit button do anything.Just like before, we'll want to make some state, except this state will just be temporary, for keeping track of what's currently in the add user form.I'm going to create an initial state with those empty values, and set the user state to the empty values. Having initial state in a variable is useful, because after we submit the form, we can return it to the initial, empty value.AddUserForm.jsconstinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)Now we'll create a function to update the state within the form.eventalways gets passed through to anyonevent in the DOM, so you'll see that as the parameter of the function.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 990,
        "chunk_id": "7dde3fbe0c54b3d7b39138af01f25bdd",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Object destructuring will allow us to easily get thename(key) andvaluefrom the form. Finally, we'll set the user much like we did on theAppcomponent, except this time we're using computed property names to dynamically set the name (using[name]) and value.consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} f you don't understand what's being passed through, try playing around withconsole.log(event)in the input handling function.Now we extract the values from the state object, and reference our function in theonChangeevent.<form><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>The last thing to take care of is actually submitting the form back to theAppcomponent. As we passed the function down withprops, we're going to use props to access the function. I'm going to write anonSubmitfunction, and we'll prevent the default form submission from firing. I added a small bit of validation to make sure empty values cannot be submitted, and sent the user through to the add function. Finally, I'm using the setter to reset the form to its initial value after successful submission.<formonSubmit={event=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}>Fortunately this code is pretty simple, as we don't have to worry about asynchronous API calls.Here is our fullAddUserFormcomponent.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{constinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>)} xportdefaultAddUserFormCool.Deleting a userThe next one we'll tackle is deleting a user, which is the easiest functionality to take care of.BelowaddUserinApp.js, we'll createdeleteUser, which will take the ID of the user and filter them out of the user array.constdeleteUser=(id)=>{setUsers(users.filter((user)=>user.id!==id))} e pass that function through props toUserTable.<UserTableusers={users} eleteUser={deleteUser}/>Now all we need to do inUserTable.jsis make sure the delete button calls that function.<buttononClick={()=>props.deleteUser(user.id)} lassName=\"button muted-button\">Delete</button>Now you can delete some or all of the users.Updating a userThe final piece of the puzzle is introducing the ability to update existing users. This will be similar to adding a user, except we'll have to be able to identify which user is being edited. In class components, we would use thecomponentDidUpdatelifecycle method to achieve this, but now we'll use anEffect Hook. TheEffect Hookis likecomponentDidMountandcomponentDidUpdatecombined.The way we're going to structure this is when the Edit action is selected for a user, the \"Add user\" form will become an \"Edit user\" form, and it will be pre-populated with the data from the selected user. You can either cancel edit mode, or submit the change, which will update the selected user and close out of edit mode.Let's begin. InApp.js, the first thing we'll want to do is make state for whether or not edit mode is turned on. It will begin as false.App.jsconst[editing,setEditing]=useState(false)Since we don't know who is being edited until it's selected, we'll create initial empty state for the form, like we did with the add form.constinitialFormState={id:null,name:'',username:''} e'll want a way to see and update who the current user being edited is, so we'll apply that empty user to acurrentUserstate.const[currentUser,setCurrentUser]=useState(initialFormState)When Edit is selected on a user, it should turn on edit mode, and set the current user, which we'll do in thiseditRowfunction.consteditRow=(user)=>{setEditing(true)setCurrentUser({id:user.id,name:user.name,username:user.username})} ow just pass that function toUserTablelike we did withdeleteUser.<UserTableusers={users} ditRow={editRow} eleteUser={deleteUser}/>Over inUserTable.js, we send theuserobject over.UserTable.js<buttononClick={()=>{props.editRow(user)}} lassName=\"button muted-button\">Edit</button>Now we've got all the setup - there's a switch for edit mode, and a button that will pass the current user into state while flipping the edit mode switch.Let's create the actual function that will get called when the edit form is submitted. Unlike delete (which filters a user out by ID) or add (which appends a user to the array), the update function needs to map through the array, and update the user that matches the ID passed through.This means we'll be taking two parameters - the updated user object, and the id - and we'll use a ternary operation to map through the users and find the one we want to update.App.jsconstupdateUser=(id,updatedUser)=>{setEditing(false)setUsers(users.map((user)=>(user.id===id?updatedUser:user)))} e just need to make the edit form itself.Createforms/EditUserForm.js. Most of it will be the same as the add form. The only difference so far is that we'll set the state directly fromcurrentUservia props. There is also a cancel button that will simply switch off edit mode.EditUserForm.jsimportReact,{useState} rom'react'constEditUserForm=(props)=>{const[user,setUser]=useState(props.currentUser)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()props.updateUser(user.id,user)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Update user</button><buttononClick={()=>props.setEditing(false)} lassName=\"button muted-button\">Cancel</button></form>)} xportdefaultEditUserFormNow we have to bring the edit form intoApp.js, as well as creating a toggle for displaying the add or edit form.First, bring in the component.App.jsimportEditUserFormfrom'./forms/EditUserForm'Then create the toggle. We'll use a ternary operation to check if theeditingstate is true or not. If true, show the edit form. If false, show the add form. Make sure to pass all the functions we created down to the editing component.App.js<divclassName=\"flex-large\">{editing?(<div><h2>Edit user</h2><EditUserFormsetEditing={setEditing} urrentUser={currentUser} pdateUser={updateUser}/></div>):(<div><h2>Add user</h2><AddUserFormaddUser={addUser}/></div>)}</div>Okay, so at this point clicking on the Edit button should toggle edit mode, and you should be able to update a user. But are we done?Using the Effect HookIf you play around with this a little, you mat notice an issue. Two, actually. If you start editing one user, then try to switch to another user, nothing will happen. Why? Well, the component is already open, and although the state on the parent has changed, it's not registered down to the props.This is where the Effect Hook comes into place. We want to let theEditUserFormcomponent know the props have changed, which we would have done before withcomponentDidUpdate.First step is to bring inuseEffect.EditUserForm.jsimportReact,{useState,useEffect} rom'react'EditUserForm.jsuseEffect(()=>{setUser(props.currentUser)},[props])In the Effect Hook, we create a callback function that updates theuserstate with the new prop that's being sent through. Before, we needed to compareif (prevProps.currentUser !== this.state.currentUser), but with the Effect Hook we can just pass[props]through to let it know we're watching props.Using the[props]array is similar to usingcomponentDidUpdate. If you're doing a one-time event likecomponentDidMount, you can pass an empty array ([]) instead.Now if you try to change the user you're editing, it will work correctly!I said there were two issues here, and the other issue is that you can delete a user while it is currently being edited. We can fix this issue by addingsetEditing(false)to thedeleteUserfunction inApp.js.And that's it. We have a complete CRUD app utilizing React State and Effect hooks.ConclusionI didn't cover every use case for Hooks, or all functionality in-depth, but I tried to provide a working example of a complete, albeit simple, React program.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 984,
        "chunk_id": "01db1189459f3f062f332a7661bf86c2",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "extract",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "For a complete FAQ on all things relating to hooks, check out theHooks FAQ.If you got lost anywhere along the way, don't forget to check out the demo and source.View Demo AppView SourceThe next thing to be on the lookout for is theSuspense API.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:November 07, 2018Category:TechnicalTagsjavascriptreactNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 97,
        "chunk_id": "f216b0cfb411e6939266779e74dfb4e2",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "A new concept was introduced in React -Hooks. Hooks are an alternative to classes. If you've used React before, you'll be familiar withsimple (functional) componentsandclass components.Simple componentconstExample=()=>{return<div>I'm a simple component</div>} lass componentclassExampleextendsComponent{render(){return<div>I'm a class component</div>}} any of the features available to classes - such aslifecycle methodsandstate- have not been available to simple components, until now. The new Hooks proposal adds all that functionality and more.I wanted to try out Hooks and see how an app might look without any classes, but I didn't see any examples yet, so I decided to make one myself. I created a simple CRUD (create, read, update, delete) app that utilizes Hooks and no classes, and I created this tutorial for anyone else who wants to learn how to use them as well.If you don't know how to make a simple CRUD app in React, regardless of whether you use classes or hooks, this article will be good for you as well.View Demo AppView SourcePrerequisitesIn order to follow along with this tutorial, you'll need a basic knowledge of HTML, CSS, and JavaScript/ES6. You should also know the fundamentals of React, which you can learn by readingGetting Started with React.GoalsIn this tutorial, we'll make asimple CRUD app. It will have users, and you'll be able to add, update, or delete users. We won't use any React classes, and instead we'll utilize State Hooks and Effect Hooks on functional components. If you get lost along the way, be sure to check outthe source of the completed project.Create React AppWe'll start by installing the project withcreate-react-app(CRA).npx create-react-app react-hooksThen runnpm i.Now you're all set with the React.Initial SetupLet's start off by clearing out all the files from the boilerplate we don't need. Delete everything from the/srcfolder exceptApp.js,index.js, andindex.css.Forindex.css, I just copy and paste the CSS fromPrimitive, a simple CSS boilerplate I made, as the point of this app is to work on React and not care about design. This CSS boilerplate just adds some sensible defaults and a simple grid so we can start prototyping.Inindex.js, we'll simplify it by removing the references to Service Workers.index.jsimportReactfrom'react'importReactDOMfrom'react-dom'import'./index.css'importAppfrom'./App'ReactDOM.render(<App/>,document.getElementById('root'))And inApp.js, I'll make a simple, functional component forAppinstead of a class.App.jsimportReactfrom'react'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2></div></div></div>)} xportdefaultAppNow we have the initial setup and skeleton for the app.State vs. Hook StateIf we look at a very simple example of a class component with state and a functional component with Hook state, we can see the similarities and differences. With class state, you get one main state object, and you update using methods on the class andsetState().I'll make some quick example code, as if it were a library and you have books that have state.Class Component State ExampleclassAppextendsComponent{initialState={title:'',available:false,} tate=initialStateupdateBook=(book)=>{this.setState({title:book.title,available:book.available})}} ith Hook state, there's a getter and setter for each type of state (you can have as many as you want), and we obviously create functions instead of methods.Hook State ExampleconstApp=()=>{constinitialBookState={title:'',available:false,} onst[book,setBook]=useState(initialBookState)constupdateBook=(book)=>{setBook({title:book.title,available:book.available})}} 'm not going to get deep into the rationale behind hooks vs. class components, as you can readall about it on React's Hooks introduction. I'm just going to show you how to work with them to create a functional app.Setting up the ViewThe first thing we'll do is make some sample data and a table to display it, for the view. Create a new directory calledtablesinsrc, and a file within calledUserTable.js. We'll make the skeleton for a table.tables/UserTable.jsimportReactfrom'react'constUserTable=()=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody><tr><td>Name data</td><td>Username data</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr></tbody></table>)exportdefaultUserTableNow just import the file and add in the new component.App.jsimportReactfrom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTable/></div></div></div>)} xportdefaultAppLet's bring in some random dummy data and theuseStateimport from React.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppProps works just as it did before. We'll map through the user data we sent through and display the properties for each user, or display a message if there are no users. The edit and delete buttons aren't hooked up to anything yet, so they won't do anything.UserTable.jsimportReactfrom'react'constUserTable=(props)=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody>{props.users.length>0?(props.users.map((user)=>(<trkey={user.id}><td>{user.name}</td><td>{user.username}</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr>))):(<tr><tdcolSpan={3}>No users</td></tr>)}</tbody></table>)exportdefaultUserTableWe'll get to the edit and delete buttons in a moment. Now that the basic view is set up, let's get the adding functionality working.Adding a new userWe're going to set up the form to add a new user.The very first thing we can do is create the actual function that will add the new user to state. We have thesetUsersfunction automatically fromuseState, so that's what we'll use to update the user state.Since we're not using a real API and database, which would probably have an auto-incrementing ID, I'm going to increment the ID of the new user manually. This function will take auserobject as a parameter, and add them to theusersarray of objects. The...userscode ensures that all the previous users remain in the array.App.jsconstaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} e're going to make a component for this, so I'll just go ahead and add the reference to the component at the top, and insert the component below the \"Add user\" header. We can pass theaddUser()through as a prop. Make sure not to include the parentheses when we pass it through as a reference -<AddUserForm addUser={addUser} />, not<AddUserForm addUser={addUser()} />.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'importAddUserFormfrom'./forms/AddUserForm'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)constaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} eturn(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2><AddUserFormaddUser={addUser}/></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppNow we have to create a form that you can use to add the new user. Let's create aformssubdirectory with a file inside calledAddUserForm.js.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{return(<form><label>Name</label><inputtype=\"text\"name=\"name\"value=\"\"/><label>Username</label><inputtype=\"text\"name=\"username\"value=\"\"/><button>Add new user</button></form>)} xportdefaultAddUserFormRight now, the form is empty, and you cannot add any values to it due to our empty value strings, nor does the submit button do anything.Just like before, we'll want to make some state, except this state will just be temporary, for keeping track of what's currently in the add user form.I'm going to create an initial state with those empty values, and set the user state to the empty values. Having initial state in a variable is useful, because after we submit the form, we can return it to the initial, empty value.AddUserForm.jsconstinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)Now we'll create a function to update the state within the form.eventalways gets passed through to anyonevent in the DOM, so you'll see that as the parameter of the function. Object destructuring will allow us to easily get thename(key) andvaluefrom the form.",
        "chunk_type": "code_class",
        "tag": "section",
        "score": 1.0030000000000001,
        "word_count": 995,
        "chunk_id": "73649abf087e343535dd6e71b7c8c11b",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Finally, we'll set the user much like we did on theAppcomponent, except this time we're using computed property names to dynamically set the name (using[name]) and value.consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} f you don't understand what's being passed through, try playing around withconsole.log(event)in the input handling function.Now we extract the values from the state object, and reference our function in theonChangeevent.<form><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>The last thing to take care of is actually submitting the form back to theAppcomponent. As we passed the function down withprops, we're going to use props to access the function. I'm going to write anonSubmitfunction, and we'll prevent the default form submission from firing. I added a small bit of validation to make sure empty values cannot be submitted, and sent the user through to the add function. Finally, I'm using the setter to reset the form to its initial value after successful submission.<formonSubmit={event=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}>Fortunately this code is pretty simple, as we don't have to worry about asynchronous API calls.Here is our fullAddUserFormcomponent.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{constinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>)} xportdefaultAddUserFormCool.Deleting a userThe next one we'll tackle is deleting a user, which is the easiest functionality to take care of.BelowaddUserinApp.js, we'll createdeleteUser, which will take the ID of the user and filter them out of the user array.constdeleteUser=(id)=>{setUsers(users.filter((user)=>user.id!==id))} e pass that function through props toUserTable.<UserTableusers={users} eleteUser={deleteUser}/>Now all we need to do inUserTable.jsis make sure the delete button calls that function.<buttononClick={()=>props.deleteUser(user.id)} lassName=\"button muted-button\">Delete</button>Now you can delete some or all of the users.Updating a userThe final piece of the puzzle is introducing the ability to update existing users. This will be similar to adding a user, except we'll have to be able to identify which user is being edited. In class components, we would use thecomponentDidUpdatelifecycle method to achieve this, but now we'll use anEffect Hook. TheEffect Hookis likecomponentDidMountandcomponentDidUpdatecombined.The way we're going to structure this is when the Edit action is selected for a user, the \"Add user\" form will become an \"Edit user\" form, and it will be pre-populated with the data from the selected user. You can either cancel edit mode, or submit the change, which will update the selected user and close out of edit mode.Let's begin. InApp.js, the first thing we'll want to do is make state for whether or not edit mode is turned on. It will begin as false.App.jsconst[editing,setEditing]=useState(false)Since we don't know who is being edited until it's selected, we'll create initial empty state for the form, like we did with the add form.constinitialFormState={id:null,name:'',username:''} e'll want a way to see and update who the current user being edited is, so we'll apply that empty user to acurrentUserstate.const[currentUser,setCurrentUser]=useState(initialFormState)When Edit is selected on a user, it should turn on edit mode, and set the current user, which we'll do in thiseditRowfunction.consteditRow=(user)=>{setEditing(true)setCurrentUser({id:user.id,name:user.name,username:user.username})} ow just pass that function toUserTablelike we did withdeleteUser.<UserTableusers={users} ditRow={editRow} eleteUser={deleteUser}/>Over inUserTable.js, we send theuserobject over.UserTable.js<buttononClick={()=>{props.editRow(user)}} lassName=\"button muted-button\">Edit</button>Now we've got all the setup - there's a switch for edit mode, and a button that will pass the current user into state while flipping the edit mode switch.Let's create the actual function that will get called when the edit form is submitted. Unlike delete (which filters a user out by ID) or add (which appends a user to the array), the update function needs to map through the array, and update the user that matches the ID passed through.This means we'll be taking two parameters - the updated user object, and the id - and we'll use a ternary operation to map through the users and find the one we want to update.App.jsconstupdateUser=(id,updatedUser)=>{setEditing(false)setUsers(users.map((user)=>(user.id===id?updatedUser:user)))} e just need to make the edit form itself.Createforms/EditUserForm.js. Most of it will be the same as the add form. The only difference so far is that we'll set the state directly fromcurrentUservia props. There is also a cancel button that will simply switch off edit mode.EditUserForm.jsimportReact,{useState} rom'react'constEditUserForm=(props)=>{const[user,setUser]=useState(props.currentUser)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()props.updateUser(user.id,user)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Update user</button><buttononClick={()=>props.setEditing(false)} lassName=\"button muted-button\">Cancel</button></form>)} xportdefaultEditUserFormNow we have to bring the edit form intoApp.js, as well as creating a toggle for displaying the add or edit form.First, bring in the component.App.jsimportEditUserFormfrom'./forms/EditUserForm'Then create the toggle. We'll use a ternary operation to check if theeditingstate is true or not. If true, show the edit form. If false, show the add form. Make sure to pass all the functions we created down to the editing component.App.js<divclassName=\"flex-large\">{editing?(<div><h2>Edit user</h2><EditUserFormsetEditing={setEditing} urrentUser={currentUser} pdateUser={updateUser}/></div>):(<div><h2>Add user</h2><AddUserFormaddUser={addUser}/></div>)}</div>Okay, so at this point clicking on the Edit button should toggle edit mode, and you should be able to update a user. But are we done?Using the Effect HookIf you play around with this a little, you mat notice an issue. Two, actually. If you start editing one user, then try to switch to another user, nothing will happen. Why? Well, the component is already open, and although the state on the parent has changed, it's not registered down to the props.This is where the Effect Hook comes into place. We want to let theEditUserFormcomponent know the props have changed, which we would have done before withcomponentDidUpdate.First step is to bring inuseEffect.EditUserForm.jsimportReact,{useState,useEffect} rom'react'EditUserForm.jsuseEffect(()=>{setUser(props.currentUser)},[props])In the Effect Hook, we create a callback function that updates theuserstate with the new prop that's being sent through. Before, we needed to compareif (prevProps.currentUser !== this.state.currentUser), but with the Effect Hook we can just pass[props]through to let it know we're watching props.Using the[props]array is similar to usingcomponentDidUpdate. If you're doing a one-time event likecomponentDidMount, you can pass an empty array ([]) instead.Now if you try to change the user you're editing, it will work correctly!I said there were two issues here, and the other issue is that you can delete a user while it is currently being edited. We can fix this issue by addingsetEditing(false)to thedeleteUserfunction inApp.js.And that's it. We have a complete CRUD app utilizing React State and Effect hooks.ConclusionI didn't cover every use case for Hooks, or all functionality in-depth, but I tried to provide a working example of a complete, albeit simple, React program.",
        "chunk_type": "code_class",
        "tag": "section",
        "score": 1.0030000000000001,
        "word_count": 972,
        "chunk_id": "762de1842cd2fe8b66270858c513d0e5",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "extract",
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "For a complete FAQ on all things relating to hooks, check out theHooks FAQ.If you got lost anywhere along the way, don't forget to check out the demo and source.View Demo AppView SourceThe next thing to be on the lookout for is theSuspense API.",
        "chunk_type": "technical_content",
        "tag": "section",
        "score": 1.0030000000000001,
        "word_count": 44,
        "chunk_id": "3af2838a8d29cf503be4495dc7a1b140",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "A new concept was introduced in React -Hooks. Hooks are an alternative to classes. If you've used React before, you'll be familiar withsimple (functional) componentsandclass components.Simple componentconstExample=()=>{return<div>I'm a simple component</div>} lass componentclassExampleextendsComponent{render(){return<div>I'm a class component</div>}} any of the features available to classes - such aslifecycle methodsandstate- have not been available to simple components, until now. The new Hooks proposal adds all that functionality and more.I wanted to try out Hooks and see how an app might look without any classes, but I didn't see any examples yet, so I decided to make one myself. I created a simple CRUD (create, read, update, delete) app that utilizes Hooks and no classes, and I created this tutorial for anyone else who wants to learn how to use them as well.If you don't know how to make a simple CRUD app in React, regardless of whether you use classes or hooks, this article will be good for you as well.View Demo AppView SourcePrerequisitesIn order to follow along with this tutorial, you'll need a basic knowledge of HTML, CSS, and JavaScript/ES6. You should also know the fundamentals of React, which you can learn by readingGetting Started with React.GoalsIn this tutorial, we'll make asimple CRUD app. It will have users, and you'll be able to add, update, or delete users. We won't use any React classes, and instead we'll utilize State Hooks and Effect Hooks on functional components. If you get lost along the way, be sure to check outthe source of the completed project.Create React AppWe'll start by installing the project withcreate-react-app(CRA).npx create-react-app react-hooksThen runnpm i.Now you're all set with the React.Initial SetupLet's start off by clearing out all the files from the boilerplate we don't need. Delete everything from the/srcfolder exceptApp.js,index.js, andindex.css.Forindex.css, I just copy and paste the CSS fromPrimitive, a simple CSS boilerplate I made, as the point of this app is to work on React and not care about design. This CSS boilerplate just adds some sensible defaults and a simple grid so we can start prototyping.Inindex.js, we'll simplify it by removing the references to Service Workers.index.jsimportReactfrom'react'importReactDOMfrom'react-dom'import'./index.css'importAppfrom'./App'ReactDOM.render(<App/>,document.getElementById('root'))And inApp.js, I'll make a simple, functional component forAppinstead of a class.App.jsimportReactfrom'react'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2></div></div></div>)} xportdefaultAppNow we have the initial setup and skeleton for the app.State vs. Hook StateIf we look at a very simple example of a class component with state and a functional component with Hook state, we can see the similarities and differences. With class state, you get one main state object, and you update using methods on the class andsetState().I'll make some quick example code, as if it were a library and you have books that have state.Class Component State ExampleclassAppextendsComponent{initialState={title:'',available:false,} tate=initialStateupdateBook=(book)=>{this.setState({title:book.title,available:book.available})}} ith Hook state, there's a getter and setter for each type of state (you can have as many as you want), and we obviously create functions instead of methods.Hook State ExampleconstApp=()=>{constinitialBookState={title:'',available:false,} onst[book,setBook]=useState(initialBookState)constupdateBook=(book)=>{setBook({title:book.title,available:book.available})}} 'm not going to get deep into the rationale behind hooks vs. class components, as you can readall about it on React's Hooks introduction. I'm just going to show you how to work with them to create a functional app.Setting up the ViewThe first thing we'll do is make some sample data and a table to display it, for the view. Create a new directory calledtablesinsrc, and a file within calledUserTable.js. We'll make the skeleton for a table.tables/UserTable.jsimportReactfrom'react'constUserTable=()=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody><tr><td>Name data</td><td>Username data</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr></tbody></table>)exportdefaultUserTableNow just import the file and add in the new component.App.jsimportReactfrom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTable/></div></div></div>)} xportdefaultAppLet's bring in some random dummy data and theuseStateimport from React.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)return(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppProps works just as it did before. We'll map through the user data we sent through and display the properties for each user, or display a message if there are no users. The edit and delete buttons aren't hooked up to anything yet, so they won't do anything.UserTable.jsimportReactfrom'react'constUserTable=(props)=>(<table><thead><tr><th>Name</th><th>Username</th><th>Actions</th></tr></thead><tbody>{props.users.length>0?(props.users.map((user)=>(<trkey={user.id}><td>{user.name}</td><td>{user.username}</td><td><buttonclassName=\"button muted-button\">Edit</button><buttonclassName=\"button muted-button\">Delete</button></td></tr>))):(<tr><tdcolSpan={3}>No users</td></tr>)}</tbody></table>)exportdefaultUserTableWe'll get to the edit and delete buttons in a moment. Now that the basic view is set up, let's get the adding functionality working.Adding a new userWe're going to set up the form to add a new user.The very first thing we can do is create the actual function that will add the new user to state. We have thesetUsersfunction automatically fromuseState, so that's what we'll use to update the user state.Since we're not using a real API and database, which would probably have an auto-incrementing ID, I'm going to increment the ID of the new user manually. This function will take auserobject as a parameter, and add them to theusersarray of objects. The...userscode ensures that all the previous users remain in the array.App.jsconstaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} e're going to make a component for this, so I'll just go ahead and add the reference to the component at the top, and insert the component below the \"Add user\" header. We can pass theaddUser()through as a prop. Make sure not to include the parentheses when we pass it through as a reference -<AddUserForm addUser={addUser} />, not<AddUserForm addUser={addUser()} />.App.jsimportReact,{useState} rom'react'importUserTablefrom'./tables/UserTable'importAddUserFormfrom'./forms/AddUserForm'constApp=()=>{constusersData=[{id:1,name:'Tania',username:'floppydiskette'},{id:2,name:'Craig',username:'siliconeidolon'},{id:3,name:'Ben',username:'benisphere'},]const[users,setUsers]=useState(usersData)constaddUser=(user)=>{user.id=users.length+1setUsers([...users,user])} eturn(<divclassName=\"container\"><h1>CRUD App with Hooks</h1><divclassName=\"flex-row\"><divclassName=\"flex-large\"><h2>Add user</h2><AddUserFormaddUser={addUser}/></div><divclassName=\"flex-large\"><h2>View users</h2><UserTableusers={users}/></div></div></div>)} xportdefaultAppNow we have to create a form that you can use to add the new user. Let's create aformssubdirectory with a file inside calledAddUserForm.js.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{return(<form><label>Name</label><inputtype=\"text\"name=\"name\"value=\"\"/><label>Username</label><inputtype=\"text\"name=\"username\"value=\"\"/><button>Add new user</button></form>)} xportdefaultAddUserFormRight now, the form is empty, and you cannot add any values to it due to our empty value strings, nor does the submit button do anything.Just like before, we'll want to make some state, except this state will just be temporary, for keeping track of what's currently in the add user form.I'm going to create an initial state with those empty values, and set the user state to the empty values. Having initial state in a variable is useful, because after we submit the form, we can return it to the initial, empty value.AddUserForm.jsconstinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)Now we'll create a function to update the state within the form.eventalways gets passed through to anyonevent in the DOM, so you'll see that as the parameter of the function. Object destructuring will allow us to easily get thename(key) andvaluefrom the form.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.0030000000000001,
        "word_count": 995,
        "chunk_id": "73649abf087e343535dd6e71b7c8c11b",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "id": "/crud-app-in-react-with-hooks/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Finally, we'll set the user much like we did on theAppcomponent, except this time we're using computed property names to dynamically set the name (using[name]) and value.consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} f you don't understand what's being passed through, try playing around withconsole.log(event)in the input handling function.Now we extract the values from the state object, and reference our function in theonChangeevent.<form><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>The last thing to take care of is actually submitting the form back to theAppcomponent. As we passed the function down withprops, we're going to use props to access the function. I'm going to write anonSubmitfunction, and we'll prevent the default form submission from firing. I added a small bit of validation to make sure empty values cannot be submitted, and sent the user through to the add function. Finally, I'm using the setter to reset the form to its initial value after successful submission.<formonSubmit={event=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}>Fortunately this code is pretty simple, as we don't have to worry about asynchronous API calls.Here is our fullAddUserFormcomponent.AddUserForm.jsimportReact,{useState} rom'react'constAddUserForm=(props)=>{constinitialFormState={id:null,name:'',username:''} onst[user,setUser]=useState(initialFormState)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()if(!user.name||!user.username)returnprops.addUser(user)setUser(initialFormState)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Add new user</button></form>)} xportdefaultAddUserFormCool.Deleting a userThe next one we'll tackle is deleting a user, which is the easiest functionality to take care of.BelowaddUserinApp.js, we'll createdeleteUser, which will take the ID of the user and filter them out of the user array.constdeleteUser=(id)=>{setUsers(users.filter((user)=>user.id!==id))} e pass that function through props toUserTable.<UserTableusers={users} eleteUser={deleteUser}/>Now all we need to do inUserTable.jsis make sure the delete button calls that function.<buttononClick={()=>props.deleteUser(user.id)} lassName=\"button muted-button\">Delete</button>Now you can delete some or all of the users.Updating a userThe final piece of the puzzle is introducing the ability to update existing users. This will be similar to adding a user, except we'll have to be able to identify which user is being edited. In class components, we would use thecomponentDidUpdatelifecycle method to achieve this, but now we'll use anEffect Hook. TheEffect Hookis likecomponentDidMountandcomponentDidUpdatecombined.The way we're going to structure this is when the Edit action is selected for a user, the \"Add user\" form will become an \"Edit user\" form, and it will be pre-populated with the data from the selected user. You can either cancel edit mode, or submit the change, which will update the selected user and close out of edit mode.Let's begin. InApp.js, the first thing we'll want to do is make state for whether or not edit mode is turned on. It will begin as false.App.jsconst[editing,setEditing]=useState(false)Since we don't know who is being edited until it's selected, we'll create initial empty state for the form, like we did with the add form.constinitialFormState={id:null,name:'',username:''} e'll want a way to see and update who the current user being edited is, so we'll apply that empty user to acurrentUserstate.const[currentUser,setCurrentUser]=useState(initialFormState)When Edit is selected on a user, it should turn on edit mode, and set the current user, which we'll do in thiseditRowfunction.consteditRow=(user)=>{setEditing(true)setCurrentUser({id:user.id,name:user.name,username:user.username})} ow just pass that function toUserTablelike we did withdeleteUser.<UserTableusers={users} ditRow={editRow} eleteUser={deleteUser}/>Over inUserTable.js, we send theuserobject over.UserTable.js<buttononClick={()=>{props.editRow(user)}} lassName=\"button muted-button\">Edit</button>Now we've got all the setup - there's a switch for edit mode, and a button that will pass the current user into state while flipping the edit mode switch.Let's create the actual function that will get called when the edit form is submitted. Unlike delete (which filters a user out by ID) or add (which appends a user to the array), the update function needs to map through the array, and update the user that matches the ID passed through.This means we'll be taking two parameters - the updated user object, and the id - and we'll use a ternary operation to map through the users and find the one we want to update.App.jsconstupdateUser=(id,updatedUser)=>{setEditing(false)setUsers(users.map((user)=>(user.id===id?updatedUser:user)))} e just need to make the edit form itself.Createforms/EditUserForm.js. Most of it will be the same as the add form. The only difference so far is that we'll set the state directly fromcurrentUservia props. There is also a cancel button that will simply switch off edit mode.EditUserForm.jsimportReact,{useState} rom'react'constEditUserForm=(props)=>{const[user,setUser]=useState(props.currentUser)consthandleInputChange=(event)=>{const{name,value}=event.targetsetUser({...user,[name]:value})} eturn(<formonSubmit={(event)=>{event.preventDefault()props.updateUser(user.id,user)}}><label>Name</label><inputtype=\"text\"name=\"name\"value={user.name} nChange={handleInputChange}/><label>Username</label><inputtype=\"text\"name=\"username\"value={user.username} nChange={handleInputChange}/><button>Update user</button><buttononClick={()=>props.setEditing(false)} lassName=\"button muted-button\">Cancel</button></form>)} xportdefaultEditUserFormNow we have to bring the edit form intoApp.js, as well as creating a toggle for displaying the add or edit form.First, bring in the component.App.jsimportEditUserFormfrom'./forms/EditUserForm'Then create the toggle. We'll use a ternary operation to check if theeditingstate is true or not. If true, show the edit form. If false, show the add form. Make sure to pass all the functions we created down to the editing component.App.js<divclassName=\"flex-large\">{editing?(<div><h2>Edit user</h2><EditUserFormsetEditing={setEditing} urrentUser={currentUser} pdateUser={updateUser}/></div>):(<div><h2>Add user</h2><AddUserFormaddUser={addUser}/></div>)}</div>Okay, so at this point clicking on the Edit button should toggle edit mode, and you should be able to update a user. But are we done?Using the Effect HookIf you play around with this a little, you mat notice an issue. Two, actually. If you start editing one user, then try to switch to another user, nothing will happen. Why? Well, the component is already open, and although the state on the parent has changed, it's not registered down to the props.This is where the Effect Hook comes into place. We want to let theEditUserFormcomponent know the props have changed, which we would have done before withcomponentDidUpdate.First step is to bring inuseEffect.EditUserForm.jsimportReact,{useState,useEffect} rom'react'EditUserForm.jsuseEffect(()=>{setUser(props.currentUser)},[props])In the Effect Hook, we create a callback function that updates theuserstate with the new prop that's being sent through. Before, we needed to compareif (prevProps.currentUser !== this.state.currentUser), but with the Effect Hook we can just pass[props]through to let it know we're watching props.Using the[props]array is similar to usingcomponentDidUpdate. If you're doing a one-time event likecomponentDidMount, you can pass an empty array ([]) instead.Now if you try to change the user you're editing, it will work correctly!I said there were two issues here, and the other issue is that you can delete a user while it is currently being edited. We can fix this issue by addingsetEditing(false)to thedeleteUserfunction inApp.js.And that's it. We have a complete CRUD app utilizing React State and Effect hooks.ConclusionI didn't cover every use case for Hooks, or all functionality in-depth, but I tried to provide a working example of a complete, albeit simple, React program.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.0030000000000001,
        "word_count": 972,
        "chunk_id": "762de1842cd2fe8b66270858c513d0e5",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "extract",
            "react"
          ],
          "attributes": {
            "id": "/crud-app-in-react-with-hooks/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "For a complete FAQ on all things relating to hooks, check out theHooks FAQ.If you got lost anywhere along the way, don't forget to check out the demo and source.View Demo AppView SourceThe next thing to be on the lookout for is theSuspense API.",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.0030000000000001,
        "word_count": 44,
        "chunk_id": "3af2838a8d29cf503be4495dc7a1b140",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [],
          "attributes": {
            "id": "/crud-app-in-react-with-hooks/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:November 07, 2018Category:TechnicalTagsjavascriptreactNewsletterSubscribe to the Newsletter",
        "chunk_type": "text",
        "tag": "aside",
        "score": 0.42600000000000005,
        "word_count": 54,
        "chunk_id": "973ee56a68d870b0028a270bd0111d30",
        "metadata": {
          "source_tag": "aside",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "post-sidebar"
            ]
          },
          "technical_indicators": [
            "javascript"
          ]
        }
      },
      {
        "content": "If you don't know how to make a simple CRUD app in React, regardless of whether you use classes or hooks, this article will be good for you as well.",
        "chunk_type": "technical_content",
        "tag": "p",
        "score": 0.324,
        "word_count": 30,
        "chunk_id": "589aa3f75705797837a3f77884329779",
        "metadata": {
          "source_tag": "p",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react"
          ]
        }
      }
    ],
    "chunk_count": 23,
    "content_types": [
      "code_class",
      "text",
      "technical_content"
    ],
    "technical_concepts": [
      "javascript",
      "sql",
      "data",
      "api",
      "react"
    ],
    "crawl_metadata": {},
    "technical_content": [
      {
        "id": "10ff59d921b1eede5c089d3fdd766a86",
        "content": "const Example = () => { return <div>I'm a simple component</div> }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "10ff59d921b1eede5c089d3fdd766a86",
        "content": "const Example = () => { return <div>I'm a simple component</div> }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "d52a68d6cd36d57bccbd0a6cedab2bbb",
        "content": "class Example extends Component { render() { return <div>I'm a class component</div> } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8052631578947369
      },
      {
        "id": "d52a68d6cd36d57bccbd0a6cedab2bbb",
        "content": "class Example extends Component { render() { return <div>I'm a class component</div> } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8052631578947369
      },
      {
        "id": "64cec1d55a6cfa382b4bea8d3337c13a",
        "content": "npx create-react-app react-hooks",
        "type": "code",
        "language": "shell",
        "relevance": 0.5105263157894737
      },
      {
        "id": "64cec1d55a6cfa382b4bea8d3337c13a",
        "content": "npx create-react-app react-hooks",
        "type": "code",
        "language": "shell",
        "relevance": 0.5105263157894737
      },
      {
        "id": "7d1654a2281de41eb75e98be8d776d2f",
        "content": "npm i",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f8087e59fd95af1ae29e8fcb7ff1a3dc",
        "content": "/src",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "958f6f56cd42c904603d226cd36a57b6",
        "content": "App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "bca1542f88ef8253c16b452e9ad09f98",
        "content": "index.css",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "bca1542f88ef8253c16b452e9ad09f98",
        "content": "index.css",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "445f950662b27353b8b8ddb92fa243a3",
        "content": "import React from 'react' import ReactDOM from 'react-dom' import './index.css' import App from './App' ReactDOM.render(<App />, document.getElementById('root'))",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "445f950662b27353b8b8ddb92fa243a3",
        "content": "import React from 'react' import ReactDOM from 'react-dom' import './index.css' import App from './App' ReactDOM.render(<App />, document.getElementById('root'))",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "958f6f56cd42c904603d226cd36a57b6",
        "content": "App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "ac863f346e618f9a959b5c95d5d28941",
        "content": "App",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d904b2282352169d3e57e87d65ebb504",
        "content": "import React from 'react' const App = () => { return ( <div className=\"container\"> <h1>CRUD App with Hooks</h1> <div className=\"flex-row\"> <div className=\"flex-large\"> <h2>Add user</h2> </div> <div className=\"flex-large\"> <h2>View users</h2> </div> </div> </div> ) } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "d904b2282352169d3e57e87d65ebb504",
        "content": "import React from 'react' const App = () => { return ( <div className=\"container\"> <h1>CRUD App with Hooks</h1> <div className=\"flex-row\"> <div className=\"flex-large\"> <h2>Add user</h2> </div> <div className=\"flex-large\"> <h2>View users</h2> </div> </div> </div> ) } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "99057c7bcc765423105744aebe81baec",
        "content": "setState()",
        "type": "code",
        "language": "text",
        "relevance": 0.605263157894737
      },
      {
        "id": "07b5354bf759404820d105a07e897c73",
        "content": "class App extends Component { initialState = { title: '', available: false, } state = initialState updateBook = (book) => { this.setState({ title: book.title, available: book.available }) } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8157894736842106
      },
      {
        "id": "07b5354bf759404820d105a07e897c73",
        "content": "class App extends Component { initialState = { title: '', available: false, } state = initialState updateBook = (book) => { this.setState({ title: book.title, available: book.available }) } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8157894736842106
      },
      {
        "id": "29d5f8752774f590fb7ed94061b562d7",
        "content": "const App = () => { const initialBookState = { title: '', available: false, } const [book, setBook] = useState(initialBookState) const updateBook = (book) => { setBook({ title: book.title, available: book.available }) } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "29d5f8752774f590fb7ed94061b562d7",
        "content": "const App = () => { const initialBookState = { title: '', available: false, } const [book, setBook] = useState(initialBookState) const updateBook = (book) => { setBook({ title: book.title, available: book.available }) } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "9ab2ec7ea4a2041306f7bdf150fcd453",
        "content": "tables",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "25d902c24283ab8cfbac54dfa101ad31",
        "content": "src",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "eb92172f851ce243ee7be1ef371623d5",
        "content": "UserTable.js",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "35e5edcee92215421da7c4ffbde33424",
        "content": "import React from 'react' const UserTable = () => ( <table> <thead> <tr> <th>Name</th> <th>Username</th> <th>Actions</th> </tr> </thead> <tbody> <tr> <td>Name data</td> <td>Username data</td> <td> <button className=\"button muted-button\">Edit</button> <button className=\"button muted-button\">Delete</button> </td> </tr> </tbody> </table> ) export default UserTable",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "35e5edcee92215421da7c4ffbde33424",
        "content": "import React from 'react' const UserTable = () => ( <table> <thead> <tr> <th>Name</th> <th>Username</th> <th>Actions</th> </tr> </thead> <tbody> <tr> <td>Name data</td> <td>Username data</td> <td> <button className=\"button muted-button\">Edit</button> <button className=\"button muted-button\">Delete</button> </td> </tr> </tbody> </table> ) export default UserTable",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "9988615c627abfef2c9fb66e7016d3d0",
        "content": "import React from 'react' import UserTable from './tables/UserTable' const App = () => { return ( <div className=\"container\"> <h1>CRUD App with Hooks</h1> <div className=\"flex-row\"> <div className=\"flex-large\"> <h2>Add user</h2> </div> <div className=\"flex-large\"> <h2>View users</h2> <UserTable /> </div> </div> </div> ) } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8157894736842106
      },
      {
        "id": "9988615c627abfef2c9fb66e7016d3d0",
        "content": "import React from 'react' import UserTable from './tables/UserTable' const App = () => { return ( <div className=\"container\"> <h1>CRUD App with Hooks</h1> <div className=\"flex-row\"> <div className=\"flex-large\"> <h2>Add user</h2> </div> <div className=\"flex-large\"> <h2>View users</h2> <UserTable /> </div> </div> </div> ) } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8157894736842106
      },
      {
        "id": "5dd7ac3770aaf6a4c6944ab4ce95f50c",
        "content": "useState",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "1552b9d0db143f3ccc38aa0d12042133",
        "content": "import React, { useState } from 'react' import UserTable from './tables/UserTable' const App = () => { const usersData = [ { id: 1, name: 'Tania', username: 'floppydiskette' }, { id: 2, name: 'Craig', username: 'siliconeidolon' }, { id: 3, name: 'Ben', username: 'benisphere' }, ] const [users, setUsers] = useState(usersData) return ( <div className=\"container\"> <h1>CRUD App with Hooks</h1> <div className=\"flex-row\"> <div className=\"flex-large\"> <h2>Add user</h2> </div> <div className=\"flex-large\"> <h2>View users</h2> <UserTable users={users} /> </div> </div> </div> ) } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "1552b9d0db143f3ccc38aa0d12042133",
        "content": "import React, { useState } from 'react' import UserTable from './tables/UserTable' const App = () => { const usersData = [ { id: 1, name: 'Tania', username: 'floppydiskette' }, { id: 2, name: 'Craig', username: 'siliconeidolon' }, { id: 3, name: 'Ben', username: 'benisphere' }, ] const [users, setUsers] = useState(usersData) return ( <div className=\"container\"> <h1>CRUD App with Hooks</h1> <div className=\"flex-row\"> <div className=\"flex-large\"> <h2>Add user</h2> </div> <div className=\"flex-large\"> <h2>View users</h2> <UserTable users={users} /> </div> </div> </div> ) } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "49b00599d8b74ddc7a151446c313c687",
        "content": "import React from 'react' const UserTable = (props) => ( <table> <thead> <tr> <th>Name</th> <th>Username</th> <th>Actions</th> </tr> </thead> <tbody> {props.users.length > 0 ? ( props.users.map((user) => ( <tr key={user.id}> <td>{user.name}</td> <td>{user.username}</td> <td> <button className=\"button muted-button\">Edit</button> <button className=\"button muted-button\">Delete</button> </td> </tr> )) ) : ( <tr> <td colSpan={3}>No users</td> </tr> )} </tbody> </table> ) export default UserTable",
        "type": "code",
        "language": "jsx",
        "relevance": 0.9157894736842105
      },
      {
        "id": "49b00599d8b74ddc7a151446c313c687",
        "content": "import React from 'react' const UserTable = (props) => ( <table> <thead> <tr> <th>Name</th> <th>Username</th> <th>Actions</th> </tr> </thead> <tbody> {props.users.length > 0 ? ( props.users.map((user) => ( <tr key={user.id}> <td>{user.name}</td> <td>{user.username}</td> <td> <button className=\"button muted-button\">Edit</button> <button className=\"button muted-button\">Delete</button> </td> </tr> )) ) : ( <tr> <td colSpan={3}>No users</td> </tr> )} </tbody> </table> ) export default UserTable",
        "type": "code",
        "language": "jsx",
        "relevance": 0.9157894736842105
      },
      {
        "id": "99c291f7d4466b3e848f8d7b9060f92f",
        "content": "setUsers",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5dd7ac3770aaf6a4c6944ab4ce95f50c",
        "content": "useState",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "ee11cbb19052e40b07aac0ca060c23ee",
        "content": "user",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9bc65c2abec141778ffaa729489f3e87",
        "content": "users",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "10d757b65a53df3747f046e683cc99a7",
        "content": "...users",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "17805b52f9e90a2f6d55b9a9ca960c00",
        "content": "const addUser = (user) => { user.id = users.length + 1 setUsers([...users, user]) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.30000000000000004
      },
      {
        "id": "17805b52f9e90a2f6d55b9a9ca960c00",
        "content": "const addUser = (user) => { user.id = users.length + 1 setUsers([...users, user]) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2cc531364c948c0cbf1df523dd08a94f",
        "content": "addUser()",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "3152fc4bda1f2e0ee553617c033e7039",
        "content": "<AddUserForm addUser={addUser} />",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "0696a1a11e137f04cbe6459dceb10e6a",
        "content": "<AddUserForm addUser={addUser()} />",
        "type": "code",
        "language": "text",
        "relevance": 0.7
      },
      {
        "id": "f7fb9c739129421568c63cb96308a571",
        "content": "import React, { useState } from 'react' import UserTable from './tables/UserTable' import AddUserForm from './forms/AddUserForm' const App = () => { const usersData = [ { id: 1, name: 'Tania', username: 'floppydiskette' }, { id: 2, name: 'Craig', username: 'siliconeidolon' }, { id: 3, name: 'Ben', username: 'benisphere' }, ] const [users, setUsers] = useState(usersData) const addUser = (user) => { user.id = users.length + 1 setUsers([...users, user]) } return ( <div className=\"container\"> <h1>CRUD App with Hooks</h1> <div className=\"flex-row\"> <div className=\"flex-large\"> <h2>Add user</h2> <AddUserForm addUser={addUser} /> </div> <div className=\"flex-large\"> <h2>View users</h2> <UserTable users={users} /> </div> </div> </div> ) } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "f7fb9c739129421568c63cb96308a571",
        "content": "import React, { useState } from 'react' import UserTable from './tables/UserTable' import AddUserForm from './forms/AddUserForm' const App = () => { const usersData = [ { id: 1, name: 'Tania', username: 'floppydiskette' }, { id: 2, name: 'Craig', username: 'siliconeidolon' }, { id: 3, name: 'Ben', username: 'benisphere' }, ] const [users, setUsers] = useState(usersData) const addUser = (user) => { user.id = users.length + 1 setUsers([...users, user]) } return ( <div className=\"container\"> <h1>CRUD App with Hooks</h1> <div className=\"flex-row\"> <div className=\"flex-large\"> <h2>Add user</h2> <AddUserForm addUser={addUser} /> </div> <div className=\"flex-large\"> <h2>View users</h2> <UserTable users={users} /> </div> </div> </div> ) } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "ac68b62abfd6a9fe26e8ac4236c8ce0c",
        "content": "forms",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5dc7f93ff9aebabb99b657aaa78a0e70",
        "content": "AddUserForm.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e11487e3a03d8220903c4444df608291",
        "content": "import React, { useState } from 'react' const AddUserForm = (props) => { return ( <form> <label>Name</label> <input type=\"text\" name=\"name\" value=\"\" /> <label>Username</label> <input type=\"text\" name=\"username\" value=\"\" /> <button>Add new user</button> </form> ) } export default AddUserForm",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8157894736842106
      },
      {
        "id": "e11487e3a03d8220903c4444df608291",
        "content": "import React, { useState } from 'react' const AddUserForm = (props) => { return ( <form> <label>Name</label> <input type=\"text\" name=\"name\" value=\"\" /> <label>Username</label> <input type=\"text\" name=\"username\" value=\"\" /> <button>Add new user</button> </form> ) } export default AddUserForm",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8157894736842106
      },
      {
        "id": "f6e01675079da78302c11cecfef68e14",
        "content": "const initialFormState = { id: null, name: '', username: '' } const [user, setUser] = useState(initialFormState)",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "f6e01675079da78302c11cecfef68e14",
        "content": "const initialFormState = { id: null, name: '', username: '' } const [user, setUser] = useState(initialFormState)",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "4119639092e62c55ea8be348e4d9260d",
        "content": "event",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "ed2b5c0139cec8ad2873829dc1117d50",
        "content": "on",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b068931cc450442b63f5b3d276ea4297",
        "content": "name",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2063c1608d6e0baf80249c42e2be5804",
        "content": "value",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "ac863f346e618f9a959b5c95d5d28941",
        "content": "App",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1615d6e9208767c1a2094f184225294b",
        "content": "[name]",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1f88a5a0445383f2d09f9483afbca15f",
        "content": "const handleInputChange = (event) => { const { name, value } = event.target setUser({ ...user, [name]: value }) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1f88a5a0445383f2d09f9483afbca15f",
        "content": "const handleInputChange = (event) => { const { name, value } = event.target setUser({ ...user, [name]: value }) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.30000000000000004
      },
      {
        "id": "8645cc15904dc29644b9f7887fffce3e",
        "content": "console.log(event)",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "ec11d8e248160aceed4b88aafec7274e",
        "content": "onChange",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "79558185509746bda33fdc656f7796a4",
        "content": "<form> <label>Name</label> <input type=\"text\" name=\"name\" value={user.name} onChange={handleInputChange} /> <label>Username</label> <input type=\"text\" name=\"username\" value={user.username} onChange={handleInputChange} /> <button>Add new user</button> </form>",
        "type": "code",
        "language": "jsx",
        "relevance": 0.5
      },
      {
        "id": "79558185509746bda33fdc656f7796a4",
        "content": "<form> <label>Name</label> <input type=\"text\" name=\"name\" value={user.name} onChange={handleInputChange} /> <label>Username</label> <input type=\"text\" name=\"username\" value={user.username} onChange={handleInputChange} /> <button>Add new user</button> </form>",
        "type": "code",
        "language": "jsx",
        "relevance": 0.5
      },
      {
        "id": "ac863f346e618f9a959b5c95d5d28941",
        "content": "App",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "50fe03ab7bf37089a7e88da9b31ffb3b",
        "content": "props",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "e7f332a88955d3c0540bb7639f463e74",
        "content": "onSubmit",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4ababe846c531b00848319e17712a393",
        "content": "<form onSubmit={event => { event.preventDefault() if (!user.name !user.username) return props.addUser(user) setUser(initialFormState) }} >",
        "type": "code",
        "language": "jsx",
        "relevance": 0.9105263157894736
      },
      {
        "id": "4ababe846c531b00848319e17712a393",
        "content": "<form onSubmit={event => { event.preventDefault() if (!user.name !user.username) return props.addUser(user) setUser(initialFormState) }} >",
        "type": "code",
        "language": "jsx",
        "relevance": 0.9105263157894736
      },
      {
        "id": "833bd9724cdb69c177c2abfd5c4f062e",
        "content": "AddUserForm",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "300d0f35b5efb6ef62c6098de707576f",
        "content": "import React, { useState } from 'react' const AddUserForm = (props) => { const initialFormState = { id: null, name: '', username: '' } const [user, setUser] = useState(initialFormState) const handleInputChange = (event) => { const { name, value } = event.target setUser({ ...user, [name]: value }) } return ( <form onSubmit={(event) => { event.preventDefault() if (!user.name !user.username) return props.addUser(user) setUser(initialFormState) }} > <label>Name</label> <input type=\"text\" name=\"name\" value={user.name} onChange={handleInputChange} /> <label>Username</label> <input type=\"text\" name=\"username\" value={user.username} onChange={handleInputChange} /> <button>Add new user</button> </form> ) } export default AddUserForm",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "300d0f35b5efb6ef62c6098de707576f",
        "content": "import React, { useState } from 'react' const AddUserForm = (props) => { const initialFormState = { id: null, name: '', username: '' } const [user, setUser] = useState(initialFormState) const handleInputChange = (event) => { const { name, value } = event.target setUser({ ...user, [name]: value }) } return ( <form onSubmit={(event) => { event.preventDefault() if (!user.name !user.username) return props.addUser(user) setUser(initialFormState) }} > <label>Name</label> <input type=\"text\" name=\"name\" value={user.name} onChange={handleInputChange} /> <label>Username</label> <input type=\"text\" name=\"username\" value={user.username} onChange={handleInputChange} /> <button>Add new user</button> </form> ) } export default AddUserForm",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "9b03dbb48f164dbe8565fa5511d77894",
        "content": "addUser",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "958f6f56cd42c904603d226cd36a57b6",
        "content": "App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "bf1562b8d814fc7f03da3bc52737cf50",
        "content": "deleteUser",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c78b5278f7fb344250f47f81e5bb4b07",
        "content": "const deleteUser = (id) => { setUsers(users.filter((user) => user.id !== id)) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c78b5278f7fb344250f47f81e5bb4b07",
        "content": "const deleteUser = (id) => { setUsers(users.filter((user) => user.id !== id)) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.30000000000000004
      },
      {
        "id": "df8d4fc072a5d1dbaaac0dbd50bdb4a3",
        "content": "UserTable",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "b6463891c9cbb0886c209fa378232a00",
        "content": "<UserTable users={users} deleteUser={deleteUser} />",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "b6463891c9cbb0886c209fa378232a00",
        "content": "<UserTable users={users} deleteUser={deleteUser} />",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "eb92172f851ce243ee7be1ef371623d5",
        "content": "UserTable.js",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "0b430007c04a7b3a53682183c0a1d9e6",
        "content": "<button onClick={() => props.deleteUser(user.id)} className=\"button muted-button\" > Delete </button>",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "0b430007c04a7b3a53682183c0a1d9e6",
        "content": "<button onClick={() => props.deleteUser(user.id)} className=\"button muted-button\" > Delete </button>",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "063dd7a0e999a76e5be61e7c9874d549",
        "content": "componentDidUpdate",
        "type": "code",
        "language": "text",
        "relevance": 0.5105263157894737
      },
      {
        "id": "a5bfcf7e4fe575c28923c968c46eadc2",
        "content": "componentDidMount",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "063dd7a0e999a76e5be61e7c9874d549",
        "content": "componentDidUpdate",
        "type": "code",
        "language": "text",
        "relevance": 0.5105263157894737
      },
      {
        "id": "958f6f56cd42c904603d226cd36a57b6",
        "content": "App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "23ad78b776809b39768f765d12bb509a",
        "content": "const [editing, setEditing] = useState(false)",
        "type": "code",
        "language": "jsx",
        "relevance": 0.4052631578947369
      },
      {
        "id": "23ad78b776809b39768f765d12bb509a",
        "content": "const [editing, setEditing] = useState(false)",
        "type": "code",
        "language": "jsx",
        "relevance": 0.4052631578947369
      },
      {
        "id": "dc963aba29c38f6ab5f5ba6afbd3f6b0",
        "content": "const initialFormState = { id: null, name: '', username: '' }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "dc963aba29c38f6ab5f5ba6afbd3f6b0",
        "content": "const initialFormState = { id: null, name: '', username: '' }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "cdd638e00095e76c42db80d69dfdec30",
        "content": "currentUser",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "31d91ba11a2472f6cd7b2ebaaaf3e3ae",
        "content": "const [currentUser, setCurrentUser] = useState(initialFormState)",
        "type": "code",
        "language": "jsx",
        "relevance": 0.4052631578947369
      },
      {
        "id": "31d91ba11a2472f6cd7b2ebaaaf3e3ae",
        "content": "const [currentUser, setCurrentUser] = useState(initialFormState)",
        "type": "code",
        "language": "jsx",
        "relevance": 0.4052631578947369
      },
      {
        "id": "09e3b63e5227d093d1690fc9f3bd6df2",
        "content": "editRow",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "30102b1ba8b5dea7b14a61f9a3eb4b18",
        "content": "const editRow = (user) => { setEditing(true) setCurrentUser({ id: user.id, name: user.name, username: user.username }) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.5
      },
      {
        "id": "30102b1ba8b5dea7b14a61f9a3eb4b18",
        "content": "const editRow = (user) => { setEditing(true) setCurrentUser({ id: user.id, name: user.name, username: user.username }) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.5
      },
      {
        "id": "df8d4fc072a5d1dbaaac0dbd50bdb4a3",
        "content": "UserTable",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "bf1562b8d814fc7f03da3bc52737cf50",
        "content": "deleteUser",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7b79f11fce62a329c272421d1acd453c",
        "content": "<UserTable users={users} editRow={editRow} deleteUser={deleteUser} />",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "7b79f11fce62a329c272421d1acd453c",
        "content": "<UserTable users={users} editRow={editRow} deleteUser={deleteUser} />",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "eb92172f851ce243ee7be1ef371623d5",
        "content": "UserTable.js",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "ee11cbb19052e40b07aac0ca060c23ee",
        "content": "user",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "bef3f5873090ada42db3e4dba9114385",
        "content": "<button onClick={() => { props.editRow(user) }} className=\"button muted-button\" > Edit </button>",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "bef3f5873090ada42db3e4dba9114385",
        "content": "<button onClick={() => { props.editRow(user) }} className=\"button muted-button\" > Edit </button>",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "35639183f80204106964d2661258f886",
        "content": "const updateUser = (id, updatedUser) => { setEditing(false) setUsers(users.map((user) => (user.id === id ? updatedUser : user))) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.4052631578947369
      },
      {
        "id": "35639183f80204106964d2661258f886",
        "content": "const updateUser = (id, updatedUser) => { setEditing(false) setUsers(users.map((user) => (user.id === id ? updatedUser : user))) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.4052631578947369
      },
      {
        "id": "ca61c958842f728d25ea6aaff1f999a3",
        "content": "forms/EditUserForm.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cdd638e00095e76c42db80d69dfdec30",
        "content": "currentUser",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7715f951abde8ac7dcce280ec7e57edb",
        "content": "import React, { useState } from 'react' const EditUserForm = (props) => { const [user, setUser] = useState(props.currentUser) const handleInputChange = (event) => { const { name, value } = event.target setUser({ ...user, [name]: value }) } return ( <form onSubmit={(event) => { event.preventDefault() props.updateUser(user.id, user) }} > <label>Name</label> <input type=\"text\" name=\"name\" value={user.name} onChange={handleInputChange} /> <label>Username</label> <input type=\"text\" name=\"username\" value={user.username} onChange={handleInputChange} /> <button>Update user</button> <button onClick={() => props.setEditing(false)} className=\"button muted-button\" > Cancel </button> </form> ) } export default EditUserForm",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "7715f951abde8ac7dcce280ec7e57edb",
        "content": "import React, { useState } from 'react' const EditUserForm = (props) => { const [user, setUser] = useState(props.currentUser) const handleInputChange = (event) => { const { name, value } = event.target setUser({ ...user, [name]: value }) } return ( <form onSubmit={(event) => { event.preventDefault() props.updateUser(user.id, user) }} > <label>Name</label> <input type=\"text\" name=\"name\" value={user.name} onChange={handleInputChange} /> <label>Username</label> <input type=\"text\" name=\"username\" value={user.username} onChange={handleInputChange} /> <button>Update user</button> <button onClick={() => props.setEditing(false)} className=\"button muted-button\" > Cancel </button> </form> ) } export default EditUserForm",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "958f6f56cd42c904603d226cd36a57b6",
        "content": "App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c85cfc460ea795dd62c378783a9f49e6",
        "content": "import EditUserForm from './forms/EditUserForm'",
        "type": "code",
        "language": "jsx",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c85cfc460ea795dd62c378783a9f49e6",
        "content": "import EditUserForm from './forms/EditUserForm'",
        "type": "code",
        "language": "jsx",
        "relevance": 0.30000000000000004
      },
      {
        "id": "3f86cc36e1df1334da973da6771b8160",
        "content": "editing",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a4518d1253882c93dd39a5238871d314",
        "content": "<div className=\"flex-large\"> {editing ? ( <div> <h2>Edit user</h2> <EditUserForm setEditing={setEditing} currentUser={currentUser} updateUser={updateUser} /> </div> ) : ( <div> <h2>Add user</h2> <AddUserForm addUser={addUser} /> </div> )} </div>",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "a4518d1253882c93dd39a5238871d314",
        "content": "<div className=\"flex-large\"> {editing ? ( <div> <h2>Edit user</h2> <EditUserForm setEditing={setEditing} currentUser={currentUser} updateUser={updateUser} /> </div> ) : ( <div> <h2>Add user</h2> <AddUserForm addUser={addUser} /> </div> )} </div>",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "8966777e5a311a9f852d7782cd2503df",
        "content": "EditUserForm",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "063dd7a0e999a76e5be61e7c9874d549",
        "content": "componentDidUpdate",
        "type": "code",
        "language": "text",
        "relevance": 0.5105263157894737
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7ec0c27feca9ee1d8bd4c6072e7b9a26",
        "content": "import React, { useState, useEffect } from 'react'",
        "type": "code",
        "language": "jsx",
        "relevance": 0.5105263157894737
      },
      {
        "id": "7ec0c27feca9ee1d8bd4c6072e7b9a26",
        "content": "import React, { useState, useEffect } from 'react'",
        "type": "code",
        "language": "jsx",
        "relevance": 0.5105263157894737
      },
      {
        "id": "939c1c1a184bcc12c9940714bfe8d32a",
        "content": "useEffect(() => { setUser(props.currentUser) }, [props])",
        "type": "code",
        "language": "jsx",
        "relevance": 0.4052631578947369
      },
      {
        "id": "939c1c1a184bcc12c9940714bfe8d32a",
        "content": "useEffect(() => { setUser(props.currentUser) }, [props])",
        "type": "code",
        "language": "jsx",
        "relevance": 0.4052631578947369
      },
      {
        "id": "ee11cbb19052e40b07aac0ca060c23ee",
        "content": "user",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1eadfb737bbee28074f629b06a9b26e4",
        "content": "if (prevProps.currentUser !== this.state.currentUser)",
        "type": "code",
        "language": "text",
        "relevance": 0.5105263157894737
      },
      {
        "id": "f003264b25df0346113b455ba65d744a",
        "content": "[props]",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "f003264b25df0346113b455ba65d744a",
        "content": "[props]",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "063dd7a0e999a76e5be61e7c9874d549",
        "content": "componentDidUpdate",
        "type": "code",
        "language": "text",
        "relevance": 0.5105263157894737
      },
      {
        "id": "a5bfcf7e4fe575c28923c968c46eadc2",
        "content": "componentDidMount",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "d751713988987e9331980363e24189ce",
        "content": "[]",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "814629207397d08801bc034a267a198b",
        "content": "setEditing(false)",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "bf1562b8d814fc7f03da3bc52737cf50",
        "content": "deleteUser",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "958f6f56cd42c904603d226cd36a57b6",
        "content": "App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      }
    ]
  },
  {
    "metadata": {
      "description": "I've been hearing about React since I first started learning JavaScript, but I'll admit I took one look at it and it scared me. I saw what…",
      "url": "https://www.taniarascia.com/getting-started-with-react/",
      "title": "How to Use React, the JavaScript Framework | Tania Rascia's Personal Website",
      "source_type": "web",
      "crawl_time": 1730107175.312564,
      "keywords": [
        "sql",
        "web",
        "article",
        "extract",
        "development",
        "information",
        "react"
      ]
    },
    "relevance_score": 0.9655526315789477,
    "chunks": [
      {
        "content": "How to Use React, the JavaScript FrameworkI've been hearing about React since I first started learning JavaScript, but I'll admit I took one look at it and it scared me. I saw what looked like a bunch of HTML mixed with JavaScript and thought,isn't this what we've been trying to avoid? What's the big deal with React?Instead, I focused on just learning vanilla JavaScript and working with jQuery in a professional setting. After a few frustrated, failed attempts to get started with React, I finally started to get it, and I began to see why I might want to use React instead of vanilla JS or jQuery.I tried to condense everything I've learned into a nice introduction to share with you, so here it is.PrerequisitesThere are a few things you should know in advance before you start playing around with React. If you've never used JavaScript or the DOM at all before, for example, I would get more familiar with those before trying to tackle React.Here are what I consider to be React prerequisites.Basic familiarity withHTML & CSS.Basic knowledge ofJavaScriptand programming.Basic understanding ofthe DOM.Familiarity withES6 syntax and features.Node.js and npminstalled globally.GoalsLearn about essential React concepts and related terms, such as Babel, Webpack, JSX, components, props, state, and lifecycle.Build a very simple React app that demonstrates the above concepts.Here's the source and a live demo of the end result.View Source on GitHubView DemoWhat is React?React is a JavaScript library - one of the most popular ones, withover 100,000 stars on GitHub.React is not a framework (unlike Angular, which is more opinionated).React is an open-source project created by Facebook.React is used to build user interfaces (UI) on the front end.React is theviewlayer of an MVC application (Model View Controller)One of the most important aspects of React is the fact that you can createcomponents, which are like custom, reusable HTML elements, to quickly and efficiently build user interfaces. React also streamlines how data is stored and handled, usingstateandprops.We'll go over all of this and more throughout the article, so let's get started.Setup and InstallationThere are a few ways to set up React, and I'll show you two so you get a good idea of how it works.Static HTML FileThis first method is not a popular way to set up React and is not how we'll be doing the rest of our tutorial, but it will be familiar and easy to understand if you've ever used a library like jQuery, and it's the least scary way to get started if you're not familiar with Webpack, Babel, and Node.js.Let's start by making a basicindex.htmlfile. We're going to load in three CDNs in thehead- React, React DOM, and Babel. We're also going to make adivwith an id calledroot, and finally we'll create ascripttag where your custom code will live.index.html<!DOCTYPEhtml><html><head><metacharset=\"utf-8\"/><title>Hello React!</title><scriptsrc=\"https://unpkg.com/react@^16/umd/react.production.min.js\"></script><scriptsrc=\"https://unpkg.com/react-dom@16.13.0/umd/react-dom.production.min.js\"></script><scriptsrc=\"https://unpkg.com/babel-standalone@6.26.0/babel.js\"></script></head><body><divid=\"root\"></div><scripttype=\"text/babel\">// React code will go here</script></body></html>I'm loading in the latest stable versions of the libraries as of the time of this writing.React- the React top level APIReact DOM- adds DOM-specific methodsBabel- a JavaScript compiler that lets us use ES6+ in old browsersThe entry point for our app will be therootdiv element, which is named by convention. You'll also notice thetext/babelscript type, which is mandatory for using Babel.Now, let's write our first code block of React. We're going to use ES6 classes to create a React component calledApp.index.htmlclassAppextendsReact.Component{//...} ow we'll add therender()method, the only required method in a class component, which is used to render DOM nodes.index.htmlclassAppextendsReact.Component{render(){return(//...);}} nside thereturn, we're going to put what looks like a simple HTML element. Note that we're not returning a string here, so don't use quotes around the element. This is calledJSX, and we'll learn more about it soon.index.htmlclassAppextendsReact.Component{render(){return<h1>Hello world!</h1>}} inally, we're going to use the React DOMrender()method to render theAppclass we created into therootdiv in our HTML.index.htmlReactDOM.render(<App/>,document.getElementById('root'))Here is the full code for ourindex.html.index.html<!DOCTYPEhtml><html><head><metacharset=\"utf-8\"/><title>Hello React!</title><scriptsrc=\"https://unpkg.com/react@16/umd/react.development.js\"></script><scriptsrc=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"></script><scriptsrc=\"https://unpkg.com/babel-standalone@6.26.0/babel.js\"></script></head><body><divid=\"root\"></div><scripttype=\"text/babel\">classAppextendsReact.Component{render(){return<h1>Hello world!</h1>}} eactDOM.render(<App/>,document.getElementById('root'))</script></body></html>Now if you view yourindex.htmlin the browser, you'll see theh1tag we created rendered to the DOM.Cool! Now that you've done this, you can see that React isn't so insanely scary to get started with. It's just some JavaScript helper libraries that we can load into our HTML.We've done this for demonstration purposes, but from here out we're going to use another method: Create React App.Create React AppThe method I just used of loading JavaScript libraries into a static HTML page and rendering the React and Babel on the fly is not very efficient, and is hard to maintain.Fortunately, Facebook has createdCreate React App, an environment that comes pre-configured with everything you need to build a React app. It will create a live development server, use Webpack to automatically compile React, JSX, and ES6, auto-prefix CSS files, and use ESLint to test and warn about mistakes in the code.To set upcreate-react-app, run the following code in your terminal, one directory up from where you want the project to live.npx create-react-app react-tutorialOnce that finishes installing, move to the newly created directory and start the project.cdreact-tutorial&&npmstartOnce you run this command, a new window will popup atlocalhost:3000with your new React app.Create React App is very good for getting started for beginners as well as large-scale enterprise applications, but it's not perfect for every workflow. You can also create your own Webpack setup for React.If you look into the project structure, you'll see a/publicand/srcdirectory, along with the regularnode_modules,.gitignore,README.md, andpackage.json.In/public, our important file isindex.html, which is very similar to the staticindex.htmlfile we made earlier - just arootdiv. This time, no libraries or scripts are being loaded in. The/srcdirectory will contain all our React code.To see how the environment automatically compiles and updates your React code, find the line that looks like this in/src/App.js:To get started, edit `src/App.js` and save to reload.And replace it with any other text. Once you save the file, you'll noticelocalhost:3000compiles and refreshes with the new data.Go ahead and delete all the files out of the/srcdirectory, and we'll create our own boilerplate file without any bloat. We'll just keepindex.cssandindex.js.Forindex.css, I just copy-and-pasted the contents ofPrimitive CSSinto the file.",
        "chunk_type": "code_class",
        "tag": "main",
        "score": 1.173,
        "word_count": 989,
        "chunk_id": "66de2eaca3681f24236ea2395325d5f5",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web",
            "article",
            "development",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "If you want, you can use Bootstrap or whatever CSS framework you want, or nothing at all. I just find it easier to work with.Now inindex.js, we're importing React, ReactDOM, and the CSS file.src/index.jsimportReactfrom'react'importReactDOMfrom'react-dom'import'./index.css'Let's create ourAppcomponent again. Before, we just had an<h1>, but now I'm adding in a div element with a class as well. You'll notice that we useclassNameinstead ofclass. This is our first hint that the code being written here is JavaScript, and not actually HTML.src/index.jsclassAppextendsReact.Component{render(){return(<divclassName=\"App\"><h1>Hello, React!</h1></div>)}} inally, we'll render theAppto the root as before.src/index.jsReactDOM.render(<App/>,document.getElementById('root'))Here's our fullindex.js. This time, we're loading theComponentas a property of React, so we no longer need to extendReact.Component.src/index.jsimportReact,{Component} rom'react'importReactDOMfrom'react-dom'import'./index.css'classAppextendsComponent{render(){return(<divclassName=\"App\"><h1>Hello, React!</h1></div>)}} eactDOM.render(<App/>,document.getElementById('root'))If you go back tolocalhost:3000, you'll see \"Hello, React!\" just like before. We have the beginnings of a React app now.React Developer ToolsThere is an extension called React Developer Tools that will make your life much easier when working with React. DownloadReact DevTools for Chrome, or whatever browser you prefer to work on.After you install it, when you open DevTools, you'll see a tab for React. Click on it, and you'll be able to inspect components as they're written. You can still go to the Elements tab to see the actual DOM output. It may not seem like that much of a deal now, but as the app gets more complicated, it will become increasingly necessary to use.Now we have all the tools and setup we need to actually begin working with React.JSX: JavaScript + XMLAs you've seen, we've been using what looks like HTML in our React code, but it's not quite HTML. This isJSX, which stands for JavaScript XML.With JSX, we can write what looks like HTML, and also we can create and use our own XML-like tags. Here's what JSX looks like assigned to a variable.JSXconstheading=<h1className=\"site-heading\">Hello, React</h1>Using JSX is not mandatory for writing React. Under the hood, it's runningcreateElement, which takes the tag, object containing the properties, and children of the component and renders the same information. The below code will have the same output as the JSX above.No JSXconstheading=React.createElement('h1',{className:'site-heading'},'Hello, React!')JSX is actually closer to JavaScript, not HTML, so there are a few key differences to note when writing it.classNameis used instead ofclassfor adding CSS classes, asclassis a reserved keyword in JavaScript.Properties and methods in JSX are camelCase -onclickwill becomeonClick.Self-closing tagsmustend in a slash - e.g.<img />JavaScript expressions can also be embedded inside JSX using curly braces, including variables, functions, and properties.constname='Tania'constheading=<h1>Hello,{name}</h1>JSX is easier to write and understand than creating and appending many elements in vanilla JavaScript, and is one of the reasons people love React so much.ComponentsSo far, we've created one component - theAppcomponent. Almost everything in React consists of components, which can beclass componentsorsimple components.Most React apps have many small components, and everything loads into the mainAppcomponent. Components also often get their own file, so let's change up our project to do so.Remove theAppclass fromindex.js, so it looks like this.src/index.jsimportReactfrom'react'importReactDOMfrom'react-dom'importAppfrom'./App'import'./index.css'ReactDOM.render(<App/>,document.getElementById('root'))We'll create a new file calledApp.jsand put the component in there.src/App.jsimportReact,{Component} rom'react'classAppextendsComponent{render(){return(<divclassName=\"App\"><h1>Hello, React!</h1></div>)}} xportdefaultAppWe export the component asAppand load it inindex.js. It's not mandatory to separate components into files, but an application will start to get unwieldy and out-of-hand if you don't.Class ComponentsLet's create another component. We're going to create a table. MakeTable.js, and fill it with the following data.src/Table.jsimportReact,{Component} rom'react'classTableextendsComponent{render(){return(<table><thead><tr><th>Name</th><th>Job</th></tr></thead><tbody><tr><td>Charlie</td><td>Janitor</td></tr><tr><td>Mac</td><td>Bouncer</td></tr><tr><td>Dee</td><td>Aspiring actress</td></tr><tr><td>Dennis</td><td>Bartender</td></tr></tbody></table>)}} xportdefaultTableThis component we created is a custom class component. We capitalize custom components to differentiate them from regular HTML elements. Back inApp.js, we can load in the Table, first by importing it in:src/App.jsimportTablefrom'./Table'Then by loading it into therender()ofApp, where before we had \"Hello, React!\". I also changed the class of the outer container.src/App.jsimportReact,{Component} rom'react'importTablefrom'./Table'classAppextendsComponent{render(){return(<divclassName=\"container\"><Table/></div>)}} xportdefaultAppIf you check back on your live environment, you'll see theTableloaded in.Now we've seen what a custom class component is. We could reuse this component over and over. However, since the data is hard-coded into it, it wouldn't be too useful at the moment.Simple ComponentsThe other type of component in React is thesimple component, which is a function. This component doesn't use theclasskeyword. Let's take ourTableand make two simple components for it - a table header, and a table body.We're going to use ES6 arrow functions to create these simple components. First, the table header.src/Table.jsconstTableHeader=()=>{return(<thead><tr><th>Name</th><th>Job</th></tr></thead>)} hen the body.src/Table.jsconstTableBody=()=>{return(<tbody><tr><td>Charlie</td><td>Janitor</td></tr><tr><td>Mac</td><td>Bouncer</td></tr><tr><td>Dee</td><td>Aspiring actress</td></tr><tr><td>Dennis</td><td>Bartender</td></tr></tbody>)} ow ourTablefile will look like this. Note that theTableHeaderandTableBodycomponents are all in the same file, and being used by theTableclass component.src/Table.jsconstTableHeader=()=>{...} onstTableBody=()=>{...} lassTableextendsComponent{render(){return(<table><TableHeader/><TableBody/></table>)}} verything should appear as it did before. As you can see, components can be nested in other components, and simple and class components can be mixed.A class component must includerender(), and thereturncan only return one parent element.As a wrap up, let's compare a simple component with a class component.Simple ComponentconstSimpleComponent=()=>{return<div>Example</div>} lass ComponentclassClassComponentextendsComponent{render(){return<div>Example</div>}} ote that if thereturnis contained to one line, it does not need parentheses.PropsRight now, we have a coolTablecomponent, but the data is being hard-coded. One of the big deals about React is how it handles data, and it does so with properties, referred to asprops, and with state. Now, we'll focus on handling data with props.First, let's remove all the data from ourTableBodycomponent.src/Table.jsconstTableBody=()=>{return<tbody/>} hen let's move all that data to an array of objects, as if we were bringing in a JSON-based API. We'll have to create this array inside ourrender().src/App.jsclassAppextendsComponent{render(){constcharacters=[{name:'Charlie',job:'Janitor',},{name:'Mac',job:'Bouncer',},{name:'Dee',job:'Aspring actress',},{name:'Dennis',job:'Bartender',},]return(<divclassName=\"container\"><Table/></div>)}} ow, we're going to pass the data through to the child component (Table) with properties, kind of how you might pass data through usingdata-attributes. We can call the property whatever we want, as long as it's not a reserved keyword, so I'll go withcharacterData. The data I'm passing through is thecharactersvariable, and I'll put curly braces around it as it's a JavaScript expression.src/App.jsreturn(<divclassName=\"container\"><TablecharacterData={characters}/></div>)Now that data is being passed through toTable, we have to work on accessing it from the other side.src/Table.jsclassTableextendsComponent{render(){const{characterData}=this.propsreturn(<table><TableHeader/><TableBodycharacterData={characterData}/></table>)}} f you open up React DevTools and inspect theTablecomponent, you'll see the array of data in the property. The data that's stored here is known as thevirtual DOM, which is a fast and efficient way of syncing data with the actual DOM.This data is not in the actual DOM yet, though.",
        "chunk_type": "code_class",
        "tag": "main",
        "score": 1.173,
        "word_count": 995,
        "chunk_id": "834fe475683d762e466312825f47548e",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "information",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "InTable, we can access all props throughthis.props. We're only passing one props through, characterData, so we'll usethis.props.characterDatato retrieve that data.I'm going to use the ES6 property shorthand to create a variable that containsthis.props.characterData.const{characterData}=this.propsSince ourTablecomponent actually consists of two smaller simple components, I'm going to pass it through to theTableBody, once again through props.src/Table.jsclassTableextendsComponent{render(){const{characterData}=this.propsreturn(<table><TableHeader/><TableBodycharacterData={characterData}/></table>)}} ight now,TableBodytakes no parameters and returns a single tag.src/Table.jsconstTableBody=()=>{return<tbody/>} e're going to pass the props through as a parameter, andmap through the arrayto return a table row for each object in the array. This map will be contained in therowsvariable, which we'll return as an expression.src/Table.jsconstTableBody=(props)=>{constrows=props.characterData.map((row,index)=>{return(<trkey={index}><td>{row.name}</td><td>{row.job}</td></tr>)})return<tbody>{rows}</tbody>} f you view the front end of the app, all the data is loading in now.You'll notice I've added a key index to each table row. You should always usekeyswhen making lists in React, as they help identify each list item. We'll also see how this is necessary in a moment when we want to manipulate list items.Props are an effective way to pass existing data to a React component, however the component cannot change the props - they're read-only. In the next section, we'll learn how to use state to have further control over handling data in React.StateRight now, we're storing our character data in an array in a variable, and passing it through as props. This is good to start, but imagine if we want to be able to delete an item from the array. With props, we have a one way data flow, but with state we can update private data from a component.You can think of state as any data that should be saved and modified without necessarily being added to a database - for example, adding and removing items from a shopping cart before confirming your purchase.To start, we're going to create astateobject.src/App.jsclassAppextendsComponent{state={}} he object will contain properties for everything you want to store in the state. For us, it'scharacters.src/App.jsclassAppextendsComponent{state={characters:[],}} ove the entire array of objects we created earlier intostate.characters.src/App.jsclassAppextendsComponent{state={characters:[{name:'Charlie',// the rest of the data},],}} ur data is officially contained in the state. Since we want to be able to remove a character from the table, we're going to create aremoveCharactermethod on the parentAppclass.To retrieve the state, we'll getthis.state.charactersusing the same ES6 method as before. To update the state, we'll usethis.setState(), a built-in method for manipulating state. We'llfilter the arraybased on anindexthat we pass through, and return the new array.You must usethis.setState()to modify an array. Simply applying a new value tothis.state.propertywill not work.src/App.jsremoveCharacter=(index)=>{const{characters}=this.statethis.setState({characters:characters.filter((character,i)=>{returni!==index}),})} ilterdoes not mutate but rather creates a new array, and is a preferred method for modifying arrays in JavaScript. This particular method is testing an index vs. all the indices in the array, and returning all but the one that is passed through.Now we have to pass that function through to the component, and render a button next to each character that can invoke the function. We'll pass theremoveCharacterfunction through as a prop toTable.src/App.jsrender(){const{characters}=this.statereturn(<divclassName=\"container\"><TablecharacterData={characters} emoveCharacter={this.removeCharacter}/></div>)} ince we're passing it down toTableBodyfromTable, we're going to have to pass it through again as a prop, just like we did with the character data.In addition, since it turns out that the only components having their own states in our project areAppandForm, it would be best practice to transformTableinto a simple component from the class component it currently is.src/Table.jsconstTable=(props)=>{const{characterData,removeCharacter}=propsreturn(<table><TableHeader/><TableBodycharacterData={characterData} emoveCharacter={removeCharacter}/></table>)} ere's where that index we defined in theremoveCharacter()method comes in. In theTableBodycomponent, we'll pass the key/index through as a parameter, so the filter function knows which item to remove. We'll create a button with anonClickand pass it through.src/Table.js<trkey={index}><td>{row.name}</td><td>{row.job}</td><td><buttononClick={()=>props.removeCharacter(index)}>Delete</button></td></tr>TheonClickfunction must pass through a function that returns theremoveCharacter()method, otherwise it will try to run automatically.Awesome. Now we have delete buttons, and we can modify our state by deleting a character.I deleted Mac.Now you should understand how state gets initialized and how it can be modified.Submitting Form DataNow we have data stored in state, and we can remove any item from the state. However, what if we wanted to be able to add new data to state? In a real world application, you'd more likely start with empty state and add to it, such as with a to-do list or a shopping cart.Before anything else, let's remove all the hard-coded data fromstate.characters, as we'll be updating that through the form now.src/App.jsclassAppextendsComponent{state={characters:[],}} ow let's go ahead and create aFormcomponent in a new file calledForm.js.We're going to set the initial state of theFormto be an object with some empty properties, and assign that initial state tothis.state.src/Form.jsimportReact,{Component} rom'react'classFormextendsComponent{initialState={name:'',job:'',} tate=this.initialState} reviously, it was necessary to include aconstructor()on React class components, but it's not required anymore.Our goal for this form will be to update the state ofFormevery time a field is changed in the form, and when we submit, all that data will pass to theAppstate, which will then update theTable.First, we'll make the function that will run every time a change is made to an input. Theeventwill be passed through, and we'll set the state ofFormto have thename(key) andvalueof the inputs.src/Form.jshandleChange=(event)=>{const{name,value}=event.targetthis.setState({[name]:value,})} et's get this working before we move on to submitting the form. In the render, let's get our two properties from state, and assign them as the values that correspond to the proper form keys. We'll run thehandleChange()method as theonChangeof the input, and finally we'll export theFormcomponent.src/Form.jsrender(){const{name,job}=this.state;return(<form><labelhtmlFor=\"name\">Name</label><inputtype=\"text\"name=\"name\"id=\"name\"value={name} nChange={this.handleChange}/><labelhtmlFor=\"job\">Job</label><inputtype=\"text\"name=\"job\"id=\"job\"value={job} nChange={this.handleChange}/></form>);} xportdefaultForm;InApp.js, we can render the form below the table.src/App.jsimportFormfrom'./Form'src/App.jsreturn(<divclassName=\"container\"><TablecharacterData={characters} emoveCharacter={this.removeCharacter}/><Form/></div>)Now if we go to the front end of our app, we'll see a form that doesn't have a submit yet. Update some fields and you'll see the local state ofFormbeing updated.Cool. Last step is to allow us to actually submit that data and update the parent state. We'll create a function calledhandleSubmit()onAppthat will update the state by taking the existingthis.state.charactersand adding the newcharacterparameter, using theES6 spread operator.src/App.jshandleSubmit=(character)=>{this.setState({characters:[...this.state.characters,character]})} et's make sure we pass that through as a parameter onForm.<FormhandleSubmit={this.handleSubmit}/>Now inForm, we'll create a method calledsubmitForm()that will call that function, and pass theFormstate through as thecharacterparameter we defined earlier. It will also reset the state to the initial state, to clear the form after submit.src/Form.jssubmitForm=()=>{this.props.handleSubmit(this.state)this.setState(this.initialState)} inally, we'll add a submit button to submit the form.",
        "chunk_type": "code_function",
        "tag": "main",
        "score": 1.173,
        "word_count": 999,
        "chunk_id": "b076d340e9a9754098f24b38e7323649",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "We're using anonClickinstead of anonSubmitsince we're not using the standard submit functionality. The click will call thesubmitFormwe just made.<inputtype=\"button\"value=\"Submit\"onClick={this.submitForm}/>And that's it! The app is complete. We can create, add, and remove users from our table. Since theTableandTableBodywere already pulling from the state, it will display properly.If you got lost anywhere along the way, you can viewthe complete source on GitHub.Pulling in API DataOne very common usage of React is pulling in data from an API. If you're not familiar with what an API is or how to connect to one, I would recommend readingHow to Connect to an API with JavaScript, which will walk you through what APIs are and how to use them with vanilla JavaScript.As a little test, we can create a newApi.jsfile, and create a newAppin there. A public API we can test with is theWikipedia API, and I have aURL endpoint right herefor a random* search. You can go to that link to see the API - and make sure you haveJSONViewinstalled on your browser.We're going to useJavaScript's built-in Fetchto gather the data from that URL endpoint and display it. You can switch between the app we created and this test file by just changing the URL inindex.js-import App from './Api';.I'm not going to explain this code line-by-line, as we've already learned about creating a component, rendering, and mapping through a state array. The new aspect to this code iscomponentDidMount(), a React lifecycle method.Lifecycleis the order in which methods are called in React.Mountingrefers to an item being inserted into the DOM.When we pull in API data, we want to usecomponentDidMount, because we want to make sure the component has rendered to the DOM before we bring in the data. In the below snippet, you'll see how we bring in data from the Wikipedia API, and display it on the pageApi.jsimportReact,{Component} rom'react'classAppextendsComponent{state={data:[],}// Code is invoked after the component is mounted/inserted into the DOM tree.componentDidMount(){consturl='https://en.wikipedia.org/w/api.php?action=opensearch&search=Seona+Dancing&format=json&origin=*'fetch(url).then((result)=>result.json()).then((result)=>{this.setState({data:result,})})} ender(){const{data}=this.stateconstresult=data.map((entry,index)=>{return<likey={index}>{entry}</li>})return<ul>{result}</ul>}} xportdefaultAppOnce you save and run this file in the local server, you'll see the Wikipedia API data displayed in the DOM.There are other lifecycle methods, but going over them will be beyond the scope of this article. You canread more about React components here.*Wikipedia search choice may not be random. It might be an article that I spearheaded back in 2005.Building and Deploying a React AppEverything we've done so far has been in a development environment. We've been compiling, hot-reloading, and updating on the fly. For production, we're going to want to have static files loading in - none of the source code. We can do this by making a build and deploying it.Now, if you just want to compile all the React code and place it in the root of a directory somewhere, all you need to do is run the following line:npmrun buildThis will create abuildfolder which will contain your app. Put the contents of that folder anywhere, and you're done!We can also take it a step further, and have npm deploy for us. We're going to build to GitHub pages, so you'll already have tobe familiar with Gitand getting your code up on GitHub.Make sure you've exited out of your local React environment, so the code isn't currently running. First, we're going to add ahomepagefield topackage.json, that has the URL we want our app to live on.package.json\"homepage\":\"https://taniarascia.github.io/react-tutorial\",We'll also add these two lines to thescriptsproperty.\"scripts\":{// ...\"predeploy\":\"npm run build\",\"deploy\":\"gh-pages -d build\"} n your project, you'll addgh-pagesto the devDependencies.npminstall--save-dev gh-pagesWe'll create thebuild, which will have all the compiled, static files.npmrun buildFinally, we'll deploy togh-pages.npmrun deployAnd we're done! The app is now available live athttps://taniarascia.github.io/react-tutorial.ConclusionThis article should have given you a good introduction to React, simple and class components, state, props, working with form data, pulling data in from an API, and deploying an app. There is much more to learn and do with React, but I hope you feel confident delving in and playing around with React yourself now.View Source on GitHubView ProjectPlease let me know if anything was unclear, or if there's anything else you'd like to see in this or a subsequent article.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:August 20, 2018Category:TechnicalTagsapijavascriptreacttutorialframeworksNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_class",
        "tag": "main",
        "score": 1.173,
        "word_count": 726,
        "chunk_id": "5f0b4f4d59fc368d25fc156739b30807",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web",
            "article",
            "development",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "How to Use React, the JavaScript FrameworkI've been hearing about React since I first started learning JavaScript, but I'll admit I took one look at it and it scared me. I saw what looked like a bunch of HTML mixed with JavaScript and thought,isn't this what we've been trying to avoid? What's the big deal with React?Instead, I focused on just learning vanilla JavaScript and working with jQuery in a professional setting. After a few frustrated, failed attempts to get started with React, I finally started to get it, and I began to see why I might want to use React instead of vanilla JS or jQuery.I tried to condense everything I've learned into a nice introduction to share with you, so here it is.PrerequisitesThere are a few things you should know in advance before you start playing around with React. If you've never used JavaScript or the DOM at all before, for example, I would get more familiar with those before trying to tackle React.Here are what I consider to be React prerequisites.Basic familiarity withHTML & CSS.Basic knowledge ofJavaScriptand programming.Basic understanding ofthe DOM.Familiarity withES6 syntax and features.Node.js and npminstalled globally.GoalsLearn about essential React concepts and related terms, such as Babel, Webpack, JSX, components, props, state, and lifecycle.Build a very simple React app that demonstrates the above concepts.Here's the source and a live demo of the end result.View Source on GitHubView DemoWhat is React?React is a JavaScript library - one of the most popular ones, withover 100,000 stars on GitHub.React is not a framework (unlike Angular, which is more opinionated).React is an open-source project created by Facebook.React is used to build user interfaces (UI) on the front end.React is theviewlayer of an MVC application (Model View Controller)One of the most important aspects of React is the fact that you can createcomponents, which are like custom, reusable HTML elements, to quickly and efficiently build user interfaces. React also streamlines how data is stored and handled, usingstateandprops.We'll go over all of this and more throughout the article, so let's get started.Setup and InstallationThere are a few ways to set up React, and I'll show you two so you get a good idea of how it works.Static HTML FileThis first method is not a popular way to set up React and is not how we'll be doing the rest of our tutorial, but it will be familiar and easy to understand if you've ever used a library like jQuery, and it's the least scary way to get started if you're not familiar with Webpack, Babel, and Node.js.Let's start by making a basicindex.htmlfile. We're going to load in three CDNs in thehead- React, React DOM, and Babel. We're also going to make adivwith an id calledroot, and finally we'll create ascripttag where your custom code will live.index.html<!DOCTYPEhtml><html><head><metacharset=\"utf-8\"/><title>Hello React!</title><scriptsrc=\"https://unpkg.com/react@^16/umd/react.production.min.js\"></script><scriptsrc=\"https://unpkg.com/react-dom@16.13.0/umd/react-dom.production.min.js\"></script><scriptsrc=\"https://unpkg.com/babel-standalone@6.26.0/babel.js\"></script></head><body><divid=\"root\"></div><scripttype=\"text/babel\">// React code will go here</script></body></html>I'm loading in the latest stable versions of the libraries as of the time of this writing.React- the React top level APIReact DOM- adds DOM-specific methodsBabel- a JavaScript compiler that lets us use ES6+ in old browsersThe entry point for our app will be therootdiv element, which is named by convention. You'll also notice thetext/babelscript type, which is mandatory for using Babel.Now, let's write our first code block of React. We're going to use ES6 classes to create a React component calledApp.index.htmlclassAppextendsReact.Component{//...} ow we'll add therender()method, the only required method in a class component, which is used to render DOM nodes.index.htmlclassAppextendsReact.Component{render(){return(//...);}} nside thereturn, we're going to put what looks like a simple HTML element. Note that we're not returning a string here, so don't use quotes around the element. This is calledJSX, and we'll learn more about it soon.index.htmlclassAppextendsReact.Component{render(){return<h1>Hello world!</h1>}} inally, we're going to use the React DOMrender()method to render theAppclass we created into therootdiv in our HTML.index.htmlReactDOM.render(<App/>,document.getElementById('root'))Here is the full code for ourindex.html.index.html<!DOCTYPEhtml><html><head><metacharset=\"utf-8\"/><title>Hello React!</title><scriptsrc=\"https://unpkg.com/react@16/umd/react.development.js\"></script><scriptsrc=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"></script><scriptsrc=\"https://unpkg.com/babel-standalone@6.26.0/babel.js\"></script></head><body><divid=\"root\"></div><scripttype=\"text/babel\">classAppextendsReact.Component{render(){return<h1>Hello world!</h1>}} eactDOM.render(<App/>,document.getElementById('root'))</script></body></html>Now if you view yourindex.htmlin the browser, you'll see theh1tag we created rendered to the DOM.Cool! Now that you've done this, you can see that React isn't so insanely scary to get started with. It's just some JavaScript helper libraries that we can load into our HTML.We've done this for demonstration purposes, but from here out we're going to use another method: Create React App.Create React AppThe method I just used of loading JavaScript libraries into a static HTML page and rendering the React and Babel on the fly is not very efficient, and is hard to maintain.Fortunately, Facebook has createdCreate React App, an environment that comes pre-configured with everything you need to build a React app. It will create a live development server, use Webpack to automatically compile React, JSX, and ES6, auto-prefix CSS files, and use ESLint to test and warn about mistakes in the code.To set upcreate-react-app, run the following code in your terminal, one directory up from where you want the project to live.npx create-react-app react-tutorialOnce that finishes installing, move to the newly created directory and start the project.cdreact-tutorial&&npmstartOnce you run this command, a new window will popup atlocalhost:3000with your new React app.Create React App is very good for getting started for beginners as well as large-scale enterprise applications, but it's not perfect for every workflow. You can also create your own Webpack setup for React.If you look into the project structure, you'll see a/publicand/srcdirectory, along with the regularnode_modules,.gitignore,README.md, andpackage.json.In/public, our important file isindex.html, which is very similar to the staticindex.htmlfile we made earlier - just arootdiv. This time, no libraries or scripts are being loaded in. The/srcdirectory will contain all our React code.To see how the environment automatically compiles and updates your React code, find the line that looks like this in/src/App.js:To get started, edit `src/App.js` and save to reload.And replace it with any other text. Once you save the file, you'll noticelocalhost:3000compiles and refreshes with the new data.Go ahead and delete all the files out of the/srcdirectory, and we'll create our own boilerplate file without any bloat. We'll just keepindex.cssandindex.js.Forindex.css, I just copy-and-pasted the contents ofPrimitive CSSinto the file.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.173,
        "word_count": 989,
        "chunk_id": "66de2eaca3681f24236ea2395325d5f5",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "development",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "If you want, you can use Bootstrap or whatever CSS framework you want, or nothing at all. I just find it easier to work with.Now inindex.js, we're importing React, ReactDOM, and the CSS file.src/index.jsimportReactfrom'react'importReactDOMfrom'react-dom'import'./index.css'Let's create ourAppcomponent again. Before, we just had an<h1>, but now I'm adding in a div element with a class as well. You'll notice that we useclassNameinstead ofclass. This is our first hint that the code being written here is JavaScript, and not actually HTML.src/index.jsclassAppextendsReact.Component{render(){return(<divclassName=\"App\"><h1>Hello, React!</h1></div>)}} inally, we'll render theAppto the root as before.src/index.jsReactDOM.render(<App/>,document.getElementById('root'))Here's our fullindex.js. This time, we're loading theComponentas a property of React, so we no longer need to extendReact.Component.src/index.jsimportReact,{Component} rom'react'importReactDOMfrom'react-dom'import'./index.css'classAppextendsComponent{render(){return(<divclassName=\"App\"><h1>Hello, React!</h1></div>)}} eactDOM.render(<App/>,document.getElementById('root'))If you go back tolocalhost:3000, you'll see \"Hello, React!\" just like before. We have the beginnings of a React app now.React Developer ToolsThere is an extension called React Developer Tools that will make your life much easier when working with React. DownloadReact DevTools for Chrome, or whatever browser you prefer to work on.After you install it, when you open DevTools, you'll see a tab for React. Click on it, and you'll be able to inspect components as they're written. You can still go to the Elements tab to see the actual DOM output. It may not seem like that much of a deal now, but as the app gets more complicated, it will become increasingly necessary to use.Now we have all the tools and setup we need to actually begin working with React.JSX: JavaScript + XMLAs you've seen, we've been using what looks like HTML in our React code, but it's not quite HTML. This isJSX, which stands for JavaScript XML.With JSX, we can write what looks like HTML, and also we can create and use our own XML-like tags. Here's what JSX looks like assigned to a variable.JSXconstheading=<h1className=\"site-heading\">Hello, React</h1>Using JSX is not mandatory for writing React. Under the hood, it's runningcreateElement, which takes the tag, object containing the properties, and children of the component and renders the same information. The below code will have the same output as the JSX above.No JSXconstheading=React.createElement('h1',{className:'site-heading'},'Hello, React!')JSX is actually closer to JavaScript, not HTML, so there are a few key differences to note when writing it.classNameis used instead ofclassfor adding CSS classes, asclassis a reserved keyword in JavaScript.Properties and methods in JSX are camelCase -onclickwill becomeonClick.Self-closing tagsmustend in a slash - e.g.<img />JavaScript expressions can also be embedded inside JSX using curly braces, including variables, functions, and properties.constname='Tania'constheading=<h1>Hello,{name}</h1>JSX is easier to write and understand than creating and appending many elements in vanilla JavaScript, and is one of the reasons people love React so much.ComponentsSo far, we've created one component - theAppcomponent. Almost everything in React consists of components, which can beclass componentsorsimple components.Most React apps have many small components, and everything loads into the mainAppcomponent. Components also often get their own file, so let's change up our project to do so.Remove theAppclass fromindex.js, so it looks like this.src/index.jsimportReactfrom'react'importReactDOMfrom'react-dom'importAppfrom'./App'import'./index.css'ReactDOM.render(<App/>,document.getElementById('root'))We'll create a new file calledApp.jsand put the component in there.src/App.jsimportReact,{Component} rom'react'classAppextendsComponent{render(){return(<divclassName=\"App\"><h1>Hello, React!</h1></div>)}} xportdefaultAppWe export the component asAppand load it inindex.js. It's not mandatory to separate components into files, but an application will start to get unwieldy and out-of-hand if you don't.Class ComponentsLet's create another component. We're going to create a table. MakeTable.js, and fill it with the following data.src/Table.jsimportReact,{Component} rom'react'classTableextendsComponent{render(){return(<table><thead><tr><th>Name</th><th>Job</th></tr></thead><tbody><tr><td>Charlie</td><td>Janitor</td></tr><tr><td>Mac</td><td>Bouncer</td></tr><tr><td>Dee</td><td>Aspiring actress</td></tr><tr><td>Dennis</td><td>Bartender</td></tr></tbody></table>)}} xportdefaultTableThis component we created is a custom class component. We capitalize custom components to differentiate them from regular HTML elements. Back inApp.js, we can load in the Table, first by importing it in:src/App.jsimportTablefrom'./Table'Then by loading it into therender()ofApp, where before we had \"Hello, React!\". I also changed the class of the outer container.src/App.jsimportReact,{Component} rom'react'importTablefrom'./Table'classAppextendsComponent{render(){return(<divclassName=\"container\"><Table/></div>)}} xportdefaultAppIf you check back on your live environment, you'll see theTableloaded in.Now we've seen what a custom class component is. We could reuse this component over and over. However, since the data is hard-coded into it, it wouldn't be too useful at the moment.Simple ComponentsThe other type of component in React is thesimple component, which is a function. This component doesn't use theclasskeyword. Let's take ourTableand make two simple components for it - a table header, and a table body.We're going to use ES6 arrow functions to create these simple components. First, the table header.src/Table.jsconstTableHeader=()=>{return(<thead><tr><th>Name</th><th>Job</th></tr></thead>)} hen the body.src/Table.jsconstTableBody=()=>{return(<tbody><tr><td>Charlie</td><td>Janitor</td></tr><tr><td>Mac</td><td>Bouncer</td></tr><tr><td>Dee</td><td>Aspiring actress</td></tr><tr><td>Dennis</td><td>Bartender</td></tr></tbody>)} ow ourTablefile will look like this. Note that theTableHeaderandTableBodycomponents are all in the same file, and being used by theTableclass component.src/Table.jsconstTableHeader=()=>{...} onstTableBody=()=>{...} lassTableextendsComponent{render(){return(<table><TableHeader/><TableBody/></table>)}} verything should appear as it did before. As you can see, components can be nested in other components, and simple and class components can be mixed.A class component must includerender(), and thereturncan only return one parent element.As a wrap up, let's compare a simple component with a class component.Simple ComponentconstSimpleComponent=()=>{return<div>Example</div>} lass ComponentclassClassComponentextendsComponent{render(){return<div>Example</div>}} ote that if thereturnis contained to one line, it does not need parentheses.PropsRight now, we have a coolTablecomponent, but the data is being hard-coded. One of the big deals about React is how it handles data, and it does so with properties, referred to asprops, and with state. Now, we'll focus on handling data with props.First, let's remove all the data from ourTableBodycomponent.src/Table.jsconstTableBody=()=>{return<tbody/>} hen let's move all that data to an array of objects, as if we were bringing in a JSON-based API. We'll have to create this array inside ourrender().src/App.jsclassAppextendsComponent{render(){constcharacters=[{name:'Charlie',job:'Janitor',},{name:'Mac',job:'Bouncer',},{name:'Dee',job:'Aspring actress',},{name:'Dennis',job:'Bartender',},]return(<divclassName=\"container\"><Table/></div>)}} ow, we're going to pass the data through to the child component (Table) with properties, kind of how you might pass data through usingdata-attributes. We can call the property whatever we want, as long as it's not a reserved keyword, so I'll go withcharacterData. The data I'm passing through is thecharactersvariable, and I'll put curly braces around it as it's a JavaScript expression.src/App.jsreturn(<divclassName=\"container\"><TablecharacterData={characters}/></div>)Now that data is being passed through toTable, we have to work on accessing it from the other side.src/Table.jsclassTableextendsComponent{render(){const{characterData}=this.propsreturn(<table><TableHeader/><TableBodycharacterData={characterData}/></table>)}} f you open up React DevTools and inspect theTablecomponent, you'll see the array of data in the property. The data that's stored here is known as thevirtual DOM, which is a fast and efficient way of syncing data with the actual DOM.This data is not in the actual DOM yet, though.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.173,
        "word_count": 995,
        "chunk_id": "834fe475683d762e466312825f47548e",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "information",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "InTable, we can access all props throughthis.props. We're only passing one props through, characterData, so we'll usethis.props.characterDatato retrieve that data.I'm going to use the ES6 property shorthand to create a variable that containsthis.props.characterData.const{characterData}=this.propsSince ourTablecomponent actually consists of two smaller simple components, I'm going to pass it through to theTableBody, once again through props.src/Table.jsclassTableextendsComponent{render(){const{characterData}=this.propsreturn(<table><TableHeader/><TableBodycharacterData={characterData}/></table>)}} ight now,TableBodytakes no parameters and returns a single tag.src/Table.jsconstTableBody=()=>{return<tbody/>} e're going to pass the props through as a parameter, andmap through the arrayto return a table row for each object in the array. This map will be contained in therowsvariable, which we'll return as an expression.src/Table.jsconstTableBody=(props)=>{constrows=props.characterData.map((row,index)=>{return(<trkey={index}><td>{row.name}</td><td>{row.job}</td></tr>)})return<tbody>{rows}</tbody>} f you view the front end of the app, all the data is loading in now.You'll notice I've added a key index to each table row. You should always usekeyswhen making lists in React, as they help identify each list item. We'll also see how this is necessary in a moment when we want to manipulate list items.Props are an effective way to pass existing data to a React component, however the component cannot change the props - they're read-only. In the next section, we'll learn how to use state to have further control over handling data in React.StateRight now, we're storing our character data in an array in a variable, and passing it through as props. This is good to start, but imagine if we want to be able to delete an item from the array. With props, we have a one way data flow, but with state we can update private data from a component.You can think of state as any data that should be saved and modified without necessarily being added to a database - for example, adding and removing items from a shopping cart before confirming your purchase.To start, we're going to create astateobject.src/App.jsclassAppextendsComponent{state={}} he object will contain properties for everything you want to store in the state. For us, it'scharacters.src/App.jsclassAppextendsComponent{state={characters:[],}} ove the entire array of objects we created earlier intostate.characters.src/App.jsclassAppextendsComponent{state={characters:[{name:'Charlie',// the rest of the data},],}} ur data is officially contained in the state. Since we want to be able to remove a character from the table, we're going to create aremoveCharactermethod on the parentAppclass.To retrieve the state, we'll getthis.state.charactersusing the same ES6 method as before. To update the state, we'll usethis.setState(), a built-in method for manipulating state. We'llfilter the arraybased on anindexthat we pass through, and return the new array.You must usethis.setState()to modify an array. Simply applying a new value tothis.state.propertywill not work.src/App.jsremoveCharacter=(index)=>{const{characters}=this.statethis.setState({characters:characters.filter((character,i)=>{returni!==index}),})} ilterdoes not mutate but rather creates a new array, and is a preferred method for modifying arrays in JavaScript. This particular method is testing an index vs. all the indices in the array, and returning all but the one that is passed through.Now we have to pass that function through to the component, and render a button next to each character that can invoke the function. We'll pass theremoveCharacterfunction through as a prop toTable.src/App.jsrender(){const{characters}=this.statereturn(<divclassName=\"container\"><TablecharacterData={characters} emoveCharacter={this.removeCharacter}/></div>)} ince we're passing it down toTableBodyfromTable, we're going to have to pass it through again as a prop, just like we did with the character data.In addition, since it turns out that the only components having their own states in our project areAppandForm, it would be best practice to transformTableinto a simple component from the class component it currently is.src/Table.jsconstTable=(props)=>{const{characterData,removeCharacter}=propsreturn(<table><TableHeader/><TableBodycharacterData={characterData} emoveCharacter={removeCharacter}/></table>)} ere's where that index we defined in theremoveCharacter()method comes in. In theTableBodycomponent, we'll pass the key/index through as a parameter, so the filter function knows which item to remove. We'll create a button with anonClickand pass it through.src/Table.js<trkey={index}><td>{row.name}</td><td>{row.job}</td><td><buttononClick={()=>props.removeCharacter(index)}>Delete</button></td></tr>TheonClickfunction must pass through a function that returns theremoveCharacter()method, otherwise it will try to run automatically.Awesome. Now we have delete buttons, and we can modify our state by deleting a character.I deleted Mac.Now you should understand how state gets initialized and how it can be modified.Submitting Form DataNow we have data stored in state, and we can remove any item from the state. However, what if we wanted to be able to add new data to state? In a real world application, you'd more likely start with empty state and add to it, such as with a to-do list or a shopping cart.Before anything else, let's remove all the hard-coded data fromstate.characters, as we'll be updating that through the form now.src/App.jsclassAppextendsComponent{state={characters:[],}} ow let's go ahead and create aFormcomponent in a new file calledForm.js.We're going to set the initial state of theFormto be an object with some empty properties, and assign that initial state tothis.state.src/Form.jsimportReact,{Component} rom'react'classFormextendsComponent{initialState={name:'',job:'',} tate=this.initialState} reviously, it was necessary to include aconstructor()on React class components, but it's not required anymore.Our goal for this form will be to update the state ofFormevery time a field is changed in the form, and when we submit, all that data will pass to theAppstate, which will then update theTable.First, we'll make the function that will run every time a change is made to an input. Theeventwill be passed through, and we'll set the state ofFormto have thename(key) andvalueof the inputs.src/Form.jshandleChange=(event)=>{const{name,value}=event.targetthis.setState({[name]:value,})} et's get this working before we move on to submitting the form. In the render, let's get our two properties from state, and assign them as the values that correspond to the proper form keys. We'll run thehandleChange()method as theonChangeof the input, and finally we'll export theFormcomponent.src/Form.jsrender(){const{name,job}=this.state;return(<form><labelhtmlFor=\"name\">Name</label><inputtype=\"text\"name=\"name\"id=\"name\"value={name} nChange={this.handleChange}/><labelhtmlFor=\"job\">Job</label><inputtype=\"text\"name=\"job\"id=\"job\"value={job} nChange={this.handleChange}/></form>);} xportdefaultForm;InApp.js, we can render the form below the table.src/App.jsimportFormfrom'./Form'src/App.jsreturn(<divclassName=\"container\"><TablecharacterData={characters} emoveCharacter={this.removeCharacter}/><Form/></div>)Now if we go to the front end of our app, we'll see a form that doesn't have a submit yet. Update some fields and you'll see the local state ofFormbeing updated.Cool. Last step is to allow us to actually submit that data and update the parent state. We'll create a function calledhandleSubmit()onAppthat will update the state by taking the existingthis.state.charactersand adding the newcharacterparameter, using theES6 spread operator.src/App.jshandleSubmit=(character)=>{this.setState({characters:[...this.state.characters,character]})} et's make sure we pass that through as a parameter onForm.<FormhandleSubmit={this.handleSubmit}/>Now inForm, we'll create a method calledsubmitForm()that will call that function, and pass theFormstate through as thecharacterparameter we defined earlier. It will also reset the state to the initial state, to clear the form after submit.src/Form.jssubmitForm=()=>{this.props.handleSubmit(this.state)this.setState(this.initialState)} inally, we'll add a submit button to submit the form.",
        "chunk_type": "code_function",
        "tag": "div",
        "score": 1.173,
        "word_count": 999,
        "chunk_id": "b076d340e9a9754098f24b38e7323649",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "We're using anonClickinstead of anonSubmitsince we're not using the standard submit functionality. The click will call thesubmitFormwe just made.<inputtype=\"button\"value=\"Submit\"onClick={this.submitForm}/>And that's it! The app is complete. We can create, add, and remove users from our table. Since theTableandTableBodywere already pulling from the state, it will display properly.If you got lost anywhere along the way, you can viewthe complete source on GitHub.Pulling in API DataOne very common usage of React is pulling in data from an API. If you're not familiar with what an API is or how to connect to one, I would recommend readingHow to Connect to an API with JavaScript, which will walk you through what APIs are and how to use them with vanilla JavaScript.As a little test, we can create a newApi.jsfile, and create a newAppin there. A public API we can test with is theWikipedia API, and I have aURL endpoint right herefor a random* search. You can go to that link to see the API - and make sure you haveJSONViewinstalled on your browser.We're going to useJavaScript's built-in Fetchto gather the data from that URL endpoint and display it. You can switch between the app we created and this test file by just changing the URL inindex.js-import App from './Api';.I'm not going to explain this code line-by-line, as we've already learned about creating a component, rendering, and mapping through a state array. The new aspect to this code iscomponentDidMount(), a React lifecycle method.Lifecycleis the order in which methods are called in React.Mountingrefers to an item being inserted into the DOM.When we pull in API data, we want to usecomponentDidMount, because we want to make sure the component has rendered to the DOM before we bring in the data. In the below snippet, you'll see how we bring in data from the Wikipedia API, and display it on the pageApi.jsimportReact,{Component} rom'react'classAppextendsComponent{state={data:[],}// Code is invoked after the component is mounted/inserted into the DOM tree.componentDidMount(){consturl='https://en.wikipedia.org/w/api.php?action=opensearch&search=Seona+Dancing&format=json&origin=*'fetch(url).then((result)=>result.json()).then((result)=>{this.setState({data:result,})})} ender(){const{data}=this.stateconstresult=data.map((entry,index)=>{return<likey={index}>{entry}</li>})return<ul>{result}</ul>}} xportdefaultAppOnce you save and run this file in the local server, you'll see the Wikipedia API data displayed in the DOM.There are other lifecycle methods, but going over them will be beyond the scope of this article. You canread more about React components here.*Wikipedia search choice may not be random. It might be an article that I spearheaded back in 2005.Building and Deploying a React AppEverything we've done so far has been in a development environment. We've been compiling, hot-reloading, and updating on the fly. For production, we're going to want to have static files loading in - none of the source code. We can do this by making a build and deploying it.Now, if you just want to compile all the React code and place it in the root of a directory somewhere, all you need to do is run the following line:npmrun buildThis will create abuildfolder which will contain your app. Put the contents of that folder anywhere, and you're done!We can also take it a step further, and have npm deploy for us. We're going to build to GitHub pages, so you'll already have tobe familiar with Gitand getting your code up on GitHub.Make sure you've exited out of your local React environment, so the code isn't currently running. First, we're going to add ahomepagefield topackage.json, that has the URL we want our app to live on.package.json\"homepage\":\"https://taniarascia.github.io/react-tutorial\",We'll also add these two lines to thescriptsproperty.\"scripts\":{// ...\"predeploy\":\"npm run build\",\"deploy\":\"gh-pages -d build\"} n your project, you'll addgh-pagesto the devDependencies.npminstall--save-dev gh-pagesWe'll create thebuild, which will have all the compiled, static files.npmrun buildFinally, we'll deploy togh-pages.npmrun deployAnd we're done! The app is now available live athttps://taniarascia.github.io/react-tutorial.ConclusionThis article should have given you a good introduction to React, simple and class components, state, props, working with form data, pulling data in from an API, and deploying an app. There is much more to learn and do with React, but I hope you feel confident delving in and playing around with React yourself now.View Source on GitHubView ProjectPlease let me know if anything was unclear, or if there's anything else you'd like to see in this or a subsequent article.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:August 20, 2018Category:TechnicalTagsapijavascriptreacttutorialframeworksNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.173,
        "word_count": 726,
        "chunk_id": "5f0b4f4d59fc368d25fc156739b30807",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "development",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "How to Use React, the JavaScript FrameworkI've been hearing about React since I first started learning JavaScript, but I'll admit I took one look at it and it scared me. I saw what looked like a bunch of HTML mixed with JavaScript and thought,isn't this what we've been trying to avoid? What's the big deal with React?Instead, I focused on just learning vanilla JavaScript and working with jQuery in a professional setting. After a few frustrated, failed attempts to get started with React, I finally started to get it, and I began to see why I might want to use React instead of vanilla JS or jQuery.I tried to condense everything I've learned into a nice introduction to share with you, so here it is.PrerequisitesThere are a few things you should know in advance before you start playing around with React. If you've never used JavaScript or the DOM at all before, for example, I would get more familiar with those before trying to tackle React.Here are what I consider to be React prerequisites.Basic familiarity withHTML & CSS.Basic knowledge ofJavaScriptand programming.Basic understanding ofthe DOM.Familiarity withES6 syntax and features.Node.js and npminstalled globally.GoalsLearn about essential React concepts and related terms, such as Babel, Webpack, JSX, components, props, state, and lifecycle.Build a very simple React app that demonstrates the above concepts.Here's the source and a live demo of the end result.View Source on GitHubView DemoWhat is React?React is a JavaScript library - one of the most popular ones, withover 100,000 stars on GitHub.React is not a framework (unlike Angular, which is more opinionated).React is an open-source project created by Facebook.React is used to build user interfaces (UI) on the front end.React is theviewlayer of an MVC application (Model View Controller)One of the most important aspects of React is the fact that you can createcomponents, which are like custom, reusable HTML elements, to quickly and efficiently build user interfaces. React also streamlines how data is stored and handled, usingstateandprops.We'll go over all of this and more throughout the article, so let's get started.Setup and InstallationThere are a few ways to set up React, and I'll show you two so you get a good idea of how it works.Static HTML FileThis first method is not a popular way to set up React and is not how we'll be doing the rest of our tutorial, but it will be familiar and easy to understand if you've ever used a library like jQuery, and it's the least scary way to get started if you're not familiar with Webpack, Babel, and Node.js.Let's start by making a basicindex.htmlfile. We're going to load in three CDNs in thehead- React, React DOM, and Babel. We're also going to make adivwith an id calledroot, and finally we'll create ascripttag where your custom code will live.index.html<!DOCTYPEhtml><html><head><metacharset=\"utf-8\"/><title>Hello React!</title><scriptsrc=\"https://unpkg.com/react@^16/umd/react.production.min.js\"></script><scriptsrc=\"https://unpkg.com/react-dom@16.13.0/umd/react-dom.production.min.js\"></script><scriptsrc=\"https://unpkg.com/babel-standalone@6.26.0/babel.js\"></script></head><body><divid=\"root\"></div><scripttype=\"text/babel\">// React code will go here</script></body></html>I'm loading in the latest stable versions of the libraries as of the time of this writing.React- the React top level APIReact DOM- adds DOM-specific methodsBabel- a JavaScript compiler that lets us use ES6+ in old browsersThe entry point for our app will be therootdiv element, which is named by convention. You'll also notice thetext/babelscript type, which is mandatory for using Babel.Now, let's write our first code block of React. We're going to use ES6 classes to create a React component calledApp.index.htmlclassAppextendsReact.Component{//...} ow we'll add therender()method, the only required method in a class component, which is used to render DOM nodes.index.htmlclassAppextendsReact.Component{render(){return(//...);}} nside thereturn, we're going to put what looks like a simple HTML element. Note that we're not returning a string here, so don't use quotes around the element. This is calledJSX, and we'll learn more about it soon.index.htmlclassAppextendsReact.Component{render(){return<h1>Hello world!</h1>}} inally, we're going to use the React DOMrender()method to render theAppclass we created into therootdiv in our HTML.index.htmlReactDOM.render(<App/>,document.getElementById('root'))Here is the full code for ourindex.html.index.html<!DOCTYPEhtml><html><head><metacharset=\"utf-8\"/><title>Hello React!</title><scriptsrc=\"https://unpkg.com/react@16/umd/react.development.js\"></script><scriptsrc=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"></script><scriptsrc=\"https://unpkg.com/babel-standalone@6.26.0/babel.js\"></script></head><body><divid=\"root\"></div><scripttype=\"text/babel\">classAppextendsReact.Component{render(){return<h1>Hello world!</h1>}} eactDOM.render(<App/>,document.getElementById('root'))</script></body></html>Now if you view yourindex.htmlin the browser, you'll see theh1tag we created rendered to the DOM.Cool! Now that you've done this, you can see that React isn't so insanely scary to get started with. It's just some JavaScript helper libraries that we can load into our HTML.We've done this for demonstration purposes, but from here out we're going to use another method: Create React App.Create React AppThe method I just used of loading JavaScript libraries into a static HTML page and rendering the React and Babel on the fly is not very efficient, and is hard to maintain.Fortunately, Facebook has createdCreate React App, an environment that comes pre-configured with everything you need to build a React app. It will create a live development server, use Webpack to automatically compile React, JSX, and ES6, auto-prefix CSS files, and use ESLint to test and warn about mistakes in the code.To set upcreate-react-app, run the following code in your terminal, one directory up from where you want the project to live.npx create-react-app react-tutorialOnce that finishes installing, move to the newly created directory and start the project.cdreact-tutorial&&npmstartOnce you run this command, a new window will popup atlocalhost:3000with your new React app.Create React App is very good for getting started for beginners as well as large-scale enterprise applications, but it's not perfect for every workflow. You can also create your own Webpack setup for React.If you look into the project structure, you'll see a/publicand/srcdirectory, along with the regularnode_modules,.gitignore,README.md, andpackage.json.In/public, our important file isindex.html, which is very similar to the staticindex.htmlfile we made earlier - just arootdiv. This time, no libraries or scripts are being loaded in. The/srcdirectory will contain all our React code.To see how the environment automatically compiles and updates your React code, find the line that looks like this in/src/App.js:To get started, edit `src/App.js` and save to reload.And replace it with any other text. Once you save the file, you'll noticelocalhost:3000compiles and refreshes with the new data.Go ahead and delete all the files out of the/srcdirectory, and we'll create our own boilerplate file without any bloat. We'll just keepindex.cssandindex.js.Forindex.css, I just copy-and-pasted the contents ofPrimitive CSSinto the file.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.173,
        "word_count": 989,
        "chunk_id": "66de2eaca3681f24236ea2395325d5f5",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "development",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "If you want, you can use Bootstrap or whatever CSS framework you want, or nothing at all. I just find it easier to work with.Now inindex.js, we're importing React, ReactDOM, and the CSS file.src/index.jsimportReactfrom'react'importReactDOMfrom'react-dom'import'./index.css'Let's create ourAppcomponent again. Before, we just had an<h1>, but now I'm adding in a div element with a class as well. You'll notice that we useclassNameinstead ofclass. This is our first hint that the code being written here is JavaScript, and not actually HTML.src/index.jsclassAppextendsReact.Component{render(){return(<divclassName=\"App\"><h1>Hello, React!</h1></div>)}} inally, we'll render theAppto the root as before.src/index.jsReactDOM.render(<App/>,document.getElementById('root'))Here's our fullindex.js. This time, we're loading theComponentas a property of React, so we no longer need to extendReact.Component.src/index.jsimportReact,{Component} rom'react'importReactDOMfrom'react-dom'import'./index.css'classAppextendsComponent{render(){return(<divclassName=\"App\"><h1>Hello, React!</h1></div>)}} eactDOM.render(<App/>,document.getElementById('root'))If you go back tolocalhost:3000, you'll see \"Hello, React!\" just like before. We have the beginnings of a React app now.React Developer ToolsThere is an extension called React Developer Tools that will make your life much easier when working with React. DownloadReact DevTools for Chrome, or whatever browser you prefer to work on.After you install it, when you open DevTools, you'll see a tab for React. Click on it, and you'll be able to inspect components as they're written. You can still go to the Elements tab to see the actual DOM output. It may not seem like that much of a deal now, but as the app gets more complicated, it will become increasingly necessary to use.Now we have all the tools and setup we need to actually begin working with React.JSX: JavaScript + XMLAs you've seen, we've been using what looks like HTML in our React code, but it's not quite HTML. This isJSX, which stands for JavaScript XML.With JSX, we can write what looks like HTML, and also we can create and use our own XML-like tags. Here's what JSX looks like assigned to a variable.JSXconstheading=<h1className=\"site-heading\">Hello, React</h1>Using JSX is not mandatory for writing React. Under the hood, it's runningcreateElement, which takes the tag, object containing the properties, and children of the component and renders the same information. The below code will have the same output as the JSX above.No JSXconstheading=React.createElement('h1',{className:'site-heading'},'Hello, React!')JSX is actually closer to JavaScript, not HTML, so there are a few key differences to note when writing it.classNameis used instead ofclassfor adding CSS classes, asclassis a reserved keyword in JavaScript.Properties and methods in JSX are camelCase -onclickwill becomeonClick.Self-closing tagsmustend in a slash - e.g.<img />JavaScript expressions can also be embedded inside JSX using curly braces, including variables, functions, and properties.constname='Tania'constheading=<h1>Hello,{name}</h1>JSX is easier to write and understand than creating and appending many elements in vanilla JavaScript, and is one of the reasons people love React so much.ComponentsSo far, we've created one component - theAppcomponent. Almost everything in React consists of components, which can beclass componentsorsimple components.Most React apps have many small components, and everything loads into the mainAppcomponent. Components also often get their own file, so let's change up our project to do so.Remove theAppclass fromindex.js, so it looks like this.src/index.jsimportReactfrom'react'importReactDOMfrom'react-dom'importAppfrom'./App'import'./index.css'ReactDOM.render(<App/>,document.getElementById('root'))We'll create a new file calledApp.jsand put the component in there.src/App.jsimportReact,{Component} rom'react'classAppextendsComponent{render(){return(<divclassName=\"App\"><h1>Hello, React!</h1></div>)}} xportdefaultAppWe export the component asAppand load it inindex.js. It's not mandatory to separate components into files, but an application will start to get unwieldy and out-of-hand if you don't.Class ComponentsLet's create another component. We're going to create a table. MakeTable.js, and fill it with the following data.src/Table.jsimportReact,{Component} rom'react'classTableextendsComponent{render(){return(<table><thead><tr><th>Name</th><th>Job</th></tr></thead><tbody><tr><td>Charlie</td><td>Janitor</td></tr><tr><td>Mac</td><td>Bouncer</td></tr><tr><td>Dee</td><td>Aspiring actress</td></tr><tr><td>Dennis</td><td>Bartender</td></tr></tbody></table>)}} xportdefaultTableThis component we created is a custom class component. We capitalize custom components to differentiate them from regular HTML elements. Back inApp.js, we can load in the Table, first by importing it in:src/App.jsimportTablefrom'./Table'Then by loading it into therender()ofApp, where before we had \"Hello, React!\". I also changed the class of the outer container.src/App.jsimportReact,{Component} rom'react'importTablefrom'./Table'classAppextendsComponent{render(){return(<divclassName=\"container\"><Table/></div>)}} xportdefaultAppIf you check back on your live environment, you'll see theTableloaded in.Now we've seen what a custom class component is. We could reuse this component over and over. However, since the data is hard-coded into it, it wouldn't be too useful at the moment.Simple ComponentsThe other type of component in React is thesimple component, which is a function. This component doesn't use theclasskeyword. Let's take ourTableand make two simple components for it - a table header, and a table body.We're going to use ES6 arrow functions to create these simple components. First, the table header.src/Table.jsconstTableHeader=()=>{return(<thead><tr><th>Name</th><th>Job</th></tr></thead>)} hen the body.src/Table.jsconstTableBody=()=>{return(<tbody><tr><td>Charlie</td><td>Janitor</td></tr><tr><td>Mac</td><td>Bouncer</td></tr><tr><td>Dee</td><td>Aspiring actress</td></tr><tr><td>Dennis</td><td>Bartender</td></tr></tbody>)} ow ourTablefile will look like this. Note that theTableHeaderandTableBodycomponents are all in the same file, and being used by theTableclass component.src/Table.jsconstTableHeader=()=>{...} onstTableBody=()=>{...} lassTableextendsComponent{render(){return(<table><TableHeader/><TableBody/></table>)}} verything should appear as it did before. As you can see, components can be nested in other components, and simple and class components can be mixed.A class component must includerender(), and thereturncan only return one parent element.As a wrap up, let's compare a simple component with a class component.Simple ComponentconstSimpleComponent=()=>{return<div>Example</div>} lass ComponentclassClassComponentextendsComponent{render(){return<div>Example</div>}} ote that if thereturnis contained to one line, it does not need parentheses.PropsRight now, we have a coolTablecomponent, but the data is being hard-coded. One of the big deals about React is how it handles data, and it does so with properties, referred to asprops, and with state. Now, we'll focus on handling data with props.First, let's remove all the data from ourTableBodycomponent.src/Table.jsconstTableBody=()=>{return<tbody/>} hen let's move all that data to an array of objects, as if we were bringing in a JSON-based API. We'll have to create this array inside ourrender().src/App.jsclassAppextendsComponent{render(){constcharacters=[{name:'Charlie',job:'Janitor',},{name:'Mac',job:'Bouncer',},{name:'Dee',job:'Aspring actress',},{name:'Dennis',job:'Bartender',},]return(<divclassName=\"container\"><Table/></div>)}} ow, we're going to pass the data through to the child component (Table) with properties, kind of how you might pass data through usingdata-attributes. We can call the property whatever we want, as long as it's not a reserved keyword, so I'll go withcharacterData. The data I'm passing through is thecharactersvariable, and I'll put curly braces around it as it's a JavaScript expression.src/App.jsreturn(<divclassName=\"container\"><TablecharacterData={characters}/></div>)Now that data is being passed through toTable, we have to work on accessing it from the other side.src/Table.jsclassTableextendsComponent{render(){const{characterData}=this.propsreturn(<table><TableHeader/><TableBodycharacterData={characterData}/></table>)}} f you open up React DevTools and inspect theTablecomponent, you'll see the array of data in the property. The data that's stored here is known as thevirtual DOM, which is a fast and efficient way of syncing data with the actual DOM.This data is not in the actual DOM yet, though.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.173,
        "word_count": 995,
        "chunk_id": "834fe475683d762e466312825f47548e",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "information",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "InTable, we can access all props throughthis.props. We're only passing one props through, characterData, so we'll usethis.props.characterDatato retrieve that data.I'm going to use the ES6 property shorthand to create a variable that containsthis.props.characterData.const{characterData}=this.propsSince ourTablecomponent actually consists of two smaller simple components, I'm going to pass it through to theTableBody, once again through props.src/Table.jsclassTableextendsComponent{render(){const{characterData}=this.propsreturn(<table><TableHeader/><TableBodycharacterData={characterData}/></table>)}} ight now,TableBodytakes no parameters and returns a single tag.src/Table.jsconstTableBody=()=>{return<tbody/>} e're going to pass the props through as a parameter, andmap through the arrayto return a table row for each object in the array. This map will be contained in therowsvariable, which we'll return as an expression.src/Table.jsconstTableBody=(props)=>{constrows=props.characterData.map((row,index)=>{return(<trkey={index}><td>{row.name}</td><td>{row.job}</td></tr>)})return<tbody>{rows}</tbody>} f you view the front end of the app, all the data is loading in now.You'll notice I've added a key index to each table row. You should always usekeyswhen making lists in React, as they help identify each list item. We'll also see how this is necessary in a moment when we want to manipulate list items.Props are an effective way to pass existing data to a React component, however the component cannot change the props - they're read-only. In the next section, we'll learn how to use state to have further control over handling data in React.StateRight now, we're storing our character data in an array in a variable, and passing it through as props. This is good to start, but imagine if we want to be able to delete an item from the array. With props, we have a one way data flow, but with state we can update private data from a component.You can think of state as any data that should be saved and modified without necessarily being added to a database - for example, adding and removing items from a shopping cart before confirming your purchase.To start, we're going to create astateobject.src/App.jsclassAppextendsComponent{state={}} he object will contain properties for everything you want to store in the state. For us, it'scharacters.src/App.jsclassAppextendsComponent{state={characters:[],}} ove the entire array of objects we created earlier intostate.characters.src/App.jsclassAppextendsComponent{state={characters:[{name:'Charlie',// the rest of the data},],}} ur data is officially contained in the state. Since we want to be able to remove a character from the table, we're going to create aremoveCharactermethod on the parentAppclass.To retrieve the state, we'll getthis.state.charactersusing the same ES6 method as before. To update the state, we'll usethis.setState(), a built-in method for manipulating state. We'llfilter the arraybased on anindexthat we pass through, and return the new array.You must usethis.setState()to modify an array. Simply applying a new value tothis.state.propertywill not work.src/App.jsremoveCharacter=(index)=>{const{characters}=this.statethis.setState({characters:characters.filter((character,i)=>{returni!==index}),})} ilterdoes not mutate but rather creates a new array, and is a preferred method for modifying arrays in JavaScript. This particular method is testing an index vs. all the indices in the array, and returning all but the one that is passed through.Now we have to pass that function through to the component, and render a button next to each character that can invoke the function. We'll pass theremoveCharacterfunction through as a prop toTable.src/App.jsrender(){const{characters}=this.statereturn(<divclassName=\"container\"><TablecharacterData={characters} emoveCharacter={this.removeCharacter}/></div>)} ince we're passing it down toTableBodyfromTable, we're going to have to pass it through again as a prop, just like we did with the character data.In addition, since it turns out that the only components having their own states in our project areAppandForm, it would be best practice to transformTableinto a simple component from the class component it currently is.src/Table.jsconstTable=(props)=>{const{characterData,removeCharacter}=propsreturn(<table><TableHeader/><TableBodycharacterData={characterData} emoveCharacter={removeCharacter}/></table>)} ere's where that index we defined in theremoveCharacter()method comes in. In theTableBodycomponent, we'll pass the key/index through as a parameter, so the filter function knows which item to remove. We'll create a button with anonClickand pass it through.src/Table.js<trkey={index}><td>{row.name}</td><td>{row.job}</td><td><buttononClick={()=>props.removeCharacter(index)}>Delete</button></td></tr>TheonClickfunction must pass through a function that returns theremoveCharacter()method, otherwise it will try to run automatically.Awesome. Now we have delete buttons, and we can modify our state by deleting a character.I deleted Mac.Now you should understand how state gets initialized and how it can be modified.Submitting Form DataNow we have data stored in state, and we can remove any item from the state. However, what if we wanted to be able to add new data to state? In a real world application, you'd more likely start with empty state and add to it, such as with a to-do list or a shopping cart.Before anything else, let's remove all the hard-coded data fromstate.characters, as we'll be updating that through the form now.src/App.jsclassAppextendsComponent{state={characters:[],}} ow let's go ahead and create aFormcomponent in a new file calledForm.js.We're going to set the initial state of theFormto be an object with some empty properties, and assign that initial state tothis.state.src/Form.jsimportReact,{Component} rom'react'classFormextendsComponent{initialState={name:'',job:'',} tate=this.initialState} reviously, it was necessary to include aconstructor()on React class components, but it's not required anymore.Our goal for this form will be to update the state ofFormevery time a field is changed in the form, and when we submit, all that data will pass to theAppstate, which will then update theTable.First, we'll make the function that will run every time a change is made to an input. Theeventwill be passed through, and we'll set the state ofFormto have thename(key) andvalueof the inputs.src/Form.jshandleChange=(event)=>{const{name,value}=event.targetthis.setState({[name]:value,})} et's get this working before we move on to submitting the form. In the render, let's get our two properties from state, and assign them as the values that correspond to the proper form keys. We'll run thehandleChange()method as theonChangeof the input, and finally we'll export theFormcomponent.src/Form.jsrender(){const{name,job}=this.state;return(<form><labelhtmlFor=\"name\">Name</label><inputtype=\"text\"name=\"name\"id=\"name\"value={name} nChange={this.handleChange}/><labelhtmlFor=\"job\">Job</label><inputtype=\"text\"name=\"job\"id=\"job\"value={job} nChange={this.handleChange}/></form>);} xportdefaultForm;InApp.js, we can render the form below the table.src/App.jsimportFormfrom'./Form'src/App.jsreturn(<divclassName=\"container\"><TablecharacterData={characters} emoveCharacter={this.removeCharacter}/><Form/></div>)Now if we go to the front end of our app, we'll see a form that doesn't have a submit yet. Update some fields and you'll see the local state ofFormbeing updated.Cool. Last step is to allow us to actually submit that data and update the parent state. We'll create a function calledhandleSubmit()onAppthat will update the state by taking the existingthis.state.charactersand adding the newcharacterparameter, using theES6 spread operator.src/App.jshandleSubmit=(character)=>{this.setState({characters:[...this.state.characters,character]})} et's make sure we pass that through as a parameter onForm.<FormhandleSubmit={this.handleSubmit}/>Now inForm, we'll create a method calledsubmitForm()that will call that function, and pass theFormstate through as thecharacterparameter we defined earlier. It will also reset the state to the initial state, to clear the form after submit.src/Form.jssubmitForm=()=>{this.props.handleSubmit(this.state)this.setState(this.initialState)} inally, we'll add a submit button to submit the form.",
        "chunk_type": "code_function",
        "tag": "div",
        "score": 1.173,
        "word_count": 999,
        "chunk_id": "b076d340e9a9754098f24b38e7323649",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "We're using anonClickinstead of anonSubmitsince we're not using the standard submit functionality. The click will call thesubmitFormwe just made.<inputtype=\"button\"value=\"Submit\"onClick={this.submitForm}/>And that's it! The app is complete. We can create, add, and remove users from our table. Since theTableandTableBodywere already pulling from the state, it will display properly.If you got lost anywhere along the way, you can viewthe complete source on GitHub.Pulling in API DataOne very common usage of React is pulling in data from an API. If you're not familiar with what an API is or how to connect to one, I would recommend readingHow to Connect to an API with JavaScript, which will walk you through what APIs are and how to use them with vanilla JavaScript.As a little test, we can create a newApi.jsfile, and create a newAppin there. A public API we can test with is theWikipedia API, and I have aURL endpoint right herefor a random* search. You can go to that link to see the API - and make sure you haveJSONViewinstalled on your browser.We're going to useJavaScript's built-in Fetchto gather the data from that URL endpoint and display it. You can switch between the app we created and this test file by just changing the URL inindex.js-import App from './Api';.I'm not going to explain this code line-by-line, as we've already learned about creating a component, rendering, and mapping through a state array. The new aspect to this code iscomponentDidMount(), a React lifecycle method.Lifecycleis the order in which methods are called in React.Mountingrefers to an item being inserted into the DOM.When we pull in API data, we want to usecomponentDidMount, because we want to make sure the component has rendered to the DOM before we bring in the data. In the below snippet, you'll see how we bring in data from the Wikipedia API, and display it on the pageApi.jsimportReact,{Component} rom'react'classAppextendsComponent{state={data:[],}// Code is invoked after the component is mounted/inserted into the DOM tree.componentDidMount(){consturl='https://en.wikipedia.org/w/api.php?action=opensearch&search=Seona+Dancing&format=json&origin=*'fetch(url).then((result)=>result.json()).then((result)=>{this.setState({data:result,})})} ender(){const{data}=this.stateconstresult=data.map((entry,index)=>{return<likey={index}>{entry}</li>})return<ul>{result}</ul>}} xportdefaultAppOnce you save and run this file in the local server, you'll see the Wikipedia API data displayed in the DOM.There are other lifecycle methods, but going over them will be beyond the scope of this article. You canread more about React components here.*Wikipedia search choice may not be random. It might be an article that I spearheaded back in 2005.Building and Deploying a React AppEverything we've done so far has been in a development environment. We've been compiling, hot-reloading, and updating on the fly. For production, we're going to want to have static files loading in - none of the source code. We can do this by making a build and deploying it.Now, if you just want to compile all the React code and place it in the root of a directory somewhere, all you need to do is run the following line:npmrun buildThis will create abuildfolder which will contain your app. Put the contents of that folder anywhere, and you're done!We can also take it a step further, and have npm deploy for us. We're going to build to GitHub pages, so you'll already have tobe familiar with Gitand getting your code up on GitHub.Make sure you've exited out of your local React environment, so the code isn't currently running. First, we're going to add ahomepagefield topackage.json, that has the URL we want our app to live on.package.json\"homepage\":\"https://taniarascia.github.io/react-tutorial\",We'll also add these two lines to thescriptsproperty.\"scripts\":{// ...\"predeploy\":\"npm run build\",\"deploy\":\"gh-pages -d build\"} n your project, you'll addgh-pagesto the devDependencies.npminstall--save-dev gh-pagesWe'll create thebuild, which will have all the compiled, static files.npmrun buildFinally, we'll deploy togh-pages.npmrun deployAnd we're done! The app is now available live athttps://taniarascia.github.io/react-tutorial.ConclusionThis article should have given you a good introduction to React, simple and class components, state, props, working with form data, pulling data in from an API, and deploying an app. There is much more to learn and do with React, but I hope you feel confident delving in and playing around with React yourself now.View Source on GitHubView ProjectPlease let me know if anything was unclear, or if there's anything else you'd like to see in this or a subsequent article.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:August 20, 2018Category:TechnicalTagsapijavascriptreacttutorialframeworksNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.173,
        "word_count": 726,
        "chunk_id": "5f0b4f4d59fc368d25fc156739b30807",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "development",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "How to Use React, the JavaScript FrameworkI've been hearing about React since I first started learning JavaScript, but I'll admit I took one look at it and it scared me. I saw what looked like a bunch of HTML mixed with JavaScript and thought,isn't this what we've been trying to avoid? What's the big deal with React?Instead, I focused on just learning vanilla JavaScript and working with jQuery in a professional setting. After a few frustrated, failed attempts to get started with React, I finally started to get it, and I began to see why I might want to use React instead of vanilla JS or jQuery.I tried to condense everything I've learned into a nice introduction to share with you, so here it is.PrerequisitesThere are a few things you should know in advance before you start playing around with React. If you've never used JavaScript or the DOM at all before, for example, I would get more familiar with those before trying to tackle React.Here are what I consider to be React prerequisites.Basic familiarity withHTML & CSS.Basic knowledge ofJavaScriptand programming.Basic understanding ofthe DOM.Familiarity withES6 syntax and features.Node.js and npminstalled globally.GoalsLearn about essential React concepts and related terms, such as Babel, Webpack, JSX, components, props, state, and lifecycle.Build a very simple React app that demonstrates the above concepts.Here's the source and a live demo of the end result.View Source on GitHubView DemoWhat is React?React is a JavaScript library - one of the most popular ones, withover 100,000 stars on GitHub.React is not a framework (unlike Angular, which is more opinionated).React is an open-source project created by Facebook.React is used to build user interfaces (UI) on the front end.React is theviewlayer of an MVC application (Model View Controller)One of the most important aspects of React is the fact that you can createcomponents, which are like custom, reusable HTML elements, to quickly and efficiently build user interfaces. React also streamlines how data is stored and handled, usingstateandprops.We'll go over all of this and more throughout the article, so let's get started.Setup and InstallationThere are a few ways to set up React, and I'll show you two so you get a good idea of how it works.Static HTML FileThis first method is not a popular way to set up React and is not how we'll be doing the rest of our tutorial, but it will be familiar and easy to understand if you've ever used a library like jQuery, and it's the least scary way to get started if you're not familiar with Webpack, Babel, and Node.js.Let's start by making a basicindex.htmlfile. We're going to load in three CDNs in thehead- React, React DOM, and Babel. We're also going to make adivwith an id calledroot, and finally we'll create ascripttag where your custom code will live.index.html<!DOCTYPEhtml><html><head><metacharset=\"utf-8\"/><title>Hello React!</title><scriptsrc=\"https://unpkg.com/react@^16/umd/react.production.min.js\"></script><scriptsrc=\"https://unpkg.com/react-dom@16.13.0/umd/react-dom.production.min.js\"></script><scriptsrc=\"https://unpkg.com/babel-standalone@6.26.0/babel.js\"></script></head><body><divid=\"root\"></div><scripttype=\"text/babel\">// React code will go here</script></body></html>I'm loading in the latest stable versions of the libraries as of the time of this writing.React- the React top level APIReact DOM- adds DOM-specific methodsBabel- a JavaScript compiler that lets us use ES6+ in old browsersThe entry point for our app will be therootdiv element, which is named by convention. You'll also notice thetext/babelscript type, which is mandatory for using Babel.Now, let's write our first code block of React. We're going to use ES6 classes to create a React component calledApp.index.htmlclassAppextendsReact.Component{//...} ow we'll add therender()method, the only required method in a class component, which is used to render DOM nodes.index.htmlclassAppextendsReact.Component{render(){return(//...);}} nside thereturn, we're going to put what looks like a simple HTML element. Note that we're not returning a string here, so don't use quotes around the element. This is calledJSX, and we'll learn more about it soon.index.htmlclassAppextendsReact.Component{render(){return<h1>Hello world!</h1>}} inally, we're going to use the React DOMrender()method to render theAppclass we created into therootdiv in our HTML.index.htmlReactDOM.render(<App/>,document.getElementById('root'))Here is the full code for ourindex.html.index.html<!DOCTYPEhtml><html><head><metacharset=\"utf-8\"/><title>Hello React!</title><scriptsrc=\"https://unpkg.com/react@16/umd/react.development.js\"></script><scriptsrc=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"></script><scriptsrc=\"https://unpkg.com/babel-standalone@6.26.0/babel.js\"></script></head><body><divid=\"root\"></div><scripttype=\"text/babel\">classAppextendsReact.Component{render(){return<h1>Hello world!</h1>}} eactDOM.render(<App/>,document.getElementById('root'))</script></body></html>Now if you view yourindex.htmlin the browser, you'll see theh1tag we created rendered to the DOM.Cool! Now that you've done this, you can see that React isn't so insanely scary to get started with. It's just some JavaScript helper libraries that we can load into our HTML.We've done this for demonstration purposes, but from here out we're going to use another method: Create React App.Create React AppThe method I just used of loading JavaScript libraries into a static HTML page and rendering the React and Babel on the fly is not very efficient, and is hard to maintain.Fortunately, Facebook has createdCreate React App, an environment that comes pre-configured with everything you need to build a React app. It will create a live development server, use Webpack to automatically compile React, JSX, and ES6, auto-prefix CSS files, and use ESLint to test and warn about mistakes in the code.To set upcreate-react-app, run the following code in your terminal, one directory up from where you want the project to live.npx create-react-app react-tutorialOnce that finishes installing, move to the newly created directory and start the project.cdreact-tutorial&&npmstartOnce you run this command, a new window will popup atlocalhost:3000with your new React app.Create React App is very good for getting started for beginners as well as large-scale enterprise applications, but it's not perfect for every workflow. You can also create your own Webpack setup for React.If you look into the project structure, you'll see a/publicand/srcdirectory, along with the regularnode_modules,.gitignore,README.md, andpackage.json.In/public, our important file isindex.html, which is very similar to the staticindex.htmlfile we made earlier - just arootdiv. This time, no libraries or scripts are being loaded in. The/srcdirectory will contain all our React code.To see how the environment automatically compiles and updates your React code, find the line that looks like this in/src/App.js:To get started, edit `src/App.js` and save to reload.And replace it with any other text. Once you save the file, you'll noticelocalhost:3000compiles and refreshes with the new data.Go ahead and delete all the files out of the/srcdirectory, and we'll create our own boilerplate file without any bloat. We'll just keepindex.cssandindex.js.Forindex.css, I just copy-and-pasted the contents ofPrimitive CSSinto the file.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.173,
        "word_count": 989,
        "chunk_id": "66de2eaca3681f24236ea2395325d5f5",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "development",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "If you want, you can use Bootstrap or whatever CSS framework you want, or nothing at all. I just find it easier to work with.Now inindex.js, we're importing React, ReactDOM, and the CSS file.src/index.jsimportReactfrom'react'importReactDOMfrom'react-dom'import'./index.css'Let's create ourAppcomponent again. Before, we just had an<h1>, but now I'm adding in a div element with a class as well. You'll notice that we useclassNameinstead ofclass. This is our first hint that the code being written here is JavaScript, and not actually HTML.src/index.jsclassAppextendsReact.Component{render(){return(<divclassName=\"App\"><h1>Hello, React!</h1></div>)}} inally, we'll render theAppto the root as before.src/index.jsReactDOM.render(<App/>,document.getElementById('root'))Here's our fullindex.js. This time, we're loading theComponentas a property of React, so we no longer need to extendReact.Component.src/index.jsimportReact,{Component} rom'react'importReactDOMfrom'react-dom'import'./index.css'classAppextendsComponent{render(){return(<divclassName=\"App\"><h1>Hello, React!</h1></div>)}} eactDOM.render(<App/>,document.getElementById('root'))If you go back tolocalhost:3000, you'll see \"Hello, React!\" just like before. We have the beginnings of a React app now.React Developer ToolsThere is an extension called React Developer Tools that will make your life much easier when working with React. DownloadReact DevTools for Chrome, or whatever browser you prefer to work on.After you install it, when you open DevTools, you'll see a tab for React. Click on it, and you'll be able to inspect components as they're written. You can still go to the Elements tab to see the actual DOM output. It may not seem like that much of a deal now, but as the app gets more complicated, it will become increasingly necessary to use.Now we have all the tools and setup we need to actually begin working with React.JSX: JavaScript + XMLAs you've seen, we've been using what looks like HTML in our React code, but it's not quite HTML. This isJSX, which stands for JavaScript XML.With JSX, we can write what looks like HTML, and also we can create and use our own XML-like tags. Here's what JSX looks like assigned to a variable.JSXconstheading=<h1className=\"site-heading\">Hello, React</h1>Using JSX is not mandatory for writing React. Under the hood, it's runningcreateElement, which takes the tag, object containing the properties, and children of the component and renders the same information. The below code will have the same output as the JSX above.No JSXconstheading=React.createElement('h1',{className:'site-heading'},'Hello, React!')JSX is actually closer to JavaScript, not HTML, so there are a few key differences to note when writing it.classNameis used instead ofclassfor adding CSS classes, asclassis a reserved keyword in JavaScript.Properties and methods in JSX are camelCase -onclickwill becomeonClick.Self-closing tagsmustend in a slash - e.g.<img />JavaScript expressions can also be embedded inside JSX using curly braces, including variables, functions, and properties.constname='Tania'constheading=<h1>Hello,{name}</h1>JSX is easier to write and understand than creating and appending many elements in vanilla JavaScript, and is one of the reasons people love React so much.ComponentsSo far, we've created one component - theAppcomponent. Almost everything in React consists of components, which can beclass componentsorsimple components.Most React apps have many small components, and everything loads into the mainAppcomponent. Components also often get their own file, so let's change up our project to do so.Remove theAppclass fromindex.js, so it looks like this.src/index.jsimportReactfrom'react'importReactDOMfrom'react-dom'importAppfrom'./App'import'./index.css'ReactDOM.render(<App/>,document.getElementById('root'))We'll create a new file calledApp.jsand put the component in there.src/App.jsimportReact,{Component} rom'react'classAppextendsComponent{render(){return(<divclassName=\"App\"><h1>Hello, React!</h1></div>)}} xportdefaultAppWe export the component asAppand load it inindex.js. It's not mandatory to separate components into files, but an application will start to get unwieldy and out-of-hand if you don't.Class ComponentsLet's create another component. We're going to create a table. MakeTable.js, and fill it with the following data.src/Table.jsimportReact,{Component} rom'react'classTableextendsComponent{render(){return(<table><thead><tr><th>Name</th><th>Job</th></tr></thead><tbody><tr><td>Charlie</td><td>Janitor</td></tr><tr><td>Mac</td><td>Bouncer</td></tr><tr><td>Dee</td><td>Aspiring actress</td></tr><tr><td>Dennis</td><td>Bartender</td></tr></tbody></table>)}} xportdefaultTableThis component we created is a custom class component. We capitalize custom components to differentiate them from regular HTML elements. Back inApp.js, we can load in the Table, first by importing it in:src/App.jsimportTablefrom'./Table'Then by loading it into therender()ofApp, where before we had \"Hello, React!\". I also changed the class of the outer container.src/App.jsimportReact,{Component} rom'react'importTablefrom'./Table'classAppextendsComponent{render(){return(<divclassName=\"container\"><Table/></div>)}} xportdefaultAppIf you check back on your live environment, you'll see theTableloaded in.Now we've seen what a custom class component is. We could reuse this component over and over. However, since the data is hard-coded into it, it wouldn't be too useful at the moment.Simple ComponentsThe other type of component in React is thesimple component, which is a function. This component doesn't use theclasskeyword. Let's take ourTableand make two simple components for it - a table header, and a table body.We're going to use ES6 arrow functions to create these simple components. First, the table header.src/Table.jsconstTableHeader=()=>{return(<thead><tr><th>Name</th><th>Job</th></tr></thead>)} hen the body.src/Table.jsconstTableBody=()=>{return(<tbody><tr><td>Charlie</td><td>Janitor</td></tr><tr><td>Mac</td><td>Bouncer</td></tr><tr><td>Dee</td><td>Aspiring actress</td></tr><tr><td>Dennis</td><td>Bartender</td></tr></tbody>)} ow ourTablefile will look like this. Note that theTableHeaderandTableBodycomponents are all in the same file, and being used by theTableclass component.src/Table.jsconstTableHeader=()=>{...} onstTableBody=()=>{...} lassTableextendsComponent{render(){return(<table><TableHeader/><TableBody/></table>)}} verything should appear as it did before. As you can see, components can be nested in other components, and simple and class components can be mixed.A class component must includerender(), and thereturncan only return one parent element.As a wrap up, let's compare a simple component with a class component.Simple ComponentconstSimpleComponent=()=>{return<div>Example</div>} lass ComponentclassClassComponentextendsComponent{render(){return<div>Example</div>}} ote that if thereturnis contained to one line, it does not need parentheses.PropsRight now, we have a coolTablecomponent, but the data is being hard-coded. One of the big deals about React is how it handles data, and it does so with properties, referred to asprops, and with state. Now, we'll focus on handling data with props.First, let's remove all the data from ourTableBodycomponent.src/Table.jsconstTableBody=()=>{return<tbody/>} hen let's move all that data to an array of objects, as if we were bringing in a JSON-based API. We'll have to create this array inside ourrender().src/App.jsclassAppextendsComponent{render(){constcharacters=[{name:'Charlie',job:'Janitor',},{name:'Mac',job:'Bouncer',},{name:'Dee',job:'Aspring actress',},{name:'Dennis',job:'Bartender',},]return(<divclassName=\"container\"><Table/></div>)}} ow, we're going to pass the data through to the child component (Table) with properties, kind of how you might pass data through usingdata-attributes. We can call the property whatever we want, as long as it's not a reserved keyword, so I'll go withcharacterData. The data I'm passing through is thecharactersvariable, and I'll put curly braces around it as it's a JavaScript expression.src/App.jsreturn(<divclassName=\"container\"><TablecharacterData={characters}/></div>)Now that data is being passed through toTable, we have to work on accessing it from the other side.src/Table.jsclassTableextendsComponent{render(){const{characterData}=this.propsreturn(<table><TableHeader/><TableBodycharacterData={characterData}/></table>)}} f you open up React DevTools and inspect theTablecomponent, you'll see the array of data in the property. The data that's stored here is known as thevirtual DOM, which is a fast and efficient way of syncing data with the actual DOM.This data is not in the actual DOM yet, though.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.173,
        "word_count": 995,
        "chunk_id": "834fe475683d762e466312825f47548e",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "information",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "InTable, we can access all props throughthis.props. We're only passing one props through, characterData, so we'll usethis.props.characterDatato retrieve that data.I'm going to use the ES6 property shorthand to create a variable that containsthis.props.characterData.const{characterData}=this.propsSince ourTablecomponent actually consists of two smaller simple components, I'm going to pass it through to theTableBody, once again through props.src/Table.jsclassTableextendsComponent{render(){const{characterData}=this.propsreturn(<table><TableHeader/><TableBodycharacterData={characterData}/></table>)}} ight now,TableBodytakes no parameters and returns a single tag.src/Table.jsconstTableBody=()=>{return<tbody/>} e're going to pass the props through as a parameter, andmap through the arrayto return a table row for each object in the array. This map will be contained in therowsvariable, which we'll return as an expression.src/Table.jsconstTableBody=(props)=>{constrows=props.characterData.map((row,index)=>{return(<trkey={index}><td>{row.name}</td><td>{row.job}</td></tr>)})return<tbody>{rows}</tbody>} f you view the front end of the app, all the data is loading in now.You'll notice I've added a key index to each table row. You should always usekeyswhen making lists in React, as they help identify each list item. We'll also see how this is necessary in a moment when we want to manipulate list items.Props are an effective way to pass existing data to a React component, however the component cannot change the props - they're read-only. In the next section, we'll learn how to use state to have further control over handling data in React.StateRight now, we're storing our character data in an array in a variable, and passing it through as props. This is good to start, but imagine if we want to be able to delete an item from the array. With props, we have a one way data flow, but with state we can update private data from a component.You can think of state as any data that should be saved and modified without necessarily being added to a database - for example, adding and removing items from a shopping cart before confirming your purchase.To start, we're going to create astateobject.src/App.jsclassAppextendsComponent{state={}} he object will contain properties for everything you want to store in the state. For us, it'scharacters.src/App.jsclassAppextendsComponent{state={characters:[],}} ove the entire array of objects we created earlier intostate.characters.src/App.jsclassAppextendsComponent{state={characters:[{name:'Charlie',// the rest of the data},],}} ur data is officially contained in the state. Since we want to be able to remove a character from the table, we're going to create aremoveCharactermethod on the parentAppclass.To retrieve the state, we'll getthis.state.charactersusing the same ES6 method as before. To update the state, we'll usethis.setState(), a built-in method for manipulating state. We'llfilter the arraybased on anindexthat we pass through, and return the new array.You must usethis.setState()to modify an array. Simply applying a new value tothis.state.propertywill not work.src/App.jsremoveCharacter=(index)=>{const{characters}=this.statethis.setState({characters:characters.filter((character,i)=>{returni!==index}),})} ilterdoes not mutate but rather creates a new array, and is a preferred method for modifying arrays in JavaScript. This particular method is testing an index vs. all the indices in the array, and returning all but the one that is passed through.Now we have to pass that function through to the component, and render a button next to each character that can invoke the function. We'll pass theremoveCharacterfunction through as a prop toTable.src/App.jsrender(){const{characters}=this.statereturn(<divclassName=\"container\"><TablecharacterData={characters} emoveCharacter={this.removeCharacter}/></div>)} ince we're passing it down toTableBodyfromTable, we're going to have to pass it through again as a prop, just like we did with the character data.In addition, since it turns out that the only components having their own states in our project areAppandForm, it would be best practice to transformTableinto a simple component from the class component it currently is.src/Table.jsconstTable=(props)=>{const{characterData,removeCharacter}=propsreturn(<table><TableHeader/><TableBodycharacterData={characterData} emoveCharacter={removeCharacter}/></table>)} ere's where that index we defined in theremoveCharacter()method comes in. In theTableBodycomponent, we'll pass the key/index through as a parameter, so the filter function knows which item to remove. We'll create a button with anonClickand pass it through.src/Table.js<trkey={index}><td>{row.name}</td><td>{row.job}</td><td><buttononClick={()=>props.removeCharacter(index)}>Delete</button></td></tr>TheonClickfunction must pass through a function that returns theremoveCharacter()method, otherwise it will try to run automatically.Awesome. Now we have delete buttons, and we can modify our state by deleting a character.I deleted Mac.Now you should understand how state gets initialized and how it can be modified.Submitting Form DataNow we have data stored in state, and we can remove any item from the state. However, what if we wanted to be able to add new data to state? In a real world application, you'd more likely start with empty state and add to it, such as with a to-do list or a shopping cart.Before anything else, let's remove all the hard-coded data fromstate.characters, as we'll be updating that through the form now.src/App.jsclassAppextendsComponent{state={characters:[],}} ow let's go ahead and create aFormcomponent in a new file calledForm.js.We're going to set the initial state of theFormto be an object with some empty properties, and assign that initial state tothis.state.src/Form.jsimportReact,{Component} rom'react'classFormextendsComponent{initialState={name:'',job:'',} tate=this.initialState} reviously, it was necessary to include aconstructor()on React class components, but it's not required anymore.Our goal for this form will be to update the state ofFormevery time a field is changed in the form, and when we submit, all that data will pass to theAppstate, which will then update theTable.First, we'll make the function that will run every time a change is made to an input. Theeventwill be passed through, and we'll set the state ofFormto have thename(key) andvalueof the inputs.src/Form.jshandleChange=(event)=>{const{name,value}=event.targetthis.setState({[name]:value,})} et's get this working before we move on to submitting the form. In the render, let's get our two properties from state, and assign them as the values that correspond to the proper form keys. We'll run thehandleChange()method as theonChangeof the input, and finally we'll export theFormcomponent.src/Form.jsrender(){const{name,job}=this.state;return(<form><labelhtmlFor=\"name\">Name</label><inputtype=\"text\"name=\"name\"id=\"name\"value={name} nChange={this.handleChange}/><labelhtmlFor=\"job\">Job</label><inputtype=\"text\"name=\"job\"id=\"job\"value={job} nChange={this.handleChange}/></form>);} xportdefaultForm;InApp.js, we can render the form below the table.src/App.jsimportFormfrom'./Form'src/App.jsreturn(<divclassName=\"container\"><TablecharacterData={characters} emoveCharacter={this.removeCharacter}/><Form/></div>)Now if we go to the front end of our app, we'll see a form that doesn't have a submit yet. Update some fields and you'll see the local state ofFormbeing updated.Cool. Last step is to allow us to actually submit that data and update the parent state. We'll create a function calledhandleSubmit()onAppthat will update the state by taking the existingthis.state.charactersand adding the newcharacterparameter, using theES6 spread operator.src/App.jshandleSubmit=(character)=>{this.setState({characters:[...this.state.characters,character]})} et's make sure we pass that through as a parameter onForm.<FormhandleSubmit={this.handleSubmit}/>Now inForm, we'll create a method calledsubmitForm()that will call that function, and pass theFormstate through as thecharacterparameter we defined earlier. It will also reset the state to the initial state, to clear the form after submit.src/Form.jssubmitForm=()=>{this.props.handleSubmit(this.state)this.setState(this.initialState)} inally, we'll add a submit button to submit the form.",
        "chunk_type": "code_function",
        "tag": "div",
        "score": 1.173,
        "word_count": 999,
        "chunk_id": "b076d340e9a9754098f24b38e7323649",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "We're using anonClickinstead of anonSubmitsince we're not using the standard submit functionality. The click will call thesubmitFormwe just made.<inputtype=\"button\"value=\"Submit\"onClick={this.submitForm}/>And that's it! The app is complete. We can create, add, and remove users from our table. Since theTableandTableBodywere already pulling from the state, it will display properly.If you got lost anywhere along the way, you can viewthe complete source on GitHub.Pulling in API DataOne very common usage of React is pulling in data from an API. If you're not familiar with what an API is or how to connect to one, I would recommend readingHow to Connect to an API with JavaScript, which will walk you through what APIs are and how to use them with vanilla JavaScript.As a little test, we can create a newApi.jsfile, and create a newAppin there. A public API we can test with is theWikipedia API, and I have aURL endpoint right herefor a random* search. You can go to that link to see the API - and make sure you haveJSONViewinstalled on your browser.We're going to useJavaScript's built-in Fetchto gather the data from that URL endpoint and display it. You can switch between the app we created and this test file by just changing the URL inindex.js-import App from './Api';.I'm not going to explain this code line-by-line, as we've already learned about creating a component, rendering, and mapping through a state array. The new aspect to this code iscomponentDidMount(), a React lifecycle method.Lifecycleis the order in which methods are called in React.Mountingrefers to an item being inserted into the DOM.When we pull in API data, we want to usecomponentDidMount, because we want to make sure the component has rendered to the DOM before we bring in the data. In the below snippet, you'll see how we bring in data from the Wikipedia API, and display it on the pageApi.jsimportReact,{Component} rom'react'classAppextendsComponent{state={data:[],}// Code is invoked after the component is mounted/inserted into the DOM tree.componentDidMount(){consturl='https://en.wikipedia.org/w/api.php?action=opensearch&search=Seona+Dancing&format=json&origin=*'fetch(url).then((result)=>result.json()).then((result)=>{this.setState({data:result,})})} ender(){const{data}=this.stateconstresult=data.map((entry,index)=>{return<likey={index}>{entry}</li>})return<ul>{result}</ul>}} xportdefaultAppOnce you save and run this file in the local server, you'll see the Wikipedia API data displayed in the DOM.There are other lifecycle methods, but going over them will be beyond the scope of this article. You canread more about React components here.*Wikipedia search choice may not be random. It might be an article that I spearheaded back in 2005.Building and Deploying a React AppEverything we've done so far has been in a development environment. We've been compiling, hot-reloading, and updating on the fly. For production, we're going to want to have static files loading in - none of the source code. We can do this by making a build and deploying it.Now, if you just want to compile all the React code and place it in the root of a directory somewhere, all you need to do is run the following line:npmrun buildThis will create abuildfolder which will contain your app. Put the contents of that folder anywhere, and you're done!We can also take it a step further, and have npm deploy for us. We're going to build to GitHub pages, so you'll already have tobe familiar with Gitand getting your code up on GitHub.Make sure you've exited out of your local React environment, so the code isn't currently running. First, we're going to add ahomepagefield topackage.json, that has the URL we want our app to live on.package.json\"homepage\":\"https://taniarascia.github.io/react-tutorial\",We'll also add these two lines to thescriptsproperty.\"scripts\":{// ...\"predeploy\":\"npm run build\",\"deploy\":\"gh-pages -d build\"} n your project, you'll addgh-pagesto the devDependencies.npminstall--save-dev gh-pagesWe'll create thebuild, which will have all the compiled, static files.npmrun buildFinally, we'll deploy togh-pages.npmrun deployAnd we're done! The app is now available live athttps://taniarascia.github.io/react-tutorial.ConclusionThis article should have given you a good introduction to React, simple and class components, state, props, working with form data, pulling data in from an API, and deploying an app. There is much more to learn and do with React, but I hope you feel confident delving in and playing around with React yourself now.View Source on GitHubView ProjectPlease let me know if anything was unclear, or if there's anything else you'd like to see in this or a subsequent article.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:August 20, 2018Category:TechnicalTagsapijavascriptreacttutorialframeworksNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.173,
        "word_count": 726,
        "chunk_id": "5f0b4f4d59fc368d25fc156739b30807",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "development",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "How to Use React, the JavaScript FrameworkI've been hearing about React since I first started learning JavaScript, but I'll admit I took one look at it and it scared me. I saw what looked like a bunch of HTML mixed with JavaScript and thought,isn't this what we've been trying to avoid? What's the big deal with React?Instead, I focused on just learning vanilla JavaScript and working with jQuery in a professional setting. After a few frustrated, failed attempts to get started with React, I finally started to get it, and I began to see why I might want to use React instead of vanilla JS or jQuery.I tried to condense everything I've learned into a nice introduction to share with you, so here it is.PrerequisitesThere are a few things you should know in advance before you start playing around with React. If you've never used JavaScript or the DOM at all before, for example, I would get more familiar with those before trying to tackle React.Here are what I consider to be React prerequisites.Basic familiarity withHTML & CSS.Basic knowledge ofJavaScriptand programming.Basic understanding ofthe DOM.Familiarity withES6 syntax and features.Node.js and npminstalled globally.GoalsLearn about essential React concepts and related terms, such as Babel, Webpack, JSX, components, props, state, and lifecycle.Build a very simple React app that demonstrates the above concepts.Here's the source and a live demo of the end result.View Source on GitHubView DemoWhat is React?React is a JavaScript library - one of the most popular ones, withover 100,000 stars on GitHub.React is not a framework (unlike Angular, which is more opinionated).React is an open-source project created by Facebook.React is used to build user interfaces (UI) on the front end.React is theviewlayer of an MVC application (Model View Controller)One of the most important aspects of React is the fact that you can createcomponents, which are like custom, reusable HTML elements, to quickly and efficiently build user interfaces. React also streamlines how data is stored and handled, usingstateandprops.We'll go over all of this and more throughout the article, so let's get started.Setup and InstallationThere are a few ways to set up React, and I'll show you two so you get a good idea of how it works.Static HTML FileThis first method is not a popular way to set up React and is not how we'll be doing the rest of our tutorial, but it will be familiar and easy to understand if you've ever used a library like jQuery, and it's the least scary way to get started if you're not familiar with Webpack, Babel, and Node.js.Let's start by making a basicindex.htmlfile. We're going to load in three CDNs in thehead- React, React DOM, and Babel. We're also going to make adivwith an id calledroot, and finally we'll create ascripttag where your custom code will live.index.html<!DOCTYPEhtml><html><head><metacharset=\"utf-8\"/><title>Hello React!</title><scriptsrc=\"https://unpkg.com/react@^16/umd/react.production.min.js\"></script><scriptsrc=\"https://unpkg.com/react-dom@16.13.0/umd/react-dom.production.min.js\"></script><scriptsrc=\"https://unpkg.com/babel-standalone@6.26.0/babel.js\"></script></head><body><divid=\"root\"></div><scripttype=\"text/babel\">// React code will go here</script></body></html>I'm loading in the latest stable versions of the libraries as of the time of this writing.React- the React top level APIReact DOM- adds DOM-specific methodsBabel- a JavaScript compiler that lets us use ES6+ in old browsersThe entry point for our app will be therootdiv element, which is named by convention. You'll also notice thetext/babelscript type, which is mandatory for using Babel.Now, let's write our first code block of React. We're going to use ES6 classes to create a React component calledApp.index.htmlclassAppextendsReact.Component{//...} ow we'll add therender()method, the only required method in a class component, which is used to render DOM nodes.index.htmlclassAppextendsReact.Component{render(){return(//...);}} nside thereturn, we're going to put what looks like a simple HTML element. Note that we're not returning a string here, so don't use quotes around the element. This is calledJSX, and we'll learn more about it soon.index.htmlclassAppextendsReact.Component{render(){return<h1>Hello world!</h1>}} inally, we're going to use the React DOMrender()method to render theAppclass we created into therootdiv in our HTML.index.htmlReactDOM.render(<App/>,document.getElementById('root'))Here is the full code for ourindex.html.index.html<!DOCTYPEhtml><html><head><metacharset=\"utf-8\"/><title>Hello React!</title><scriptsrc=\"https://unpkg.com/react@16/umd/react.development.js\"></script><scriptsrc=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"></script><scriptsrc=\"https://unpkg.com/babel-standalone@6.26.0/babel.js\"></script></head><body><divid=\"root\"></div><scripttype=\"text/babel\">classAppextendsReact.Component{render(){return<h1>Hello world!</h1>}} eactDOM.render(<App/>,document.getElementById('root'))</script></body></html>Now if you view yourindex.htmlin the browser, you'll see theh1tag we created rendered to the DOM.Cool! Now that you've done this, you can see that React isn't so insanely scary to get started with. It's just some JavaScript helper libraries that we can load into our HTML.We've done this for demonstration purposes, but from here out we're going to use another method: Create React App.Create React AppThe method I just used of loading JavaScript libraries into a static HTML page and rendering the React and Babel on the fly is not very efficient, and is hard to maintain.Fortunately, Facebook has createdCreate React App, an environment that comes pre-configured with everything you need to build a React app. It will create a live development server, use Webpack to automatically compile React, JSX, and ES6, auto-prefix CSS files, and use ESLint to test and warn about mistakes in the code.To set upcreate-react-app, run the following code in your terminal, one directory up from where you want the project to live.npx create-react-app react-tutorialOnce that finishes installing, move to the newly created directory and start the project.cdreact-tutorial&&npmstartOnce you run this command, a new window will popup atlocalhost:3000with your new React app.Create React App is very good for getting started for beginners as well as large-scale enterprise applications, but it's not perfect for every workflow. You can also create your own Webpack setup for React.If you look into the project structure, you'll see a/publicand/srcdirectory, along with the regularnode_modules,.gitignore,README.md, andpackage.json.In/public, our important file isindex.html, which is very similar to the staticindex.htmlfile we made earlier - just arootdiv. This time, no libraries or scripts are being loaded in. The/srcdirectory will contain all our React code.To see how the environment automatically compiles and updates your React code, find the line that looks like this in/src/App.js:To get started, edit `src/App.js` and save to reload.And replace it with any other text. Once you save the file, you'll noticelocalhost:3000compiles and refreshes with the new data.Go ahead and delete all the files out of the/srcdirectory, and we'll create our own boilerplate file without any bloat. We'll just keepindex.cssandindex.js.Forindex.css, I just copy-and-pasted the contents ofPrimitive CSSinto the file.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.173,
        "word_count": 989,
        "chunk_id": "66de2eaca3681f24236ea2395325d5f5",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "development",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "If you want, you can use Bootstrap or whatever CSS framework you want, or nothing at all. I just find it easier to work with.Now inindex.js, we're importing React, ReactDOM, and the CSS file.src/index.jsimportReactfrom'react'importReactDOMfrom'react-dom'import'./index.css'Let's create ourAppcomponent again. Before, we just had an<h1>, but now I'm adding in a div element with a class as well. You'll notice that we useclassNameinstead ofclass. This is our first hint that the code being written here is JavaScript, and not actually HTML.src/index.jsclassAppextendsReact.Component{render(){return(<divclassName=\"App\"><h1>Hello, React!</h1></div>)}} inally, we'll render theAppto the root as before.src/index.jsReactDOM.render(<App/>,document.getElementById('root'))Here's our fullindex.js. This time, we're loading theComponentas a property of React, so we no longer need to extendReact.Component.src/index.jsimportReact,{Component} rom'react'importReactDOMfrom'react-dom'import'./index.css'classAppextendsComponent{render(){return(<divclassName=\"App\"><h1>Hello, React!</h1></div>)}} eactDOM.render(<App/>,document.getElementById('root'))If you go back tolocalhost:3000, you'll see \"Hello, React!\" just like before. We have the beginnings of a React app now.React Developer ToolsThere is an extension called React Developer Tools that will make your life much easier when working with React. DownloadReact DevTools for Chrome, or whatever browser you prefer to work on.After you install it, when you open DevTools, you'll see a tab for React. Click on it, and you'll be able to inspect components as they're written. You can still go to the Elements tab to see the actual DOM output. It may not seem like that much of a deal now, but as the app gets more complicated, it will become increasingly necessary to use.Now we have all the tools and setup we need to actually begin working with React.JSX: JavaScript + XMLAs you've seen, we've been using what looks like HTML in our React code, but it's not quite HTML. This isJSX, which stands for JavaScript XML.With JSX, we can write what looks like HTML, and also we can create and use our own XML-like tags. Here's what JSX looks like assigned to a variable.JSXconstheading=<h1className=\"site-heading\">Hello, React</h1>Using JSX is not mandatory for writing React. Under the hood, it's runningcreateElement, which takes the tag, object containing the properties, and children of the component and renders the same information. The below code will have the same output as the JSX above.No JSXconstheading=React.createElement('h1',{className:'site-heading'},'Hello, React!')JSX is actually closer to JavaScript, not HTML, so there are a few key differences to note when writing it.classNameis used instead ofclassfor adding CSS classes, asclassis a reserved keyword in JavaScript.Properties and methods in JSX are camelCase -onclickwill becomeonClick.Self-closing tagsmustend in a slash - e.g.<img />JavaScript expressions can also be embedded inside JSX using curly braces, including variables, functions, and properties.constname='Tania'constheading=<h1>Hello,{name}</h1>JSX is easier to write and understand than creating and appending many elements in vanilla JavaScript, and is one of the reasons people love React so much.ComponentsSo far, we've created one component - theAppcomponent. Almost everything in React consists of components, which can beclass componentsorsimple components.Most React apps have many small components, and everything loads into the mainAppcomponent. Components also often get their own file, so let's change up our project to do so.Remove theAppclass fromindex.js, so it looks like this.src/index.jsimportReactfrom'react'importReactDOMfrom'react-dom'importAppfrom'./App'import'./index.css'ReactDOM.render(<App/>,document.getElementById('root'))We'll create a new file calledApp.jsand put the component in there.src/App.jsimportReact,{Component} rom'react'classAppextendsComponent{render(){return(<divclassName=\"App\"><h1>Hello, React!</h1></div>)}} xportdefaultAppWe export the component asAppand load it inindex.js. It's not mandatory to separate components into files, but an application will start to get unwieldy and out-of-hand if you don't.Class ComponentsLet's create another component. We're going to create a table. MakeTable.js, and fill it with the following data.src/Table.jsimportReact,{Component} rom'react'classTableextendsComponent{render(){return(<table><thead><tr><th>Name</th><th>Job</th></tr></thead><tbody><tr><td>Charlie</td><td>Janitor</td></tr><tr><td>Mac</td><td>Bouncer</td></tr><tr><td>Dee</td><td>Aspiring actress</td></tr><tr><td>Dennis</td><td>Bartender</td></tr></tbody></table>)}} xportdefaultTableThis component we created is a custom class component. We capitalize custom components to differentiate them from regular HTML elements. Back inApp.js, we can load in the Table, first by importing it in:src/App.jsimportTablefrom'./Table'Then by loading it into therender()ofApp, where before we had \"Hello, React!\". I also changed the class of the outer container.src/App.jsimportReact,{Component} rom'react'importTablefrom'./Table'classAppextendsComponent{render(){return(<divclassName=\"container\"><Table/></div>)}} xportdefaultAppIf you check back on your live environment, you'll see theTableloaded in.Now we've seen what a custom class component is. We could reuse this component over and over. However, since the data is hard-coded into it, it wouldn't be too useful at the moment.Simple ComponentsThe other type of component in React is thesimple component, which is a function. This component doesn't use theclasskeyword. Let's take ourTableand make two simple components for it - a table header, and a table body.We're going to use ES6 arrow functions to create these simple components. First, the table header.src/Table.jsconstTableHeader=()=>{return(<thead><tr><th>Name</th><th>Job</th></tr></thead>)} hen the body.src/Table.jsconstTableBody=()=>{return(<tbody><tr><td>Charlie</td><td>Janitor</td></tr><tr><td>Mac</td><td>Bouncer</td></tr><tr><td>Dee</td><td>Aspiring actress</td></tr><tr><td>Dennis</td><td>Bartender</td></tr></tbody>)} ow ourTablefile will look like this. Note that theTableHeaderandTableBodycomponents are all in the same file, and being used by theTableclass component.src/Table.jsconstTableHeader=()=>{...} onstTableBody=()=>{...} lassTableextendsComponent{render(){return(<table><TableHeader/><TableBody/></table>)}} verything should appear as it did before. As you can see, components can be nested in other components, and simple and class components can be mixed.A class component must includerender(), and thereturncan only return one parent element.As a wrap up, let's compare a simple component with a class component.Simple ComponentconstSimpleComponent=()=>{return<div>Example</div>} lass ComponentclassClassComponentextendsComponent{render(){return<div>Example</div>}} ote that if thereturnis contained to one line, it does not need parentheses.PropsRight now, we have a coolTablecomponent, but the data is being hard-coded. One of the big deals about React is how it handles data, and it does so with properties, referred to asprops, and with state. Now, we'll focus on handling data with props.First, let's remove all the data from ourTableBodycomponent.src/Table.jsconstTableBody=()=>{return<tbody/>} hen let's move all that data to an array of objects, as if we were bringing in a JSON-based API. We'll have to create this array inside ourrender().src/App.jsclassAppextendsComponent{render(){constcharacters=[{name:'Charlie',job:'Janitor',},{name:'Mac',job:'Bouncer',},{name:'Dee',job:'Aspring actress',},{name:'Dennis',job:'Bartender',},]return(<divclassName=\"container\"><Table/></div>)}} ow, we're going to pass the data through to the child component (Table) with properties, kind of how you might pass data through usingdata-attributes. We can call the property whatever we want, as long as it's not a reserved keyword, so I'll go withcharacterData. The data I'm passing through is thecharactersvariable, and I'll put curly braces around it as it's a JavaScript expression.src/App.jsreturn(<divclassName=\"container\"><TablecharacterData={characters}/></div>)Now that data is being passed through toTable, we have to work on accessing it from the other side.src/Table.jsclassTableextendsComponent{render(){const{characterData}=this.propsreturn(<table><TableHeader/><TableBodycharacterData={characterData}/></table>)}} f you open up React DevTools and inspect theTablecomponent, you'll see the array of data in the property. The data that's stored here is known as thevirtual DOM, which is a fast and efficient way of syncing data with the actual DOM.This data is not in the actual DOM yet, though.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.173,
        "word_count": 995,
        "chunk_id": "834fe475683d762e466312825f47548e",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "information",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "InTable, we can access all props throughthis.props. We're only passing one props through, characterData, so we'll usethis.props.characterDatato retrieve that data.I'm going to use the ES6 property shorthand to create a variable that containsthis.props.characterData.const{characterData}=this.propsSince ourTablecomponent actually consists of two smaller simple components, I'm going to pass it through to theTableBody, once again through props.src/Table.jsclassTableextendsComponent{render(){const{characterData}=this.propsreturn(<table><TableHeader/><TableBodycharacterData={characterData}/></table>)}} ight now,TableBodytakes no parameters and returns a single tag.src/Table.jsconstTableBody=()=>{return<tbody/>} e're going to pass the props through as a parameter, andmap through the arrayto return a table row for each object in the array. This map will be contained in therowsvariable, which we'll return as an expression.src/Table.jsconstTableBody=(props)=>{constrows=props.characterData.map((row,index)=>{return(<trkey={index}><td>{row.name}</td><td>{row.job}</td></tr>)})return<tbody>{rows}</tbody>} f you view the front end of the app, all the data is loading in now.You'll notice I've added a key index to each table row. You should always usekeyswhen making lists in React, as they help identify each list item. We'll also see how this is necessary in a moment when we want to manipulate list items.Props are an effective way to pass existing data to a React component, however the component cannot change the props - they're read-only. In the next section, we'll learn how to use state to have further control over handling data in React.StateRight now, we're storing our character data in an array in a variable, and passing it through as props. This is good to start, but imagine if we want to be able to delete an item from the array. With props, we have a one way data flow, but with state we can update private data from a component.You can think of state as any data that should be saved and modified without necessarily being added to a database - for example, adding and removing items from a shopping cart before confirming your purchase.To start, we're going to create astateobject.src/App.jsclassAppextendsComponent{state={}} he object will contain properties for everything you want to store in the state. For us, it'scharacters.src/App.jsclassAppextendsComponent{state={characters:[],}} ove the entire array of objects we created earlier intostate.characters.src/App.jsclassAppextendsComponent{state={characters:[{name:'Charlie',// the rest of the data},],}} ur data is officially contained in the state. Since we want to be able to remove a character from the table, we're going to create aremoveCharactermethod on the parentAppclass.To retrieve the state, we'll getthis.state.charactersusing the same ES6 method as before. To update the state, we'll usethis.setState(), a built-in method for manipulating state. We'llfilter the arraybased on anindexthat we pass through, and return the new array.You must usethis.setState()to modify an array. Simply applying a new value tothis.state.propertywill not work.src/App.jsremoveCharacter=(index)=>{const{characters}=this.statethis.setState({characters:characters.filter((character,i)=>{returni!==index}),})} ilterdoes not mutate but rather creates a new array, and is a preferred method for modifying arrays in JavaScript. This particular method is testing an index vs. all the indices in the array, and returning all but the one that is passed through.Now we have to pass that function through to the component, and render a button next to each character that can invoke the function. We'll pass theremoveCharacterfunction through as a prop toTable.src/App.jsrender(){const{characters}=this.statereturn(<divclassName=\"container\"><TablecharacterData={characters} emoveCharacter={this.removeCharacter}/></div>)} ince we're passing it down toTableBodyfromTable, we're going to have to pass it through again as a prop, just like we did with the character data.In addition, since it turns out that the only components having their own states in our project areAppandForm, it would be best practice to transformTableinto a simple component from the class component it currently is.src/Table.jsconstTable=(props)=>{const{characterData,removeCharacter}=propsreturn(<table><TableHeader/><TableBodycharacterData={characterData} emoveCharacter={removeCharacter}/></table>)} ere's where that index we defined in theremoveCharacter()method comes in. In theTableBodycomponent, we'll pass the key/index through as a parameter, so the filter function knows which item to remove. We'll create a button with anonClickand pass it through.src/Table.js<trkey={index}><td>{row.name}</td><td>{row.job}</td><td><buttononClick={()=>props.removeCharacter(index)}>Delete</button></td></tr>TheonClickfunction must pass through a function that returns theremoveCharacter()method, otherwise it will try to run automatically.Awesome. Now we have delete buttons, and we can modify our state by deleting a character.I deleted Mac.Now you should understand how state gets initialized and how it can be modified.Submitting Form DataNow we have data stored in state, and we can remove any item from the state. However, what if we wanted to be able to add new data to state? In a real world application, you'd more likely start with empty state and add to it, such as with a to-do list or a shopping cart.Before anything else, let's remove all the hard-coded data fromstate.characters, as we'll be updating that through the form now.src/App.jsclassAppextendsComponent{state={characters:[],}} ow let's go ahead and create aFormcomponent in a new file calledForm.js.We're going to set the initial state of theFormto be an object with some empty properties, and assign that initial state tothis.state.src/Form.jsimportReact,{Component} rom'react'classFormextendsComponent{initialState={name:'',job:'',} tate=this.initialState} reviously, it was necessary to include aconstructor()on React class components, but it's not required anymore.Our goal for this form will be to update the state ofFormevery time a field is changed in the form, and when we submit, all that data will pass to theAppstate, which will then update theTable.First, we'll make the function that will run every time a change is made to an input. Theeventwill be passed through, and we'll set the state ofFormto have thename(key) andvalueof the inputs.src/Form.jshandleChange=(event)=>{const{name,value}=event.targetthis.setState({[name]:value,})} et's get this working before we move on to submitting the form. In the render, let's get our two properties from state, and assign them as the values that correspond to the proper form keys. We'll run thehandleChange()method as theonChangeof the input, and finally we'll export theFormcomponent.src/Form.jsrender(){const{name,job}=this.state;return(<form><labelhtmlFor=\"name\">Name</label><inputtype=\"text\"name=\"name\"id=\"name\"value={name} nChange={this.handleChange}/><labelhtmlFor=\"job\">Job</label><inputtype=\"text\"name=\"job\"id=\"job\"value={job} nChange={this.handleChange}/></form>);} xportdefaultForm;InApp.js, we can render the form below the table.src/App.jsimportFormfrom'./Form'src/App.jsreturn(<divclassName=\"container\"><TablecharacterData={characters} emoveCharacter={this.removeCharacter}/><Form/></div>)Now if we go to the front end of our app, we'll see a form that doesn't have a submit yet. Update some fields and you'll see the local state ofFormbeing updated.Cool. Last step is to allow us to actually submit that data and update the parent state. We'll create a function calledhandleSubmit()onAppthat will update the state by taking the existingthis.state.charactersand adding the newcharacterparameter, using theES6 spread operator.src/App.jshandleSubmit=(character)=>{this.setState({characters:[...this.state.characters,character]})} et's make sure we pass that through as a parameter onForm.<FormhandleSubmit={this.handleSubmit}/>Now inForm, we'll create a method calledsubmitForm()that will call that function, and pass theFormstate through as thecharacterparameter we defined earlier. It will also reset the state to the initial state, to clear the form after submit.src/Form.jssubmitForm=()=>{this.props.handleSubmit(this.state)this.setState(this.initialState)} inally, we'll add a submit button to submit the form.",
        "chunk_type": "code_function",
        "tag": "div",
        "score": 1.173,
        "word_count": 999,
        "chunk_id": "b076d340e9a9754098f24b38e7323649",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "We're using anonClickinstead of anonSubmitsince we're not using the standard submit functionality. The click will call thesubmitFormwe just made.<inputtype=\"button\"value=\"Submit\"onClick={this.submitForm}/>And that's it! The app is complete. We can create, add, and remove users from our table. Since theTableandTableBodywere already pulling from the state, it will display properly.If you got lost anywhere along the way, you can viewthe complete source on GitHub.Pulling in API DataOne very common usage of React is pulling in data from an API. If you're not familiar with what an API is or how to connect to one, I would recommend readingHow to Connect to an API with JavaScript, which will walk you through what APIs are and how to use them with vanilla JavaScript.As a little test, we can create a newApi.jsfile, and create a newAppin there. A public API we can test with is theWikipedia API, and I have aURL endpoint right herefor a random* search. You can go to that link to see the API - and make sure you haveJSONViewinstalled on your browser.We're going to useJavaScript's built-in Fetchto gather the data from that URL endpoint and display it. You can switch between the app we created and this test file by just changing the URL inindex.js-import App from './Api';.I'm not going to explain this code line-by-line, as we've already learned about creating a component, rendering, and mapping through a state array. The new aspect to this code iscomponentDidMount(), a React lifecycle method.Lifecycleis the order in which methods are called in React.Mountingrefers to an item being inserted into the DOM.When we pull in API data, we want to usecomponentDidMount, because we want to make sure the component has rendered to the DOM before we bring in the data. In the below snippet, you'll see how we bring in data from the Wikipedia API, and display it on the pageApi.jsimportReact,{Component} rom'react'classAppextendsComponent{state={data:[],}// Code is invoked after the component is mounted/inserted into the DOM tree.componentDidMount(){consturl='https://en.wikipedia.org/w/api.php?action=opensearch&search=Seona+Dancing&format=json&origin=*'fetch(url).then((result)=>result.json()).then((result)=>{this.setState({data:result,})})} ender(){const{data}=this.stateconstresult=data.map((entry,index)=>{return<likey={index}>{entry}</li>})return<ul>{result}</ul>}} xportdefaultAppOnce you save and run this file in the local server, you'll see the Wikipedia API data displayed in the DOM.There are other lifecycle methods, but going over them will be beyond the scope of this article. You canread more about React components here.*Wikipedia search choice may not be random. It might be an article that I spearheaded back in 2005.Building and Deploying a React AppEverything we've done so far has been in a development environment. We've been compiling, hot-reloading, and updating on the fly. For production, we're going to want to have static files loading in - none of the source code. We can do this by making a build and deploying it.Now, if you just want to compile all the React code and place it in the root of a directory somewhere, all you need to do is run the following line:npmrun buildThis will create abuildfolder which will contain your app. Put the contents of that folder anywhere, and you're done!We can also take it a step further, and have npm deploy for us. We're going to build to GitHub pages, so you'll already have tobe familiar with Gitand getting your code up on GitHub.Make sure you've exited out of your local React environment, so the code isn't currently running. First, we're going to add ahomepagefield topackage.json, that has the URL we want our app to live on.package.json\"homepage\":\"https://taniarascia.github.io/react-tutorial\",We'll also add these two lines to thescriptsproperty.\"scripts\":{// ...\"predeploy\":\"npm run build\",\"deploy\":\"gh-pages -d build\"} n your project, you'll addgh-pagesto the devDependencies.npminstall--save-dev gh-pagesWe'll create thebuild, which will have all the compiled, static files.npmrun buildFinally, we'll deploy togh-pages.npmrun deployAnd we're done! The app is now available live athttps://taniarascia.github.io/react-tutorial.ConclusionThis article should have given you a good introduction to React, simple and class components, state, props, working with form data, pulling data in from an API, and deploying an app. There is much more to learn and do with React, but I hope you feel confident delving in and playing around with React yourself now.View Source on GitHubView ProjectPlease let me know if anything was unclear, or if there's anything else you'd like to see in this or a subsequent article.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:August 20, 2018Category:TechnicalTagsapijavascriptreacttutorialframeworksNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.173,
        "word_count": 726,
        "chunk_id": "5f0b4f4d59fc368d25fc156739b30807",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "development",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "I've been hearing about React since I first started learning JavaScript, but I'll admit I took one look at it and it scared me. I saw what looked like a bunch of HTML mixed with JavaScript and thought,isn't this what we've been trying to avoid? What's the big deal with React?Instead, I focused on just learning vanilla JavaScript and working with jQuery in a professional setting. After a few frustrated, failed attempts to get started with React, I finally started to get it, and I began to see why I might want to use React instead of vanilla JS or jQuery.I tried to condense everything I've learned into a nice introduction to share with you, so here it is.PrerequisitesThere are a few things you should know in advance before you start playing around with React. If you've never used JavaScript or the DOM at all before, for example, I would get more familiar with those before trying to tackle React.Here are what I consider to be React prerequisites.Basic familiarity withHTML & CSS.Basic knowledge ofJavaScriptand programming.Basic understanding ofthe DOM.Familiarity withES6 syntax and features.Node.js and npminstalled globally.GoalsLearn about essential React concepts and related terms, such as Babel, Webpack, JSX, components, props, state, and lifecycle.Build a very simple React app that demonstrates the above concepts.Here's the source and a live demo of the end result.View Source on GitHubView DemoWhat is React?React is a JavaScript library - one of the most popular ones, withover 100,000 stars on GitHub.React is not a framework (unlike Angular, which is more opinionated).React is an open-source project created by Facebook.React is used to build user interfaces (UI) on the front end.React is theviewlayer of an MVC application (Model View Controller)One of the most important aspects of React is the fact that you can createcomponents, which are like custom, reusable HTML elements, to quickly and efficiently build user interfaces. React also streamlines how data is stored and handled, usingstateandprops.We'll go over all of this and more throughout the article, so let's get started.Setup and InstallationThere are a few ways to set up React, and I'll show you two so you get a good idea of how it works.Static HTML FileThis first method is not a popular way to set up React and is not how we'll be doing the rest of our tutorial, but it will be familiar and easy to understand if you've ever used a library like jQuery, and it's the least scary way to get started if you're not familiar with Webpack, Babel, and Node.js.Let's start by making a basicindex.htmlfile. We're going to load in three CDNs in thehead- React, React DOM, and Babel. We're also going to make adivwith an id calledroot, and finally we'll create ascripttag where your custom code will live.index.html<!DOCTYPEhtml><html><head><metacharset=\"utf-8\"/><title>Hello React!</title><scriptsrc=\"https://unpkg.com/react@^16/umd/react.production.min.js\"></script><scriptsrc=\"https://unpkg.com/react-dom@16.13.0/umd/react-dom.production.min.js\"></script><scriptsrc=\"https://unpkg.com/babel-standalone@6.26.0/babel.js\"></script></head><body><divid=\"root\"></div><scripttype=\"text/babel\">// React code will go here</script></body></html>I'm loading in the latest stable versions of the libraries as of the time of this writing.React- the React top level APIReact DOM- adds DOM-specific methodsBabel- a JavaScript compiler that lets us use ES6+ in old browsersThe entry point for our app will be therootdiv element, which is named by convention. You'll also notice thetext/babelscript type, which is mandatory for using Babel.Now, let's write our first code block of React. We're going to use ES6 classes to create a React component calledApp.index.htmlclassAppextendsReact.Component{//...} ow we'll add therender()method, the only required method in a class component, which is used to render DOM nodes.index.htmlclassAppextendsReact.Component{render(){return(//...);}} nside thereturn, we're going to put what looks like a simple HTML element. Note that we're not returning a string here, so don't use quotes around the element. This is calledJSX, and we'll learn more about it soon.index.htmlclassAppextendsReact.Component{render(){return<h1>Hello world!</h1>}} inally, we're going to use the React DOMrender()method to render theAppclass we created into therootdiv in our HTML.index.htmlReactDOM.render(<App/>,document.getElementById('root'))Here is the full code for ourindex.html.index.html<!DOCTYPEhtml><html><head><metacharset=\"utf-8\"/><title>Hello React!</title><scriptsrc=\"https://unpkg.com/react@16/umd/react.development.js\"></script><scriptsrc=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"></script><scriptsrc=\"https://unpkg.com/babel-standalone@6.26.0/babel.js\"></script></head><body><divid=\"root\"></div><scripttype=\"text/babel\">classAppextendsReact.Component{render(){return<h1>Hello world!</h1>}} eactDOM.render(<App/>,document.getElementById('root'))</script></body></html>Now if you view yourindex.htmlin the browser, you'll see theh1tag we created rendered to the DOM.Cool! Now that you've done this, you can see that React isn't so insanely scary to get started with. It's just some JavaScript helper libraries that we can load into our HTML.We've done this for demonstration purposes, but from here out we're going to use another method: Create React App.Create React AppThe method I just used of loading JavaScript libraries into a static HTML page and rendering the React and Babel on the fly is not very efficient, and is hard to maintain.Fortunately, Facebook has createdCreate React App, an environment that comes pre-configured with everything you need to build a React app. It will create a live development server, use Webpack to automatically compile React, JSX, and ES6, auto-prefix CSS files, and use ESLint to test and warn about mistakes in the code.To set upcreate-react-app, run the following code in your terminal, one directory up from where you want the project to live.npx create-react-app react-tutorialOnce that finishes installing, move to the newly created directory and start the project.cdreact-tutorial&&npmstartOnce you run this command, a new window will popup atlocalhost:3000with your new React app.Create React App is very good for getting started for beginners as well as large-scale enterprise applications, but it's not perfect for every workflow. You can also create your own Webpack setup for React.If you look into the project structure, you'll see a/publicand/srcdirectory, along with the regularnode_modules,.gitignore,README.md, andpackage.json.In/public, our important file isindex.html, which is very similar to the staticindex.htmlfile we made earlier - just arootdiv. This time, no libraries or scripts are being loaded in. The/srcdirectory will contain all our React code.To see how the environment automatically compiles and updates your React code, find the line that looks like this in/src/App.js:To get started, edit `src/App.js` and save to reload.And replace it with any other text. Once you save the file, you'll noticelocalhost:3000compiles and refreshes with the new data.Go ahead and delete all the files out of the/srcdirectory, and we'll create our own boilerplate file without any bloat. We'll just keepindex.cssandindex.js.Forindex.css, I just copy-and-pasted the contents ofPrimitive CSSinto the file. If you want, you can use Bootstrap or whatever CSS framework you want, or nothing at all.",
        "chunk_type": "code_class",
        "tag": "section",
        "score": 1.187,
        "word_count": 1000,
        "chunk_id": "38045482ac853ea07fc1d9bd04659d0d",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "web",
            "article",
            "development",
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "I just find it easier to work with.Now inindex.js, we're importing React, ReactDOM, and the CSS file.src/index.jsimportReactfrom'react'importReactDOMfrom'react-dom'import'./index.css'Let's create ourAppcomponent again. Before, we just had an<h1>, but now I'm adding in a div element with a class as well. You'll notice that we useclassNameinstead ofclass. This is our first hint that the code being written here is JavaScript, and not actually HTML.src/index.jsclassAppextendsReact.Component{render(){return(<divclassName=\"App\"><h1>Hello, React!</h1></div>)}} inally, we'll render theAppto the root as before.src/index.jsReactDOM.render(<App/>,document.getElementById('root'))Here's our fullindex.js. This time, we're loading theComponentas a property of React, so we no longer need to extendReact.Component.src/index.jsimportReact,{Component} rom'react'importReactDOMfrom'react-dom'import'./index.css'classAppextendsComponent{render(){return(<divclassName=\"App\"><h1>Hello, React!</h1></div>)}} eactDOM.render(<App/>,document.getElementById('root'))If you go back tolocalhost:3000, you'll see \"Hello, React!\" just like before. We have the beginnings of a React app now.React Developer ToolsThere is an extension called React Developer Tools that will make your life much easier when working with React. DownloadReact DevTools for Chrome, or whatever browser you prefer to work on.After you install it, when you open DevTools, you'll see a tab for React. Click on it, and you'll be able to inspect components as they're written. You can still go to the Elements tab to see the actual DOM output. It may not seem like that much of a deal now, but as the app gets more complicated, it will become increasingly necessary to use.Now we have all the tools and setup we need to actually begin working with React.JSX: JavaScript + XMLAs you've seen, we've been using what looks like HTML in our React code, but it's not quite HTML. This isJSX, which stands for JavaScript XML.With JSX, we can write what looks like HTML, and also we can create and use our own XML-like tags. Here's what JSX looks like assigned to a variable.JSXconstheading=<h1className=\"site-heading\">Hello, React</h1>Using JSX is not mandatory for writing React. Under the hood, it's runningcreateElement, which takes the tag, object containing the properties, and children of the component and renders the same information. The below code will have the same output as the JSX above.No JSXconstheading=React.createElement('h1',{className:'site-heading'},'Hello, React!')JSX is actually closer to JavaScript, not HTML, so there are a few key differences to note when writing it.classNameis used instead ofclassfor adding CSS classes, asclassis a reserved keyword in JavaScript.Properties and methods in JSX are camelCase -onclickwill becomeonClick.Self-closing tagsmustend in a slash - e.g.<img />JavaScript expressions can also be embedded inside JSX using curly braces, including variables, functions, and properties.constname='Tania'constheading=<h1>Hello,{name}</h1>JSX is easier to write and understand than creating and appending many elements in vanilla JavaScript, and is one of the reasons people love React so much.ComponentsSo far, we've created one component - theAppcomponent. Almost everything in React consists of components, which can beclass componentsorsimple components.Most React apps have many small components, and everything loads into the mainAppcomponent. Components also often get their own file, so let's change up our project to do so.Remove theAppclass fromindex.js, so it looks like this.src/index.jsimportReactfrom'react'importReactDOMfrom'react-dom'importAppfrom'./App'import'./index.css'ReactDOM.render(<App/>,document.getElementById('root'))We'll create a new file calledApp.jsand put the component in there.src/App.jsimportReact,{Component} rom'react'classAppextendsComponent{render(){return(<divclassName=\"App\"><h1>Hello, React!</h1></div>)}} xportdefaultAppWe export the component asAppand load it inindex.js. It's not mandatory to separate components into files, but an application will start to get unwieldy and out-of-hand if you don't.Class ComponentsLet's create another component. We're going to create a table. MakeTable.js, and fill it with the following data.src/Table.jsimportReact,{Component} rom'react'classTableextendsComponent{render(){return(<table><thead><tr><th>Name</th><th>Job</th></tr></thead><tbody><tr><td>Charlie</td><td>Janitor</td></tr><tr><td>Mac</td><td>Bouncer</td></tr><tr><td>Dee</td><td>Aspiring actress</td></tr><tr><td>Dennis</td><td>Bartender</td></tr></tbody></table>)}} xportdefaultTableThis component we created is a custom class component. We capitalize custom components to differentiate them from regular HTML elements. Back inApp.js, we can load in the Table, first by importing it in:src/App.jsimportTablefrom'./Table'Then by loading it into therender()ofApp, where before we had \"Hello, React!\". I also changed the class of the outer container.src/App.jsimportReact,{Component} rom'react'importTablefrom'./Table'classAppextendsComponent{render(){return(<divclassName=\"container\"><Table/></div>)}} xportdefaultAppIf you check back on your live environment, you'll see theTableloaded in.Now we've seen what a custom class component is. We could reuse this component over and over. However, since the data is hard-coded into it, it wouldn't be too useful at the moment.Simple ComponentsThe other type of component in React is thesimple component, which is a function. This component doesn't use theclasskeyword. Let's take ourTableand make two simple components for it - a table header, and a table body.We're going to use ES6 arrow functions to create these simple components. First, the table header.src/Table.jsconstTableHeader=()=>{return(<thead><tr><th>Name</th><th>Job</th></tr></thead>)} hen the body.src/Table.jsconstTableBody=()=>{return(<tbody><tr><td>Charlie</td><td>Janitor</td></tr><tr><td>Mac</td><td>Bouncer</td></tr><tr><td>Dee</td><td>Aspiring actress</td></tr><tr><td>Dennis</td><td>Bartender</td></tr></tbody>)} ow ourTablefile will look like this. Note that theTableHeaderandTableBodycomponents are all in the same file, and being used by theTableclass component.src/Table.jsconstTableHeader=()=>{...} onstTableBody=()=>{...} lassTableextendsComponent{render(){return(<table><TableHeader/><TableBody/></table>)}} verything should appear as it did before. As you can see, components can be nested in other components, and simple and class components can be mixed.A class component must includerender(), and thereturncan only return one parent element.As a wrap up, let's compare a simple component with a class component.Simple ComponentconstSimpleComponent=()=>{return<div>Example</div>} lass ComponentclassClassComponentextendsComponent{render(){return<div>Example</div>}} ote that if thereturnis contained to one line, it does not need parentheses.PropsRight now, we have a coolTablecomponent, but the data is being hard-coded. One of the big deals about React is how it handles data, and it does so with properties, referred to asprops, and with state. Now, we'll focus on handling data with props.First, let's remove all the data from ourTableBodycomponent.src/Table.jsconstTableBody=()=>{return<tbody/>} hen let's move all that data to an array of objects, as if we were bringing in a JSON-based API. We'll have to create this array inside ourrender().src/App.jsclassAppextendsComponent{render(){constcharacters=[{name:'Charlie',job:'Janitor',},{name:'Mac',job:'Bouncer',},{name:'Dee',job:'Aspring actress',},{name:'Dennis',job:'Bartender',},]return(<divclassName=\"container\"><Table/></div>)}} ow, we're going to pass the data through to the child component (Table) with properties, kind of how you might pass data through usingdata-attributes. We can call the property whatever we want, as long as it's not a reserved keyword, so I'll go withcharacterData. The data I'm passing through is thecharactersvariable, and I'll put curly braces around it as it's a JavaScript expression.src/App.jsreturn(<divclassName=\"container\"><TablecharacterData={characters}/></div>)Now that data is being passed through toTable, we have to work on accessing it from the other side.src/Table.jsclassTableextendsComponent{render(){const{characterData}=this.propsreturn(<table><TableHeader/><TableBodycharacterData={characterData}/></table>)}} f you open up React DevTools and inspect theTablecomponent, you'll see the array of data in the property. The data that's stored here is known as thevirtual DOM, which is a fast and efficient way of syncing data with the actual DOM.This data is not in the actual DOM yet, though. InTable, we can access all props throughthis.props.",
        "chunk_type": "code_class",
        "tag": "section",
        "score": 1.187,
        "word_count": 985,
        "chunk_id": "ce2837ce2263523be9f25dcc1070f9c7",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "information",
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "We're only passing one props through, characterData, so we'll usethis.props.characterDatato retrieve that data.I'm going to use the ES6 property shorthand to create a variable that containsthis.props.characterData.const{characterData}=this.propsSince ourTablecomponent actually consists of two smaller simple components, I'm going to pass it through to theTableBody, once again through props.src/Table.jsclassTableextendsComponent{render(){const{characterData}=this.propsreturn(<table><TableHeader/><TableBodycharacterData={characterData}/></table>)}} ight now,TableBodytakes no parameters and returns a single tag.src/Table.jsconstTableBody=()=>{return<tbody/>} e're going to pass the props through as a parameter, andmap through the arrayto return a table row for each object in the array. This map will be contained in therowsvariable, which we'll return as an expression.src/Table.jsconstTableBody=(props)=>{constrows=props.characterData.map((row,index)=>{return(<trkey={index}><td>{row.name}</td><td>{row.job}</td></tr>)})return<tbody>{rows}</tbody>} f you view the front end of the app, all the data is loading in now.You'll notice I've added a key index to each table row. You should always usekeyswhen making lists in React, as they help identify each list item. We'll also see how this is necessary in a moment when we want to manipulate list items.Props are an effective way to pass existing data to a React component, however the component cannot change the props - they're read-only. In the next section, we'll learn how to use state to have further control over handling data in React.StateRight now, we're storing our character data in an array in a variable, and passing it through as props. This is good to start, but imagine if we want to be able to delete an item from the array. With props, we have a one way data flow, but with state we can update private data from a component.You can think of state as any data that should be saved and modified without necessarily being added to a database - for example, adding and removing items from a shopping cart before confirming your purchase.To start, we're going to create astateobject.src/App.jsclassAppextendsComponent{state={}} he object will contain properties for everything you want to store in the state. For us, it'scharacters.src/App.jsclassAppextendsComponent{state={characters:[],}} ove the entire array of objects we created earlier intostate.characters.src/App.jsclassAppextendsComponent{state={characters:[{name:'Charlie',// the rest of the data},],}} ur data is officially contained in the state. Since we want to be able to remove a character from the table, we're going to create aremoveCharactermethod on the parentAppclass.To retrieve the state, we'll getthis.state.charactersusing the same ES6 method as before. To update the state, we'll usethis.setState(), a built-in method for manipulating state. We'llfilter the arraybased on anindexthat we pass through, and return the new array.You must usethis.setState()to modify an array. Simply applying a new value tothis.state.propertywill not work.src/App.jsremoveCharacter=(index)=>{const{characters}=this.statethis.setState({characters:characters.filter((character,i)=>{returni!==index}),})} ilterdoes not mutate but rather creates a new array, and is a preferred method for modifying arrays in JavaScript. This particular method is testing an index vs. all the indices in the array, and returning all but the one that is passed through.Now we have to pass that function through to the component, and render a button next to each character that can invoke the function. We'll pass theremoveCharacterfunction through as a prop toTable.src/App.jsrender(){const{characters}=this.statereturn(<divclassName=\"container\"><TablecharacterData={characters} emoveCharacter={this.removeCharacter}/></div>)} ince we're passing it down toTableBodyfromTable, we're going to have to pass it through again as a prop, just like we did with the character data.In addition, since it turns out that the only components having their own states in our project areAppandForm, it would be best practice to transformTableinto a simple component from the class component it currently is.src/Table.jsconstTable=(props)=>{const{characterData,removeCharacter}=propsreturn(<table><TableHeader/><TableBodycharacterData={characterData} emoveCharacter={removeCharacter}/></table>)} ere's where that index we defined in theremoveCharacter()method comes in. In theTableBodycomponent, we'll pass the key/index through as a parameter, so the filter function knows which item to remove. We'll create a button with anonClickand pass it through.src/Table.js<trkey={index}><td>{row.name}</td><td>{row.job}</td><td><buttononClick={()=>props.removeCharacter(index)}>Delete</button></td></tr>TheonClickfunction must pass through a function that returns theremoveCharacter()method, otherwise it will try to run automatically.Awesome. Now we have delete buttons, and we can modify our state by deleting a character.I deleted Mac.Now you should understand how state gets initialized and how it can be modified.Submitting Form DataNow we have data stored in state, and we can remove any item from the state. However, what if we wanted to be able to add new data to state? In a real world application, you'd more likely start with empty state and add to it, such as with a to-do list or a shopping cart.Before anything else, let's remove all the hard-coded data fromstate.characters, as we'll be updating that through the form now.src/App.jsclassAppextendsComponent{state={characters:[],}} ow let's go ahead and create aFormcomponent in a new file calledForm.js.We're going to set the initial state of theFormto be an object with some empty properties, and assign that initial state tothis.state.src/Form.jsimportReact,{Component} rom'react'classFormextendsComponent{initialState={name:'',job:'',} tate=this.initialState} reviously, it was necessary to include aconstructor()on React class components, but it's not required anymore.Our goal for this form will be to update the state ofFormevery time a field is changed in the form, and when we submit, all that data will pass to theAppstate, which will then update theTable.First, we'll make the function that will run every time a change is made to an input. Theeventwill be passed through, and we'll set the state ofFormto have thename(key) andvalueof the inputs.src/Form.jshandleChange=(event)=>{const{name,value}=event.targetthis.setState({[name]:value,})} et's get this working before we move on to submitting the form. In the render, let's get our two properties from state, and assign them as the values that correspond to the proper form keys. We'll run thehandleChange()method as theonChangeof the input, and finally we'll export theFormcomponent.src/Form.jsrender(){const{name,job}=this.state;return(<form><labelhtmlFor=\"name\">Name</label><inputtype=\"text\"name=\"name\"id=\"name\"value={name} nChange={this.handleChange}/><labelhtmlFor=\"job\">Job</label><inputtype=\"text\"name=\"job\"id=\"job\"value={job} nChange={this.handleChange}/></form>);} xportdefaultForm;InApp.js, we can render the form below the table.src/App.jsimportFormfrom'./Form'src/App.jsreturn(<divclassName=\"container\"><TablecharacterData={characters} emoveCharacter={this.removeCharacter}/><Form/></div>)Now if we go to the front end of our app, we'll see a form that doesn't have a submit yet. Update some fields and you'll see the local state ofFormbeing updated.Cool. Last step is to allow us to actually submit that data and update the parent state. We'll create a function calledhandleSubmit()onAppthat will update the state by taking the existingthis.state.charactersand adding the newcharacterparameter, using theES6 spread operator.src/App.jshandleSubmit=(character)=>{this.setState({characters:[...this.state.characters,character]})} et's make sure we pass that through as a parameter onForm.<FormhandleSubmit={this.handleSubmit}/>Now inForm, we'll create a method calledsubmitForm()that will call that function, and pass theFormstate through as thecharacterparameter we defined earlier. It will also reset the state to the initial state, to clear the form after submit.src/Form.jssubmitForm=()=>{this.props.handleSubmit(this.state)this.setState(this.initialState)} inally, we'll add a submit button to submit the form.",
        "chunk_type": "code_function",
        "tag": "section",
        "score": 1.187,
        "word_count": 992,
        "chunk_id": "f14dbcc93e3d36e22f7683a667a9387c",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "We're using anonClickinstead of anonSubmitsince we're not using the standard submit functionality. The click will call thesubmitFormwe just made.<inputtype=\"button\"value=\"Submit\"onClick={this.submitForm}/>And that's it! The app is complete. We can create, add, and remove users from our table. Since theTableandTableBodywere already pulling from the state, it will display properly.If you got lost anywhere along the way, you can viewthe complete source on GitHub.Pulling in API DataOne very common usage of React is pulling in data from an API. If you're not familiar with what an API is or how to connect to one, I would recommend readingHow to Connect to an API with JavaScript, which will walk you through what APIs are and how to use them with vanilla JavaScript.As a little test, we can create a newApi.jsfile, and create a newAppin there. A public API we can test with is theWikipedia API, and I have aURL endpoint right herefor a random* search. You can go to that link to see the API - and make sure you haveJSONViewinstalled on your browser.We're going to useJavaScript's built-in Fetchto gather the data from that URL endpoint and display it. You can switch between the app we created and this test file by just changing the URL inindex.js-import App from './Api';.I'm not going to explain this code line-by-line, as we've already learned about creating a component, rendering, and mapping through a state array. The new aspect to this code iscomponentDidMount(), a React lifecycle method.Lifecycleis the order in which methods are called in React.Mountingrefers to an item being inserted into the DOM.When we pull in API data, we want to usecomponentDidMount, because we want to make sure the component has rendered to the DOM before we bring in the data. In the below snippet, you'll see how we bring in data from the Wikipedia API, and display it on the pageApi.jsimportReact,{Component} rom'react'classAppextendsComponent{state={data:[],}// Code is invoked after the component is mounted/inserted into the DOM tree.componentDidMount(){consturl='https://en.wikipedia.org/w/api.php?action=opensearch&search=Seona+Dancing&format=json&origin=*'fetch(url).then((result)=>result.json()).then((result)=>{this.setState({data:result,})})} ender(){const{data}=this.stateconstresult=data.map((entry,index)=>{return<likey={index}>{entry}</li>})return<ul>{result}</ul>}} xportdefaultAppOnce you save and run this file in the local server, you'll see the Wikipedia API data displayed in the DOM.There are other lifecycle methods, but going over them will be beyond the scope of this article. You canread more about React components here.*Wikipedia search choice may not be random. It might be an article that I spearheaded back in 2005.Building and Deploying a React AppEverything we've done so far has been in a development environment. We've been compiling, hot-reloading, and updating on the fly. For production, we're going to want to have static files loading in - none of the source code. We can do this by making a build and deploying it.Now, if you just want to compile all the React code and place it in the root of a directory somewhere, all you need to do is run the following line:npmrun buildThis will create abuildfolder which will contain your app. Put the contents of that folder anywhere, and you're done!We can also take it a step further, and have npm deploy for us. We're going to build to GitHub pages, so you'll already have tobe familiar with Gitand getting your code up on GitHub.Make sure you've exited out of your local React environment, so the code isn't currently running. First, we're going to add ahomepagefield topackage.json, that has the URL we want our app to live on.package.json\"homepage\":\"https://taniarascia.github.io/react-tutorial\",We'll also add these two lines to thescriptsproperty.\"scripts\":{// ...\"predeploy\":\"npm run build\",\"deploy\":\"gh-pages -d build\"} n your project, you'll addgh-pagesto the devDependencies.npminstall--save-dev gh-pagesWe'll create thebuild, which will have all the compiled, static files.npmrun buildFinally, we'll deploy togh-pages.npmrun deployAnd we're done! The app is now available live athttps://taniarascia.github.io/react-tutorial.ConclusionThis article should have given you a good introduction to React, simple and class components, state, props, working with form data, pulling data in from an API, and deploying an app. There is much more to learn and do with React, but I hope you feel confident delving in and playing around with React yourself now.View Source on GitHubView ProjectPlease let me know if anything was unclear, or if there's anything else you'd like to see in this or a subsequent article.",
        "chunk_type": "code_class",
        "tag": "section",
        "score": 1.187,
        "word_count": 673,
        "chunk_id": "3eb45c0d093cdd6c0ab305181f12b25d",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "article",
            "development",
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "I've been hearing about React since I first started learning JavaScript, but I'll admit I took one look at it and it scared me. I saw what looked like a bunch of HTML mixed with JavaScript and thought,isn't this what we've been trying to avoid? What's the big deal with React?Instead, I focused on just learning vanilla JavaScript and working with jQuery in a professional setting. After a few frustrated, failed attempts to get started with React, I finally started to get it, and I began to see why I might want to use React instead of vanilla JS or jQuery.I tried to condense everything I've learned into a nice introduction to share with you, so here it is.PrerequisitesThere are a few things you should know in advance before you start playing around with React. If you've never used JavaScript or the DOM at all before, for example, I would get more familiar with those before trying to tackle React.Here are what I consider to be React prerequisites.Basic familiarity withHTML & CSS.Basic knowledge ofJavaScriptand programming.Basic understanding ofthe DOM.Familiarity withES6 syntax and features.Node.js and npminstalled globally.GoalsLearn about essential React concepts and related terms, such as Babel, Webpack, JSX, components, props, state, and lifecycle.Build a very simple React app that demonstrates the above concepts.Here's the source and a live demo of the end result.View Source on GitHubView DemoWhat is React?React is a JavaScript library - one of the most popular ones, withover 100,000 stars on GitHub.React is not a framework (unlike Angular, which is more opinionated).React is an open-source project created by Facebook.React is used to build user interfaces (UI) on the front end.React is theviewlayer of an MVC application (Model View Controller)One of the most important aspects of React is the fact that you can createcomponents, which are like custom, reusable HTML elements, to quickly and efficiently build user interfaces. React also streamlines how data is stored and handled, usingstateandprops.We'll go over all of this and more throughout the article, so let's get started.Setup and InstallationThere are a few ways to set up React, and I'll show you two so you get a good idea of how it works.Static HTML FileThis first method is not a popular way to set up React and is not how we'll be doing the rest of our tutorial, but it will be familiar and easy to understand if you've ever used a library like jQuery, and it's the least scary way to get started if you're not familiar with Webpack, Babel, and Node.js.Let's start by making a basicindex.htmlfile. We're going to load in three CDNs in thehead- React, React DOM, and Babel. We're also going to make adivwith an id calledroot, and finally we'll create ascripttag where your custom code will live.index.html<!DOCTYPEhtml><html><head><metacharset=\"utf-8\"/><title>Hello React!</title><scriptsrc=\"https://unpkg.com/react@^16/umd/react.production.min.js\"></script><scriptsrc=\"https://unpkg.com/react-dom@16.13.0/umd/react-dom.production.min.js\"></script><scriptsrc=\"https://unpkg.com/babel-standalone@6.26.0/babel.js\"></script></head><body><divid=\"root\"></div><scripttype=\"text/babel\">// React code will go here</script></body></html>I'm loading in the latest stable versions of the libraries as of the time of this writing.React- the React top level APIReact DOM- adds DOM-specific methodsBabel- a JavaScript compiler that lets us use ES6+ in old browsersThe entry point for our app will be therootdiv element, which is named by convention. You'll also notice thetext/babelscript type, which is mandatory for using Babel.Now, let's write our first code block of React. We're going to use ES6 classes to create a React component calledApp.index.htmlclassAppextendsReact.Component{//...} ow we'll add therender()method, the only required method in a class component, which is used to render DOM nodes.index.htmlclassAppextendsReact.Component{render(){return(//...);}} nside thereturn, we're going to put what looks like a simple HTML element. Note that we're not returning a string here, so don't use quotes around the element. This is calledJSX, and we'll learn more about it soon.index.htmlclassAppextendsReact.Component{render(){return<h1>Hello world!</h1>}} inally, we're going to use the React DOMrender()method to render theAppclass we created into therootdiv in our HTML.index.htmlReactDOM.render(<App/>,document.getElementById('root'))Here is the full code for ourindex.html.index.html<!DOCTYPEhtml><html><head><metacharset=\"utf-8\"/><title>Hello React!</title><scriptsrc=\"https://unpkg.com/react@16/umd/react.development.js\"></script><scriptsrc=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"></script><scriptsrc=\"https://unpkg.com/babel-standalone@6.26.0/babel.js\"></script></head><body><divid=\"root\"></div><scripttype=\"text/babel\">classAppextendsReact.Component{render(){return<h1>Hello world!</h1>}} eactDOM.render(<App/>,document.getElementById('root'))</script></body></html>Now if you view yourindex.htmlin the browser, you'll see theh1tag we created rendered to the DOM.Cool! Now that you've done this, you can see that React isn't so insanely scary to get started with. It's just some JavaScript helper libraries that we can load into our HTML.We've done this for demonstration purposes, but from here out we're going to use another method: Create React App.Create React AppThe method I just used of loading JavaScript libraries into a static HTML page and rendering the React and Babel on the fly is not very efficient, and is hard to maintain.Fortunately, Facebook has createdCreate React App, an environment that comes pre-configured with everything you need to build a React app. It will create a live development server, use Webpack to automatically compile React, JSX, and ES6, auto-prefix CSS files, and use ESLint to test and warn about mistakes in the code.To set upcreate-react-app, run the following code in your terminal, one directory up from where you want the project to live.npx create-react-app react-tutorialOnce that finishes installing, move to the newly created directory and start the project.cdreact-tutorial&&npmstartOnce you run this command, a new window will popup atlocalhost:3000with your new React app.Create React App is very good for getting started for beginners as well as large-scale enterprise applications, but it's not perfect for every workflow. You can also create your own Webpack setup for React.If you look into the project structure, you'll see a/publicand/srcdirectory, along with the regularnode_modules,.gitignore,README.md, andpackage.json.In/public, our important file isindex.html, which is very similar to the staticindex.htmlfile we made earlier - just arootdiv. This time, no libraries or scripts are being loaded in. The/srcdirectory will contain all our React code.To see how the environment automatically compiles and updates your React code, find the line that looks like this in/src/App.js:To get started, edit `src/App.js` and save to reload.And replace it with any other text. Once you save the file, you'll noticelocalhost:3000compiles and refreshes with the new data.Go ahead and delete all the files out of the/srcdirectory, and we'll create our own boilerplate file without any bloat. We'll just keepindex.cssandindex.js.Forindex.css, I just copy-and-pasted the contents ofPrimitive CSSinto the file. If you want, you can use Bootstrap or whatever CSS framework you want, or nothing at all.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.187,
        "word_count": 1000,
        "chunk_id": "38045482ac853ea07fc1d9bd04659d0d",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "development",
            "react"
          ],
          "attributes": {
            "id": "/getting-started-with-react/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "I just find it easier to work with.Now inindex.js, we're importing React, ReactDOM, and the CSS file.src/index.jsimportReactfrom'react'importReactDOMfrom'react-dom'import'./index.css'Let's create ourAppcomponent again. Before, we just had an<h1>, but now I'm adding in a div element with a class as well. You'll notice that we useclassNameinstead ofclass. This is our first hint that the code being written here is JavaScript, and not actually HTML.src/index.jsclassAppextendsReact.Component{render(){return(<divclassName=\"App\"><h1>Hello, React!</h1></div>)}} inally, we'll render theAppto the root as before.src/index.jsReactDOM.render(<App/>,document.getElementById('root'))Here's our fullindex.js. This time, we're loading theComponentas a property of React, so we no longer need to extendReact.Component.src/index.jsimportReact,{Component} rom'react'importReactDOMfrom'react-dom'import'./index.css'classAppextendsComponent{render(){return(<divclassName=\"App\"><h1>Hello, React!</h1></div>)}} eactDOM.render(<App/>,document.getElementById('root'))If you go back tolocalhost:3000, you'll see \"Hello, React!\" just like before. We have the beginnings of a React app now.React Developer ToolsThere is an extension called React Developer Tools that will make your life much easier when working with React. DownloadReact DevTools for Chrome, or whatever browser you prefer to work on.After you install it, when you open DevTools, you'll see a tab for React. Click on it, and you'll be able to inspect components as they're written. You can still go to the Elements tab to see the actual DOM output. It may not seem like that much of a deal now, but as the app gets more complicated, it will become increasingly necessary to use.Now we have all the tools and setup we need to actually begin working with React.JSX: JavaScript + XMLAs you've seen, we've been using what looks like HTML in our React code, but it's not quite HTML. This isJSX, which stands for JavaScript XML.With JSX, we can write what looks like HTML, and also we can create and use our own XML-like tags. Here's what JSX looks like assigned to a variable.JSXconstheading=<h1className=\"site-heading\">Hello, React</h1>Using JSX is not mandatory for writing React. Under the hood, it's runningcreateElement, which takes the tag, object containing the properties, and children of the component and renders the same information. The below code will have the same output as the JSX above.No JSXconstheading=React.createElement('h1',{className:'site-heading'},'Hello, React!')JSX is actually closer to JavaScript, not HTML, so there are a few key differences to note when writing it.classNameis used instead ofclassfor adding CSS classes, asclassis a reserved keyword in JavaScript.Properties and methods in JSX are camelCase -onclickwill becomeonClick.Self-closing tagsmustend in a slash - e.g.<img />JavaScript expressions can also be embedded inside JSX using curly braces, including variables, functions, and properties.constname='Tania'constheading=<h1>Hello,{name}</h1>JSX is easier to write and understand than creating and appending many elements in vanilla JavaScript, and is one of the reasons people love React so much.ComponentsSo far, we've created one component - theAppcomponent. Almost everything in React consists of components, which can beclass componentsorsimple components.Most React apps have many small components, and everything loads into the mainAppcomponent. Components also often get their own file, so let's change up our project to do so.Remove theAppclass fromindex.js, so it looks like this.src/index.jsimportReactfrom'react'importReactDOMfrom'react-dom'importAppfrom'./App'import'./index.css'ReactDOM.render(<App/>,document.getElementById('root'))We'll create a new file calledApp.jsand put the component in there.src/App.jsimportReact,{Component} rom'react'classAppextendsComponent{render(){return(<divclassName=\"App\"><h1>Hello, React!</h1></div>)}} xportdefaultAppWe export the component asAppand load it inindex.js. It's not mandatory to separate components into files, but an application will start to get unwieldy and out-of-hand if you don't.Class ComponentsLet's create another component. We're going to create a table. MakeTable.js, and fill it with the following data.src/Table.jsimportReact,{Component} rom'react'classTableextendsComponent{render(){return(<table><thead><tr><th>Name</th><th>Job</th></tr></thead><tbody><tr><td>Charlie</td><td>Janitor</td></tr><tr><td>Mac</td><td>Bouncer</td></tr><tr><td>Dee</td><td>Aspiring actress</td></tr><tr><td>Dennis</td><td>Bartender</td></tr></tbody></table>)}} xportdefaultTableThis component we created is a custom class component. We capitalize custom components to differentiate them from regular HTML elements. Back inApp.js, we can load in the Table, first by importing it in:src/App.jsimportTablefrom'./Table'Then by loading it into therender()ofApp, where before we had \"Hello, React!\". I also changed the class of the outer container.src/App.jsimportReact,{Component} rom'react'importTablefrom'./Table'classAppextendsComponent{render(){return(<divclassName=\"container\"><Table/></div>)}} xportdefaultAppIf you check back on your live environment, you'll see theTableloaded in.Now we've seen what a custom class component is. We could reuse this component over and over. However, since the data is hard-coded into it, it wouldn't be too useful at the moment.Simple ComponentsThe other type of component in React is thesimple component, which is a function. This component doesn't use theclasskeyword. Let's take ourTableand make two simple components for it - a table header, and a table body.We're going to use ES6 arrow functions to create these simple components. First, the table header.src/Table.jsconstTableHeader=()=>{return(<thead><tr><th>Name</th><th>Job</th></tr></thead>)} hen the body.src/Table.jsconstTableBody=()=>{return(<tbody><tr><td>Charlie</td><td>Janitor</td></tr><tr><td>Mac</td><td>Bouncer</td></tr><tr><td>Dee</td><td>Aspiring actress</td></tr><tr><td>Dennis</td><td>Bartender</td></tr></tbody>)} ow ourTablefile will look like this. Note that theTableHeaderandTableBodycomponents are all in the same file, and being used by theTableclass component.src/Table.jsconstTableHeader=()=>{...} onstTableBody=()=>{...} lassTableextendsComponent{render(){return(<table><TableHeader/><TableBody/></table>)}} verything should appear as it did before. As you can see, components can be nested in other components, and simple and class components can be mixed.A class component must includerender(), and thereturncan only return one parent element.As a wrap up, let's compare a simple component with a class component.Simple ComponentconstSimpleComponent=()=>{return<div>Example</div>} lass ComponentclassClassComponentextendsComponent{render(){return<div>Example</div>}} ote that if thereturnis contained to one line, it does not need parentheses.PropsRight now, we have a coolTablecomponent, but the data is being hard-coded. One of the big deals about React is how it handles data, and it does so with properties, referred to asprops, and with state. Now, we'll focus on handling data with props.First, let's remove all the data from ourTableBodycomponent.src/Table.jsconstTableBody=()=>{return<tbody/>} hen let's move all that data to an array of objects, as if we were bringing in a JSON-based API. We'll have to create this array inside ourrender().src/App.jsclassAppextendsComponent{render(){constcharacters=[{name:'Charlie',job:'Janitor',},{name:'Mac',job:'Bouncer',},{name:'Dee',job:'Aspring actress',},{name:'Dennis',job:'Bartender',},]return(<divclassName=\"container\"><Table/></div>)}} ow, we're going to pass the data through to the child component (Table) with properties, kind of how you might pass data through usingdata-attributes. We can call the property whatever we want, as long as it's not a reserved keyword, so I'll go withcharacterData. The data I'm passing through is thecharactersvariable, and I'll put curly braces around it as it's a JavaScript expression.src/App.jsreturn(<divclassName=\"container\"><TablecharacterData={characters}/></div>)Now that data is being passed through toTable, we have to work on accessing it from the other side.src/Table.jsclassTableextendsComponent{render(){const{characterData}=this.propsreturn(<table><TableHeader/><TableBodycharacterData={characterData}/></table>)}} f you open up React DevTools and inspect theTablecomponent, you'll see the array of data in the property. The data that's stored here is known as thevirtual DOM, which is a fast and efficient way of syncing data with the actual DOM.This data is not in the actual DOM yet, though. InTable, we can access all props throughthis.props.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.187,
        "word_count": 985,
        "chunk_id": "ce2837ce2263523be9f25dcc1070f9c7",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "information",
            "react"
          ],
          "attributes": {
            "id": "/getting-started-with-react/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "We're only passing one props through, characterData, so we'll usethis.props.characterDatato retrieve that data.I'm going to use the ES6 property shorthand to create a variable that containsthis.props.characterData.const{characterData}=this.propsSince ourTablecomponent actually consists of two smaller simple components, I'm going to pass it through to theTableBody, once again through props.src/Table.jsclassTableextendsComponent{render(){const{characterData}=this.propsreturn(<table><TableHeader/><TableBodycharacterData={characterData}/></table>)}} ight now,TableBodytakes no parameters and returns a single tag.src/Table.jsconstTableBody=()=>{return<tbody/>} e're going to pass the props through as a parameter, andmap through the arrayto return a table row for each object in the array. This map will be contained in therowsvariable, which we'll return as an expression.src/Table.jsconstTableBody=(props)=>{constrows=props.characterData.map((row,index)=>{return(<trkey={index}><td>{row.name}</td><td>{row.job}</td></tr>)})return<tbody>{rows}</tbody>} f you view the front end of the app, all the data is loading in now.You'll notice I've added a key index to each table row. You should always usekeyswhen making lists in React, as they help identify each list item. We'll also see how this is necessary in a moment when we want to manipulate list items.Props are an effective way to pass existing data to a React component, however the component cannot change the props - they're read-only. In the next section, we'll learn how to use state to have further control over handling data in React.StateRight now, we're storing our character data in an array in a variable, and passing it through as props. This is good to start, but imagine if we want to be able to delete an item from the array. With props, we have a one way data flow, but with state we can update private data from a component.You can think of state as any data that should be saved and modified without necessarily being added to a database - for example, adding and removing items from a shopping cart before confirming your purchase.To start, we're going to create astateobject.src/App.jsclassAppextendsComponent{state={}} he object will contain properties for everything you want to store in the state. For us, it'scharacters.src/App.jsclassAppextendsComponent{state={characters:[],}} ove the entire array of objects we created earlier intostate.characters.src/App.jsclassAppextendsComponent{state={characters:[{name:'Charlie',// the rest of the data},],}} ur data is officially contained in the state. Since we want to be able to remove a character from the table, we're going to create aremoveCharactermethod on the parentAppclass.To retrieve the state, we'll getthis.state.charactersusing the same ES6 method as before. To update the state, we'll usethis.setState(), a built-in method for manipulating state. We'llfilter the arraybased on anindexthat we pass through, and return the new array.You must usethis.setState()to modify an array. Simply applying a new value tothis.state.propertywill not work.src/App.jsremoveCharacter=(index)=>{const{characters}=this.statethis.setState({characters:characters.filter((character,i)=>{returni!==index}),})} ilterdoes not mutate but rather creates a new array, and is a preferred method for modifying arrays in JavaScript. This particular method is testing an index vs. all the indices in the array, and returning all but the one that is passed through.Now we have to pass that function through to the component, and render a button next to each character that can invoke the function. We'll pass theremoveCharacterfunction through as a prop toTable.src/App.jsrender(){const{characters}=this.statereturn(<divclassName=\"container\"><TablecharacterData={characters} emoveCharacter={this.removeCharacter}/></div>)} ince we're passing it down toTableBodyfromTable, we're going to have to pass it through again as a prop, just like we did with the character data.In addition, since it turns out that the only components having their own states in our project areAppandForm, it would be best practice to transformTableinto a simple component from the class component it currently is.src/Table.jsconstTable=(props)=>{const{characterData,removeCharacter}=propsreturn(<table><TableHeader/><TableBodycharacterData={characterData} emoveCharacter={removeCharacter}/></table>)} ere's where that index we defined in theremoveCharacter()method comes in. In theTableBodycomponent, we'll pass the key/index through as a parameter, so the filter function knows which item to remove. We'll create a button with anonClickand pass it through.src/Table.js<trkey={index}><td>{row.name}</td><td>{row.job}</td><td><buttononClick={()=>props.removeCharacter(index)}>Delete</button></td></tr>TheonClickfunction must pass through a function that returns theremoveCharacter()method, otherwise it will try to run automatically.Awesome. Now we have delete buttons, and we can modify our state by deleting a character.I deleted Mac.Now you should understand how state gets initialized and how it can be modified.Submitting Form DataNow we have data stored in state, and we can remove any item from the state. However, what if we wanted to be able to add new data to state? In a real world application, you'd more likely start with empty state and add to it, such as with a to-do list or a shopping cart.Before anything else, let's remove all the hard-coded data fromstate.characters, as we'll be updating that through the form now.src/App.jsclassAppextendsComponent{state={characters:[],}} ow let's go ahead and create aFormcomponent in a new file calledForm.js.We're going to set the initial state of theFormto be an object with some empty properties, and assign that initial state tothis.state.src/Form.jsimportReact,{Component} rom'react'classFormextendsComponent{initialState={name:'',job:'',} tate=this.initialState} reviously, it was necessary to include aconstructor()on React class components, but it's not required anymore.Our goal for this form will be to update the state ofFormevery time a field is changed in the form, and when we submit, all that data will pass to theAppstate, which will then update theTable.First, we'll make the function that will run every time a change is made to an input. Theeventwill be passed through, and we'll set the state ofFormto have thename(key) andvalueof the inputs.src/Form.jshandleChange=(event)=>{const{name,value}=event.targetthis.setState({[name]:value,})} et's get this working before we move on to submitting the form. In the render, let's get our two properties from state, and assign them as the values that correspond to the proper form keys. We'll run thehandleChange()method as theonChangeof the input, and finally we'll export theFormcomponent.src/Form.jsrender(){const{name,job}=this.state;return(<form><labelhtmlFor=\"name\">Name</label><inputtype=\"text\"name=\"name\"id=\"name\"value={name} nChange={this.handleChange}/><labelhtmlFor=\"job\">Job</label><inputtype=\"text\"name=\"job\"id=\"job\"value={job} nChange={this.handleChange}/></form>);} xportdefaultForm;InApp.js, we can render the form below the table.src/App.jsimportFormfrom'./Form'src/App.jsreturn(<divclassName=\"container\"><TablecharacterData={characters} emoveCharacter={this.removeCharacter}/><Form/></div>)Now if we go to the front end of our app, we'll see a form that doesn't have a submit yet. Update some fields and you'll see the local state ofFormbeing updated.Cool. Last step is to allow us to actually submit that data and update the parent state. We'll create a function calledhandleSubmit()onAppthat will update the state by taking the existingthis.state.charactersand adding the newcharacterparameter, using theES6 spread operator.src/App.jshandleSubmit=(character)=>{this.setState({characters:[...this.state.characters,character]})} et's make sure we pass that through as a parameter onForm.<FormhandleSubmit={this.handleSubmit}/>Now inForm, we'll create a method calledsubmitForm()that will call that function, and pass theFormstate through as thecharacterparameter we defined earlier. It will also reset the state to the initial state, to clear the form after submit.src/Form.jssubmitForm=()=>{this.props.handleSubmit(this.state)this.setState(this.initialState)} inally, we'll add a submit button to submit the form.",
        "chunk_type": "code_function",
        "tag": "div",
        "score": 1.187,
        "word_count": 992,
        "chunk_id": "f14dbcc93e3d36e22f7683a667a9387c",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "id": "/getting-started-with-react/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "We're using anonClickinstead of anonSubmitsince we're not using the standard submit functionality. The click will call thesubmitFormwe just made.<inputtype=\"button\"value=\"Submit\"onClick={this.submitForm}/>And that's it! The app is complete. We can create, add, and remove users from our table. Since theTableandTableBodywere already pulling from the state, it will display properly.If you got lost anywhere along the way, you can viewthe complete source on GitHub.Pulling in API DataOne very common usage of React is pulling in data from an API. If you're not familiar with what an API is or how to connect to one, I would recommend readingHow to Connect to an API with JavaScript, which will walk you through what APIs are and how to use them with vanilla JavaScript.As a little test, we can create a newApi.jsfile, and create a newAppin there. A public API we can test with is theWikipedia API, and I have aURL endpoint right herefor a random* search. You can go to that link to see the API - and make sure you haveJSONViewinstalled on your browser.We're going to useJavaScript's built-in Fetchto gather the data from that URL endpoint and display it. You can switch between the app we created and this test file by just changing the URL inindex.js-import App from './Api';.I'm not going to explain this code line-by-line, as we've already learned about creating a component, rendering, and mapping through a state array. The new aspect to this code iscomponentDidMount(), a React lifecycle method.Lifecycleis the order in which methods are called in React.Mountingrefers to an item being inserted into the DOM.When we pull in API data, we want to usecomponentDidMount, because we want to make sure the component has rendered to the DOM before we bring in the data. In the below snippet, you'll see how we bring in data from the Wikipedia API, and display it on the pageApi.jsimportReact,{Component} rom'react'classAppextendsComponent{state={data:[],}// Code is invoked after the component is mounted/inserted into the DOM tree.componentDidMount(){consturl='https://en.wikipedia.org/w/api.php?action=opensearch&search=Seona+Dancing&format=json&origin=*'fetch(url).then((result)=>result.json()).then((result)=>{this.setState({data:result,})})} ender(){const{data}=this.stateconstresult=data.map((entry,index)=>{return<likey={index}>{entry}</li>})return<ul>{result}</ul>}} xportdefaultAppOnce you save and run this file in the local server, you'll see the Wikipedia API data displayed in the DOM.There are other lifecycle methods, but going over them will be beyond the scope of this article. You canread more about React components here.*Wikipedia search choice may not be random. It might be an article that I spearheaded back in 2005.Building and Deploying a React AppEverything we've done so far has been in a development environment. We've been compiling, hot-reloading, and updating on the fly. For production, we're going to want to have static files loading in - none of the source code. We can do this by making a build and deploying it.Now, if you just want to compile all the React code and place it in the root of a directory somewhere, all you need to do is run the following line:npmrun buildThis will create abuildfolder which will contain your app. Put the contents of that folder anywhere, and you're done!We can also take it a step further, and have npm deploy for us. We're going to build to GitHub pages, so you'll already have tobe familiar with Gitand getting your code up on GitHub.Make sure you've exited out of your local React environment, so the code isn't currently running. First, we're going to add ahomepagefield topackage.json, that has the URL we want our app to live on.package.json\"homepage\":\"https://taniarascia.github.io/react-tutorial\",We'll also add these two lines to thescriptsproperty.\"scripts\":{// ...\"predeploy\":\"npm run build\",\"deploy\":\"gh-pages -d build\"} n your project, you'll addgh-pagesto the devDependencies.npminstall--save-dev gh-pagesWe'll create thebuild, which will have all the compiled, static files.npmrun buildFinally, we'll deploy togh-pages.npmrun deployAnd we're done! The app is now available live athttps://taniarascia.github.io/react-tutorial.ConclusionThis article should have given you a good introduction to React, simple and class components, state, props, working with form data, pulling data in from an API, and deploying an app. There is much more to learn and do with React, but I hope you feel confident delving in and playing around with React yourself now.View Source on GitHubView ProjectPlease let me know if anything was unclear, or if there's anything else you'd like to see in this or a subsequent article.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.187,
        "word_count": 673,
        "chunk_id": "3eb45c0d093cdd6c0ab305181f12b25d",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "development",
            "react"
          ],
          "attributes": {
            "id": "/getting-started-with-react/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "This first method is not a popular way to set up React and is not how we'll be doing the rest of our tutorial, but it will be familiar and easy to understand if you've ever used a library like jQuery, and it's the least scary way to get started if you're not familiar with Webpack, Babel, and Node.js.",
        "chunk_type": "technical_content",
        "tag": "p",
        "score": 0.396,
        "word_count": 59,
        "chunk_id": "7db2f0c8fcb6e29a5e8706b5f75c5246",
        "metadata": {
          "source_tag": "p",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": []
        }
      },
      {
        "content": "Fortunately, Facebook has createdCreate React App, an environment that comes pre-configured with everything you need to build a React app. It will create a live development server, use Webpack to automatically compile React, JSX, and ES6, auto-prefix CSS files, and use ESLint to test and warn about mistakes in the code.",
        "chunk_type": "text",
        "tag": "p",
        "score": 0.519,
        "word_count": 51,
        "chunk_id": "348307c8bc07424131f8b9ca9bc6a423",
        "metadata": {
          "source_tag": "p",
          "keywords_found": [
            "web",
            "development",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react"
          ]
        }
      },
      {
        "content": "This article should have given you a good introduction to React, simple and class components, state, props, working with form data, pulling data in from an API, and deploying an app. There is much more to learn and do with React, but I hope you feel confident delving in and playing around with React yourself now.",
        "chunk_type": "code_class",
        "tag": "p",
        "score": 0.386,
        "word_count": 56,
        "chunk_id": "a17fb8aa03456fb3718ae09206ac1608",
        "metadata": {
          "source_tag": "p",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:August 20, 2018Category:TechnicalTagsapijavascriptreacttutorialframeworksNewsletterSubscribe to the Newsletter",
        "chunk_type": "technical_content",
        "tag": "aside",
        "score": 0.438,
        "word_count": 54,
        "chunk_id": "5e9b4cf09de9d30f452fc09d5ef1b979",
        "metadata": {
          "source_tag": "aside",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "post-sidebar"
            ]
          },
          "technical_indicators": [
            "javascript",
            "api"
          ]
        }
      },
      {
        "content": "Learn about essential React concepts and related terms, such as Babel, Webpack, JSX, components, props, state, and lifecycle.Build a very simple React app that demonstrates the above concepts.",
        "chunk_type": "technical_content",
        "tag": "ul",
        "score": 0.336,
        "word_count": 28,
        "chunk_id": "9194a658f809c468c8fe42a5d4bbc6f6",
        "metadata": {
          "source_tag": "ul",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react"
          ]
        }
      },
      {
        "content": "Learn about essential React concepts and related terms, such as Babel, Webpack, JSX, components, props, state, and lifecycle.",
        "chunk_type": "technical_content",
        "tag": "li",
        "score": 0.312,
        "word_count": 18,
        "chunk_id": "e15eb5b25625b4d50eadc59022734aaa",
        "metadata": {
          "source_tag": "li",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react"
          ]
        }
      },
      {
        "content": "Create React App is very good for getting started for beginners as well as large-scale enterprise applications, but it's not perfect for every workflow. You can also create your own Webpack setup for React.",
        "chunk_type": "text",
        "tag": "blockquote",
        "score": 0.336,
        "word_count": 34,
        "chunk_id": "71d0ad8a21e4ac0ae8276afa25be09be",
        "metadata": {
          "source_tag": "blockquote",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": []
        }
      },
      {
        "content": "Create React App is very good for getting started for beginners as well as large-scale enterprise applications, but it's not perfect for every workflow. You can also create your own Webpack setup for React.",
        "chunk_type": "text",
        "tag": "p",
        "score": 0.336,
        "word_count": 34,
        "chunk_id": "71d0ad8a21e4ac0ae8276afa25be09be",
        "metadata": {
          "source_tag": "p",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": []
        }
      },
      {
        "content": "Using JSX is not mandatory for writing React. Under the hood, it's runningcreateElement, which takes the tag, object containing the properties, and children of the component and renders the same information. The below code will have the same output as the JSX above.",
        "chunk_type": "technical_content",
        "tag": "p",
        "score": 0.364,
        "word_count": 43,
        "chunk_id": "d8dba6d230c8bd19c1919ff1af7f1fd0",
        "metadata": {
          "source_tag": "p",
          "keywords_found": [
            "information",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "data"
          ]
        }
      },
      {
        "content": "There are other lifecycle methods, but going over them will be beyond the scope of this article. You canread more about React components here.",
        "chunk_type": "technical_content",
        "tag": "p",
        "score": 0.312,
        "word_count": 24,
        "chunk_id": "867345195b505cbf9d9cad0701b8f078",
        "metadata": {
          "source_tag": "p",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react"
          ]
        }
      }
    ],
    "chunk_count": 38,
    "content_types": [
      "code_class",
      "text",
      "code_function",
      "technical_content"
    ],
    "technical_concepts": [
      "javascript",
      "sql",
      "data",
      "api",
      "react"
    ],
    "crawl_metadata": {},
    "technical_content": [
      {
        "id": "eacf331f0ffc35d4b482f1d15a887d3b",
        "content": "index.html",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "96e89a298e0a9f469b9ae458d6afae9f",
        "content": "head",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "38696558dc98494c08d951c052900a2a",
        "content": "div",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "63a9f0ea7bb98050796b649e85481845",
        "content": "root",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "3205c0ded576131ea255ad2bd38b0fb2",
        "content": "script",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "55ee428497a2d904e6ff92a61358fcf5",
        "content": "<!DOCTYPE html> <html> <head> <meta charset=\"utf-8\" /> <title>Hello React!</title> <script src=\"https://unpkg.com/react 16/umd/react.production.min.js\"></script> <script src=\"https://unpkg.com/react-dom 16.13.0/umd/react-dom.production.min.js\"></script> <script src=\"https://unpkg.com/babel-standalone 6.26.0/babel.js\"></script> </head> <body> <div id=\"root\"></div> <script type=\"text/babel\"> // React code will go here </script> </body> </html>",
        "type": "code",
        "language": "html",
        "relevance": 0.605263157894737
      },
      {
        "id": "55ee428497a2d904e6ff92a61358fcf5",
        "content": "<!DOCTYPE html> <html> <head> <meta charset=\"utf-8\" /> <title>Hello React!</title> <script src=\"https://unpkg.com/react 16/umd/react.production.min.js\"></script> <script src=\"https://unpkg.com/react-dom 16.13.0/umd/react-dom.production.min.js\"></script> <script src=\"https://unpkg.com/babel-standalone 6.26.0/babel.js\"></script> </head> <body> <div id=\"root\"></div> <script type=\"text/babel\"> // React code will go here </script> </body> </html>",
        "type": "code",
        "language": "html",
        "relevance": 0.605263157894737
      },
      {
        "id": "63a9f0ea7bb98050796b649e85481845",
        "content": "root",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c7a33ccb01ba2463017db86d2c6b9e5b",
        "content": "text/babel",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "ac863f346e618f9a959b5c95d5d28941",
        "content": "App",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "ec321d2305f37e94e4acf6f889636590",
        "content": "class App extends React.Component { //... }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.5105263157894737
      },
      {
        "id": "ec321d2305f37e94e4acf6f889636590",
        "content": "class App extends React.Component { //... }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.5105263157894737
      },
      {
        "id": "eaad0dd06cc677f81b7572b5dd5c7784",
        "content": "render()",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "5698259d61e65b285f609c9cdb1ecba1",
        "content": "class App extends React.Component { render() { return ( //... ) } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "5698259d61e65b285f609c9cdb1ecba1",
        "content": "class App extends React.Component { render() { return ( //... ) } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "e70c4df10ef0983b9c8c31bd06b2a2c3",
        "content": "return",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "0b121e1be8f2620261311e2163f970d9",
        "content": "JSX",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "cae013e36dc26435043fe1ce7c014daf",
        "content": "class App extends React.Component { render() { return <h1>Hello world!</h1> } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.9105263157894736
      },
      {
        "id": "cae013e36dc26435043fe1ce7c014daf",
        "content": "class App extends React.Component { render() { return <h1>Hello world!</h1> } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.9105263157894736
      },
      {
        "id": "eaad0dd06cc677f81b7572b5dd5c7784",
        "content": "render()",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "ac863f346e618f9a959b5c95d5d28941",
        "content": "App",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "63a9f0ea7bb98050796b649e85481845",
        "content": "root",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1c3cc031508834569e24d5eba1e6eff7",
        "content": "ReactDOM.render(<App />, document.getElementById('root'))",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "1c3cc031508834569e24d5eba1e6eff7",
        "content": "ReactDOM.render(<App />, document.getElementById('root'))",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "eacf331f0ffc35d4b482f1d15a887d3b",
        "content": "index.html",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b9cf129aa3ea6238f49607c40c633c66",
        "content": "<!DOCTYPE html> <html> <head> <meta charset=\"utf-8\" /> <title>Hello React!</title> <script src=\"https://unpkg.com/react 16/umd/react.development.js\"></script> <script src=\"https://unpkg.com/react-dom 16/umd/react-dom.development.js\"></script> <script src=\"https://unpkg.com/babel-standalone 6.26.0/babel.js\"></script> </head> <body> <div id=\"root\"></div> <script type=\"text/babel\"> class App extends React.Component { render() { return <h1>Hello world!</h1> } } ReactDOM.render(<App />, document.getElementById('root')) </script> </body> </html>",
        "type": "code",
        "language": "html",
        "relevance": 1.0157894736842106
      },
      {
        "id": "b9cf129aa3ea6238f49607c40c633c66",
        "content": "<!DOCTYPE html> <html> <head> <meta charset=\"utf-8\" /> <title>Hello React!</title> <script src=\"https://unpkg.com/react 16/umd/react.development.js\"></script> <script src=\"https://unpkg.com/react-dom 16/umd/react-dom.development.js\"></script> <script src=\"https://unpkg.com/babel-standalone 6.26.0/babel.js\"></script> </head> <body> <div id=\"root\"></div> <script type=\"text/babel\"> class App extends React.Component { render() { return <h1>Hello world!</h1> } } ReactDOM.render(<App />, document.getElementById('root')) </script> </body> </html>",
        "type": "code",
        "language": "html",
        "relevance": 1.0157894736842106
      },
      {
        "id": "eacf331f0ffc35d4b482f1d15a887d3b",
        "content": "index.html",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "346b81a32e7007eccadf60252bb599f0",
        "content": "h1",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6982027bd07b07ef1da9885d1a581d33",
        "content": "create-react-app",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "1543ac23d99a0ee8040c576bf79a4db6",
        "content": "npx create-react-app react-tutorial",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "1543ac23d99a0ee8040c576bf79a4db6",
        "content": "npx create-react-app react-tutorial",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "287fd21e5af114e2816a33fc95eff4cd",
        "content": "cd react-tutorial npm start",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "287fd21e5af114e2816a33fc95eff4cd",
        "content": "cd react-tutorial npm start",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "93b6b6f3c7c8d824afc9cb6d0b32454c",
        "content": "localhost:3000",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "15276d0be2c414e04b17f65f7b1d8323",
        "content": "/public",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f8087e59fd95af1ae29e8fcb7ff1a3dc",
        "content": "/src",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "3ec03583f8eaec275cb2183db769ff47",
        "content": "node_modules",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a084b794bc0759e7a6b77810e01874f2",
        "content": ".gitignore",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "04c6e90faac2675aa89e2176d2eec7d8",
        "content": "README.md",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b9cfc7f2cdf78a7f4b91a753d10865a2",
        "content": "package.json",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "15276d0be2c414e04b17f65f7b1d8323",
        "content": "/public",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "eacf331f0ffc35d4b482f1d15a887d3b",
        "content": "index.html",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "eacf331f0ffc35d4b482f1d15a887d3b",
        "content": "index.html",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "63a9f0ea7bb98050796b649e85481845",
        "content": "root",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f8087e59fd95af1ae29e8fcb7ff1a3dc",
        "content": "/src",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b2ab5f978a7fb02ea77dd54e3f22b5e2",
        "content": "/src/App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "98b9fa50d982241880349227f7888e35",
        "content": "To get started, edit src/App.js and save to reload.",
        "type": "code",
        "language": "html",
        "relevance": 0.30000000000000004
      },
      {
        "id": "98b9fa50d982241880349227f7888e35",
        "content": "To get started, edit src/App.js and save to reload.",
        "type": "code",
        "language": "html",
        "relevance": 0.30000000000000004
      },
      {
        "id": "93b6b6f3c7c8d824afc9cb6d0b32454c",
        "content": "localhost:3000",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f8087e59fd95af1ae29e8fcb7ff1a3dc",
        "content": "/src",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "bca1542f88ef8253c16b452e9ad09f98",
        "content": "index.css",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "bca1542f88ef8253c16b452e9ad09f98",
        "content": "index.css",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "af342d7e43768587da652fb5e35b08a0",
        "content": "import React from 'react' import ReactDOM from 'react-dom' import './index.css'",
        "type": "code",
        "language": "jsx",
        "relevance": 0.4052631578947369
      },
      {
        "id": "af342d7e43768587da652fb5e35b08a0",
        "content": "import React from 'react' import ReactDOM from 'react-dom' import './index.css'",
        "type": "code",
        "language": "jsx",
        "relevance": 0.4052631578947369
      },
      {
        "id": "ac863f346e618f9a959b5c95d5d28941",
        "content": "App",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a5c0aa5a33c99f4179eb48443e8bb33c",
        "content": "<h1>",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "6f66e878c62db60568a3487869695820",
        "content": "className",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a2f2ed4f8ebc2cbb4c21a29dc40ab61d",
        "content": "class",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d565e6bec5224840673a390c79edebf8",
        "content": "class App extends React.Component { render() { return ( <div className=\"App\"> <h1>Hello, React!</h1> </div> ) } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.9105263157894736
      },
      {
        "id": "d565e6bec5224840673a390c79edebf8",
        "content": "class App extends React.Component { render() { return ( <div className=\"App\"> <h1>Hello, React!</h1> </div> ) } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.9105263157894736
      },
      {
        "id": "ac863f346e618f9a959b5c95d5d28941",
        "content": "App",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1c3cc031508834569e24d5eba1e6eff7",
        "content": "ReactDOM.render(<App />, document.getElementById('root'))",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "1c3cc031508834569e24d5eba1e6eff7",
        "content": "ReactDOM.render(<App />, document.getElementById('root'))",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2cb05e4bb7830be982f0922fed86b4cd",
        "content": "Component",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "72f87cd9e11869bdbd2412600293f69b",
        "content": "React.Component",
        "type": "code",
        "language": "text",
        "relevance": 0.5105263157894737
      },
      {
        "id": "f881d6b6785313b3832d9c889657f7f6",
        "content": "import React, { Component } from 'react' import ReactDOM from 'react-dom' import './index.css' class App extends Component { render() { return ( <div className=\"App\"> <h1>Hello, React!</h1> </div> ) } } ReactDOM.render(<App />, document.getElementById('root'))",
        "type": "code",
        "language": "jsx",
        "relevance": 0.9105263157894736
      },
      {
        "id": "f881d6b6785313b3832d9c889657f7f6",
        "content": "import React, { Component } from 'react' import ReactDOM from 'react-dom' import './index.css' class App extends Component { render() { return ( <div className=\"App\"> <h1>Hello, React!</h1> </div> ) } } ReactDOM.render(<App />, document.getElementById('root'))",
        "type": "code",
        "language": "jsx",
        "relevance": 0.9105263157894736
      },
      {
        "id": "93b6b6f3c7c8d824afc9cb6d0b32454c",
        "content": "localhost:3000",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9e8a7142b294f0225b62479fbe6d5768",
        "content": "const heading = <h1 className=\"site-heading\">Hello, React</h1>",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "9e8a7142b294f0225b62479fbe6d5768",
        "content": "const heading = <h1 className=\"site-heading\">Hello, React</h1>",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "46a449228c868557e794e40b8beb9e92",
        "content": "createElement",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f893e993e4d61f4a8b1027d6e9a9732e",
        "content": "const heading = React.createElement('h1', { className: 'site-heading' }, 'Hello, React!')",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "f893e993e4d61f4a8b1027d6e9a9732e",
        "content": "const heading = React.createElement('h1', { className: 'site-heading' }, 'Hello, React!')",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "6f66e878c62db60568a3487869695820",
        "content": "className",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a2f2ed4f8ebc2cbb4c21a29dc40ab61d",
        "content": "class",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a2f2ed4f8ebc2cbb4c21a29dc40ab61d",
        "content": "class",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c0bb2196426022e8adf9a5b6d34fd45e",
        "content": "onclick",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b73cab20ce55a0033ca6f07a587d0483",
        "content": "onClick",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "0a22925ab034fd09eb49cc4224720dcb",
        "content": "<img />",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "41fcbae5bf4ee4c6ecbdfe65751b7819",
        "content": "const name = 'Tania' const heading = <h1>Hello, {name}</h1>",
        "type": "code",
        "language": "jsx",
        "relevance": 0.5
      },
      {
        "id": "41fcbae5bf4ee4c6ecbdfe65751b7819",
        "content": "const name = 'Tania' const heading = <h1>Hello, {name}</h1>",
        "type": "code",
        "language": "jsx",
        "relevance": 0.5
      },
      {
        "id": "ac863f346e618f9a959b5c95d5d28941",
        "content": "App",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "ac863f346e618f9a959b5c95d5d28941",
        "content": "App",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "ac863f346e618f9a959b5c95d5d28941",
        "content": "App",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cc2947054416c43579e1a81d2e07ca19",
        "content": "import React from 'react' import ReactDOM from 'react-dom' import App from './App' import './index.css' ReactDOM.render(<App />, document.getElementById('root'))",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "cc2947054416c43579e1a81d2e07ca19",
        "content": "import React from 'react' import ReactDOM from 'react-dom' import App from './App' import './index.css' ReactDOM.render(<App />, document.getElementById('root'))",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "958f6f56cd42c904603d226cd36a57b6",
        "content": "App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "468d91615696167f448ffbf3eeb0c687",
        "content": "import React, { Component } from 'react' class App extends Component { render() { return ( <div className=\"App\"> <h1>Hello, React!</h1> </div> ) } } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 0.9105263157894736
      },
      {
        "id": "468d91615696167f448ffbf3eeb0c687",
        "content": "import React, { Component } from 'react' class App extends Component { render() { return ( <div className=\"App\"> <h1>Hello, React!</h1> </div> ) } } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 0.9105263157894736
      },
      {
        "id": "ac863f346e618f9a959b5c95d5d28941",
        "content": "App",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "ec7e359946c2643e5768203fa96c0cc4",
        "content": "Table.js",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "61a9e1bba6ce7c36dae902b6c7c70569",
        "content": "import React, { Component } from 'react' class Table extends Component { render() { return ( <table> <thead> <tr> <th>Name</th> <th>Job</th> </tr> </thead> <tbody> <tr> <td>Charlie</td> <td>Janitor</td> </tr> <tr> <td>Mac</td> <td>Bouncer</td> </tr> <tr> <td>Dee</td> <td>Aspiring actress</td> </tr> <tr> <td>Dennis</td> <td>Bartender</td> </tr> </tbody> </table> ) } } export default Table",
        "type": "code",
        "language": "jsx",
        "relevance": 1.0157894736842106
      },
      {
        "id": "61a9e1bba6ce7c36dae902b6c7c70569",
        "content": "import React, { Component } from 'react' class Table extends Component { render() { return ( <table> <thead> <tr> <th>Name</th> <th>Job</th> </tr> </thead> <tbody> <tr> <td>Charlie</td> <td>Janitor</td> </tr> <tr> <td>Mac</td> <td>Bouncer</td> </tr> <tr> <td>Dee</td> <td>Aspiring actress</td> </tr> <tr> <td>Dennis</td> <td>Bartender</td> </tr> </tbody> </table> ) } } export default Table",
        "type": "code",
        "language": "jsx",
        "relevance": 1.0157894736842106
      },
      {
        "id": "958f6f56cd42c904603d226cd36a57b6",
        "content": "App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4532dfec69d7db1bb188e5915f0f6bee",
        "content": "import Table from './Table'",
        "type": "code",
        "language": "jsx",
        "relevance": 0.4052631578947369
      },
      {
        "id": "4532dfec69d7db1bb188e5915f0f6bee",
        "content": "import Table from './Table'",
        "type": "code",
        "language": "jsx",
        "relevance": 0.4052631578947369
      },
      {
        "id": "eaad0dd06cc677f81b7572b5dd5c7784",
        "content": "render()",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "ac863f346e618f9a959b5c95d5d28941",
        "content": "App",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e42dc026ed5df883f2ba73573b2260a9",
        "content": "import React, { Component } from 'react' import Table from './Table' class App extends Component { render() { return ( <div className=\"container\"> <Table /> </div> ) } } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 1.0157894736842106
      },
      {
        "id": "e42dc026ed5df883f2ba73573b2260a9",
        "content": "import React, { Component } from 'react' import Table from './Table' class App extends Component { render() { return ( <div className=\"container\"> <Table /> </div> ) } } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 1.0157894736842106
      },
      {
        "id": "51c45b795d5d18a3e4e0c37e8b20a141",
        "content": "Table",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "a2f2ed4f8ebc2cbb4c21a29dc40ab61d",
        "content": "class",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "51c45b795d5d18a3e4e0c37e8b20a141",
        "content": "Table",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "bd3656096f358c1781328e419901b7e3",
        "content": "const TableHeader = () => { return ( <thead> <tr> <th>Name</th> <th>Job</th> </tr> </thead> ) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "bd3656096f358c1781328e419901b7e3",
        "content": "const TableHeader = () => { return ( <thead> <tr> <th>Name</th> <th>Job</th> </tr> </thead> ) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "deca14ebd67726a4674196fbffbfffe6",
        "content": "const TableBody = () => { return ( <tbody> <tr> <td>Charlie</td> <td>Janitor</td> </tr> <tr> <td>Mac</td> <td>Bouncer</td> </tr> <tr> <td>Dee</td> <td>Aspiring actress</td> </tr> <tr> <td>Dennis</td> <td>Bartender</td> </tr> </tbody> ) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "deca14ebd67726a4674196fbffbfffe6",
        "content": "const TableBody = () => { return ( <tbody> <tr> <td>Charlie</td> <td>Janitor</td> </tr> <tr> <td>Mac</td> <td>Bouncer</td> </tr> <tr> <td>Dee</td> <td>Aspiring actress</td> </tr> <tr> <td>Dennis</td> <td>Bartender</td> </tr> </tbody> ) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "51c45b795d5d18a3e4e0c37e8b20a141",
        "content": "Table",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "243175ae785741fefe614e32a751a575",
        "content": "TableHeader",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "4055948244a47792d78b4cae250815ed",
        "content": "TableBody",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "51c45b795d5d18a3e4e0c37e8b20a141",
        "content": "Table",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "6f8776bcf57f6a74404aca60423e2207",
        "content": "const TableHeader = () => { ... } const TableBody = () => { ... } class Table extends Component { render() { return ( <table> <TableHeader /> <TableBody /> </table> ) } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.9105263157894736
      },
      {
        "id": "6f8776bcf57f6a74404aca60423e2207",
        "content": "const TableHeader = () => { ... } const TableBody = () => { ... } class Table extends Component { render() { return ( <table> <TableHeader /> <TableBody /> </table> ) } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.9105263157894736
      },
      {
        "id": "eaad0dd06cc677f81b7572b5dd5c7784",
        "content": "render()",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "e70c4df10ef0983b9c8c31bd06b2a2c3",
        "content": "return",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "74e8a00160e36caada2c3ef081f90b8c",
        "content": "const SimpleComponent = () => { return <div>Example</div> }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "74e8a00160e36caada2c3ef081f90b8c",
        "content": "const SimpleComponent = () => { return <div>Example</div> }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "3f628778705749afa5f2910d74f4c57c",
        "content": "class ClassComponent extends Component { render() { return <div>Example</div> } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8052631578947369
      },
      {
        "id": "3f628778705749afa5f2910d74f4c57c",
        "content": "class ClassComponent extends Component { render() { return <div>Example</div> } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8052631578947369
      },
      {
        "id": "e70c4df10ef0983b9c8c31bd06b2a2c3",
        "content": "return",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "51c45b795d5d18a3e4e0c37e8b20a141",
        "content": "Table",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "4055948244a47792d78b4cae250815ed",
        "content": "TableBody",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "0e27f99f9788960a931be9c2ed62c41e",
        "content": "const TableBody = () => { return <tbody /> }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "0e27f99f9788960a931be9c2ed62c41e",
        "content": "const TableBody = () => { return <tbody /> }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "eaad0dd06cc677f81b7572b5dd5c7784",
        "content": "render()",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "02fe62da4e9d5c0bd29602659c2fa368",
        "content": "class App extends Component { render() { const characters = [ { name: 'Charlie', job: 'Janitor', }, { name: 'Mac', job: 'Bouncer', }, { name: 'Dee', job: 'Aspring actress', }, { name: 'Dennis', job: 'Bartender', }, ] return ( <div className=\"container\"> <Table /> </div> ) } }",
        "type": "code",
        "language": "jsx",
        "relevance": 1.1105263157894738
      },
      {
        "id": "02fe62da4e9d5c0bd29602659c2fa368",
        "content": "class App extends Component { render() { const characters = [ { name: 'Charlie', job: 'Janitor', }, { name: 'Mac', job: 'Bouncer', }, { name: 'Dee', job: 'Aspring actress', }, { name: 'Dennis', job: 'Bartender', }, ] return ( <div className=\"container\"> <Table /> </div> ) } }",
        "type": "code",
        "language": "jsx",
        "relevance": 1.1105263157894738
      },
      {
        "id": "51c45b795d5d18a3e4e0c37e8b20a141",
        "content": "Table",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "7d1ded3b6ae6cb9b140c40c58f88bf45",
        "content": "data-",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "18445622d32487497f974b2f2ab78bd6",
        "content": "characterData",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2593c7ce3ff937293feb1e61c152e551",
        "content": "characters",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "3aea093bd460be44d80e2bfacde247cb",
        "content": "return ( <div className=\"container\"> <Table characterData={characters} /> </div> )",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "3aea093bd460be44d80e2bfacde247cb",
        "content": "return ( <div className=\"container\"> <Table characterData={characters} /> </div> )",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "51c45b795d5d18a3e4e0c37e8b20a141",
        "content": "Table",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "e3311701faa3d48d08b62029cf3b0d11",
        "content": "class Table extends Component { render() { const { characterData } = this.props return ( <table> <TableHeader /> <TableBody characterData={characterData} /> </table> ) } }",
        "type": "code",
        "language": "jsx",
        "relevance": 1.0157894736842106
      },
      {
        "id": "e3311701faa3d48d08b62029cf3b0d11",
        "content": "class Table extends Component { render() { const { characterData } = this.props return ( <table> <TableHeader /> <TableBody characterData={characterData} /> </table> ) } }",
        "type": "code",
        "language": "jsx",
        "relevance": 1.0157894736842106
      },
      {
        "id": "51c45b795d5d18a3e4e0c37e8b20a141",
        "content": "Table",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "51c45b795d5d18a3e4e0c37e8b20a141",
        "content": "Table",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "c53d3d7b16dbed35f1be50aab84231c6",
        "content": "this.props",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "01c1034c012e4ac78b4ad51a9bf59e5a",
        "content": "this.props.characterData",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "01c1034c012e4ac78b4ad51a9bf59e5a",
        "content": "this.props.characterData",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "5440fef7ecbe96413823107de1f0c8a7",
        "content": "const { characterData } = this.props",
        "type": "code",
        "language": "jsx",
        "relevance": 0.4052631578947369
      },
      {
        "id": "5440fef7ecbe96413823107de1f0c8a7",
        "content": "const { characterData } = this.props",
        "type": "code",
        "language": "jsx",
        "relevance": 0.4052631578947369
      },
      {
        "id": "51c45b795d5d18a3e4e0c37e8b20a141",
        "content": "Table",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "4055948244a47792d78b4cae250815ed",
        "content": "TableBody",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "e3311701faa3d48d08b62029cf3b0d11",
        "content": "class Table extends Component { render() { const { characterData } = this.props return ( <table> <TableHeader /> <TableBody characterData={characterData} /> </table> ) } }",
        "type": "code",
        "language": "jsx",
        "relevance": 1.0157894736842106
      },
      {
        "id": "e3311701faa3d48d08b62029cf3b0d11",
        "content": "class Table extends Component { render() { const { characterData } = this.props return ( <table> <TableHeader /> <TableBody characterData={characterData} /> </table> ) } }",
        "type": "code",
        "language": "jsx",
        "relevance": 1.0157894736842106
      },
      {
        "id": "4055948244a47792d78b4cae250815ed",
        "content": "TableBody",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "0e27f99f9788960a931be9c2ed62c41e",
        "content": "const TableBody = () => { return <tbody /> }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "0e27f99f9788960a931be9c2ed62c41e",
        "content": "const TableBody = () => { return <tbody /> }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "df347a373b8f92aa0ae3dd920a5ec2f6",
        "content": "rows",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "be04acf6dc129aa11fa0b31f0e9c0760",
        "content": "const TableBody = (props) => { const rows = props.characterData.map((row, index) => { return ( <tr key={index}> <td>{row.name}</td> <td>{row.job}</td> </tr> ) }) return <tbody>{rows}</tbody> }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "be04acf6dc129aa11fa0b31f0e9c0760",
        "content": "const TableBody = (props) => { const rows = props.characterData.map((row, index) => { return ( <tr key={index}> <td>{row.name}</td> <td>{row.job}</td> </tr> ) }) return <tbody>{rows}</tbody> }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "9ed39e2ea931586b6a985a6942ef573e",
        "content": "state",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "b9cb59d33e5308a35b715d1aa12993b8",
        "content": "class App extends Component { state = {} }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.5105263157894737
      },
      {
        "id": "b9cb59d33e5308a35b715d1aa12993b8",
        "content": "class App extends Component { state = {} }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.5105263157894737
      },
      {
        "id": "2593c7ce3ff937293feb1e61c152e551",
        "content": "characters",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c31e85535aab549917c64ede546d0afe",
        "content": "class App extends Component { state = { characters: [], } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "c31e85535aab549917c64ede546d0afe",
        "content": "class App extends Component { state = { characters: [], } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "1b1795852cd38599203df5d68f24eeef",
        "content": "state.characters",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "2eeb7c3331068262c7c507007ea57899",
        "content": "class App extends Component { state = { characters: [ { name: 'Charlie', // the rest of the data }, ], } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "2eeb7c3331068262c7c507007ea57899",
        "content": "class App extends Component { state = { characters: [ { name: 'Charlie', // the rest of the data }, ], } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "9d1cd66f1ce0c29cd004bce650ddc5f0",
        "content": "removeCharacter",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "ac863f346e618f9a959b5c95d5d28941",
        "content": "App",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b06cb30aa115c3e3aa8f68dbcbc2a7c7",
        "content": "this.state.characters",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "cdac83b557f8342614698fbb64895564",
        "content": "this.setState()",
        "type": "code",
        "language": "text",
        "relevance": 0.605263157894737
      },
      {
        "id": "6a992d5529f459a44fee58c733255e86",
        "content": "index",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cdac83b557f8342614698fbb64895564",
        "content": "this.setState()",
        "type": "code",
        "language": "text",
        "relevance": 0.605263157894737
      },
      {
        "id": "f25f742413fc52b2aa761177a8bd8910",
        "content": "this.state.property",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "fafce4f322d0d0981424d9ebfc874c64",
        "content": "removeCharacter = (index) => { const { characters } = this.state this.setState({ characters: characters.filter((character, i) => { return i !== index }), }) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "fafce4f322d0d0981424d9ebfc874c64",
        "content": "removeCharacter = (index) => { const { characters } = this.state this.setState({ characters: characters.filter((character, i) => { return i !== index }), }) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "b2c97ae425dd751b0e48a3acae79cf4a",
        "content": "filter",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9d1cd66f1ce0c29cd004bce650ddc5f0",
        "content": "removeCharacter",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "51c45b795d5d18a3e4e0c37e8b20a141",
        "content": "Table",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "16a5a63872d456ccc7ffa7b9a64bbefe",
        "content": "render() { const { characters } = this.state return ( <div className=\"container\"> <Table characterData={characters} removeCharacter={this.removeCharacter} /> </div> ) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.9105263157894736
      },
      {
        "id": "16a5a63872d456ccc7ffa7b9a64bbefe",
        "content": "render() { const { characters } = this.state return ( <div className=\"container\"> <Table characterData={characters} removeCharacter={this.removeCharacter} /> </div> ) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.9105263157894736
      },
      {
        "id": "4055948244a47792d78b4cae250815ed",
        "content": "TableBody",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "51c45b795d5d18a3e4e0c37e8b20a141",
        "content": "Table",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "ac863f346e618f9a959b5c95d5d28941",
        "content": "App",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d359c6df99b25183d81f7d728b71de0e",
        "content": "Form",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "51c45b795d5d18a3e4e0c37e8b20a141",
        "content": "Table",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "22ddb1d5762f0534c19f594dbd544b4f",
        "content": "const Table = (props) => { const { characterData, removeCharacter } = props return ( <table> <TableHeader /> <TableBody characterData={characterData} removeCharacter={removeCharacter} /> </table> ) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "22ddb1d5762f0534c19f594dbd544b4f",
        "content": "const Table = (props) => { const { characterData, removeCharacter } = props return ( <table> <TableHeader /> <TableBody characterData={characterData} removeCharacter={removeCharacter} /> </table> ) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "c26c0c055c72bbe97e26291f6722e06d",
        "content": "removeCharacter()",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "4055948244a47792d78b4cae250815ed",
        "content": "TableBody",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "b73cab20ce55a0033ca6f07a587d0483",
        "content": "onClick",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "0e2feeffb1143844bfd111a98352ccc7",
        "content": "<tr key={index}> <td>{row.name}</td> <td>{row.job}</td> <td> <button onClick={() => props.removeCharacter(index)}>Delete</button> </td> </tr>",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "0e2feeffb1143844bfd111a98352ccc7",
        "content": "<tr key={index}> <td>{row.name}</td> <td>{row.job}</td> <td> <button onClick={() => props.removeCharacter(index)}>Delete</button> </td> </tr>",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "b73cab20ce55a0033ca6f07a587d0483",
        "content": "onClick",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c26c0c055c72bbe97e26291f6722e06d",
        "content": "removeCharacter()",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "1b1795852cd38599203df5d68f24eeef",
        "content": "state.characters",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "c31e85535aab549917c64ede546d0afe",
        "content": "class App extends Component { state = { characters: [], } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "c31e85535aab549917c64ede546d0afe",
        "content": "class App extends Component { state = { characters: [], } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "d359c6df99b25183d81f7d728b71de0e",
        "content": "Form",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "01af090bd902122397fb0ba2ed69a492",
        "content": "Form.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d359c6df99b25183d81f7d728b71de0e",
        "content": "Form",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "04ff956a54ccbc109bb36e11676838f8",
        "content": "this.state",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "9489459b3f3efd56d5ee146c21137076",
        "content": "import React, { Component } from 'react' class Form extends Component { initialState = { name: '', job: '', } state = this.initialState }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8157894736842106
      },
      {
        "id": "9489459b3f3efd56d5ee146c21137076",
        "content": "import React, { Component } from 'react' class Form extends Component { initialState = { name: '', job: '', } state = this.initialState }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8157894736842106
      },
      {
        "id": "6700209fa95cd3c045da7b7ed8b3404c",
        "content": "constructor()",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "d359c6df99b25183d81f7d728b71de0e",
        "content": "Form",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "ac863f346e618f9a959b5c95d5d28941",
        "content": "App",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "51c45b795d5d18a3e4e0c37e8b20a141",
        "content": "Table",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "4119639092e62c55ea8be348e4d9260d",
        "content": "event",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d359c6df99b25183d81f7d728b71de0e",
        "content": "Form",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b068931cc450442b63f5b3d276ea4297",
        "content": "name",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2063c1608d6e0baf80249c42e2be5804",
        "content": "value",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "db2f71434bbde19237656b0d457a7701",
        "content": "handleChange = (event) => { const { name, value } = event.target this.setState({ [name]: value, }) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.4052631578947369
      },
      {
        "id": "db2f71434bbde19237656b0d457a7701",
        "content": "handleChange = (event) => { const { name, value } = event.target this.setState({ [name]: value, }) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.4052631578947369
      },
      {
        "id": "6f43202a226958b58e362a25c2d7c5eb",
        "content": "handleChange()",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "ec11d8e248160aceed4b88aafec7274e",
        "content": "onChange",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d359c6df99b25183d81f7d728b71de0e",
        "content": "Form",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a5286767075279ee6be47b44905adb37",
        "content": "render() { const { name, job } = this.state return ( <form> <label htmlFor=\"name\">Name</label> <input type=\"text\" name=\"name\" id=\"name\" value={name} onChange={this.handleChange} /> <label htmlFor=\"job\">Job</label> <input type=\"text\" name=\"job\" id=\"job\" value={job} onChange={this.handleChange} /> </form> ) } export default Form",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8052631578947369
      },
      {
        "id": "a5286767075279ee6be47b44905adb37",
        "content": "render() { const { name, job } = this.state return ( <form> <label htmlFor=\"name\">Name</label> <input type=\"text\" name=\"name\" id=\"name\" value={name} onChange={this.handleChange} /> <label htmlFor=\"job\">Job</label> <input type=\"text\" name=\"job\" id=\"job\" value={job} onChange={this.handleChange} /> </form> ) } export default Form",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8052631578947369
      },
      {
        "id": "958f6f56cd42c904603d226cd36a57b6",
        "content": "App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6db13462fa2dbeeb820143baf47aba19",
        "content": "import Form from './Form'",
        "type": "code",
        "language": "jsx",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6db13462fa2dbeeb820143baf47aba19",
        "content": "import Form from './Form'",
        "type": "code",
        "language": "jsx",
        "relevance": 0.30000000000000004
      },
      {
        "id": "bf958772f156df639140fe79f5a7f512",
        "content": "return ( <div className=\"container\"> <Table characterData={characters} removeCharacter={this.removeCharacter} /> <Form /> </div> )",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "bf958772f156df639140fe79f5a7f512",
        "content": "return ( <div className=\"container\"> <Table characterData={characters} removeCharacter={this.removeCharacter} /> <Form /> </div> )",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "d359c6df99b25183d81f7d728b71de0e",
        "content": "Form",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "58796cc24b9e23688eb941779bb254a1",
        "content": "handleSubmit()",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "ac863f346e618f9a959b5c95d5d28941",
        "content": "App",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b06cb30aa115c3e3aa8f68dbcbc2a7c7",
        "content": "this.state.characters",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "a956161a69928cd130a889b88082fb6e",
        "content": "character",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e7537620328a1e7e61ea0ec240639796",
        "content": "handleSubmit = (character) => { this.setState({ characters: [...this.state.characters, character] }) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "e7537620328a1e7e61ea0ec240639796",
        "content": "handleSubmit = (character) => { this.setState({ characters: [...this.state.characters, character] }) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "d359c6df99b25183d81f7d728b71de0e",
        "content": "Form",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "89ca19ac901aad9aca79d80621b6522d",
        "content": "<Form handleSubmit={this.handleSubmit} />",
        "type": "code",
        "language": "jsx",
        "relevance": 0.5
      },
      {
        "id": "89ca19ac901aad9aca79d80621b6522d",
        "content": "<Form handleSubmit={this.handleSubmit} />",
        "type": "code",
        "language": "jsx",
        "relevance": 0.5
      },
      {
        "id": "d359c6df99b25183d81f7d728b71de0e",
        "content": "Form",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "35f3c77c027c305018831dc73615df74",
        "content": "submitForm()",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "d359c6df99b25183d81f7d728b71de0e",
        "content": "Form",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a956161a69928cd130a889b88082fb6e",
        "content": "character",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1ab9be44d955c6530e3dbdcea2d790e2",
        "content": "submitForm = () => { this.props.handleSubmit(this.state) this.setState(this.initialState) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.5105263157894737
      },
      {
        "id": "1ab9be44d955c6530e3dbdcea2d790e2",
        "content": "submitForm = () => { this.props.handleSubmit(this.state) this.setState(this.initialState) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.5105263157894737
      },
      {
        "id": "b73cab20ce55a0033ca6f07a587d0483",
        "content": "onClick",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e7f332a88955d3c0540bb7639f463e74",
        "content": "onSubmit",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a1f86c5413c3cd87c53ce6d363d66083",
        "content": "submitForm",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "69953ede50af1f7ae0b93d63852f46b6",
        "content": "<input type=\"button\" value=\"Submit\" onClick={this.submitForm} />",
        "type": "code",
        "language": "jsx",
        "relevance": 0.5
      },
      {
        "id": "69953ede50af1f7ae0b93d63852f46b6",
        "content": "<input type=\"button\" value=\"Submit\" onClick={this.submitForm} />",
        "type": "code",
        "language": "jsx",
        "relevance": 0.5
      },
      {
        "id": "51c45b795d5d18a3e4e0c37e8b20a141",
        "content": "Table",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "4055948244a47792d78b4cae250815ed",
        "content": "TableBody",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "1e6ee2a4e902f5cad3fb8e000169663c",
        "content": "Api.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "ac863f346e618f9a959b5c95d5d28941",
        "content": "App",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "19d48a4b15179476413c203716f6abd5",
        "content": "import App from './Api'",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "3a7b8ee91a6eeefee48053e53085e6ae",
        "content": "componentDidMount()",
        "type": "code",
        "language": "text",
        "relevance": 0.605263157894737
      },
      {
        "id": "a5bfcf7e4fe575c28923c968c46eadc2",
        "content": "componentDidMount",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "0fcb127de14daa7c185a27e1d99d46c8",
        "content": "import React, { Component } from 'react' class App extends Component { state = { data: [], } // Code is invoked after the component is mounted/inserted into the DOM tree. componentDidMount() { const url = 'https://en.wikipedia.org/w/api.php?action=opensearch search=Seona+Dancing format=json origin=*' fetch(url) .then((result) => result.json()) .then((result) => { this.setState({ data: result, }) }) } render() { const { data } = this.state const result = data.map((entry, index) => { return <li key={index}>{entry}</li> }) return <ul>{result}</ul> } } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "0fcb127de14daa7c185a27e1d99d46c8",
        "content": "import React, { Component } from 'react' class App extends Component { state = { data: [], } // Code is invoked after the component is mounted/inserted into the DOM tree. componentDidMount() { const url = 'https://en.wikipedia.org/w/api.php?action=opensearch search=Seona+Dancing format=json origin=*' fetch(url) .then((result) => result.json()) .then((result) => { this.setState({ data: result, }) }) } render() { const { data } = this.state const result = data.map((entry, index) => { return <li key={index}>{entry}</li> }) return <ul>{result}</ul> } } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "f73820457e78d14766df9b3bc17ae9cd",
        "content": "npm run build",
        "type": "code",
        "language": "shell",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f73820457e78d14766df9b3bc17ae9cd",
        "content": "npm run build",
        "type": "code",
        "language": "shell",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b0da275520918e23dd615e2a747528f1",
        "content": "build",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "ba3988db0a3167093b1f74e8ae4a8e83",
        "content": "homepage",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b9cfc7f2cdf78a7f4b91a753d10865a2",
        "content": "package.json",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "01ab68da510b6d2e9bfa3586329902bc",
        "content": "\"homepage\": \"https://taniarascia.github.io/react-tutorial\",",
        "type": "code",
        "language": "js",
        "relevance": 0.4052631578947369
      },
      {
        "id": "01ab68da510b6d2e9bfa3586329902bc",
        "content": "\"homepage\": \"https://taniarascia.github.io/react-tutorial\",",
        "type": "code",
        "language": "js",
        "relevance": 0.4052631578947369
      },
      {
        "id": "d6c5855a62cf32a4dadbc2831f0f295f",
        "content": "scripts",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "428573dd74f50a40f0646eaba109f273",
        "content": "\"scripts\": { // ... \"predeploy\": \"npm run build\", \"deploy\": \"gh-pages -d build\" }",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "428573dd74f50a40f0646eaba109f273",
        "content": "\"scripts\": { // ... \"predeploy\": \"npm run build\", \"deploy\": \"gh-pages -d build\" }",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cd0ad3fd552a8dfd873ddfd5628ea6f5",
        "content": "gh-pages",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "0116ac15f5e59a80c2094286dd4e58d8",
        "content": "npm install --save-dev gh-pages",
        "type": "code",
        "language": "shell",
        "relevance": 0.30000000000000004
      },
      {
        "id": "0116ac15f5e59a80c2094286dd4e58d8",
        "content": "npm install --save-dev gh-pages",
        "type": "code",
        "language": "shell",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b0da275520918e23dd615e2a747528f1",
        "content": "build",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f73820457e78d14766df9b3bc17ae9cd",
        "content": "npm run build",
        "type": "code",
        "language": "shell",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f73820457e78d14766df9b3bc17ae9cd",
        "content": "npm run build",
        "type": "code",
        "language": "shell",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cd0ad3fd552a8dfd873ddfd5628ea6f5",
        "content": "gh-pages",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d6f9339c12b5aa05694b358d4e4713f8",
        "content": "npm run deploy",
        "type": "code",
        "language": "shell",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d6f9339c12b5aa05694b358d4e4713f8",
        "content": "npm run deploy",
        "type": "code",
        "language": "shell",
        "relevance": 0.30000000000000004
      }
    ]
  },
  {
    "metadata": {
      "description": "Do you have experience using React? Have you heard of Redux, but you've put off learning it because it looks very complicated and all the…",
      "url": "https://www.taniarascia.com/redux-react-guide/",
      "title": "How to Use Redux and React | Tania Rascia's Personal Website",
      "source_type": "web",
      "crawl_time": 1730107271.5590951,
      "keywords": [
        "sql",
        "web",
        "article",
        "extract",
        "development",
        "information",
        "react"
      ]
    },
    "relevance_score": 0.9331891891891891,
    "chunks": [
      {
        "content": "How to Use Redux and ReactDo you have experience usingReact? Have you heard ofRedux, but you've put off learning it because it looks very complicated and all the guides seem overwhelming? If that's the case, this is the article for you! Contain your fear of containing state and come along with me on this relatively painless journey.PrerequisitesYou must already know how to use React for this tutorial, as I will not be explaining any aspects of React itself.Familiarity withHTML & CSS.Familiarity withES6 syntax and features.Knowledge of React terminology:JSX, State, Components, Props, LifecycleandHooksKnowledge ofReact RouterKnowledge of asynchronous JavaScript andmaking API callsAlso, download Redux DevToolsfor Chromeorfor FireFox.GoalsIn this tutorial, we will build a small blog app. It will fetch posts and comments from an API. I've created the same app with both plain Redux, andRedux Toolkit(RTK), the officially sanctioned toolset for Redux. Here are the links to the source and demos of both the plain and RTK versions.React + Redux Application (Plain Redux)SourceDemo ApplicationReact + Redux Toolkit ApplicationSourceDemo ApplicationNote: The applications are pulling from a real API viaJSON Placeholder API. Due to rate limiting on CodeSandbox, the API may appear slow, but it has nothing to do with the Redux application itself. You can also clone the repository locally.We will learn:Whatis Redux andwhyyou might want to use itTheterminologyof Redux: actions, reducers, store, dispatch, connect, and containerMaking asynchronous API calls withRedux ThunkHow to make a small, real-world application with React and ReduxHow to use Redux Toolkit to simplify Redux app developmentWhat is Redux?Redux is a state container for JavaScript applications. Normally with React, you manage state at a component level, and pass state around via props. With Redux, the entire state of your application is managed in one immutable object. Every update to the Redux state results in a copy of sections of the state, plus the new change.Redux was originally created byDan AbramovandAndrew Clark.Why should I use Redux?Easily manage global state- access or update any part of the state from any Redux-connected componentEasily keep track of changes with Redux DevTools- any action or state change is tracked and easy to follow with Redux. The fact that the entire state of the application is tracked with each change means you can easily do time-travel debugging to move back and forth between changes.The downside to Redux is that there's a lot of initial boilerplate to set up and maintain (especially if you use plain Redux without Redux Toolkit). A smaller applicationmay not need Reduxand may instead benefit from simply usingthe Context APIfor global state needs.In my personal experience, I set up an application with Context alone, and later needed to convert everything over to Redux to make it more maintainable and organized.TerminologyUsually I don't like to just make a list of terms and definitions, but Redux has a few that are likely unfamiliar, so I'm just going to define them all up front to make it easy to refer back to them. Although you canskip to the beginning of the tutorial section, I think it would be good to read through all the definitions just to get exposure and an idea of them in your head first.ActionsReducersStoreDispatchConnectI'll just use the typical todo application, and the action of deleting a todo, for the examples.ActionsAnactionsends data from your application to the Redux store. An action is conventionally an object with two properties:typeand (optional)payload. The type is generally an uppercase string (assigned to a constant) that describes the action. The payload is additional data that may be passed.Action TypeconstDELETE_TODO='posts/deleteTodo'Action{type:DELETE_TODO,payload:id,} ction creatorsAnaction creatoris a function that returns an action.Action CreatorconstdeleteTodo=(id)=>({type:DELETE_TODO,payload:id})ReducersAreduceris a function that takes two parameters:stateandaction. A reducer is immutable and always returns a copy of the entire state. A reducer typically consists of aswitchstatement that goes through all the possible action types.ReducerconstinitialState={todos:[{id:1,text:'Eat'},{id:2,text:'Sleep'},],loading:false,hasErrors:false,} unctiontodoReducer(state=initialState,action){switch(action.type){caseDELETE_TODO:return{...state,todos:state.todos.filter((todo)=>todo.id!==action.payload),} efault:returnstate}} toreThe Redux application state lives in thestore, which is initialized with a reducer. When used with React, a<Provider>exists to wrap the application, and anything within the Provider can have access to Redux.Storeimport{createStore} rom'redux'import{Provider} rom'react-redux'importreducerfrom'./reducers'conststore=createStore(reducer)render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Dispatchdispatchis a method available on the store object that accepts an object which is used to update the Redux state. Usually, this object is the result of invoking an action creator.constComponent=({dispatch})=>{useEffect(()=>{dispatch(deleteTodo())},[dispatch])} onnectTheconnect()function is one typical way to connect React to Redux. A connected component is sometimes referred to as acontainer.Okay, that about covers it for the major terms of Redux. It can be overwhelming to read the terminology without any context, so let's begin.Getting StartedFor ease of getting started quickly, my example usesCreate React Appto set up the environment.npx create-react-app redux-tutorialcdredux-tutorialRedux requires a few dependencies.Redux- Core libraryReact Redux- React bindings for ReduxRedux Thunk- Async middleware for ReduxRedux DevTools Extension- Connects Redux app to Redux DevToolsYou canyarn addornpm ithem, and I'll be usingreact-router-domas well, but that's it for extra dependencies.npmi\\redux\\react-redux\\redux-thunk\\redux-devtools-extension\\react-router-domAnd delete all the boilerplate. We'll add everything we need from scratch instead.cdsrc&&rm*# move to src and delete all files withinWe'll make directories for Reduxreducersand Reduxactions, as well aspagesandcomponentswhich you should already be familiar with from React.mkdiractions components pages reducersAnd we'll bring backindex.js,App.js, andindex.css.touchindex.js index.css App.jsSo at this point your project directory tree looks like this.└── src/\n    ├── actions/\n    ├── components/\n    ├── pages/\n    ├── reducers/\n    ├── App.js\n    ├── index.css\n    └── index.jsFor theindex.cssfile, just take the contents ofthis gistand paste it. I intend only to go over functionality and not anything about style, so I just wrote some very basic styles to ensure the site looks decent enough.Now we have enough boilerplate to get started, so we'll begin working on the entrypoint.Setting up the Redux StoreWhen I first started learning Redux, it seemed so overwhelming because every app I looked at hadindex.jsset up a bit differently.",
        "chunk_type": "code_markup",
        "tag": "main",
        "score": 1.1219999999999999,
        "word_count": 933,
        "chunk_id": "657514346dca44a325e6412500ee416d",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "article",
            "development",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "After looking at a lot of the more up-to-date apps and taking the aspects that were common across all of them, I got a good feel for what should really be in a Redux app, and what is just people moving things around to be unique.There are plenty of tutorials out there that show you how to get a very basic Redux store with todos set up, but I don't find that very useful for knowing how to make a production level setup, so I'm going to set it up with everything you need from the get-go. Even so, there will be some opinionated aspects because Redux is very flexible.Inindex.js, we'll be bringing in a few things.createStore, to create the store that will maintain the Redux stateapplyMiddleware, to be able to use middleware, in this casethunkProvider, to wrap the entire application in Reduxthunk, a middleware that allows us to make asynchronous actions in ReduxcomposeWithDevTools, code that connects your app to Redux DevToolsindex.js// External importsimportReactfrom'react'import{render} rom'react-dom'import{createStore,applyMiddleware} rom'redux'import{Provider} rom'react-redux'importthunkfrom'redux-thunk'import{composeWithDevTools} rom'redux-devtools-extension'// Local importsimportAppfrom'./App'importrootReducerfrom'./reducers'// Assetsimport'./index.css'conststore=createStore(rootReducer,composeWithDevTools(applyMiddleware(thunk)))render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Put a component inApp.js. We'll modify this later, but we just want to get the app up and running for now.App.jsimportReactfrom'react'constApp=()=>{return<div>Hello, Redux</div>} xportdefaultAppBringing in reducersThe last thing to do is bring in the reducer. Areduceris a function that determines changes to Redux state. It is a pure function that returns a copy of the state with the new change.A neat feature of Redux is that we can have many reducers, and combine them all into one root reducer that the store uses, usingcombineReducers. This leads to us being able to easily organize our code while still having everything in one root state tree.Since this app will be like a blog, it will have a list of posts, and we'll put that in thepostsReducerin a moment. Having thiscombineReducersmethod allows us to bring whatever we want in - acommentsReducer, anauthReducer, and so on.Inreducers/index.js, create the file that will combine all reducers.reducers/index.jsimport{combineReducers} rom'redux'importpostsReducerfrom'./postsReducer'constrootReducer=combineReducers({posts:postsReducer,})exportdefaultrootReducerFinally, we'll make thepostsReducer. We can set it up with an initial state. Just like you might expect from a regular React component, we'll have aloadingandhasErrorsstate, as well as apostsarray, where all the posts will live. First we'll set it up with no actions in the switch, just a default case that returns the entire state.reducers/postsReducer.jsexportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow we at least have enough setup that the application will load without crashing.Redux DevToolsWith the application loading and the Redux<Provider>set up, we can take a look at Redux DevTools. After downloading it, it'll be a tab in your Developer Tools. If you click onState, you'll see the entire state of the application so far.There's not much in here yet, but Redux DevTools is amazing once you get to having a lot of reducers and actions. It keeps track of all changes to your app and makes debugging a breeze compared to plain React.Setting up Redux ActionsSo now we have a reducer for posts, but we don't have any actions, meaning the reducer will only return the state without modifying it in any way.Actionsare how we communicate with the Redux store. For this blog app, we're going to want to fetch posts from an API and put them in our Redux state.Since fetching posts is an asynchronous action, it will require the use of Redux thunk. Fortunately, we don't have to do anything special to use thunk beyond setting it up in the store, which we already did.Create aactions/postsActions.js. First, we'll define theaction typesas constants. This is not necessary, but is a common convention, and makes it easy to export the actions around and prevent typos. We want to do three things:getPosts- begin telling Redux we're going to fetch posts from an APIgetPostsSuccess- pass the posts to Redux on successful API callgetPostsFailure- inform Redux that an error was encountered during Redux on failed API callactions/postsActions.js// Create Redux action typesexportconstGET_POSTS='GET_POSTS'exportconstGET_POSTS_SUCCESS='GET_POSTS_SUCCESS'exportconstGET_POSTS_FAILURE='GET_POSTS_FAILURE'Then createaction creators, functions that return anaction, which consists of the type and an optional payload containing data.actions/postsActions.js// Create Redux action creators that return an actionexportconstgetPosts=()=>({type:GET_POSTS,})exportconstgetPostsSuccess=(posts)=>({type:GET_POSTS_SUCCESS,payload:posts,})exportconstgetPostsFailure=()=>({type:GET_POSTS_FAILURE,})Finally, make the asynchronous thunk action that combines all three of the above actions. When called, it will dispatch the initialgetPosts()action to inform Redux to prepare for an API call, then in atry/catch, do everything necessary to get the data, and dispatch a success or failure action as necessary.actions/postsActions.js// Combine them all in an asynchronous thunkexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} reat, we're all done with creating actions now! All that's left to do is tell the reducer what to do with the state on each action.Responding to actionsBack at our post reducer, we have a switch that isn't doing anything yet.reducers/postsReducer.jsexportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow that we have actions, we can bring them in from thepostsActionspage.// Import all actionsimport*asactionsfrom'../actions/postsActions'For each action, we'll make acase, that returns the entire state plus whatever change we're making to it. ForGET_POSTS, for example, all we want to do is tell the app to setloadingtotruesince we'll be making an API call.caseactions.GET_POSTS:return{...state,loading:true} ET_POSTS- begin loadingGET_POSTS_SUCCESS- the app has posts, no errors, and should stop loadingGET_POSTS_FAILURE- the app has errors and should stop loadingHere's the whole reducer.reducers/postsReducer.jsimport*asactionsfrom'../actions/postsActions'exportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){caseactions.GET_POSTS:return{...state,loading:true} aseactions.GET_POSTS_SUCCESS:return{posts:action.payload,loading:false,hasErrors:false} aseactions.GET_POSTS_FAILURE:return{...state,loading:false,hasErrors:true} efault:returnstate}} ow our actions and reducers are ready, so all that's left to do is connect everything to the React app.Connecting Redux to React ComponentsSince the demo app I've created uses React Router to have a few routes - a dashboard, a listing of all posts, and an individual posts page, I'll bring React Router in now. I'll just bring in the dashboard and all posts listing for this demo.App.jsimportReactfrom'react'import{BrowserRouterasRouter,Switch,Route,Redirect} rom'react-router-dom'importDashboardPagefrom'./pages/DashboardPage'importPostsPagefrom'./pages/PostsPage'constApp=()=>{return(<Router><Switch><Routeexactpath=\"/\"component={DashboardPage}/><Routeexactpath=\"/posts\"component={PostsPage}/><Redirectto=\"/\"/></Switch></Router>)} xportdefaultAppWe can create the dashboard page, which is just a regular React component.pages/DashboardPage.jsimportReactfrom'react'import{Link} rom'react-router-dom'constDashboardPage=()=>(<section><h1>Dashboard</h1><p>This is the dashboard.</p><Linkto=\"/posts\"className=\"button\">View Posts</Link></section>)exportdefaultDashboardPageFor each post, let's make aPostcomponent that will display the title and an excerpt of the text of the article. Make aPost.jsin thecomponentssubdirectory.components/Post.jsimportReactfrom'react'exportconstPost=({post})=>(<articleclassName=\"post-excerpt\"><h2>{post.title}</h2><p>{post.body.substring(0,100)}</p></article>)Components that do not connect to Redux are still important and useful for smaller, reusable areas, such as this Post component.Now the interesting part comes in for the posts page - bringing Redux into React. To do this we'll useconnectfromreact-redux. First, we'll just make a regular component for the page.pages/PostsPage.jsimportReactfrom'react'constPostsPage=()=>{return(<section><h1>Posts</h1></section>)} xportdefaultPostsPageThen we'll bring inconnect.",
        "chunk_type": "code_markup",
        "tag": "main",
        "score": 1.1219999999999999,
        "word_count": 1000,
        "chunk_id": "ce44a83cb22103e6a639d48b1d686d36",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Theconnect functionis a higher-order function that connects the Redux store to a React component. We'll pass a parameter calledmapStateToPropstoconnect. This aptly named function will take any state from the Redux store and pass it to the props of the React component. We'll bring inloading,posts, andhasErrorsfrom the ReduxpostsReducer.pages/PostsPage.jsimportReactfrom'react'import{connect} rom'react-redux'// Redux state is now in the props of the componentconstPostsPage=({loading,posts,hasErrors})=>{return(<section><h1>Posts</h1></section>)}// Map Redux state to React component propsconstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})// Connect Redux to Reactexportdefaultconnect(mapStateToProps)(PostsPage)Since this component uses state from the same reducer, we could also writestate => state.posts. However, learning how to write it the long way is useful to know in case you need to bring multiple reducers into the same component.Finally, we'll bring in the asynchronousfetchPostsfrom the actions, which is the action that combines the whole lifecycle of fetching all posts into one. UsinguseEffectfrom React, we'lldispatchfetchPostswhen the component mounts.dispatchwill automatically be available on a connected component.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'// Bring in the asynchronous fetchPosts actionimport{fetchPosts} rom'../actions/postsActions'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])return(<section><h1>Posts</h1></section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)All that's left to do at this point is display all three possible states of the page - whether it's loading, has an error, or successfully retrieved the posts from the API.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'import{fetchPosts} rom'../actions/postsActions'import{Post} rom'../components/Post'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])// Show loading, error, or success stateconstrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post}/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)And that's all - we now have a connected component, and are bringing in data from an API to our Redux store. Using Redux DevTools, we can see each action as it happens, and the changes (diff) after each state change.The EndThis is where the tutorial for creating an application with plain Redux ends. If you look at thesource code of the demo application, you'll see a lot has been added - a reducer and actions for a single post, and for comments.I would recommend completing your project so that it matches the demo app. There are no new concepts to be learned, but you will create two more reducers and actions, and see how to bring two states into one component for the single post page, which brings in one post as well as comments for that post.Redux ToolkitThere is one more thing I want to cover -Redux Toolkit. Redux Toolkit, or RTK, is a newer and easier official way to use Redux. You may notice that Redux has alotof boilerplate for setup and requires many more folders and files than plain React would. Some patterns have emerged to attempt to mitigate all that, such asRedux ducks pattern, but we can simplify it even more.View thesource of the demo Redux Toolkit application, which is the same application we just created with Redux, but using RTK. It is much simpler, with a drastic reduction in lines of code for all the same functionality.Using RTK just requires one dependency,@reduxjs/toolkit.npmi @reduxjs/toolkitAnd no longer requires you to install theredux-thunkorredux-devtools-extensiondependencies.Advantages to Redux ToolkitThe main advantages to using RTK are:Easier to set up (less dependencies)Reduction of boilerplate code (one slice vs. many files for actions and reducers)Sensible defaults (Redux Thunk, Redux DevTools built-in)The ability to usedirect state mutation, since RTK usesimmerunder the hood. This means you no longer need to return{ ...state } ith every reducer.StoreSince Redux Toolkit comes with a lot built-in already, like Redux DevTools and Redux Thunk, we no longer have to bring them into theindex.jsfile. Now we only needconfigureStore, instead ofcreateStore.index.jsimportReactfrom'react'import{render} rom'react-dom'import{configureStore} rom'@reduxjs/toolkit'import{Provider} rom'react-redux'importAppfrom'./App'importrootReducerfrom'./slices'import'./index.css'conststore=configureStore({reducer:rootReducer})render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))SlicesInstead of dealing with reducers, actions, and all as separate files and individually creating all those action types, RTK gives us the concept ofslices. Asliceautomatically generates reducers, action types, and action creators. As such, you'll only have to create one folder -slices.initialStatewill look the same.slices/posts.jsimport{createSlice} rom'@reduxjs/toolkit'exportconstinitialState={loading:false,hasErrors:false,posts:[],} he names of the reducers in the slice will also be the same -getPosts,getPostsSuccess, andgetPostsFailure. We'll make all the same changes, but note that we're no longer returning the entire state - we're just mutating state. It's still immutable under the hood, but this approach may be easier and faster for some. If preferred, you can still return the whole state as an object.slices/posts.js// A slice for posts with our three reducersconstpostsSlice=createSlice({name:'posts',initialState,reducers:{getPosts:(state)=>{state.loading=true},getPostsSuccess:(state,{payload})=>{state.posts=payload\n      state.loading=falsestate.hasErrors=false},getPostsFailure:(state)=>{state.loading=falsestate.hasErrors=true},},})The actions that get generated are the same, we just don't have to write them out individually anymore. From the same file, we can export all the actions, the reducer, the asynchronous thunk, and one new thing - aselector, which we'll use to access any of the state from a React component instead of usingconnect.slices/posts.js// Three actions generated from the sliceexportconst{getPosts,getPostsSuccess,getPostsFailure}=postsSlice.actions// A selectorexportconstpostsSelector=(state)=>state.posts// The reducerexportdefaultpostsSlice.reducer// Asynchronous thunk actionexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} electing Redux state in a React componentThe traditional approach, as we just learned, is to usemapStateToPropswith theconnect()function. This is still common in codebases and therefore worth learning. You can still use this approach with RTK, but the newer, React Hooks way of going about it is to useuseDispatchanduseSelectorfromreact-redux. This approach requires less code overall as well.As you can see in the updatedPostsPage.jsfile below, the Redux state is no longer available as props on the connected component, but from the selector we exported in the slice.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{useDispatch,useSelector} rom'react-redux'import{fetchPosts,postsSelector} rom'../slices/posts'import{Post} rom'../components/Post'constPostsPage=()=>{constdispatch=useDispatch()const{posts,loading,hasErrors}=useSelector(postsSelector)useEffect(()=>{dispatch(fetchPosts())},[dispatch])constrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post} xcerpt/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} xportdefaultPostsPageNow we have the same app as before with a few updates from Redux Toolkit, and a lot less code to maintain.ConclusionWe did it! If you followed along with me through this whole tutorial, you should have a really good feel for Redux now, both the old-fashioned way and using Redux Toolkit to simplify things. To summarize, Redux allows us to easily manage global state in a React application. We can access and update the state from anywhere, and easily debug the entire state of an application with Redux Devtools.You can place most of the state of your application in Redux, but certain areas of an app, such as forms as they are being updated, still make sense to keep in the React component state itself until the form is officially submitted.I hope you enjoyed this article!",
        "chunk_type": "code_markup",
        "tag": "main",
        "score": 1.1219999999999999,
        "word_count": 962,
        "chunk_id": "33861c3fc43be5f54517d6f1ff94d72e",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "It was a lot of work to put together two complete demo applications and run through the whole thing here, and the article ran pretty long, but hopefully this is your one-stop shop for learning all beginner and intermediate Redux concepts. Please let me know what you think and share the article if it helped you out, and donations are always welcome!About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:March 09, 2020Category:TechnicalTagsreduxreacttutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "example",
        "tag": "main",
        "score": 1.1219999999999999,
        "word_count": 115,
        "chunk_id": "96791525f7e53af6b5369b2eec9f621c",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "javascript"
          ]
        }
      },
      {
        "content": "How to Use Redux and ReactDo you have experience usingReact? Have you heard ofRedux, but you've put off learning it because it looks very complicated and all the guides seem overwhelming? If that's the case, this is the article for you! Contain your fear of containing state and come along with me on this relatively painless journey.PrerequisitesYou must already know how to use React for this tutorial, as I will not be explaining any aspects of React itself.Familiarity withHTML & CSS.Familiarity withES6 syntax and features.Knowledge of React terminology:JSX, State, Components, Props, LifecycleandHooksKnowledge ofReact RouterKnowledge of asynchronous JavaScript andmaking API callsAlso, download Redux DevToolsfor Chromeorfor FireFox.GoalsIn this tutorial, we will build a small blog app. It will fetch posts and comments from an API. I've created the same app with both plain Redux, andRedux Toolkit(RTK), the officially sanctioned toolset for Redux. Here are the links to the source and demos of both the plain and RTK versions.React + Redux Application (Plain Redux)SourceDemo ApplicationReact + Redux Toolkit ApplicationSourceDemo ApplicationNote: The applications are pulling from a real API viaJSON Placeholder API. Due to rate limiting on CodeSandbox, the API may appear slow, but it has nothing to do with the Redux application itself. You can also clone the repository locally.We will learn:Whatis Redux andwhyyou might want to use itTheterminologyof Redux: actions, reducers, store, dispatch, connect, and containerMaking asynchronous API calls withRedux ThunkHow to make a small, real-world application with React and ReduxHow to use Redux Toolkit to simplify Redux app developmentWhat is Redux?Redux is a state container for JavaScript applications. Normally with React, you manage state at a component level, and pass state around via props. With Redux, the entire state of your application is managed in one immutable object. Every update to the Redux state results in a copy of sections of the state, plus the new change.Redux was originally created byDan AbramovandAndrew Clark.Why should I use Redux?Easily manage global state- access or update any part of the state from any Redux-connected componentEasily keep track of changes with Redux DevTools- any action or state change is tracked and easy to follow with Redux. The fact that the entire state of the application is tracked with each change means you can easily do time-travel debugging to move back and forth between changes.The downside to Redux is that there's a lot of initial boilerplate to set up and maintain (especially if you use plain Redux without Redux Toolkit). A smaller applicationmay not need Reduxand may instead benefit from simply usingthe Context APIfor global state needs.In my personal experience, I set up an application with Context alone, and later needed to convert everything over to Redux to make it more maintainable and organized.TerminologyUsually I don't like to just make a list of terms and definitions, but Redux has a few that are likely unfamiliar, so I'm just going to define them all up front to make it easy to refer back to them. Although you canskip to the beginning of the tutorial section, I think it would be good to read through all the definitions just to get exposure and an idea of them in your head first.ActionsReducersStoreDispatchConnectI'll just use the typical todo application, and the action of deleting a todo, for the examples.ActionsAnactionsends data from your application to the Redux store. An action is conventionally an object with two properties:typeand (optional)payload. The type is generally an uppercase string (assigned to a constant) that describes the action. The payload is additional data that may be passed.Action TypeconstDELETE_TODO='posts/deleteTodo'Action{type:DELETE_TODO,payload:id,} ction creatorsAnaction creatoris a function that returns an action.Action CreatorconstdeleteTodo=(id)=>({type:DELETE_TODO,payload:id})ReducersAreduceris a function that takes two parameters:stateandaction. A reducer is immutable and always returns a copy of the entire state. A reducer typically consists of aswitchstatement that goes through all the possible action types.ReducerconstinitialState={todos:[{id:1,text:'Eat'},{id:2,text:'Sleep'},],loading:false,hasErrors:false,} unctiontodoReducer(state=initialState,action){switch(action.type){caseDELETE_TODO:return{...state,todos:state.todos.filter((todo)=>todo.id!==action.payload),} efault:returnstate}} toreThe Redux application state lives in thestore, which is initialized with a reducer. When used with React, a<Provider>exists to wrap the application, and anything within the Provider can have access to Redux.Storeimport{createStore} rom'redux'import{Provider} rom'react-redux'importreducerfrom'./reducers'conststore=createStore(reducer)render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Dispatchdispatchis a method available on the store object that accepts an object which is used to update the Redux state. Usually, this object is the result of invoking an action creator.constComponent=({dispatch})=>{useEffect(()=>{dispatch(deleteTodo())},[dispatch])} onnectTheconnect()function is one typical way to connect React to Redux. A connected component is sometimes referred to as acontainer.Okay, that about covers it for the major terms of Redux. It can be overwhelming to read the terminology without any context, so let's begin.Getting StartedFor ease of getting started quickly, my example usesCreate React Appto set up the environment.npx create-react-app redux-tutorialcdredux-tutorialRedux requires a few dependencies.Redux- Core libraryReact Redux- React bindings for ReduxRedux Thunk- Async middleware for ReduxRedux DevTools Extension- Connects Redux app to Redux DevToolsYou canyarn addornpm ithem, and I'll be usingreact-router-domas well, but that's it for extra dependencies.npmi\\redux\\react-redux\\redux-thunk\\redux-devtools-extension\\react-router-domAnd delete all the boilerplate. We'll add everything we need from scratch instead.cdsrc&&rm*# move to src and delete all files withinWe'll make directories for Reduxreducersand Reduxactions, as well aspagesandcomponentswhich you should already be familiar with from React.mkdiractions components pages reducersAnd we'll bring backindex.js,App.js, andindex.css.touchindex.js index.css App.jsSo at this point your project directory tree looks like this.└── src/\n    ├── actions/\n    ├── components/\n    ├── pages/\n    ├── reducers/\n    ├── App.js\n    ├── index.css\n    └── index.jsFor theindex.cssfile, just take the contents ofthis gistand paste it. I intend only to go over functionality and not anything about style, so I just wrote some very basic styles to ensure the site looks decent enough.Now we have enough boilerplate to get started, so we'll begin working on the entrypoint.Setting up the Redux StoreWhen I first started learning Redux, it seemed so overwhelming because every app I looked at hadindex.jsset up a bit differently.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 933,
        "chunk_id": "657514346dca44a325e6412500ee416d",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "development",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "After looking at a lot of the more up-to-date apps and taking the aspects that were common across all of them, I got a good feel for what should really be in a Redux app, and what is just people moving things around to be unique.There are plenty of tutorials out there that show you how to get a very basic Redux store with todos set up, but I don't find that very useful for knowing how to make a production level setup, so I'm going to set it up with everything you need from the get-go. Even so, there will be some opinionated aspects because Redux is very flexible.Inindex.js, we'll be bringing in a few things.createStore, to create the store that will maintain the Redux stateapplyMiddleware, to be able to use middleware, in this casethunkProvider, to wrap the entire application in Reduxthunk, a middleware that allows us to make asynchronous actions in ReduxcomposeWithDevTools, code that connects your app to Redux DevToolsindex.js// External importsimportReactfrom'react'import{render} rom'react-dom'import{createStore,applyMiddleware} rom'redux'import{Provider} rom'react-redux'importthunkfrom'redux-thunk'import{composeWithDevTools} rom'redux-devtools-extension'// Local importsimportAppfrom'./App'importrootReducerfrom'./reducers'// Assetsimport'./index.css'conststore=createStore(rootReducer,composeWithDevTools(applyMiddleware(thunk)))render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Put a component inApp.js. We'll modify this later, but we just want to get the app up and running for now.App.jsimportReactfrom'react'constApp=()=>{return<div>Hello, Redux</div>} xportdefaultAppBringing in reducersThe last thing to do is bring in the reducer. Areduceris a function that determines changes to Redux state. It is a pure function that returns a copy of the state with the new change.A neat feature of Redux is that we can have many reducers, and combine them all into one root reducer that the store uses, usingcombineReducers. This leads to us being able to easily organize our code while still having everything in one root state tree.Since this app will be like a blog, it will have a list of posts, and we'll put that in thepostsReducerin a moment. Having thiscombineReducersmethod allows us to bring whatever we want in - acommentsReducer, anauthReducer, and so on.Inreducers/index.js, create the file that will combine all reducers.reducers/index.jsimport{combineReducers} rom'redux'importpostsReducerfrom'./postsReducer'constrootReducer=combineReducers({posts:postsReducer,})exportdefaultrootReducerFinally, we'll make thepostsReducer. We can set it up with an initial state. Just like you might expect from a regular React component, we'll have aloadingandhasErrorsstate, as well as apostsarray, where all the posts will live. First we'll set it up with no actions in the switch, just a default case that returns the entire state.reducers/postsReducer.jsexportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow we at least have enough setup that the application will load without crashing.Redux DevToolsWith the application loading and the Redux<Provider>set up, we can take a look at Redux DevTools. After downloading it, it'll be a tab in your Developer Tools. If you click onState, you'll see the entire state of the application so far.There's not much in here yet, but Redux DevTools is amazing once you get to having a lot of reducers and actions. It keeps track of all changes to your app and makes debugging a breeze compared to plain React.Setting up Redux ActionsSo now we have a reducer for posts, but we don't have any actions, meaning the reducer will only return the state without modifying it in any way.Actionsare how we communicate with the Redux store. For this blog app, we're going to want to fetch posts from an API and put them in our Redux state.Since fetching posts is an asynchronous action, it will require the use of Redux thunk. Fortunately, we don't have to do anything special to use thunk beyond setting it up in the store, which we already did.Create aactions/postsActions.js. First, we'll define theaction typesas constants. This is not necessary, but is a common convention, and makes it easy to export the actions around and prevent typos. We want to do three things:getPosts- begin telling Redux we're going to fetch posts from an APIgetPostsSuccess- pass the posts to Redux on successful API callgetPostsFailure- inform Redux that an error was encountered during Redux on failed API callactions/postsActions.js// Create Redux action typesexportconstGET_POSTS='GET_POSTS'exportconstGET_POSTS_SUCCESS='GET_POSTS_SUCCESS'exportconstGET_POSTS_FAILURE='GET_POSTS_FAILURE'Then createaction creators, functions that return anaction, which consists of the type and an optional payload containing data.actions/postsActions.js// Create Redux action creators that return an actionexportconstgetPosts=()=>({type:GET_POSTS,})exportconstgetPostsSuccess=(posts)=>({type:GET_POSTS_SUCCESS,payload:posts,})exportconstgetPostsFailure=()=>({type:GET_POSTS_FAILURE,})Finally, make the asynchronous thunk action that combines all three of the above actions. When called, it will dispatch the initialgetPosts()action to inform Redux to prepare for an API call, then in atry/catch, do everything necessary to get the data, and dispatch a success or failure action as necessary.actions/postsActions.js// Combine them all in an asynchronous thunkexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} reat, we're all done with creating actions now! All that's left to do is tell the reducer what to do with the state on each action.Responding to actionsBack at our post reducer, we have a switch that isn't doing anything yet.reducers/postsReducer.jsexportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow that we have actions, we can bring them in from thepostsActionspage.// Import all actionsimport*asactionsfrom'../actions/postsActions'For each action, we'll make acase, that returns the entire state plus whatever change we're making to it. ForGET_POSTS, for example, all we want to do is tell the app to setloadingtotruesince we'll be making an API call.caseactions.GET_POSTS:return{...state,loading:true} ET_POSTS- begin loadingGET_POSTS_SUCCESS- the app has posts, no errors, and should stop loadingGET_POSTS_FAILURE- the app has errors and should stop loadingHere's the whole reducer.reducers/postsReducer.jsimport*asactionsfrom'../actions/postsActions'exportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){caseactions.GET_POSTS:return{...state,loading:true} aseactions.GET_POSTS_SUCCESS:return{posts:action.payload,loading:false,hasErrors:false} aseactions.GET_POSTS_FAILURE:return{...state,loading:false,hasErrors:true} efault:returnstate}} ow our actions and reducers are ready, so all that's left to do is connect everything to the React app.Connecting Redux to React ComponentsSince the demo app I've created uses React Router to have a few routes - a dashboard, a listing of all posts, and an individual posts page, I'll bring React Router in now. I'll just bring in the dashboard and all posts listing for this demo.App.jsimportReactfrom'react'import{BrowserRouterasRouter,Switch,Route,Redirect} rom'react-router-dom'importDashboardPagefrom'./pages/DashboardPage'importPostsPagefrom'./pages/PostsPage'constApp=()=>{return(<Router><Switch><Routeexactpath=\"/\"component={DashboardPage}/><Routeexactpath=\"/posts\"component={PostsPage}/><Redirectto=\"/\"/></Switch></Router>)} xportdefaultAppWe can create the dashboard page, which is just a regular React component.pages/DashboardPage.jsimportReactfrom'react'import{Link} rom'react-router-dom'constDashboardPage=()=>(<section><h1>Dashboard</h1><p>This is the dashboard.</p><Linkto=\"/posts\"className=\"button\">View Posts</Link></section>)exportdefaultDashboardPageFor each post, let's make aPostcomponent that will display the title and an excerpt of the text of the article. Make aPost.jsin thecomponentssubdirectory.components/Post.jsimportReactfrom'react'exportconstPost=({post})=>(<articleclassName=\"post-excerpt\"><h2>{post.title}</h2><p>{post.body.substring(0,100)}</p></article>)Components that do not connect to Redux are still important and useful for smaller, reusable areas, such as this Post component.Now the interesting part comes in for the posts page - bringing Redux into React. To do this we'll useconnectfromreact-redux. First, we'll just make a regular component for the page.pages/PostsPage.jsimportReactfrom'react'constPostsPage=()=>{return(<section><h1>Posts</h1></section>)} xportdefaultPostsPageThen we'll bring inconnect.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 1000,
        "chunk_id": "ce44a83cb22103e6a639d48b1d686d36",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Theconnect functionis a higher-order function that connects the Redux store to a React component. We'll pass a parameter calledmapStateToPropstoconnect. This aptly named function will take any state from the Redux store and pass it to the props of the React component. We'll bring inloading,posts, andhasErrorsfrom the ReduxpostsReducer.pages/PostsPage.jsimportReactfrom'react'import{connect} rom'react-redux'// Redux state is now in the props of the componentconstPostsPage=({loading,posts,hasErrors})=>{return(<section><h1>Posts</h1></section>)}// Map Redux state to React component propsconstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})// Connect Redux to Reactexportdefaultconnect(mapStateToProps)(PostsPage)Since this component uses state from the same reducer, we could also writestate => state.posts. However, learning how to write it the long way is useful to know in case you need to bring multiple reducers into the same component.Finally, we'll bring in the asynchronousfetchPostsfrom the actions, which is the action that combines the whole lifecycle of fetching all posts into one. UsinguseEffectfrom React, we'lldispatchfetchPostswhen the component mounts.dispatchwill automatically be available on a connected component.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'// Bring in the asynchronous fetchPosts actionimport{fetchPosts} rom'../actions/postsActions'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])return(<section><h1>Posts</h1></section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)All that's left to do at this point is display all three possible states of the page - whether it's loading, has an error, or successfully retrieved the posts from the API.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'import{fetchPosts} rom'../actions/postsActions'import{Post} rom'../components/Post'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])// Show loading, error, or success stateconstrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post}/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)And that's all - we now have a connected component, and are bringing in data from an API to our Redux store. Using Redux DevTools, we can see each action as it happens, and the changes (diff) after each state change.The EndThis is where the tutorial for creating an application with plain Redux ends. If you look at thesource code of the demo application, you'll see a lot has been added - a reducer and actions for a single post, and for comments.I would recommend completing your project so that it matches the demo app. There are no new concepts to be learned, but you will create two more reducers and actions, and see how to bring two states into one component for the single post page, which brings in one post as well as comments for that post.Redux ToolkitThere is one more thing I want to cover -Redux Toolkit. Redux Toolkit, or RTK, is a newer and easier official way to use Redux. You may notice that Redux has alotof boilerplate for setup and requires many more folders and files than plain React would. Some patterns have emerged to attempt to mitigate all that, such asRedux ducks pattern, but we can simplify it even more.View thesource of the demo Redux Toolkit application, which is the same application we just created with Redux, but using RTK. It is much simpler, with a drastic reduction in lines of code for all the same functionality.Using RTK just requires one dependency,@reduxjs/toolkit.npmi @reduxjs/toolkitAnd no longer requires you to install theredux-thunkorredux-devtools-extensiondependencies.Advantages to Redux ToolkitThe main advantages to using RTK are:Easier to set up (less dependencies)Reduction of boilerplate code (one slice vs. many files for actions and reducers)Sensible defaults (Redux Thunk, Redux DevTools built-in)The ability to usedirect state mutation, since RTK usesimmerunder the hood. This means you no longer need to return{ ...state } ith every reducer.StoreSince Redux Toolkit comes with a lot built-in already, like Redux DevTools and Redux Thunk, we no longer have to bring them into theindex.jsfile. Now we only needconfigureStore, instead ofcreateStore.index.jsimportReactfrom'react'import{render} rom'react-dom'import{configureStore} rom'@reduxjs/toolkit'import{Provider} rom'react-redux'importAppfrom'./App'importrootReducerfrom'./slices'import'./index.css'conststore=configureStore({reducer:rootReducer})render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))SlicesInstead of dealing with reducers, actions, and all as separate files and individually creating all those action types, RTK gives us the concept ofslices. Asliceautomatically generates reducers, action types, and action creators. As such, you'll only have to create one folder -slices.initialStatewill look the same.slices/posts.jsimport{createSlice} rom'@reduxjs/toolkit'exportconstinitialState={loading:false,hasErrors:false,posts:[],} he names of the reducers in the slice will also be the same -getPosts,getPostsSuccess, andgetPostsFailure. We'll make all the same changes, but note that we're no longer returning the entire state - we're just mutating state. It's still immutable under the hood, but this approach may be easier and faster for some. If preferred, you can still return the whole state as an object.slices/posts.js// A slice for posts with our three reducersconstpostsSlice=createSlice({name:'posts',initialState,reducers:{getPosts:(state)=>{state.loading=true},getPostsSuccess:(state,{payload})=>{state.posts=payload\n      state.loading=falsestate.hasErrors=false},getPostsFailure:(state)=>{state.loading=falsestate.hasErrors=true},},})The actions that get generated are the same, we just don't have to write them out individually anymore. From the same file, we can export all the actions, the reducer, the asynchronous thunk, and one new thing - aselector, which we'll use to access any of the state from a React component instead of usingconnect.slices/posts.js// Three actions generated from the sliceexportconst{getPosts,getPostsSuccess,getPostsFailure}=postsSlice.actions// A selectorexportconstpostsSelector=(state)=>state.posts// The reducerexportdefaultpostsSlice.reducer// Asynchronous thunk actionexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} electing Redux state in a React componentThe traditional approach, as we just learned, is to usemapStateToPropswith theconnect()function. This is still common in codebases and therefore worth learning. You can still use this approach with RTK, but the newer, React Hooks way of going about it is to useuseDispatchanduseSelectorfromreact-redux. This approach requires less code overall as well.As you can see in the updatedPostsPage.jsfile below, the Redux state is no longer available as props on the connected component, but from the selector we exported in the slice.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{useDispatch,useSelector} rom'react-redux'import{fetchPosts,postsSelector} rom'../slices/posts'import{Post} rom'../components/Post'constPostsPage=()=>{constdispatch=useDispatch()const{posts,loading,hasErrors}=useSelector(postsSelector)useEffect(()=>{dispatch(fetchPosts())},[dispatch])constrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post} xcerpt/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} xportdefaultPostsPageNow we have the same app as before with a few updates from Redux Toolkit, and a lot less code to maintain.ConclusionWe did it! If you followed along with me through this whole tutorial, you should have a really good feel for Redux now, both the old-fashioned way and using Redux Toolkit to simplify things. To summarize, Redux allows us to easily manage global state in a React application. We can access and update the state from anywhere, and easily debug the entire state of an application with Redux Devtools.You can place most of the state of your application in Redux, but certain areas of an app, such as forms as they are being updated, still make sense to keep in the React component state itself until the form is officially submitted.I hope you enjoyed this article!",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 962,
        "chunk_id": "33861c3fc43be5f54517d6f1ff94d72e",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "It was a lot of work to put together two complete demo applications and run through the whole thing here, and the article ran pretty long, but hopefully this is your one-stop shop for learning all beginner and intermediate Redux concepts. Please let me know what you think and share the article if it helped you out, and donations are always welcome!About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:March 09, 2020Category:TechnicalTagsreduxreacttutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "example",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 115,
        "chunk_id": "96791525f7e53af6b5369b2eec9f621c",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "javascript"
          ]
        }
      },
      {
        "content": "How to Use Redux and ReactDo you have experience usingReact? Have you heard ofRedux, but you've put off learning it because it looks very complicated and all the guides seem overwhelming? If that's the case, this is the article for you! Contain your fear of containing state and come along with me on this relatively painless journey.PrerequisitesYou must already know how to use React for this tutorial, as I will not be explaining any aspects of React itself.Familiarity withHTML & CSS.Familiarity withES6 syntax and features.Knowledge of React terminology:JSX, State, Components, Props, LifecycleandHooksKnowledge ofReact RouterKnowledge of asynchronous JavaScript andmaking API callsAlso, download Redux DevToolsfor Chromeorfor FireFox.GoalsIn this tutorial, we will build a small blog app. It will fetch posts and comments from an API. I've created the same app with both plain Redux, andRedux Toolkit(RTK), the officially sanctioned toolset for Redux. Here are the links to the source and demos of both the plain and RTK versions.React + Redux Application (Plain Redux)SourceDemo ApplicationReact + Redux Toolkit ApplicationSourceDemo ApplicationNote: The applications are pulling from a real API viaJSON Placeholder API. Due to rate limiting on CodeSandbox, the API may appear slow, but it has nothing to do with the Redux application itself. You can also clone the repository locally.We will learn:Whatis Redux andwhyyou might want to use itTheterminologyof Redux: actions, reducers, store, dispatch, connect, and containerMaking asynchronous API calls withRedux ThunkHow to make a small, real-world application with React and ReduxHow to use Redux Toolkit to simplify Redux app developmentWhat is Redux?Redux is a state container for JavaScript applications. Normally with React, you manage state at a component level, and pass state around via props. With Redux, the entire state of your application is managed in one immutable object. Every update to the Redux state results in a copy of sections of the state, plus the new change.Redux was originally created byDan AbramovandAndrew Clark.Why should I use Redux?Easily manage global state- access or update any part of the state from any Redux-connected componentEasily keep track of changes with Redux DevTools- any action or state change is tracked and easy to follow with Redux. The fact that the entire state of the application is tracked with each change means you can easily do time-travel debugging to move back and forth between changes.The downside to Redux is that there's a lot of initial boilerplate to set up and maintain (especially if you use plain Redux without Redux Toolkit). A smaller applicationmay not need Reduxand may instead benefit from simply usingthe Context APIfor global state needs.In my personal experience, I set up an application with Context alone, and later needed to convert everything over to Redux to make it more maintainable and organized.TerminologyUsually I don't like to just make a list of terms and definitions, but Redux has a few that are likely unfamiliar, so I'm just going to define them all up front to make it easy to refer back to them. Although you canskip to the beginning of the tutorial section, I think it would be good to read through all the definitions just to get exposure and an idea of them in your head first.ActionsReducersStoreDispatchConnectI'll just use the typical todo application, and the action of deleting a todo, for the examples.ActionsAnactionsends data from your application to the Redux store. An action is conventionally an object with two properties:typeand (optional)payload. The type is generally an uppercase string (assigned to a constant) that describes the action. The payload is additional data that may be passed.Action TypeconstDELETE_TODO='posts/deleteTodo'Action{type:DELETE_TODO,payload:id,} ction creatorsAnaction creatoris a function that returns an action.Action CreatorconstdeleteTodo=(id)=>({type:DELETE_TODO,payload:id})ReducersAreduceris a function that takes two parameters:stateandaction. A reducer is immutable and always returns a copy of the entire state. A reducer typically consists of aswitchstatement that goes through all the possible action types.ReducerconstinitialState={todos:[{id:1,text:'Eat'},{id:2,text:'Sleep'},],loading:false,hasErrors:false,} unctiontodoReducer(state=initialState,action){switch(action.type){caseDELETE_TODO:return{...state,todos:state.todos.filter((todo)=>todo.id!==action.payload),} efault:returnstate}} toreThe Redux application state lives in thestore, which is initialized with a reducer. When used with React, a<Provider>exists to wrap the application, and anything within the Provider can have access to Redux.Storeimport{createStore} rom'redux'import{Provider} rom'react-redux'importreducerfrom'./reducers'conststore=createStore(reducer)render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Dispatchdispatchis a method available on the store object that accepts an object which is used to update the Redux state. Usually, this object is the result of invoking an action creator.constComponent=({dispatch})=>{useEffect(()=>{dispatch(deleteTodo())},[dispatch])} onnectTheconnect()function is one typical way to connect React to Redux. A connected component is sometimes referred to as acontainer.Okay, that about covers it for the major terms of Redux. It can be overwhelming to read the terminology without any context, so let's begin.Getting StartedFor ease of getting started quickly, my example usesCreate React Appto set up the environment.npx create-react-app redux-tutorialcdredux-tutorialRedux requires a few dependencies.Redux- Core libraryReact Redux- React bindings for ReduxRedux Thunk- Async middleware for ReduxRedux DevTools Extension- Connects Redux app to Redux DevToolsYou canyarn addornpm ithem, and I'll be usingreact-router-domas well, but that's it for extra dependencies.npmi\\redux\\react-redux\\redux-thunk\\redux-devtools-extension\\react-router-domAnd delete all the boilerplate. We'll add everything we need from scratch instead.cdsrc&&rm*# move to src and delete all files withinWe'll make directories for Reduxreducersand Reduxactions, as well aspagesandcomponentswhich you should already be familiar with from React.mkdiractions components pages reducersAnd we'll bring backindex.js,App.js, andindex.css.touchindex.js index.css App.jsSo at this point your project directory tree looks like this.└── src/\n    ├── actions/\n    ├── components/\n    ├── pages/\n    ├── reducers/\n    ├── App.js\n    ├── index.css\n    └── index.jsFor theindex.cssfile, just take the contents ofthis gistand paste it. I intend only to go over functionality and not anything about style, so I just wrote some very basic styles to ensure the site looks decent enough.Now we have enough boilerplate to get started, so we'll begin working on the entrypoint.Setting up the Redux StoreWhen I first started learning Redux, it seemed so overwhelming because every app I looked at hadindex.jsset up a bit differently.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 933,
        "chunk_id": "657514346dca44a325e6412500ee416d",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "development",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "After looking at a lot of the more up-to-date apps and taking the aspects that were common across all of them, I got a good feel for what should really be in a Redux app, and what is just people moving things around to be unique.There are plenty of tutorials out there that show you how to get a very basic Redux store with todos set up, but I don't find that very useful for knowing how to make a production level setup, so I'm going to set it up with everything you need from the get-go. Even so, there will be some opinionated aspects because Redux is very flexible.Inindex.js, we'll be bringing in a few things.createStore, to create the store that will maintain the Redux stateapplyMiddleware, to be able to use middleware, in this casethunkProvider, to wrap the entire application in Reduxthunk, a middleware that allows us to make asynchronous actions in ReduxcomposeWithDevTools, code that connects your app to Redux DevToolsindex.js// External importsimportReactfrom'react'import{render} rom'react-dom'import{createStore,applyMiddleware} rom'redux'import{Provider} rom'react-redux'importthunkfrom'redux-thunk'import{composeWithDevTools} rom'redux-devtools-extension'// Local importsimportAppfrom'./App'importrootReducerfrom'./reducers'// Assetsimport'./index.css'conststore=createStore(rootReducer,composeWithDevTools(applyMiddleware(thunk)))render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Put a component inApp.js. We'll modify this later, but we just want to get the app up and running for now.App.jsimportReactfrom'react'constApp=()=>{return<div>Hello, Redux</div>} xportdefaultAppBringing in reducersThe last thing to do is bring in the reducer. Areduceris a function that determines changes to Redux state. It is a pure function that returns a copy of the state with the new change.A neat feature of Redux is that we can have many reducers, and combine them all into one root reducer that the store uses, usingcombineReducers. This leads to us being able to easily organize our code while still having everything in one root state tree.Since this app will be like a blog, it will have a list of posts, and we'll put that in thepostsReducerin a moment. Having thiscombineReducersmethod allows us to bring whatever we want in - acommentsReducer, anauthReducer, and so on.Inreducers/index.js, create the file that will combine all reducers.reducers/index.jsimport{combineReducers} rom'redux'importpostsReducerfrom'./postsReducer'constrootReducer=combineReducers({posts:postsReducer,})exportdefaultrootReducerFinally, we'll make thepostsReducer. We can set it up with an initial state. Just like you might expect from a regular React component, we'll have aloadingandhasErrorsstate, as well as apostsarray, where all the posts will live. First we'll set it up with no actions in the switch, just a default case that returns the entire state.reducers/postsReducer.jsexportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow we at least have enough setup that the application will load without crashing.Redux DevToolsWith the application loading and the Redux<Provider>set up, we can take a look at Redux DevTools. After downloading it, it'll be a tab in your Developer Tools. If you click onState, you'll see the entire state of the application so far.There's not much in here yet, but Redux DevTools is amazing once you get to having a lot of reducers and actions. It keeps track of all changes to your app and makes debugging a breeze compared to plain React.Setting up Redux ActionsSo now we have a reducer for posts, but we don't have any actions, meaning the reducer will only return the state without modifying it in any way.Actionsare how we communicate with the Redux store. For this blog app, we're going to want to fetch posts from an API and put them in our Redux state.Since fetching posts is an asynchronous action, it will require the use of Redux thunk. Fortunately, we don't have to do anything special to use thunk beyond setting it up in the store, which we already did.Create aactions/postsActions.js. First, we'll define theaction typesas constants. This is not necessary, but is a common convention, and makes it easy to export the actions around and prevent typos. We want to do three things:getPosts- begin telling Redux we're going to fetch posts from an APIgetPostsSuccess- pass the posts to Redux on successful API callgetPostsFailure- inform Redux that an error was encountered during Redux on failed API callactions/postsActions.js// Create Redux action typesexportconstGET_POSTS='GET_POSTS'exportconstGET_POSTS_SUCCESS='GET_POSTS_SUCCESS'exportconstGET_POSTS_FAILURE='GET_POSTS_FAILURE'Then createaction creators, functions that return anaction, which consists of the type and an optional payload containing data.actions/postsActions.js// Create Redux action creators that return an actionexportconstgetPosts=()=>({type:GET_POSTS,})exportconstgetPostsSuccess=(posts)=>({type:GET_POSTS_SUCCESS,payload:posts,})exportconstgetPostsFailure=()=>({type:GET_POSTS_FAILURE,})Finally, make the asynchronous thunk action that combines all three of the above actions. When called, it will dispatch the initialgetPosts()action to inform Redux to prepare for an API call, then in atry/catch, do everything necessary to get the data, and dispatch a success or failure action as necessary.actions/postsActions.js// Combine them all in an asynchronous thunkexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} reat, we're all done with creating actions now! All that's left to do is tell the reducer what to do with the state on each action.Responding to actionsBack at our post reducer, we have a switch that isn't doing anything yet.reducers/postsReducer.jsexportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow that we have actions, we can bring them in from thepostsActionspage.// Import all actionsimport*asactionsfrom'../actions/postsActions'For each action, we'll make acase, that returns the entire state plus whatever change we're making to it. ForGET_POSTS, for example, all we want to do is tell the app to setloadingtotruesince we'll be making an API call.caseactions.GET_POSTS:return{...state,loading:true} ET_POSTS- begin loadingGET_POSTS_SUCCESS- the app has posts, no errors, and should stop loadingGET_POSTS_FAILURE- the app has errors and should stop loadingHere's the whole reducer.reducers/postsReducer.jsimport*asactionsfrom'../actions/postsActions'exportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){caseactions.GET_POSTS:return{...state,loading:true} aseactions.GET_POSTS_SUCCESS:return{posts:action.payload,loading:false,hasErrors:false} aseactions.GET_POSTS_FAILURE:return{...state,loading:false,hasErrors:true} efault:returnstate}} ow our actions and reducers are ready, so all that's left to do is connect everything to the React app.Connecting Redux to React ComponentsSince the demo app I've created uses React Router to have a few routes - a dashboard, a listing of all posts, and an individual posts page, I'll bring React Router in now. I'll just bring in the dashboard and all posts listing for this demo.App.jsimportReactfrom'react'import{BrowserRouterasRouter,Switch,Route,Redirect} rom'react-router-dom'importDashboardPagefrom'./pages/DashboardPage'importPostsPagefrom'./pages/PostsPage'constApp=()=>{return(<Router><Switch><Routeexactpath=\"/\"component={DashboardPage}/><Routeexactpath=\"/posts\"component={PostsPage}/><Redirectto=\"/\"/></Switch></Router>)} xportdefaultAppWe can create the dashboard page, which is just a regular React component.pages/DashboardPage.jsimportReactfrom'react'import{Link} rom'react-router-dom'constDashboardPage=()=>(<section><h1>Dashboard</h1><p>This is the dashboard.</p><Linkto=\"/posts\"className=\"button\">View Posts</Link></section>)exportdefaultDashboardPageFor each post, let's make aPostcomponent that will display the title and an excerpt of the text of the article. Make aPost.jsin thecomponentssubdirectory.components/Post.jsimportReactfrom'react'exportconstPost=({post})=>(<articleclassName=\"post-excerpt\"><h2>{post.title}</h2><p>{post.body.substring(0,100)}</p></article>)Components that do not connect to Redux are still important and useful for smaller, reusable areas, such as this Post component.Now the interesting part comes in for the posts page - bringing Redux into React. To do this we'll useconnectfromreact-redux. First, we'll just make a regular component for the page.pages/PostsPage.jsimportReactfrom'react'constPostsPage=()=>{return(<section><h1>Posts</h1></section>)} xportdefaultPostsPageThen we'll bring inconnect.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 1000,
        "chunk_id": "ce44a83cb22103e6a639d48b1d686d36",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Theconnect functionis a higher-order function that connects the Redux store to a React component. We'll pass a parameter calledmapStateToPropstoconnect. This aptly named function will take any state from the Redux store and pass it to the props of the React component. We'll bring inloading,posts, andhasErrorsfrom the ReduxpostsReducer.pages/PostsPage.jsimportReactfrom'react'import{connect} rom'react-redux'// Redux state is now in the props of the componentconstPostsPage=({loading,posts,hasErrors})=>{return(<section><h1>Posts</h1></section>)}// Map Redux state to React component propsconstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})// Connect Redux to Reactexportdefaultconnect(mapStateToProps)(PostsPage)Since this component uses state from the same reducer, we could also writestate => state.posts. However, learning how to write it the long way is useful to know in case you need to bring multiple reducers into the same component.Finally, we'll bring in the asynchronousfetchPostsfrom the actions, which is the action that combines the whole lifecycle of fetching all posts into one. UsinguseEffectfrom React, we'lldispatchfetchPostswhen the component mounts.dispatchwill automatically be available on a connected component.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'// Bring in the asynchronous fetchPosts actionimport{fetchPosts} rom'../actions/postsActions'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])return(<section><h1>Posts</h1></section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)All that's left to do at this point is display all three possible states of the page - whether it's loading, has an error, or successfully retrieved the posts from the API.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'import{fetchPosts} rom'../actions/postsActions'import{Post} rom'../components/Post'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])// Show loading, error, or success stateconstrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post}/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)And that's all - we now have a connected component, and are bringing in data from an API to our Redux store. Using Redux DevTools, we can see each action as it happens, and the changes (diff) after each state change.The EndThis is where the tutorial for creating an application with plain Redux ends. If you look at thesource code of the demo application, you'll see a lot has been added - a reducer and actions for a single post, and for comments.I would recommend completing your project so that it matches the demo app. There are no new concepts to be learned, but you will create two more reducers and actions, and see how to bring two states into one component for the single post page, which brings in one post as well as comments for that post.Redux ToolkitThere is one more thing I want to cover -Redux Toolkit. Redux Toolkit, or RTK, is a newer and easier official way to use Redux. You may notice that Redux has alotof boilerplate for setup and requires many more folders and files than plain React would. Some patterns have emerged to attempt to mitigate all that, such asRedux ducks pattern, but we can simplify it even more.View thesource of the demo Redux Toolkit application, which is the same application we just created with Redux, but using RTK. It is much simpler, with a drastic reduction in lines of code for all the same functionality.Using RTK just requires one dependency,@reduxjs/toolkit.npmi @reduxjs/toolkitAnd no longer requires you to install theredux-thunkorredux-devtools-extensiondependencies.Advantages to Redux ToolkitThe main advantages to using RTK are:Easier to set up (less dependencies)Reduction of boilerplate code (one slice vs. many files for actions and reducers)Sensible defaults (Redux Thunk, Redux DevTools built-in)The ability to usedirect state mutation, since RTK usesimmerunder the hood. This means you no longer need to return{ ...state } ith every reducer.StoreSince Redux Toolkit comes with a lot built-in already, like Redux DevTools and Redux Thunk, we no longer have to bring them into theindex.jsfile. Now we only needconfigureStore, instead ofcreateStore.index.jsimportReactfrom'react'import{render} rom'react-dom'import{configureStore} rom'@reduxjs/toolkit'import{Provider} rom'react-redux'importAppfrom'./App'importrootReducerfrom'./slices'import'./index.css'conststore=configureStore({reducer:rootReducer})render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))SlicesInstead of dealing with reducers, actions, and all as separate files and individually creating all those action types, RTK gives us the concept ofslices. Asliceautomatically generates reducers, action types, and action creators. As such, you'll only have to create one folder -slices.initialStatewill look the same.slices/posts.jsimport{createSlice} rom'@reduxjs/toolkit'exportconstinitialState={loading:false,hasErrors:false,posts:[],} he names of the reducers in the slice will also be the same -getPosts,getPostsSuccess, andgetPostsFailure. We'll make all the same changes, but note that we're no longer returning the entire state - we're just mutating state. It's still immutable under the hood, but this approach may be easier and faster for some. If preferred, you can still return the whole state as an object.slices/posts.js// A slice for posts with our three reducersconstpostsSlice=createSlice({name:'posts',initialState,reducers:{getPosts:(state)=>{state.loading=true},getPostsSuccess:(state,{payload})=>{state.posts=payload\n      state.loading=falsestate.hasErrors=false},getPostsFailure:(state)=>{state.loading=falsestate.hasErrors=true},},})The actions that get generated are the same, we just don't have to write them out individually anymore. From the same file, we can export all the actions, the reducer, the asynchronous thunk, and one new thing - aselector, which we'll use to access any of the state from a React component instead of usingconnect.slices/posts.js// Three actions generated from the sliceexportconst{getPosts,getPostsSuccess,getPostsFailure}=postsSlice.actions// A selectorexportconstpostsSelector=(state)=>state.posts// The reducerexportdefaultpostsSlice.reducer// Asynchronous thunk actionexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} electing Redux state in a React componentThe traditional approach, as we just learned, is to usemapStateToPropswith theconnect()function. This is still common in codebases and therefore worth learning. You can still use this approach with RTK, but the newer, React Hooks way of going about it is to useuseDispatchanduseSelectorfromreact-redux. This approach requires less code overall as well.As you can see in the updatedPostsPage.jsfile below, the Redux state is no longer available as props on the connected component, but from the selector we exported in the slice.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{useDispatch,useSelector} rom'react-redux'import{fetchPosts,postsSelector} rom'../slices/posts'import{Post} rom'../components/Post'constPostsPage=()=>{constdispatch=useDispatch()const{posts,loading,hasErrors}=useSelector(postsSelector)useEffect(()=>{dispatch(fetchPosts())},[dispatch])constrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post} xcerpt/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} xportdefaultPostsPageNow we have the same app as before with a few updates from Redux Toolkit, and a lot less code to maintain.ConclusionWe did it! If you followed along with me through this whole tutorial, you should have a really good feel for Redux now, both the old-fashioned way and using Redux Toolkit to simplify things. To summarize, Redux allows us to easily manage global state in a React application. We can access and update the state from anywhere, and easily debug the entire state of an application with Redux Devtools.You can place most of the state of your application in Redux, but certain areas of an app, such as forms as they are being updated, still make sense to keep in the React component state itself until the form is officially submitted.I hope you enjoyed this article!",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 962,
        "chunk_id": "33861c3fc43be5f54517d6f1ff94d72e",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "It was a lot of work to put together two complete demo applications and run through the whole thing here, and the article ran pretty long, but hopefully this is your one-stop shop for learning all beginner and intermediate Redux concepts. Please let me know what you think and share the article if it helped you out, and donations are always welcome!About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:March 09, 2020Category:TechnicalTagsreduxreacttutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "example",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 115,
        "chunk_id": "96791525f7e53af6b5369b2eec9f621c",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "javascript"
          ]
        }
      },
      {
        "content": "How to Use Redux and ReactDo you have experience usingReact? Have you heard ofRedux, but you've put off learning it because it looks very complicated and all the guides seem overwhelming? If that's the case, this is the article for you! Contain your fear of containing state and come along with me on this relatively painless journey.PrerequisitesYou must already know how to use React for this tutorial, as I will not be explaining any aspects of React itself.Familiarity withHTML & CSS.Familiarity withES6 syntax and features.Knowledge of React terminology:JSX, State, Components, Props, LifecycleandHooksKnowledge ofReact RouterKnowledge of asynchronous JavaScript andmaking API callsAlso, download Redux DevToolsfor Chromeorfor FireFox.GoalsIn this tutorial, we will build a small blog app. It will fetch posts and comments from an API. I've created the same app with both plain Redux, andRedux Toolkit(RTK), the officially sanctioned toolset for Redux. Here are the links to the source and demos of both the plain and RTK versions.React + Redux Application (Plain Redux)SourceDemo ApplicationReact + Redux Toolkit ApplicationSourceDemo ApplicationNote: The applications are pulling from a real API viaJSON Placeholder API. Due to rate limiting on CodeSandbox, the API may appear slow, but it has nothing to do with the Redux application itself. You can also clone the repository locally.We will learn:Whatis Redux andwhyyou might want to use itTheterminologyof Redux: actions, reducers, store, dispatch, connect, and containerMaking asynchronous API calls withRedux ThunkHow to make a small, real-world application with React and ReduxHow to use Redux Toolkit to simplify Redux app developmentWhat is Redux?Redux is a state container for JavaScript applications. Normally with React, you manage state at a component level, and pass state around via props. With Redux, the entire state of your application is managed in one immutable object. Every update to the Redux state results in a copy of sections of the state, plus the new change.Redux was originally created byDan AbramovandAndrew Clark.Why should I use Redux?Easily manage global state- access or update any part of the state from any Redux-connected componentEasily keep track of changes with Redux DevTools- any action or state change is tracked and easy to follow with Redux. The fact that the entire state of the application is tracked with each change means you can easily do time-travel debugging to move back and forth between changes.The downside to Redux is that there's a lot of initial boilerplate to set up and maintain (especially if you use plain Redux without Redux Toolkit). A smaller applicationmay not need Reduxand may instead benefit from simply usingthe Context APIfor global state needs.In my personal experience, I set up an application with Context alone, and later needed to convert everything over to Redux to make it more maintainable and organized.TerminologyUsually I don't like to just make a list of terms and definitions, but Redux has a few that are likely unfamiliar, so I'm just going to define them all up front to make it easy to refer back to them. Although you canskip to the beginning of the tutorial section, I think it would be good to read through all the definitions just to get exposure and an idea of them in your head first.ActionsReducersStoreDispatchConnectI'll just use the typical todo application, and the action of deleting a todo, for the examples.ActionsAnactionsends data from your application to the Redux store. An action is conventionally an object with two properties:typeand (optional)payload. The type is generally an uppercase string (assigned to a constant) that describes the action. The payload is additional data that may be passed.Action TypeconstDELETE_TODO='posts/deleteTodo'Action{type:DELETE_TODO,payload:id,} ction creatorsAnaction creatoris a function that returns an action.Action CreatorconstdeleteTodo=(id)=>({type:DELETE_TODO,payload:id})ReducersAreduceris a function that takes two parameters:stateandaction. A reducer is immutable and always returns a copy of the entire state. A reducer typically consists of aswitchstatement that goes through all the possible action types.ReducerconstinitialState={todos:[{id:1,text:'Eat'},{id:2,text:'Sleep'},],loading:false,hasErrors:false,} unctiontodoReducer(state=initialState,action){switch(action.type){caseDELETE_TODO:return{...state,todos:state.todos.filter((todo)=>todo.id!==action.payload),} efault:returnstate}} toreThe Redux application state lives in thestore, which is initialized with a reducer. When used with React, a<Provider>exists to wrap the application, and anything within the Provider can have access to Redux.Storeimport{createStore} rom'redux'import{Provider} rom'react-redux'importreducerfrom'./reducers'conststore=createStore(reducer)render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Dispatchdispatchis a method available on the store object that accepts an object which is used to update the Redux state. Usually, this object is the result of invoking an action creator.constComponent=({dispatch})=>{useEffect(()=>{dispatch(deleteTodo())},[dispatch])} onnectTheconnect()function is one typical way to connect React to Redux. A connected component is sometimes referred to as acontainer.Okay, that about covers it for the major terms of Redux. It can be overwhelming to read the terminology without any context, so let's begin.Getting StartedFor ease of getting started quickly, my example usesCreate React Appto set up the environment.npx create-react-app redux-tutorialcdredux-tutorialRedux requires a few dependencies.Redux- Core libraryReact Redux- React bindings for ReduxRedux Thunk- Async middleware for ReduxRedux DevTools Extension- Connects Redux app to Redux DevToolsYou canyarn addornpm ithem, and I'll be usingreact-router-domas well, but that's it for extra dependencies.npmi\\redux\\react-redux\\redux-thunk\\redux-devtools-extension\\react-router-domAnd delete all the boilerplate. We'll add everything we need from scratch instead.cdsrc&&rm*# move to src and delete all files withinWe'll make directories for Reduxreducersand Reduxactions, as well aspagesandcomponentswhich you should already be familiar with from React.mkdiractions components pages reducersAnd we'll bring backindex.js,App.js, andindex.css.touchindex.js index.css App.jsSo at this point your project directory tree looks like this.└── src/\n    ├── actions/\n    ├── components/\n    ├── pages/\n    ├── reducers/\n    ├── App.js\n    ├── index.css\n    └── index.jsFor theindex.cssfile, just take the contents ofthis gistand paste it. I intend only to go over functionality and not anything about style, so I just wrote some very basic styles to ensure the site looks decent enough.Now we have enough boilerplate to get started, so we'll begin working on the entrypoint.Setting up the Redux StoreWhen I first started learning Redux, it seemed so overwhelming because every app I looked at hadindex.jsset up a bit differently.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 933,
        "chunk_id": "657514346dca44a325e6412500ee416d",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "development",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "After looking at a lot of the more up-to-date apps and taking the aspects that were common across all of them, I got a good feel for what should really be in a Redux app, and what is just people moving things around to be unique.There are plenty of tutorials out there that show you how to get a very basic Redux store with todos set up, but I don't find that very useful for knowing how to make a production level setup, so I'm going to set it up with everything you need from the get-go. Even so, there will be some opinionated aspects because Redux is very flexible.Inindex.js, we'll be bringing in a few things.createStore, to create the store that will maintain the Redux stateapplyMiddleware, to be able to use middleware, in this casethunkProvider, to wrap the entire application in Reduxthunk, a middleware that allows us to make asynchronous actions in ReduxcomposeWithDevTools, code that connects your app to Redux DevToolsindex.js// External importsimportReactfrom'react'import{render} rom'react-dom'import{createStore,applyMiddleware} rom'redux'import{Provider} rom'react-redux'importthunkfrom'redux-thunk'import{composeWithDevTools} rom'redux-devtools-extension'// Local importsimportAppfrom'./App'importrootReducerfrom'./reducers'// Assetsimport'./index.css'conststore=createStore(rootReducer,composeWithDevTools(applyMiddleware(thunk)))render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Put a component inApp.js. We'll modify this later, but we just want to get the app up and running for now.App.jsimportReactfrom'react'constApp=()=>{return<div>Hello, Redux</div>} xportdefaultAppBringing in reducersThe last thing to do is bring in the reducer. Areduceris a function that determines changes to Redux state. It is a pure function that returns a copy of the state with the new change.A neat feature of Redux is that we can have many reducers, and combine them all into one root reducer that the store uses, usingcombineReducers. This leads to us being able to easily organize our code while still having everything in one root state tree.Since this app will be like a blog, it will have a list of posts, and we'll put that in thepostsReducerin a moment. Having thiscombineReducersmethod allows us to bring whatever we want in - acommentsReducer, anauthReducer, and so on.Inreducers/index.js, create the file that will combine all reducers.reducers/index.jsimport{combineReducers} rom'redux'importpostsReducerfrom'./postsReducer'constrootReducer=combineReducers({posts:postsReducer,})exportdefaultrootReducerFinally, we'll make thepostsReducer. We can set it up with an initial state. Just like you might expect from a regular React component, we'll have aloadingandhasErrorsstate, as well as apostsarray, where all the posts will live. First we'll set it up with no actions in the switch, just a default case that returns the entire state.reducers/postsReducer.jsexportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow we at least have enough setup that the application will load without crashing.Redux DevToolsWith the application loading and the Redux<Provider>set up, we can take a look at Redux DevTools. After downloading it, it'll be a tab in your Developer Tools. If you click onState, you'll see the entire state of the application so far.There's not much in here yet, but Redux DevTools is amazing once you get to having a lot of reducers and actions. It keeps track of all changes to your app and makes debugging a breeze compared to plain React.Setting up Redux ActionsSo now we have a reducer for posts, but we don't have any actions, meaning the reducer will only return the state without modifying it in any way.Actionsare how we communicate with the Redux store. For this blog app, we're going to want to fetch posts from an API and put them in our Redux state.Since fetching posts is an asynchronous action, it will require the use of Redux thunk. Fortunately, we don't have to do anything special to use thunk beyond setting it up in the store, which we already did.Create aactions/postsActions.js. First, we'll define theaction typesas constants. This is not necessary, but is a common convention, and makes it easy to export the actions around and prevent typos. We want to do three things:getPosts- begin telling Redux we're going to fetch posts from an APIgetPostsSuccess- pass the posts to Redux on successful API callgetPostsFailure- inform Redux that an error was encountered during Redux on failed API callactions/postsActions.js// Create Redux action typesexportconstGET_POSTS='GET_POSTS'exportconstGET_POSTS_SUCCESS='GET_POSTS_SUCCESS'exportconstGET_POSTS_FAILURE='GET_POSTS_FAILURE'Then createaction creators, functions that return anaction, which consists of the type and an optional payload containing data.actions/postsActions.js// Create Redux action creators that return an actionexportconstgetPosts=()=>({type:GET_POSTS,})exportconstgetPostsSuccess=(posts)=>({type:GET_POSTS_SUCCESS,payload:posts,})exportconstgetPostsFailure=()=>({type:GET_POSTS_FAILURE,})Finally, make the asynchronous thunk action that combines all three of the above actions. When called, it will dispatch the initialgetPosts()action to inform Redux to prepare for an API call, then in atry/catch, do everything necessary to get the data, and dispatch a success or failure action as necessary.actions/postsActions.js// Combine them all in an asynchronous thunkexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} reat, we're all done with creating actions now! All that's left to do is tell the reducer what to do with the state on each action.Responding to actionsBack at our post reducer, we have a switch that isn't doing anything yet.reducers/postsReducer.jsexportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow that we have actions, we can bring them in from thepostsActionspage.// Import all actionsimport*asactionsfrom'../actions/postsActions'For each action, we'll make acase, that returns the entire state plus whatever change we're making to it. ForGET_POSTS, for example, all we want to do is tell the app to setloadingtotruesince we'll be making an API call.caseactions.GET_POSTS:return{...state,loading:true} ET_POSTS- begin loadingGET_POSTS_SUCCESS- the app has posts, no errors, and should stop loadingGET_POSTS_FAILURE- the app has errors and should stop loadingHere's the whole reducer.reducers/postsReducer.jsimport*asactionsfrom'../actions/postsActions'exportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){caseactions.GET_POSTS:return{...state,loading:true} aseactions.GET_POSTS_SUCCESS:return{posts:action.payload,loading:false,hasErrors:false} aseactions.GET_POSTS_FAILURE:return{...state,loading:false,hasErrors:true} efault:returnstate}} ow our actions and reducers are ready, so all that's left to do is connect everything to the React app.Connecting Redux to React ComponentsSince the demo app I've created uses React Router to have a few routes - a dashboard, a listing of all posts, and an individual posts page, I'll bring React Router in now. I'll just bring in the dashboard and all posts listing for this demo.App.jsimportReactfrom'react'import{BrowserRouterasRouter,Switch,Route,Redirect} rom'react-router-dom'importDashboardPagefrom'./pages/DashboardPage'importPostsPagefrom'./pages/PostsPage'constApp=()=>{return(<Router><Switch><Routeexactpath=\"/\"component={DashboardPage}/><Routeexactpath=\"/posts\"component={PostsPage}/><Redirectto=\"/\"/></Switch></Router>)} xportdefaultAppWe can create the dashboard page, which is just a regular React component.pages/DashboardPage.jsimportReactfrom'react'import{Link} rom'react-router-dom'constDashboardPage=()=>(<section><h1>Dashboard</h1><p>This is the dashboard.</p><Linkto=\"/posts\"className=\"button\">View Posts</Link></section>)exportdefaultDashboardPageFor each post, let's make aPostcomponent that will display the title and an excerpt of the text of the article. Make aPost.jsin thecomponentssubdirectory.components/Post.jsimportReactfrom'react'exportconstPost=({post})=>(<articleclassName=\"post-excerpt\"><h2>{post.title}</h2><p>{post.body.substring(0,100)}</p></article>)Components that do not connect to Redux are still important and useful for smaller, reusable areas, such as this Post component.Now the interesting part comes in for the posts page - bringing Redux into React. To do this we'll useconnectfromreact-redux. First, we'll just make a regular component for the page.pages/PostsPage.jsimportReactfrom'react'constPostsPage=()=>{return(<section><h1>Posts</h1></section>)} xportdefaultPostsPageThen we'll bring inconnect.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 1000,
        "chunk_id": "ce44a83cb22103e6a639d48b1d686d36",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Theconnect functionis a higher-order function that connects the Redux store to a React component. We'll pass a parameter calledmapStateToPropstoconnect. This aptly named function will take any state from the Redux store and pass it to the props of the React component. We'll bring inloading,posts, andhasErrorsfrom the ReduxpostsReducer.pages/PostsPage.jsimportReactfrom'react'import{connect} rom'react-redux'// Redux state is now in the props of the componentconstPostsPage=({loading,posts,hasErrors})=>{return(<section><h1>Posts</h1></section>)}// Map Redux state to React component propsconstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})// Connect Redux to Reactexportdefaultconnect(mapStateToProps)(PostsPage)Since this component uses state from the same reducer, we could also writestate => state.posts. However, learning how to write it the long way is useful to know in case you need to bring multiple reducers into the same component.Finally, we'll bring in the asynchronousfetchPostsfrom the actions, which is the action that combines the whole lifecycle of fetching all posts into one. UsinguseEffectfrom React, we'lldispatchfetchPostswhen the component mounts.dispatchwill automatically be available on a connected component.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'// Bring in the asynchronous fetchPosts actionimport{fetchPosts} rom'../actions/postsActions'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])return(<section><h1>Posts</h1></section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)All that's left to do at this point is display all three possible states of the page - whether it's loading, has an error, or successfully retrieved the posts from the API.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'import{fetchPosts} rom'../actions/postsActions'import{Post} rom'../components/Post'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])// Show loading, error, or success stateconstrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post}/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)And that's all - we now have a connected component, and are bringing in data from an API to our Redux store. Using Redux DevTools, we can see each action as it happens, and the changes (diff) after each state change.The EndThis is where the tutorial for creating an application with plain Redux ends. If you look at thesource code of the demo application, you'll see a lot has been added - a reducer and actions for a single post, and for comments.I would recommend completing your project so that it matches the demo app. There are no new concepts to be learned, but you will create two more reducers and actions, and see how to bring two states into one component for the single post page, which brings in one post as well as comments for that post.Redux ToolkitThere is one more thing I want to cover -Redux Toolkit. Redux Toolkit, or RTK, is a newer and easier official way to use Redux. You may notice that Redux has alotof boilerplate for setup and requires many more folders and files than plain React would. Some patterns have emerged to attempt to mitigate all that, such asRedux ducks pattern, but we can simplify it even more.View thesource of the demo Redux Toolkit application, which is the same application we just created with Redux, but using RTK. It is much simpler, with a drastic reduction in lines of code for all the same functionality.Using RTK just requires one dependency,@reduxjs/toolkit.npmi @reduxjs/toolkitAnd no longer requires you to install theredux-thunkorredux-devtools-extensiondependencies.Advantages to Redux ToolkitThe main advantages to using RTK are:Easier to set up (less dependencies)Reduction of boilerplate code (one slice vs. many files for actions and reducers)Sensible defaults (Redux Thunk, Redux DevTools built-in)The ability to usedirect state mutation, since RTK usesimmerunder the hood. This means you no longer need to return{ ...state } ith every reducer.StoreSince Redux Toolkit comes with a lot built-in already, like Redux DevTools and Redux Thunk, we no longer have to bring them into theindex.jsfile. Now we only needconfigureStore, instead ofcreateStore.index.jsimportReactfrom'react'import{render} rom'react-dom'import{configureStore} rom'@reduxjs/toolkit'import{Provider} rom'react-redux'importAppfrom'./App'importrootReducerfrom'./slices'import'./index.css'conststore=configureStore({reducer:rootReducer})render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))SlicesInstead of dealing with reducers, actions, and all as separate files and individually creating all those action types, RTK gives us the concept ofslices. Asliceautomatically generates reducers, action types, and action creators. As such, you'll only have to create one folder -slices.initialStatewill look the same.slices/posts.jsimport{createSlice} rom'@reduxjs/toolkit'exportconstinitialState={loading:false,hasErrors:false,posts:[],} he names of the reducers in the slice will also be the same -getPosts,getPostsSuccess, andgetPostsFailure. We'll make all the same changes, but note that we're no longer returning the entire state - we're just mutating state. It's still immutable under the hood, but this approach may be easier and faster for some. If preferred, you can still return the whole state as an object.slices/posts.js// A slice for posts with our three reducersconstpostsSlice=createSlice({name:'posts',initialState,reducers:{getPosts:(state)=>{state.loading=true},getPostsSuccess:(state,{payload})=>{state.posts=payload\n      state.loading=falsestate.hasErrors=false},getPostsFailure:(state)=>{state.loading=falsestate.hasErrors=true},},})The actions that get generated are the same, we just don't have to write them out individually anymore. From the same file, we can export all the actions, the reducer, the asynchronous thunk, and one new thing - aselector, which we'll use to access any of the state from a React component instead of usingconnect.slices/posts.js// Three actions generated from the sliceexportconst{getPosts,getPostsSuccess,getPostsFailure}=postsSlice.actions// A selectorexportconstpostsSelector=(state)=>state.posts// The reducerexportdefaultpostsSlice.reducer// Asynchronous thunk actionexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} electing Redux state in a React componentThe traditional approach, as we just learned, is to usemapStateToPropswith theconnect()function. This is still common in codebases and therefore worth learning. You can still use this approach with RTK, but the newer, React Hooks way of going about it is to useuseDispatchanduseSelectorfromreact-redux. This approach requires less code overall as well.As you can see in the updatedPostsPage.jsfile below, the Redux state is no longer available as props on the connected component, but from the selector we exported in the slice.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{useDispatch,useSelector} rom'react-redux'import{fetchPosts,postsSelector} rom'../slices/posts'import{Post} rom'../components/Post'constPostsPage=()=>{constdispatch=useDispatch()const{posts,loading,hasErrors}=useSelector(postsSelector)useEffect(()=>{dispatch(fetchPosts())},[dispatch])constrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post} xcerpt/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} xportdefaultPostsPageNow we have the same app as before with a few updates from Redux Toolkit, and a lot less code to maintain.ConclusionWe did it! If you followed along with me through this whole tutorial, you should have a really good feel for Redux now, both the old-fashioned way and using Redux Toolkit to simplify things. To summarize, Redux allows us to easily manage global state in a React application. We can access and update the state from anywhere, and easily debug the entire state of an application with Redux Devtools.You can place most of the state of your application in Redux, but certain areas of an app, such as forms as they are being updated, still make sense to keep in the React component state itself until the form is officially submitted.I hope you enjoyed this article!",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 962,
        "chunk_id": "33861c3fc43be5f54517d6f1ff94d72e",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "It was a lot of work to put together two complete demo applications and run through the whole thing here, and the article ran pretty long, but hopefully this is your one-stop shop for learning all beginner and intermediate Redux concepts. Please let me know what you think and share the article if it helped you out, and donations are always welcome!About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:March 09, 2020Category:TechnicalTagsreduxreacttutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "example",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 115,
        "chunk_id": "96791525f7e53af6b5369b2eec9f621c",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "javascript"
          ]
        }
      },
      {
        "content": "How to Use Redux and ReactDo you have experience usingReact? Have you heard ofRedux, but you've put off learning it because it looks very complicated and all the guides seem overwhelming? If that's the case, this is the article for you! Contain your fear of containing state and come along with me on this relatively painless journey.PrerequisitesYou must already know how to use React for this tutorial, as I will not be explaining any aspects of React itself.Familiarity withHTML & CSS.Familiarity withES6 syntax and features.Knowledge of React terminology:JSX, State, Components, Props, LifecycleandHooksKnowledge ofReact RouterKnowledge of asynchronous JavaScript andmaking API callsAlso, download Redux DevToolsfor Chromeorfor FireFox.GoalsIn this tutorial, we will build a small blog app. It will fetch posts and comments from an API. I've created the same app with both plain Redux, andRedux Toolkit(RTK), the officially sanctioned toolset for Redux. Here are the links to the source and demos of both the plain and RTK versions.React + Redux Application (Plain Redux)SourceDemo ApplicationReact + Redux Toolkit ApplicationSourceDemo ApplicationNote: The applications are pulling from a real API viaJSON Placeholder API. Due to rate limiting on CodeSandbox, the API may appear slow, but it has nothing to do with the Redux application itself. You can also clone the repository locally.We will learn:Whatis Redux andwhyyou might want to use itTheterminologyof Redux: actions, reducers, store, dispatch, connect, and containerMaking asynchronous API calls withRedux ThunkHow to make a small, real-world application with React and ReduxHow to use Redux Toolkit to simplify Redux app developmentWhat is Redux?Redux is a state container for JavaScript applications. Normally with React, you manage state at a component level, and pass state around via props. With Redux, the entire state of your application is managed in one immutable object. Every update to the Redux state results in a copy of sections of the state, plus the new change.Redux was originally created byDan AbramovandAndrew Clark.Why should I use Redux?Easily manage global state- access or update any part of the state from any Redux-connected componentEasily keep track of changes with Redux DevTools- any action or state change is tracked and easy to follow with Redux. The fact that the entire state of the application is tracked with each change means you can easily do time-travel debugging to move back and forth between changes.The downside to Redux is that there's a lot of initial boilerplate to set up and maintain (especially if you use plain Redux without Redux Toolkit). A smaller applicationmay not need Reduxand may instead benefit from simply usingthe Context APIfor global state needs.In my personal experience, I set up an application with Context alone, and later needed to convert everything over to Redux to make it more maintainable and organized.TerminologyUsually I don't like to just make a list of terms and definitions, but Redux has a few that are likely unfamiliar, so I'm just going to define them all up front to make it easy to refer back to them. Although you canskip to the beginning of the tutorial section, I think it would be good to read through all the definitions just to get exposure and an idea of them in your head first.ActionsReducersStoreDispatchConnectI'll just use the typical todo application, and the action of deleting a todo, for the examples.ActionsAnactionsends data from your application to the Redux store. An action is conventionally an object with two properties:typeand (optional)payload. The type is generally an uppercase string (assigned to a constant) that describes the action. The payload is additional data that may be passed.Action TypeconstDELETE_TODO='posts/deleteTodo'Action{type:DELETE_TODO,payload:id,} ction creatorsAnaction creatoris a function that returns an action.Action CreatorconstdeleteTodo=(id)=>({type:DELETE_TODO,payload:id})ReducersAreduceris a function that takes two parameters:stateandaction. A reducer is immutable and always returns a copy of the entire state. A reducer typically consists of aswitchstatement that goes through all the possible action types.ReducerconstinitialState={todos:[{id:1,text:'Eat'},{id:2,text:'Sleep'},],loading:false,hasErrors:false,} unctiontodoReducer(state=initialState,action){switch(action.type){caseDELETE_TODO:return{...state,todos:state.todos.filter((todo)=>todo.id!==action.payload),} efault:returnstate}} toreThe Redux application state lives in thestore, which is initialized with a reducer. When used with React, a<Provider>exists to wrap the application, and anything within the Provider can have access to Redux.Storeimport{createStore} rom'redux'import{Provider} rom'react-redux'importreducerfrom'./reducers'conststore=createStore(reducer)render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Dispatchdispatchis a method available on the store object that accepts an object which is used to update the Redux state. Usually, this object is the result of invoking an action creator.constComponent=({dispatch})=>{useEffect(()=>{dispatch(deleteTodo())},[dispatch])} onnectTheconnect()function is one typical way to connect React to Redux. A connected component is sometimes referred to as acontainer.Okay, that about covers it for the major terms of Redux. It can be overwhelming to read the terminology without any context, so let's begin.Getting StartedFor ease of getting started quickly, my example usesCreate React Appto set up the environment.npx create-react-app redux-tutorialcdredux-tutorialRedux requires a few dependencies.Redux- Core libraryReact Redux- React bindings for ReduxRedux Thunk- Async middleware for ReduxRedux DevTools Extension- Connects Redux app to Redux DevToolsYou canyarn addornpm ithem, and I'll be usingreact-router-domas well, but that's it for extra dependencies.npmi\\redux\\react-redux\\redux-thunk\\redux-devtools-extension\\react-router-domAnd delete all the boilerplate. We'll add everything we need from scratch instead.cdsrc&&rm*# move to src and delete all files withinWe'll make directories for Reduxreducersand Reduxactions, as well aspagesandcomponentswhich you should already be familiar with from React.mkdiractions components pages reducersAnd we'll bring backindex.js,App.js, andindex.css.touchindex.js index.css App.jsSo at this point your project directory tree looks like this.└── src/\n    ├── actions/\n    ├── components/\n    ├── pages/\n    ├── reducers/\n    ├── App.js\n    ├── index.css\n    └── index.jsFor theindex.cssfile, just take the contents ofthis gistand paste it. I intend only to go over functionality and not anything about style, so I just wrote some very basic styles to ensure the site looks decent enough.Now we have enough boilerplate to get started, so we'll begin working on the entrypoint.Setting up the Redux StoreWhen I first started learning Redux, it seemed so overwhelming because every app I looked at hadindex.jsset up a bit differently.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 933,
        "chunk_id": "657514346dca44a325e6412500ee416d",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "development",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "After looking at a lot of the more up-to-date apps and taking the aspects that were common across all of them, I got a good feel for what should really be in a Redux app, and what is just people moving things around to be unique.There are plenty of tutorials out there that show you how to get a very basic Redux store with todos set up, but I don't find that very useful for knowing how to make a production level setup, so I'm going to set it up with everything you need from the get-go. Even so, there will be some opinionated aspects because Redux is very flexible.Inindex.js, we'll be bringing in a few things.createStore, to create the store that will maintain the Redux stateapplyMiddleware, to be able to use middleware, in this casethunkProvider, to wrap the entire application in Reduxthunk, a middleware that allows us to make asynchronous actions in ReduxcomposeWithDevTools, code that connects your app to Redux DevToolsindex.js// External importsimportReactfrom'react'import{render} rom'react-dom'import{createStore,applyMiddleware} rom'redux'import{Provider} rom'react-redux'importthunkfrom'redux-thunk'import{composeWithDevTools} rom'redux-devtools-extension'// Local importsimportAppfrom'./App'importrootReducerfrom'./reducers'// Assetsimport'./index.css'conststore=createStore(rootReducer,composeWithDevTools(applyMiddleware(thunk)))render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Put a component inApp.js. We'll modify this later, but we just want to get the app up and running for now.App.jsimportReactfrom'react'constApp=()=>{return<div>Hello, Redux</div>} xportdefaultAppBringing in reducersThe last thing to do is bring in the reducer. Areduceris a function that determines changes to Redux state. It is a pure function that returns a copy of the state with the new change.A neat feature of Redux is that we can have many reducers, and combine them all into one root reducer that the store uses, usingcombineReducers. This leads to us being able to easily organize our code while still having everything in one root state tree.Since this app will be like a blog, it will have a list of posts, and we'll put that in thepostsReducerin a moment. Having thiscombineReducersmethod allows us to bring whatever we want in - acommentsReducer, anauthReducer, and so on.Inreducers/index.js, create the file that will combine all reducers.reducers/index.jsimport{combineReducers} rom'redux'importpostsReducerfrom'./postsReducer'constrootReducer=combineReducers({posts:postsReducer,})exportdefaultrootReducerFinally, we'll make thepostsReducer. We can set it up with an initial state. Just like you might expect from a regular React component, we'll have aloadingandhasErrorsstate, as well as apostsarray, where all the posts will live. First we'll set it up with no actions in the switch, just a default case that returns the entire state.reducers/postsReducer.jsexportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow we at least have enough setup that the application will load without crashing.Redux DevToolsWith the application loading and the Redux<Provider>set up, we can take a look at Redux DevTools. After downloading it, it'll be a tab in your Developer Tools. If you click onState, you'll see the entire state of the application so far.There's not much in here yet, but Redux DevTools is amazing once you get to having a lot of reducers and actions. It keeps track of all changes to your app and makes debugging a breeze compared to plain React.Setting up Redux ActionsSo now we have a reducer for posts, but we don't have any actions, meaning the reducer will only return the state without modifying it in any way.Actionsare how we communicate with the Redux store. For this blog app, we're going to want to fetch posts from an API and put them in our Redux state.Since fetching posts is an asynchronous action, it will require the use of Redux thunk. Fortunately, we don't have to do anything special to use thunk beyond setting it up in the store, which we already did.Create aactions/postsActions.js. First, we'll define theaction typesas constants. This is not necessary, but is a common convention, and makes it easy to export the actions around and prevent typos. We want to do three things:getPosts- begin telling Redux we're going to fetch posts from an APIgetPostsSuccess- pass the posts to Redux on successful API callgetPostsFailure- inform Redux that an error was encountered during Redux on failed API callactions/postsActions.js// Create Redux action typesexportconstGET_POSTS='GET_POSTS'exportconstGET_POSTS_SUCCESS='GET_POSTS_SUCCESS'exportconstGET_POSTS_FAILURE='GET_POSTS_FAILURE'Then createaction creators, functions that return anaction, which consists of the type and an optional payload containing data.actions/postsActions.js// Create Redux action creators that return an actionexportconstgetPosts=()=>({type:GET_POSTS,})exportconstgetPostsSuccess=(posts)=>({type:GET_POSTS_SUCCESS,payload:posts,})exportconstgetPostsFailure=()=>({type:GET_POSTS_FAILURE,})Finally, make the asynchronous thunk action that combines all three of the above actions. When called, it will dispatch the initialgetPosts()action to inform Redux to prepare for an API call, then in atry/catch, do everything necessary to get the data, and dispatch a success or failure action as necessary.actions/postsActions.js// Combine them all in an asynchronous thunkexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} reat, we're all done with creating actions now! All that's left to do is tell the reducer what to do with the state on each action.Responding to actionsBack at our post reducer, we have a switch that isn't doing anything yet.reducers/postsReducer.jsexportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow that we have actions, we can bring them in from thepostsActionspage.// Import all actionsimport*asactionsfrom'../actions/postsActions'For each action, we'll make acase, that returns the entire state plus whatever change we're making to it. ForGET_POSTS, for example, all we want to do is tell the app to setloadingtotruesince we'll be making an API call.caseactions.GET_POSTS:return{...state,loading:true} ET_POSTS- begin loadingGET_POSTS_SUCCESS- the app has posts, no errors, and should stop loadingGET_POSTS_FAILURE- the app has errors and should stop loadingHere's the whole reducer.reducers/postsReducer.jsimport*asactionsfrom'../actions/postsActions'exportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){caseactions.GET_POSTS:return{...state,loading:true} aseactions.GET_POSTS_SUCCESS:return{posts:action.payload,loading:false,hasErrors:false} aseactions.GET_POSTS_FAILURE:return{...state,loading:false,hasErrors:true} efault:returnstate}} ow our actions and reducers are ready, so all that's left to do is connect everything to the React app.Connecting Redux to React ComponentsSince the demo app I've created uses React Router to have a few routes - a dashboard, a listing of all posts, and an individual posts page, I'll bring React Router in now. I'll just bring in the dashboard and all posts listing for this demo.App.jsimportReactfrom'react'import{BrowserRouterasRouter,Switch,Route,Redirect} rom'react-router-dom'importDashboardPagefrom'./pages/DashboardPage'importPostsPagefrom'./pages/PostsPage'constApp=()=>{return(<Router><Switch><Routeexactpath=\"/\"component={DashboardPage}/><Routeexactpath=\"/posts\"component={PostsPage}/><Redirectto=\"/\"/></Switch></Router>)} xportdefaultAppWe can create the dashboard page, which is just a regular React component.pages/DashboardPage.jsimportReactfrom'react'import{Link} rom'react-router-dom'constDashboardPage=()=>(<section><h1>Dashboard</h1><p>This is the dashboard.</p><Linkto=\"/posts\"className=\"button\">View Posts</Link></section>)exportdefaultDashboardPageFor each post, let's make aPostcomponent that will display the title and an excerpt of the text of the article. Make aPost.jsin thecomponentssubdirectory.components/Post.jsimportReactfrom'react'exportconstPost=({post})=>(<articleclassName=\"post-excerpt\"><h2>{post.title}</h2><p>{post.body.substring(0,100)}</p></article>)Components that do not connect to Redux are still important and useful for smaller, reusable areas, such as this Post component.Now the interesting part comes in for the posts page - bringing Redux into React. To do this we'll useconnectfromreact-redux. First, we'll just make a regular component for the page.pages/PostsPage.jsimportReactfrom'react'constPostsPage=()=>{return(<section><h1>Posts</h1></section>)} xportdefaultPostsPageThen we'll bring inconnect.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 1000,
        "chunk_id": "ce44a83cb22103e6a639d48b1d686d36",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Theconnect functionis a higher-order function that connects the Redux store to a React component. We'll pass a parameter calledmapStateToPropstoconnect. This aptly named function will take any state from the Redux store and pass it to the props of the React component. We'll bring inloading,posts, andhasErrorsfrom the ReduxpostsReducer.pages/PostsPage.jsimportReactfrom'react'import{connect} rom'react-redux'// Redux state is now in the props of the componentconstPostsPage=({loading,posts,hasErrors})=>{return(<section><h1>Posts</h1></section>)}// Map Redux state to React component propsconstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})// Connect Redux to Reactexportdefaultconnect(mapStateToProps)(PostsPage)Since this component uses state from the same reducer, we could also writestate => state.posts. However, learning how to write it the long way is useful to know in case you need to bring multiple reducers into the same component.Finally, we'll bring in the asynchronousfetchPostsfrom the actions, which is the action that combines the whole lifecycle of fetching all posts into one. UsinguseEffectfrom React, we'lldispatchfetchPostswhen the component mounts.dispatchwill automatically be available on a connected component.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'// Bring in the asynchronous fetchPosts actionimport{fetchPosts} rom'../actions/postsActions'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])return(<section><h1>Posts</h1></section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)All that's left to do at this point is display all three possible states of the page - whether it's loading, has an error, or successfully retrieved the posts from the API.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'import{fetchPosts} rom'../actions/postsActions'import{Post} rom'../components/Post'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])// Show loading, error, or success stateconstrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post}/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)And that's all - we now have a connected component, and are bringing in data from an API to our Redux store. Using Redux DevTools, we can see each action as it happens, and the changes (diff) after each state change.The EndThis is where the tutorial for creating an application with plain Redux ends. If you look at thesource code of the demo application, you'll see a lot has been added - a reducer and actions for a single post, and for comments.I would recommend completing your project so that it matches the demo app. There are no new concepts to be learned, but you will create two more reducers and actions, and see how to bring two states into one component for the single post page, which brings in one post as well as comments for that post.Redux ToolkitThere is one more thing I want to cover -Redux Toolkit. Redux Toolkit, or RTK, is a newer and easier official way to use Redux. You may notice that Redux has alotof boilerplate for setup and requires many more folders and files than plain React would. Some patterns have emerged to attempt to mitigate all that, such asRedux ducks pattern, but we can simplify it even more.View thesource of the demo Redux Toolkit application, which is the same application we just created with Redux, but using RTK. It is much simpler, with a drastic reduction in lines of code for all the same functionality.Using RTK just requires one dependency,@reduxjs/toolkit.npmi @reduxjs/toolkitAnd no longer requires you to install theredux-thunkorredux-devtools-extensiondependencies.Advantages to Redux ToolkitThe main advantages to using RTK are:Easier to set up (less dependencies)Reduction of boilerplate code (one slice vs. many files for actions and reducers)Sensible defaults (Redux Thunk, Redux DevTools built-in)The ability to usedirect state mutation, since RTK usesimmerunder the hood. This means you no longer need to return{ ...state } ith every reducer.StoreSince Redux Toolkit comes with a lot built-in already, like Redux DevTools and Redux Thunk, we no longer have to bring them into theindex.jsfile. Now we only needconfigureStore, instead ofcreateStore.index.jsimportReactfrom'react'import{render} rom'react-dom'import{configureStore} rom'@reduxjs/toolkit'import{Provider} rom'react-redux'importAppfrom'./App'importrootReducerfrom'./slices'import'./index.css'conststore=configureStore({reducer:rootReducer})render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))SlicesInstead of dealing with reducers, actions, and all as separate files and individually creating all those action types, RTK gives us the concept ofslices. Asliceautomatically generates reducers, action types, and action creators. As such, you'll only have to create one folder -slices.initialStatewill look the same.slices/posts.jsimport{createSlice} rom'@reduxjs/toolkit'exportconstinitialState={loading:false,hasErrors:false,posts:[],} he names of the reducers in the slice will also be the same -getPosts,getPostsSuccess, andgetPostsFailure. We'll make all the same changes, but note that we're no longer returning the entire state - we're just mutating state. It's still immutable under the hood, but this approach may be easier and faster for some. If preferred, you can still return the whole state as an object.slices/posts.js// A slice for posts with our three reducersconstpostsSlice=createSlice({name:'posts',initialState,reducers:{getPosts:(state)=>{state.loading=true},getPostsSuccess:(state,{payload})=>{state.posts=payload\n      state.loading=falsestate.hasErrors=false},getPostsFailure:(state)=>{state.loading=falsestate.hasErrors=true},},})The actions that get generated are the same, we just don't have to write them out individually anymore. From the same file, we can export all the actions, the reducer, the asynchronous thunk, and one new thing - aselector, which we'll use to access any of the state from a React component instead of usingconnect.slices/posts.js// Three actions generated from the sliceexportconst{getPosts,getPostsSuccess,getPostsFailure}=postsSlice.actions// A selectorexportconstpostsSelector=(state)=>state.posts// The reducerexportdefaultpostsSlice.reducer// Asynchronous thunk actionexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} electing Redux state in a React componentThe traditional approach, as we just learned, is to usemapStateToPropswith theconnect()function. This is still common in codebases and therefore worth learning. You can still use this approach with RTK, but the newer, React Hooks way of going about it is to useuseDispatchanduseSelectorfromreact-redux. This approach requires less code overall as well.As you can see in the updatedPostsPage.jsfile below, the Redux state is no longer available as props on the connected component, but from the selector we exported in the slice.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{useDispatch,useSelector} rom'react-redux'import{fetchPosts,postsSelector} rom'../slices/posts'import{Post} rom'../components/Post'constPostsPage=()=>{constdispatch=useDispatch()const{posts,loading,hasErrors}=useSelector(postsSelector)useEffect(()=>{dispatch(fetchPosts())},[dispatch])constrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post} xcerpt/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} xportdefaultPostsPageNow we have the same app as before with a few updates from Redux Toolkit, and a lot less code to maintain.ConclusionWe did it! If you followed along with me through this whole tutorial, you should have a really good feel for Redux now, both the old-fashioned way and using Redux Toolkit to simplify things. To summarize, Redux allows us to easily manage global state in a React application. We can access and update the state from anywhere, and easily debug the entire state of an application with Redux Devtools.You can place most of the state of your application in Redux, but certain areas of an app, such as forms as they are being updated, still make sense to keep in the React component state itself until the form is officially submitted.I hope you enjoyed this article!",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 962,
        "chunk_id": "33861c3fc43be5f54517d6f1ff94d72e",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "It was a lot of work to put together two complete demo applications and run through the whole thing here, and the article ran pretty long, but hopefully this is your one-stop shop for learning all beginner and intermediate Redux concepts. Please let me know what you think and share the article if it helped you out, and donations are always welcome!About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:March 09, 2020Category:TechnicalTagsreduxreacttutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "example",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 115,
        "chunk_id": "96791525f7e53af6b5369b2eec9f621c",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "javascript"
          ]
        }
      },
      {
        "content": "Do you have experience usingReact? Have you heard ofRedux, but you've put off learning it because it looks very complicated and all the guides seem overwhelming? If that's the case, this is the article for you! Contain your fear of containing state and come along with me on this relatively painless journey.PrerequisitesYou must already know how to use React for this tutorial, as I will not be explaining any aspects of React itself.Familiarity withHTML & CSS.Familiarity withES6 syntax and features.Knowledge of React terminology:JSX, State, Components, Props, LifecycleandHooksKnowledge ofReact RouterKnowledge of asynchronous JavaScript andmaking API callsAlso, download Redux DevToolsfor Chromeorfor FireFox.GoalsIn this tutorial, we will build a small blog app. It will fetch posts and comments from an API. I've created the same app with both plain Redux, andRedux Toolkit(RTK), the officially sanctioned toolset for Redux. Here are the links to the source and demos of both the plain and RTK versions.React + Redux Application (Plain Redux)SourceDemo ApplicationReact + Redux Toolkit ApplicationSourceDemo ApplicationNote: The applications are pulling from a real API viaJSON Placeholder API. Due to rate limiting on CodeSandbox, the API may appear slow, but it has nothing to do with the Redux application itself. You can also clone the repository locally.We will learn:Whatis Redux andwhyyou might want to use itTheterminologyof Redux: actions, reducers, store, dispatch, connect, and containerMaking asynchronous API calls withRedux ThunkHow to make a small, real-world application with React and ReduxHow to use Redux Toolkit to simplify Redux app developmentWhat is Redux?Redux is a state container for JavaScript applications. Normally with React, you manage state at a component level, and pass state around via props. With Redux, the entire state of your application is managed in one immutable object. Every update to the Redux state results in a copy of sections of the state, plus the new change.Redux was originally created byDan AbramovandAndrew Clark.Why should I use Redux?Easily manage global state- access or update any part of the state from any Redux-connected componentEasily keep track of changes with Redux DevTools- any action or state change is tracked and easy to follow with Redux. The fact that the entire state of the application is tracked with each change means you can easily do time-travel debugging to move back and forth between changes.The downside to Redux is that there's a lot of initial boilerplate to set up and maintain (especially if you use plain Redux without Redux Toolkit). A smaller applicationmay not need Reduxand may instead benefit from simply usingthe Context APIfor global state needs.In my personal experience, I set up an application with Context alone, and later needed to convert everything over to Redux to make it more maintainable and organized.TerminologyUsually I don't like to just make a list of terms and definitions, but Redux has a few that are likely unfamiliar, so I'm just going to define them all up front to make it easy to refer back to them. Although you canskip to the beginning of the tutorial section, I think it would be good to read through all the definitions just to get exposure and an idea of them in your head first.ActionsReducersStoreDispatchConnectI'll just use the typical todo application, and the action of deleting a todo, for the examples.ActionsAnactionsends data from your application to the Redux store. An action is conventionally an object with two properties:typeand (optional)payload. The type is generally an uppercase string (assigned to a constant) that describes the action. The payload is additional data that may be passed.Action TypeconstDELETE_TODO='posts/deleteTodo'Action{type:DELETE_TODO,payload:id,} ction creatorsAnaction creatoris a function that returns an action.Action CreatorconstdeleteTodo=(id)=>({type:DELETE_TODO,payload:id})ReducersAreduceris a function that takes two parameters:stateandaction. A reducer is immutable and always returns a copy of the entire state. A reducer typically consists of aswitchstatement that goes through all the possible action types.ReducerconstinitialState={todos:[{id:1,text:'Eat'},{id:2,text:'Sleep'},],loading:false,hasErrors:false,} unctiontodoReducer(state=initialState,action){switch(action.type){caseDELETE_TODO:return{...state,todos:state.todos.filter((todo)=>todo.id!==action.payload),} efault:returnstate}} toreThe Redux application state lives in thestore, which is initialized with a reducer. When used with React, a<Provider>exists to wrap the application, and anything within the Provider can have access to Redux.Storeimport{createStore} rom'redux'import{Provider} rom'react-redux'importreducerfrom'./reducers'conststore=createStore(reducer)render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Dispatchdispatchis a method available on the store object that accepts an object which is used to update the Redux state. Usually, this object is the result of invoking an action creator.constComponent=({dispatch})=>{useEffect(()=>{dispatch(deleteTodo())},[dispatch])} onnectTheconnect()function is one typical way to connect React to Redux. A connected component is sometimes referred to as acontainer.Okay, that about covers it for the major terms of Redux. It can be overwhelming to read the terminology without any context, so let's begin.Getting StartedFor ease of getting started quickly, my example usesCreate React Appto set up the environment.npx create-react-app redux-tutorialcdredux-tutorialRedux requires a few dependencies.Redux- Core libraryReact Redux- React bindings for ReduxRedux Thunk- Async middleware for ReduxRedux DevTools Extension- Connects Redux app to Redux DevToolsYou canyarn addornpm ithem, and I'll be usingreact-router-domas well, but that's it for extra dependencies.npmi\\redux\\react-redux\\redux-thunk\\redux-devtools-extension\\react-router-domAnd delete all the boilerplate. We'll add everything we need from scratch instead.cdsrc&&rm*# move to src and delete all files withinWe'll make directories for Reduxreducersand Reduxactions, as well aspagesandcomponentswhich you should already be familiar with from React.mkdiractions components pages reducersAnd we'll bring backindex.js,App.js, andindex.css.touchindex.js index.css App.jsSo at this point your project directory tree looks like this.└── src/\n    ├── actions/\n    ├── components/\n    ├── pages/\n    ├── reducers/\n    ├── App.js\n    ├── index.css\n    └── index.jsFor theindex.cssfile, just take the contents ofthis gistand paste it. I intend only to go over functionality and not anything about style, so I just wrote some very basic styles to ensure the site looks decent enough.Now we have enough boilerplate to get started, so we'll begin working on the entrypoint.Setting up the Redux StoreWhen I first started learning Redux, it seemed so overwhelming because every app I looked at hadindex.jsset up a bit differently.",
        "chunk_type": "code_markup",
        "tag": "section",
        "score": 0.9950000000000001,
        "word_count": 928,
        "chunk_id": "6f17d1ad6b267106210d686119946326",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "article",
            "development",
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "After looking at a lot of the more up-to-date apps and taking the aspects that were common across all of them, I got a good feel for what should really be in a Redux app, and what is just people moving things around to be unique.There are plenty of tutorials out there that show you how to get a very basic Redux store with todos set up, but I don't find that very useful for knowing how to make a production level setup, so I'm going to set it up with everything you need from the get-go. Even so, there will be some opinionated aspects because Redux is very flexible.Inindex.js, we'll be bringing in a few things.createStore, to create the store that will maintain the Redux stateapplyMiddleware, to be able to use middleware, in this casethunkProvider, to wrap the entire application in Reduxthunk, a middleware that allows us to make asynchronous actions in ReduxcomposeWithDevTools, code that connects your app to Redux DevToolsindex.js// External importsimportReactfrom'react'import{render} rom'react-dom'import{createStore,applyMiddleware} rom'redux'import{Provider} rom'react-redux'importthunkfrom'redux-thunk'import{composeWithDevTools} rom'redux-devtools-extension'// Local importsimportAppfrom'./App'importrootReducerfrom'./reducers'// Assetsimport'./index.css'conststore=createStore(rootReducer,composeWithDevTools(applyMiddleware(thunk)))render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Put a component inApp.js. We'll modify this later, but we just want to get the app up and running for now.App.jsimportReactfrom'react'constApp=()=>{return<div>Hello, Redux</div>} xportdefaultAppBringing in reducersThe last thing to do is bring in the reducer. Areduceris a function that determines changes to Redux state. It is a pure function that returns a copy of the state with the new change.A neat feature of Redux is that we can have many reducers, and combine them all into one root reducer that the store uses, usingcombineReducers. This leads to us being able to easily organize our code while still having everything in one root state tree.Since this app will be like a blog, it will have a list of posts, and we'll put that in thepostsReducerin a moment. Having thiscombineReducersmethod allows us to bring whatever we want in - acommentsReducer, anauthReducer, and so on.Inreducers/index.js, create the file that will combine all reducers.reducers/index.jsimport{combineReducers} rom'redux'importpostsReducerfrom'./postsReducer'constrootReducer=combineReducers({posts:postsReducer,})exportdefaultrootReducerFinally, we'll make thepostsReducer. We can set it up with an initial state. Just like you might expect from a regular React component, we'll have aloadingandhasErrorsstate, as well as apostsarray, where all the posts will live. First we'll set it up with no actions in the switch, just a default case that returns the entire state.reducers/postsReducer.jsexportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow we at least have enough setup that the application will load without crashing.Redux DevToolsWith the application loading and the Redux<Provider>set up, we can take a look at Redux DevTools. After downloading it, it'll be a tab in your Developer Tools. If you click onState, you'll see the entire state of the application so far.There's not much in here yet, but Redux DevTools is amazing once you get to having a lot of reducers and actions. It keeps track of all changes to your app and makes debugging a breeze compared to plain React.Setting up Redux ActionsSo now we have a reducer for posts, but we don't have any actions, meaning the reducer will only return the state without modifying it in any way.Actionsare how we communicate with the Redux store. For this blog app, we're going to want to fetch posts from an API and put them in our Redux state.Since fetching posts is an asynchronous action, it will require the use of Redux thunk. Fortunately, we don't have to do anything special to use thunk beyond setting it up in the store, which we already did.Create aactions/postsActions.js. First, we'll define theaction typesas constants. This is not necessary, but is a common convention, and makes it easy to export the actions around and prevent typos. We want to do three things:getPosts- begin telling Redux we're going to fetch posts from an APIgetPostsSuccess- pass the posts to Redux on successful API callgetPostsFailure- inform Redux that an error was encountered during Redux on failed API callactions/postsActions.js// Create Redux action typesexportconstGET_POSTS='GET_POSTS'exportconstGET_POSTS_SUCCESS='GET_POSTS_SUCCESS'exportconstGET_POSTS_FAILURE='GET_POSTS_FAILURE'Then createaction creators, functions that return anaction, which consists of the type and an optional payload containing data.actions/postsActions.js// Create Redux action creators that return an actionexportconstgetPosts=()=>({type:GET_POSTS,})exportconstgetPostsSuccess=(posts)=>({type:GET_POSTS_SUCCESS,payload:posts,})exportconstgetPostsFailure=()=>({type:GET_POSTS_FAILURE,})Finally, make the asynchronous thunk action that combines all three of the above actions. When called, it will dispatch the initialgetPosts()action to inform Redux to prepare for an API call, then in atry/catch, do everything necessary to get the data, and dispatch a success or failure action as necessary.actions/postsActions.js// Combine them all in an asynchronous thunkexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} reat, we're all done with creating actions now! All that's left to do is tell the reducer what to do with the state on each action.Responding to actionsBack at our post reducer, we have a switch that isn't doing anything yet.reducers/postsReducer.jsexportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow that we have actions, we can bring them in from thepostsActionspage.// Import all actionsimport*asactionsfrom'../actions/postsActions'For each action, we'll make acase, that returns the entire state plus whatever change we're making to it. ForGET_POSTS, for example, all we want to do is tell the app to setloadingtotruesince we'll be making an API call.caseactions.GET_POSTS:return{...state,loading:true} ET_POSTS- begin loadingGET_POSTS_SUCCESS- the app has posts, no errors, and should stop loadingGET_POSTS_FAILURE- the app has errors and should stop loadingHere's the whole reducer.reducers/postsReducer.jsimport*asactionsfrom'../actions/postsActions'exportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){caseactions.GET_POSTS:return{...state,loading:true} aseactions.GET_POSTS_SUCCESS:return{posts:action.payload,loading:false,hasErrors:false} aseactions.GET_POSTS_FAILURE:return{...state,loading:false,hasErrors:true} efault:returnstate}} ow our actions and reducers are ready, so all that's left to do is connect everything to the React app.Connecting Redux to React ComponentsSince the demo app I've created uses React Router to have a few routes - a dashboard, a listing of all posts, and an individual posts page, I'll bring React Router in now. I'll just bring in the dashboard and all posts listing for this demo.App.jsimportReactfrom'react'import{BrowserRouterasRouter,Switch,Route,Redirect} rom'react-router-dom'importDashboardPagefrom'./pages/DashboardPage'importPostsPagefrom'./pages/PostsPage'constApp=()=>{return(<Router><Switch><Routeexactpath=\"/\"component={DashboardPage}/><Routeexactpath=\"/posts\"component={PostsPage}/><Redirectto=\"/\"/></Switch></Router>)} xportdefaultAppWe can create the dashboard page, which is just a regular React component.pages/DashboardPage.jsimportReactfrom'react'import{Link} rom'react-router-dom'constDashboardPage=()=>(<section><h1>Dashboard</h1><p>This is the dashboard.</p><Linkto=\"/posts\"className=\"button\">View Posts</Link></section>)exportdefaultDashboardPageFor each post, let's make aPostcomponent that will display the title and an excerpt of the text of the article. Make aPost.jsin thecomponentssubdirectory.components/Post.jsimportReactfrom'react'exportconstPost=({post})=>(<articleclassName=\"post-excerpt\"><h2>{post.title}</h2><p>{post.body.substring(0,100)}</p></article>)Components that do not connect to Redux are still important and useful for smaller, reusable areas, such as this Post component.Now the interesting part comes in for the posts page - bringing Redux into React. To do this we'll useconnectfromreact-redux. First, we'll just make a regular component for the page.pages/PostsPage.jsimportReactfrom'react'constPostsPage=()=>{return(<section><h1>Posts</h1></section>)} xportdefaultPostsPageThen we'll bring inconnect.",
        "chunk_type": "code_markup",
        "tag": "section",
        "score": 0.9950000000000001,
        "word_count": 1000,
        "chunk_id": "ce44a83cb22103e6a639d48b1d686d36",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Theconnect functionis a higher-order function that connects the Redux store to a React component. We'll pass a parameter calledmapStateToPropstoconnect. This aptly named function will take any state from the Redux store and pass it to the props of the React component. We'll bring inloading,posts, andhasErrorsfrom the ReduxpostsReducer.pages/PostsPage.jsimportReactfrom'react'import{connect} rom'react-redux'// Redux state is now in the props of the componentconstPostsPage=({loading,posts,hasErrors})=>{return(<section><h1>Posts</h1></section>)}// Map Redux state to React component propsconstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})// Connect Redux to Reactexportdefaultconnect(mapStateToProps)(PostsPage)Since this component uses state from the same reducer, we could also writestate => state.posts. However, learning how to write it the long way is useful to know in case you need to bring multiple reducers into the same component.Finally, we'll bring in the asynchronousfetchPostsfrom the actions, which is the action that combines the whole lifecycle of fetching all posts into one. UsinguseEffectfrom React, we'lldispatchfetchPostswhen the component mounts.dispatchwill automatically be available on a connected component.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'// Bring in the asynchronous fetchPosts actionimport{fetchPosts} rom'../actions/postsActions'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])return(<section><h1>Posts</h1></section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)All that's left to do at this point is display all three possible states of the page - whether it's loading, has an error, or successfully retrieved the posts from the API.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'import{fetchPosts} rom'../actions/postsActions'import{Post} rom'../components/Post'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])// Show loading, error, or success stateconstrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post}/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)And that's all - we now have a connected component, and are bringing in data from an API to our Redux store. Using Redux DevTools, we can see each action as it happens, and the changes (diff) after each state change.The EndThis is where the tutorial for creating an application with plain Redux ends. If you look at thesource code of the demo application, you'll see a lot has been added - a reducer and actions for a single post, and for comments.I would recommend completing your project so that it matches the demo app. There are no new concepts to be learned, but you will create two more reducers and actions, and see how to bring two states into one component for the single post page, which brings in one post as well as comments for that post.Redux ToolkitThere is one more thing I want to cover -Redux Toolkit. Redux Toolkit, or RTK, is a newer and easier official way to use Redux. You may notice that Redux has alotof boilerplate for setup and requires many more folders and files than plain React would. Some patterns have emerged to attempt to mitigate all that, such asRedux ducks pattern, but we can simplify it even more.View thesource of the demo Redux Toolkit application, which is the same application we just created with Redux, but using RTK. It is much simpler, with a drastic reduction in lines of code for all the same functionality.Using RTK just requires one dependency,@reduxjs/toolkit.npmi @reduxjs/toolkitAnd no longer requires you to install theredux-thunkorredux-devtools-extensiondependencies.Advantages to Redux ToolkitThe main advantages to using RTK are:Easier to set up (less dependencies)Reduction of boilerplate code (one slice vs. many files for actions and reducers)Sensible defaults (Redux Thunk, Redux DevTools built-in)The ability to usedirect state mutation, since RTK usesimmerunder the hood. This means you no longer need to return{ ...state } ith every reducer.StoreSince Redux Toolkit comes with a lot built-in already, like Redux DevTools and Redux Thunk, we no longer have to bring them into theindex.jsfile. Now we only needconfigureStore, instead ofcreateStore.index.jsimportReactfrom'react'import{render} rom'react-dom'import{configureStore} rom'@reduxjs/toolkit'import{Provider} rom'react-redux'importAppfrom'./App'importrootReducerfrom'./slices'import'./index.css'conststore=configureStore({reducer:rootReducer})render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))SlicesInstead of dealing with reducers, actions, and all as separate files and individually creating all those action types, RTK gives us the concept ofslices. Asliceautomatically generates reducers, action types, and action creators. As such, you'll only have to create one folder -slices.initialStatewill look the same.slices/posts.jsimport{createSlice} rom'@reduxjs/toolkit'exportconstinitialState={loading:false,hasErrors:false,posts:[],} he names of the reducers in the slice will also be the same -getPosts,getPostsSuccess, andgetPostsFailure. We'll make all the same changes, but note that we're no longer returning the entire state - we're just mutating state. It's still immutable under the hood, but this approach may be easier and faster for some. If preferred, you can still return the whole state as an object.slices/posts.js// A slice for posts with our three reducersconstpostsSlice=createSlice({name:'posts',initialState,reducers:{getPosts:(state)=>{state.loading=true},getPostsSuccess:(state,{payload})=>{state.posts=payload\n      state.loading=falsestate.hasErrors=false},getPostsFailure:(state)=>{state.loading=falsestate.hasErrors=true},},})The actions that get generated are the same, we just don't have to write them out individually anymore. From the same file, we can export all the actions, the reducer, the asynchronous thunk, and one new thing - aselector, which we'll use to access any of the state from a React component instead of usingconnect.slices/posts.js// Three actions generated from the sliceexportconst{getPosts,getPostsSuccess,getPostsFailure}=postsSlice.actions// A selectorexportconstpostsSelector=(state)=>state.posts// The reducerexportdefaultpostsSlice.reducer// Asynchronous thunk actionexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} electing Redux state in a React componentThe traditional approach, as we just learned, is to usemapStateToPropswith theconnect()function. This is still common in codebases and therefore worth learning. You can still use this approach with RTK, but the newer, React Hooks way of going about it is to useuseDispatchanduseSelectorfromreact-redux. This approach requires less code overall as well.As you can see in the updatedPostsPage.jsfile below, the Redux state is no longer available as props on the connected component, but from the selector we exported in the slice.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{useDispatch,useSelector} rom'react-redux'import{fetchPosts,postsSelector} rom'../slices/posts'import{Post} rom'../components/Post'constPostsPage=()=>{constdispatch=useDispatch()const{posts,loading,hasErrors}=useSelector(postsSelector)useEffect(()=>{dispatch(fetchPosts())},[dispatch])constrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post} xcerpt/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} xportdefaultPostsPageNow we have the same app as before with a few updates from Redux Toolkit, and a lot less code to maintain.ConclusionWe did it! If you followed along with me through this whole tutorial, you should have a really good feel for Redux now, both the old-fashioned way and using Redux Toolkit to simplify things. To summarize, Redux allows us to easily manage global state in a React application. We can access and update the state from anywhere, and easily debug the entire state of an application with Redux Devtools.You can place most of the state of your application in Redux, but certain areas of an app, such as forms as they are being updated, still make sense to keep in the React component state itself until the form is officially submitted.I hope you enjoyed this article!",
        "chunk_type": "code_markup",
        "tag": "section",
        "score": 0.9950000000000001,
        "word_count": 962,
        "chunk_id": "33861c3fc43be5f54517d6f1ff94d72e",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "It was a lot of work to put together two complete demo applications and run through the whole thing here, and the article ran pretty long, but hopefully this is your one-stop shop for learning all beginner and intermediate Redux concepts. Please let me know what you think and share the article if it helped you out, and donations are always welcome!",
        "chunk_type": "text",
        "tag": "section",
        "score": 0.9950000000000001,
        "word_count": 62,
        "chunk_id": "3844023a704de7c7fddf3e35d714cd7b",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "article"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "javascript"
          ]
        }
      },
      {
        "content": "Do you have experience usingReact? Have you heard ofRedux, but you've put off learning it because it looks very complicated and all the guides seem overwhelming? If that's the case, this is the article for you! Contain your fear of containing state and come along with me on this relatively painless journey.PrerequisitesYou must already know how to use React for this tutorial, as I will not be explaining any aspects of React itself.Familiarity withHTML & CSS.Familiarity withES6 syntax and features.Knowledge of React terminology:JSX, State, Components, Props, LifecycleandHooksKnowledge ofReact RouterKnowledge of asynchronous JavaScript andmaking API callsAlso, download Redux DevToolsfor Chromeorfor FireFox.GoalsIn this tutorial, we will build a small blog app. It will fetch posts and comments from an API. I've created the same app with both plain Redux, andRedux Toolkit(RTK), the officially sanctioned toolset for Redux. Here are the links to the source and demos of both the plain and RTK versions.React + Redux Application (Plain Redux)SourceDemo ApplicationReact + Redux Toolkit ApplicationSourceDemo ApplicationNote: The applications are pulling from a real API viaJSON Placeholder API. Due to rate limiting on CodeSandbox, the API may appear slow, but it has nothing to do with the Redux application itself. You can also clone the repository locally.We will learn:Whatis Redux andwhyyou might want to use itTheterminologyof Redux: actions, reducers, store, dispatch, connect, and containerMaking asynchronous API calls withRedux ThunkHow to make a small, real-world application with React and ReduxHow to use Redux Toolkit to simplify Redux app developmentWhat is Redux?Redux is a state container for JavaScript applications. Normally with React, you manage state at a component level, and pass state around via props. With Redux, the entire state of your application is managed in one immutable object. Every update to the Redux state results in a copy of sections of the state, plus the new change.Redux was originally created byDan AbramovandAndrew Clark.Why should I use Redux?Easily manage global state- access or update any part of the state from any Redux-connected componentEasily keep track of changes with Redux DevTools- any action or state change is tracked and easy to follow with Redux. The fact that the entire state of the application is tracked with each change means you can easily do time-travel debugging to move back and forth between changes.The downside to Redux is that there's a lot of initial boilerplate to set up and maintain (especially if you use plain Redux without Redux Toolkit). A smaller applicationmay not need Reduxand may instead benefit from simply usingthe Context APIfor global state needs.In my personal experience, I set up an application with Context alone, and later needed to convert everything over to Redux to make it more maintainable and organized.TerminologyUsually I don't like to just make a list of terms and definitions, but Redux has a few that are likely unfamiliar, so I'm just going to define them all up front to make it easy to refer back to them. Although you canskip to the beginning of the tutorial section, I think it would be good to read through all the definitions just to get exposure and an idea of them in your head first.ActionsReducersStoreDispatchConnectI'll just use the typical todo application, and the action of deleting a todo, for the examples.ActionsAnactionsends data from your application to the Redux store. An action is conventionally an object with two properties:typeand (optional)payload. The type is generally an uppercase string (assigned to a constant) that describes the action. The payload is additional data that may be passed.Action TypeconstDELETE_TODO='posts/deleteTodo'Action{type:DELETE_TODO,payload:id,} ction creatorsAnaction creatoris a function that returns an action.Action CreatorconstdeleteTodo=(id)=>({type:DELETE_TODO,payload:id})ReducersAreduceris a function that takes two parameters:stateandaction. A reducer is immutable and always returns a copy of the entire state. A reducer typically consists of aswitchstatement that goes through all the possible action types.ReducerconstinitialState={todos:[{id:1,text:'Eat'},{id:2,text:'Sleep'},],loading:false,hasErrors:false,} unctiontodoReducer(state=initialState,action){switch(action.type){caseDELETE_TODO:return{...state,todos:state.todos.filter((todo)=>todo.id!==action.payload),} efault:returnstate}} toreThe Redux application state lives in thestore, which is initialized with a reducer. When used with React, a<Provider>exists to wrap the application, and anything within the Provider can have access to Redux.Storeimport{createStore} rom'redux'import{Provider} rom'react-redux'importreducerfrom'./reducers'conststore=createStore(reducer)render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Dispatchdispatchis a method available on the store object that accepts an object which is used to update the Redux state. Usually, this object is the result of invoking an action creator.constComponent=({dispatch})=>{useEffect(()=>{dispatch(deleteTodo())},[dispatch])} onnectTheconnect()function is one typical way to connect React to Redux. A connected component is sometimes referred to as acontainer.Okay, that about covers it for the major terms of Redux. It can be overwhelming to read the terminology without any context, so let's begin.Getting StartedFor ease of getting started quickly, my example usesCreate React Appto set up the environment.npx create-react-app redux-tutorialcdredux-tutorialRedux requires a few dependencies.Redux- Core libraryReact Redux- React bindings for ReduxRedux Thunk- Async middleware for ReduxRedux DevTools Extension- Connects Redux app to Redux DevToolsYou canyarn addornpm ithem, and I'll be usingreact-router-domas well, but that's it for extra dependencies.npmi\\redux\\react-redux\\redux-thunk\\redux-devtools-extension\\react-router-domAnd delete all the boilerplate. We'll add everything we need from scratch instead.cdsrc&&rm*# move to src and delete all files withinWe'll make directories for Reduxreducersand Reduxactions, as well aspagesandcomponentswhich you should already be familiar with from React.mkdiractions components pages reducersAnd we'll bring backindex.js,App.js, andindex.css.touchindex.js index.css App.jsSo at this point your project directory tree looks like this.└── src/\n    ├── actions/\n    ├── components/\n    ├── pages/\n    ├── reducers/\n    ├── App.js\n    ├── index.css\n    └── index.jsFor theindex.cssfile, just take the contents ofthis gistand paste it. I intend only to go over functionality and not anything about style, so I just wrote some very basic styles to ensure the site looks decent enough.Now we have enough boilerplate to get started, so we'll begin working on the entrypoint.Setting up the Redux StoreWhen I first started learning Redux, it seemed so overwhelming because every app I looked at hadindex.jsset up a bit differently.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.9950000000000001,
        "word_count": 928,
        "chunk_id": "6f17d1ad6b267106210d686119946326",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "development",
            "react"
          ],
          "attributes": {
            "id": "/redux-react-guide/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "After looking at a lot of the more up-to-date apps and taking the aspects that were common across all of them, I got a good feel for what should really be in a Redux app, and what is just people moving things around to be unique.There are plenty of tutorials out there that show you how to get a very basic Redux store with todos set up, but I don't find that very useful for knowing how to make a production level setup, so I'm going to set it up with everything you need from the get-go. Even so, there will be some opinionated aspects because Redux is very flexible.Inindex.js, we'll be bringing in a few things.createStore, to create the store that will maintain the Redux stateapplyMiddleware, to be able to use middleware, in this casethunkProvider, to wrap the entire application in Reduxthunk, a middleware that allows us to make asynchronous actions in ReduxcomposeWithDevTools, code that connects your app to Redux DevToolsindex.js// External importsimportReactfrom'react'import{render} rom'react-dom'import{createStore,applyMiddleware} rom'redux'import{Provider} rom'react-redux'importthunkfrom'redux-thunk'import{composeWithDevTools} rom'redux-devtools-extension'// Local importsimportAppfrom'./App'importrootReducerfrom'./reducers'// Assetsimport'./index.css'conststore=createStore(rootReducer,composeWithDevTools(applyMiddleware(thunk)))render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Put a component inApp.js. We'll modify this later, but we just want to get the app up and running for now.App.jsimportReactfrom'react'constApp=()=>{return<div>Hello, Redux</div>} xportdefaultAppBringing in reducersThe last thing to do is bring in the reducer. Areduceris a function that determines changes to Redux state. It is a pure function that returns a copy of the state with the new change.A neat feature of Redux is that we can have many reducers, and combine them all into one root reducer that the store uses, usingcombineReducers. This leads to us being able to easily organize our code while still having everything in one root state tree.Since this app will be like a blog, it will have a list of posts, and we'll put that in thepostsReducerin a moment. Having thiscombineReducersmethod allows us to bring whatever we want in - acommentsReducer, anauthReducer, and so on.Inreducers/index.js, create the file that will combine all reducers.reducers/index.jsimport{combineReducers} rom'redux'importpostsReducerfrom'./postsReducer'constrootReducer=combineReducers({posts:postsReducer,})exportdefaultrootReducerFinally, we'll make thepostsReducer. We can set it up with an initial state. Just like you might expect from a regular React component, we'll have aloadingandhasErrorsstate, as well as apostsarray, where all the posts will live. First we'll set it up with no actions in the switch, just a default case that returns the entire state.reducers/postsReducer.jsexportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow we at least have enough setup that the application will load without crashing.Redux DevToolsWith the application loading and the Redux<Provider>set up, we can take a look at Redux DevTools. After downloading it, it'll be a tab in your Developer Tools. If you click onState, you'll see the entire state of the application so far.There's not much in here yet, but Redux DevTools is amazing once you get to having a lot of reducers and actions. It keeps track of all changes to your app and makes debugging a breeze compared to plain React.Setting up Redux ActionsSo now we have a reducer for posts, but we don't have any actions, meaning the reducer will only return the state without modifying it in any way.Actionsare how we communicate with the Redux store. For this blog app, we're going to want to fetch posts from an API and put them in our Redux state.Since fetching posts is an asynchronous action, it will require the use of Redux thunk. Fortunately, we don't have to do anything special to use thunk beyond setting it up in the store, which we already did.Create aactions/postsActions.js. First, we'll define theaction typesas constants. This is not necessary, but is a common convention, and makes it easy to export the actions around and prevent typos. We want to do three things:getPosts- begin telling Redux we're going to fetch posts from an APIgetPostsSuccess- pass the posts to Redux on successful API callgetPostsFailure- inform Redux that an error was encountered during Redux on failed API callactions/postsActions.js// Create Redux action typesexportconstGET_POSTS='GET_POSTS'exportconstGET_POSTS_SUCCESS='GET_POSTS_SUCCESS'exportconstGET_POSTS_FAILURE='GET_POSTS_FAILURE'Then createaction creators, functions that return anaction, which consists of the type and an optional payload containing data.actions/postsActions.js// Create Redux action creators that return an actionexportconstgetPosts=()=>({type:GET_POSTS,})exportconstgetPostsSuccess=(posts)=>({type:GET_POSTS_SUCCESS,payload:posts,})exportconstgetPostsFailure=()=>({type:GET_POSTS_FAILURE,})Finally, make the asynchronous thunk action that combines all three of the above actions. When called, it will dispatch the initialgetPosts()action to inform Redux to prepare for an API call, then in atry/catch, do everything necessary to get the data, and dispatch a success or failure action as necessary.actions/postsActions.js// Combine them all in an asynchronous thunkexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} reat, we're all done with creating actions now! All that's left to do is tell the reducer what to do with the state on each action.Responding to actionsBack at our post reducer, we have a switch that isn't doing anything yet.reducers/postsReducer.jsexportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow that we have actions, we can bring them in from thepostsActionspage.// Import all actionsimport*asactionsfrom'../actions/postsActions'For each action, we'll make acase, that returns the entire state plus whatever change we're making to it. ForGET_POSTS, for example, all we want to do is tell the app to setloadingtotruesince we'll be making an API call.caseactions.GET_POSTS:return{...state,loading:true} ET_POSTS- begin loadingGET_POSTS_SUCCESS- the app has posts, no errors, and should stop loadingGET_POSTS_FAILURE- the app has errors and should stop loadingHere's the whole reducer.reducers/postsReducer.jsimport*asactionsfrom'../actions/postsActions'exportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){caseactions.GET_POSTS:return{...state,loading:true} aseactions.GET_POSTS_SUCCESS:return{posts:action.payload,loading:false,hasErrors:false} aseactions.GET_POSTS_FAILURE:return{...state,loading:false,hasErrors:true} efault:returnstate}} ow our actions and reducers are ready, so all that's left to do is connect everything to the React app.Connecting Redux to React ComponentsSince the demo app I've created uses React Router to have a few routes - a dashboard, a listing of all posts, and an individual posts page, I'll bring React Router in now. I'll just bring in the dashboard and all posts listing for this demo.App.jsimportReactfrom'react'import{BrowserRouterasRouter,Switch,Route,Redirect} rom'react-router-dom'importDashboardPagefrom'./pages/DashboardPage'importPostsPagefrom'./pages/PostsPage'constApp=()=>{return(<Router><Switch><Routeexactpath=\"/\"component={DashboardPage}/><Routeexactpath=\"/posts\"component={PostsPage}/><Redirectto=\"/\"/></Switch></Router>)} xportdefaultAppWe can create the dashboard page, which is just a regular React component.pages/DashboardPage.jsimportReactfrom'react'import{Link} rom'react-router-dom'constDashboardPage=()=>(<section><h1>Dashboard</h1><p>This is the dashboard.</p><Linkto=\"/posts\"className=\"button\">View Posts</Link></section>)exportdefaultDashboardPageFor each post, let's make aPostcomponent that will display the title and an excerpt of the text of the article. Make aPost.jsin thecomponentssubdirectory.components/Post.jsimportReactfrom'react'exportconstPost=({post})=>(<articleclassName=\"post-excerpt\"><h2>{post.title}</h2><p>{post.body.substring(0,100)}</p></article>)Components that do not connect to Redux are still important and useful for smaller, reusable areas, such as this Post component.Now the interesting part comes in for the posts page - bringing Redux into React. To do this we'll useconnectfromreact-redux. First, we'll just make a regular component for the page.pages/PostsPage.jsimportReactfrom'react'constPostsPage=()=>{return(<section><h1>Posts</h1></section>)} xportdefaultPostsPageThen we'll bring inconnect.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.9950000000000001,
        "word_count": 1000,
        "chunk_id": "ce44a83cb22103e6a639d48b1d686d36",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "id": "/redux-react-guide/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Theconnect functionis a higher-order function that connects the Redux store to a React component. We'll pass a parameter calledmapStateToPropstoconnect. This aptly named function will take any state from the Redux store and pass it to the props of the React component. We'll bring inloading,posts, andhasErrorsfrom the ReduxpostsReducer.pages/PostsPage.jsimportReactfrom'react'import{connect} rom'react-redux'// Redux state is now in the props of the componentconstPostsPage=({loading,posts,hasErrors})=>{return(<section><h1>Posts</h1></section>)}// Map Redux state to React component propsconstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})// Connect Redux to Reactexportdefaultconnect(mapStateToProps)(PostsPage)Since this component uses state from the same reducer, we could also writestate => state.posts. However, learning how to write it the long way is useful to know in case you need to bring multiple reducers into the same component.Finally, we'll bring in the asynchronousfetchPostsfrom the actions, which is the action that combines the whole lifecycle of fetching all posts into one. UsinguseEffectfrom React, we'lldispatchfetchPostswhen the component mounts.dispatchwill automatically be available on a connected component.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'// Bring in the asynchronous fetchPosts actionimport{fetchPosts} rom'../actions/postsActions'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])return(<section><h1>Posts</h1></section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)All that's left to do at this point is display all three possible states of the page - whether it's loading, has an error, or successfully retrieved the posts from the API.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'import{fetchPosts} rom'../actions/postsActions'import{Post} rom'../components/Post'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])// Show loading, error, or success stateconstrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post}/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)And that's all - we now have a connected component, and are bringing in data from an API to our Redux store. Using Redux DevTools, we can see each action as it happens, and the changes (diff) after each state change.The EndThis is where the tutorial for creating an application with plain Redux ends. If you look at thesource code of the demo application, you'll see a lot has been added - a reducer and actions for a single post, and for comments.I would recommend completing your project so that it matches the demo app. There are no new concepts to be learned, but you will create two more reducers and actions, and see how to bring two states into one component for the single post page, which brings in one post as well as comments for that post.Redux ToolkitThere is one more thing I want to cover -Redux Toolkit. Redux Toolkit, or RTK, is a newer and easier official way to use Redux. You may notice that Redux has alotof boilerplate for setup and requires many more folders and files than plain React would. Some patterns have emerged to attempt to mitigate all that, such asRedux ducks pattern, but we can simplify it even more.View thesource of the demo Redux Toolkit application, which is the same application we just created with Redux, but using RTK. It is much simpler, with a drastic reduction in lines of code for all the same functionality.Using RTK just requires one dependency,@reduxjs/toolkit.npmi @reduxjs/toolkitAnd no longer requires you to install theredux-thunkorredux-devtools-extensiondependencies.Advantages to Redux ToolkitThe main advantages to using RTK are:Easier to set up (less dependencies)Reduction of boilerplate code (one slice vs. many files for actions and reducers)Sensible defaults (Redux Thunk, Redux DevTools built-in)The ability to usedirect state mutation, since RTK usesimmerunder the hood. This means you no longer need to return{ ...state } ith every reducer.StoreSince Redux Toolkit comes with a lot built-in already, like Redux DevTools and Redux Thunk, we no longer have to bring them into theindex.jsfile. Now we only needconfigureStore, instead ofcreateStore.index.jsimportReactfrom'react'import{render} rom'react-dom'import{configureStore} rom'@reduxjs/toolkit'import{Provider} rom'react-redux'importAppfrom'./App'importrootReducerfrom'./slices'import'./index.css'conststore=configureStore({reducer:rootReducer})render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))SlicesInstead of dealing with reducers, actions, and all as separate files and individually creating all those action types, RTK gives us the concept ofslices. Asliceautomatically generates reducers, action types, and action creators. As such, you'll only have to create one folder -slices.initialStatewill look the same.slices/posts.jsimport{createSlice} rom'@reduxjs/toolkit'exportconstinitialState={loading:false,hasErrors:false,posts:[],} he names of the reducers in the slice will also be the same -getPosts,getPostsSuccess, andgetPostsFailure. We'll make all the same changes, but note that we're no longer returning the entire state - we're just mutating state. It's still immutable under the hood, but this approach may be easier and faster for some. If preferred, you can still return the whole state as an object.slices/posts.js// A slice for posts with our three reducersconstpostsSlice=createSlice({name:'posts',initialState,reducers:{getPosts:(state)=>{state.loading=true},getPostsSuccess:(state,{payload})=>{state.posts=payload\n      state.loading=falsestate.hasErrors=false},getPostsFailure:(state)=>{state.loading=falsestate.hasErrors=true},},})The actions that get generated are the same, we just don't have to write them out individually anymore. From the same file, we can export all the actions, the reducer, the asynchronous thunk, and one new thing - aselector, which we'll use to access any of the state from a React component instead of usingconnect.slices/posts.js// Three actions generated from the sliceexportconst{getPosts,getPostsSuccess,getPostsFailure}=postsSlice.actions// A selectorexportconstpostsSelector=(state)=>state.posts// The reducerexportdefaultpostsSlice.reducer// Asynchronous thunk actionexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} electing Redux state in a React componentThe traditional approach, as we just learned, is to usemapStateToPropswith theconnect()function. This is still common in codebases and therefore worth learning. You can still use this approach with RTK, but the newer, React Hooks way of going about it is to useuseDispatchanduseSelectorfromreact-redux. This approach requires less code overall as well.As you can see in the updatedPostsPage.jsfile below, the Redux state is no longer available as props on the connected component, but from the selector we exported in the slice.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{useDispatch,useSelector} rom'react-redux'import{fetchPosts,postsSelector} rom'../slices/posts'import{Post} rom'../components/Post'constPostsPage=()=>{constdispatch=useDispatch()const{posts,loading,hasErrors}=useSelector(postsSelector)useEffect(()=>{dispatch(fetchPosts())},[dispatch])constrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post} xcerpt/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} xportdefaultPostsPageNow we have the same app as before with a few updates from Redux Toolkit, and a lot less code to maintain.ConclusionWe did it! If you followed along with me through this whole tutorial, you should have a really good feel for Redux now, both the old-fashioned way and using Redux Toolkit to simplify things. To summarize, Redux allows us to easily manage global state in a React application. We can access and update the state from anywhere, and easily debug the entire state of an application with Redux Devtools.You can place most of the state of your application in Redux, but certain areas of an app, such as forms as they are being updated, still make sense to keep in the React component state itself until the form is officially submitted.I hope you enjoyed this article!",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.9950000000000001,
        "word_count": 962,
        "chunk_id": "33861c3fc43be5f54517d6f1ff94d72e",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "id": "/redux-react-guide/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "It was a lot of work to put together two complete demo applications and run through the whole thing here, and the article ran pretty long, but hopefully this is your one-stop shop for learning all beginner and intermediate Redux concepts. Please let me know what you think and share the article if it helped you out, and donations are always welcome!",
        "chunk_type": "text",
        "tag": "div",
        "score": 0.9950000000000001,
        "word_count": 62,
        "chunk_id": "3844023a704de7c7fddf3e35d714cd7b",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article"
          ],
          "attributes": {
            "id": "/redux-react-guide/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "javascript"
          ]
        }
      },
      {
        "content": "Do you have experience usingReact? Have you heard ofRedux, but you've put off learning it because it looks very complicated and all the guides seem overwhelming? If that's the case, this is the article for you! Contain your fear of containing state and come along with me on this relatively painless journey.",
        "chunk_type": "technical_content",
        "tag": "p",
        "score": 0.386,
        "word_count": 52,
        "chunk_id": "74005d77e435b33461b3b72655049d0f",
        "metadata": {
          "source_tag": "p",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react"
          ]
        }
      },
      {
        "content": "About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:March 09, 2020Category:TechnicalTagsreduxreacttutorialNewsletterSubscribe to the Newsletter",
        "chunk_type": "example",
        "tag": "aside",
        "score": 0.43200000000000005,
        "word_count": 54,
        "chunk_id": "443bfc0c2f4009bcea7ab86d113fc715",
        "metadata": {
          "source_tag": "aside",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "post-sidebar"
            ]
          },
          "technical_indicators": [
            "javascript"
          ]
        }
      },
      {
        "content": "Whatis Redux andwhyyou might want to use itTheterminologyof Redux: actions, reducers, store, dispatch, connect, and containerMaking asynchronous API calls withRedux ThunkHow to make a small, real-world application with React and ReduxHow to use Redux Toolkit to simplify Redux app development",
        "chunk_type": "technical_content",
        "tag": "ul",
        "score": 0.382,
        "word_count": 40,
        "chunk_id": "1c233dade0037b0d796185d76b362849",
        "metadata": {
          "source_tag": "ul",
          "keywords_found": [
            "development",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "javascript",
            "api"
          ]
        }
      },
      {
        "content": "importReactfrom'react'import{connect} rom'react-redux'// Redux state is now in the props of the componentconstPostsPage=({loading,posts,hasErrors})=>{return(<section><h1>Posts</h1></section>)}// Map Redux state to React component propsconstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})// Connect Redux to Reactexportdefaultconnect(mapStateToProps)(PostsPage)",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.381,
        "word_count": 23,
        "chunk_id": "fefddd005870f062fb11001a84053212",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "jsx"
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "importReactfrom'react'import{connect} rom'react-redux'// Redux state is now in the props of the componentconstPostsPage=({loading,posts,hasErrors})=>{return(<section><h1>Posts</h1></section>)}// Map Redux state to React component propsconstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})// Connect Redux to Reactexportdefaultconnect(mapStateToProps)(PostsPage)",
        "chunk_type": "code_markup",
        "tag": "pre",
        "score": 0.381,
        "word_count": 23,
        "chunk_id": "fefddd005870f062fb11001a84053212",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-jsx"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "importReactfrom'react'import{connect} rom'react-redux'// Redux state is now in the props of the componentconstPostsPage=({loading,posts,hasErrors})=>{return(<section><h1>Posts</h1></section>)}// Map Redux state to React component propsconstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})// Connect Redux to Reactexportdefaultconnect(mapStateToProps)(PostsPage)",
        "chunk_type": "code_markup",
        "tag": "code",
        "score": 0.381,
        "word_count": 23,
        "chunk_id": "fefddd005870f062fb11001a84053212",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-jsx"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "importReact,{useEffect} rom'react'import{connect} rom'react-redux'import{fetchPosts} rom'../actions/postsActions'import{Post} rom'../components/Post'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])// Show loading, error, or success stateconstrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post}/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.595,
        "word_count": 18,
        "chunk_id": "d2c6446d787088ecd2e8e2a217aa857f",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "jsx"
          },
          "technical_indicators": [
            "react",
            "javascript"
          ]
        }
      },
      {
        "content": "importReact,{useEffect} rom'react'import{connect} rom'react-redux'import{fetchPosts} rom'../actions/postsActions'import{Post} rom'../components/Post'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])// Show loading, error, or success stateconstrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post}/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)",
        "chunk_type": "code_markup",
        "tag": "pre",
        "score": 0.595,
        "word_count": 18,
        "chunk_id": "d2c6446d787088ecd2e8e2a217aa857f",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-jsx"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript"
          ]
        }
      },
      {
        "content": "importReact,{useEffect} rom'react'import{connect} rom'react-redux'import{fetchPosts} rom'../actions/postsActions'import{Post} rom'../components/Post'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])// Show loading, error, or success stateconstrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post}/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)",
        "chunk_type": "code_markup",
        "tag": "code",
        "score": 0.595,
        "word_count": 18,
        "chunk_id": "d2c6446d787088ecd2e8e2a217aa857f",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-jsx"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript"
          ]
        }
      }
    ],
    "chunk_count": 37,
    "content_types": [
      "text",
      "code_markup",
      "technical_content",
      "example"
    ],
    "technical_concepts": [
      "javascript",
      "sql",
      "data",
      "api",
      "react"
    ],
    "crawl_metadata": {},
    "technical_content": [
      {
        "id": "599dcce2998a6b40b1e38e8c6006cb0a",
        "content": "type",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "321c3cf486ed509164edec1e1981fec8",
        "content": "payload",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9d751262de89d556cc1d3c6cc6c96005",
        "content": "const DELETE_TODO = 'posts/deleteTodo'",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9d751262de89d556cc1d3c6cc6c96005",
        "content": "const DELETE_TODO = 'posts/deleteTodo'",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "bdc525db8795fbd198b4890ecf9477d9",
        "content": "{ type: DELETE_TODO, payload: id, }",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "bdc525db8795fbd198b4890ecf9477d9",
        "content": "{ type: DELETE_TODO, payload: id, }",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "d8eee56ea1e697a426953e6fb72940a9",
        "content": "const deleteTodo = (id) => ({ type: DELETE_TODO, payload: id })",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "d8eee56ea1e697a426953e6fb72940a9",
        "content": "const deleteTodo = (id) => ({ type: DELETE_TODO, payload: id })",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "9ed39e2ea931586b6a985a6942ef573e",
        "content": "state",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "418c5509e2171d55b0aee5c2ea4442b5",
        "content": "action",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b36eb6a54154f7301f004e1e61c87ce8",
        "content": "switch",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "8b6d581bf88a33ab1439e0ee6b299613",
        "content": "const initialState = { todos: [ { id: 1, text: 'Eat' }, { id: 2, text: 'Sleep' }, ], loading: false, hasErrors: false, } function todoReducer(state = initialState, action) { switch (action.type) { case DELETE_TODO: return { ...state, todos: state.todos.filter((todo) => todo.id !== action.payload), } default: return state } }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "8b6d581bf88a33ab1439e0ee6b299613",
        "content": "const initialState = { todos: [ { id: 1, text: 'Eat' }, { id: 2, text: 'Sleep' }, ], loading: false, hasErrors: false, } function todoReducer(state = initialState, action) { switch (action.type) { case DELETE_TODO: return { ...state, todos: state.todos.filter((todo) => todo.id !== action.payload), } default: return state } }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "f167f0d2262a808a784ea63ed0580e7f",
        "content": "<Provider>",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "7282a352f5ebc05a49e8f7ddefacb887",
        "content": "import { createStore } from 'redux' import { Provider } from 'react-redux' import reducer from './reducers' const store = createStore(reducer) render( <Provider store={store}> <App /> </Provider>, document.getElementById('root') )",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "7282a352f5ebc05a49e8f7ddefacb887",
        "content": "import { createStore } from 'redux' import { Provider } from 'react-redux' import reducer from './reducers' const store = createStore(reducer) render( <Provider store={store}> <App /> </Provider>, document.getElementById('root') )",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "9dddf2a4f7d94594ec2ea98407a410e1",
        "content": "dispatch",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "48288914e5f9b6638fa205ae1aac154c",
        "content": "const Component = ({ dispatch }) => { useEffect(() => { dispatch(deleteTodo()) }, [dispatch]) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "48288914e5f9b6638fa205ae1aac154c",
        "content": "const Component = ({ dispatch }) => { useEffect(() => { dispatch(deleteTodo()) }, [dispatch]) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "fcb3434e4e9bfb46457aa0b3479e32fd",
        "content": "connect()",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "742b9ebeae6261f38d825a387a0fd25d",
        "content": "npx create-react-app redux-tutorial cd redux-tutorial",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "742b9ebeae6261f38d825a387a0fd25d",
        "content": "npx create-react-app redux-tutorial cd redux-tutorial",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "854acd1adb599f742ed225ce81711546",
        "content": "yarn add",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7d1654a2281de41eb75e98be8d776d2f",
        "content": "npm i",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "282dc9a83be8c24556288cbd9e645a4d",
        "content": "react-router-dom",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "9a2780b67d07c6d0f491e7f268b6e769",
        "content": "npm i redux react-redux redux-thunk redux-devtools-extension react-router-dom",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "9a2780b67d07c6d0f491e7f268b6e769",
        "content": "npm i redux react-redux redux-thunk redux-devtools-extension react-router-dom",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "c62fa1b38d72e4ba346d90dfe93da927",
        "content": "cd src rm * move to src and delete all files within",
        "type": "code",
        "language": "shell",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c62fa1b38d72e4ba346d90dfe93da927",
        "content": "cd src rm * move to src and delete all files within",
        "type": "code",
        "language": "shell",
        "relevance": 0.30000000000000004
      },
      {
        "id": "8d406160bb69e3708551729e3294d46b",
        "content": "reducers",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "ebb67a4271abe715344471b0f16321f6",
        "content": "actions",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b3b32a2d422265cd25c3323ed0157f81",
        "content": "pages",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4725dcf446a342f1473a8228e42dfa48",
        "content": "components",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "133d1fc5cb811ffd38fa5d65790846e1",
        "content": "mkdir actions components pages reducers",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "133d1fc5cb811ffd38fa5d65790846e1",
        "content": "mkdir actions components pages reducers",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "958f6f56cd42c904603d226cd36a57b6",
        "content": "App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "bca1542f88ef8253c16b452e9ad09f98",
        "content": "index.css",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "97e1cf126ab47607d6f90c50657044dc",
        "content": "touch index.js index.css App.js",
        "type": "code",
        "language": "shell",
        "relevance": 0.30000000000000004
      },
      {
        "id": "97e1cf126ab47607d6f90c50657044dc",
        "content": "touch index.js index.css App.js",
        "type": "code",
        "language": "shell",
        "relevance": 0.30000000000000004
      },
      {
        "id": "62df2e4ec3a1a2e507b141c4f0f7c8ad",
        "content": "src/ actions/ components/ pages/ reducers/ App.js index.css index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "62df2e4ec3a1a2e507b141c4f0f7c8ad",
        "content": "src/ actions/ components/ pages/ reducers/ App.js index.css index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "bca1542f88ef8253c16b452e9ad09f98",
        "content": "index.css",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cc258ed4fa61a08b3610f663fb7e2455",
        "content": "createStore",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1f90098366bb33536f4133cf056d6930",
        "content": "applyMiddleware",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "230e216f8d80e5d88c91310f149b6112",
        "content": "thunk",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "27703c8f150ac4bb0a3a83a7857353af",
        "content": "Provider",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "230e216f8d80e5d88c91310f149b6112",
        "content": "thunk",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5716284a7703388721696c447f5c2155",
        "content": "composeWithDevTools",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2276eb19fbad6f5bafebccdba475ba9c",
        "content": "// External imports import React from 'react' import { render } from 'react-dom' import { createStore, applyMiddleware } from 'redux' import { Provider } from 'react-redux' import thunk from 'redux-thunk' import { composeWithDevTools } from 'redux-devtools-extension' // Local imports import App from './App' import rootReducer from './reducers' // Assets import './index.css' const store = createStore(rootReducer, composeWithDevTools(applyMiddleware(thunk))) render( <Provider store={store}> <App /> </Provider>, document.getElementById('root') )",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7052631578947368
      },
      {
        "id": "2276eb19fbad6f5bafebccdba475ba9c",
        "content": "// External imports import React from 'react' import { render } from 'react-dom' import { createStore, applyMiddleware } from 'redux' import { Provider } from 'react-redux' import thunk from 'redux-thunk' import { composeWithDevTools } from 'redux-devtools-extension' // Local imports import App from './App' import rootReducer from './reducers' // Assets import './index.css' const store = createStore(rootReducer, composeWithDevTools(applyMiddleware(thunk))) render( <Provider store={store}> <App /> </Provider>, document.getElementById('root') )",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7052631578947368
      },
      {
        "id": "958f6f56cd42c904603d226cd36a57b6",
        "content": "App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "689505e1b2c57da382e58a5863688750",
        "content": "import React from 'react' const App = () => { return <div>Hello, Redux</div> } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "689505e1b2c57da382e58a5863688750",
        "content": "import React from 'react' const App = () => { return <div>Hello, Redux</div> } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "4b7dbab04392cd22a1fec72b0a1831ce",
        "content": "combineReducers",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2f82bc0db49a2f28022ba43b3f9383b5",
        "content": "postsReducer",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4b7dbab04392cd22a1fec72b0a1831ce",
        "content": "combineReducers",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d4e46256d55b452727da000816bcf316",
        "content": "commentsReducer",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "22221abcba75d1e5861a418a83e62e92",
        "content": "authReducer",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "ff660260591e4b988922cc7179fafdc2",
        "content": "reducers/index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c4c3a303016a96160e40134044a80e3b",
        "content": "import { combineReducers } from 'redux' import postsReducer from './postsReducer' const rootReducer = combineReducers({ posts: postsReducer, }) export default rootReducer",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "c4c3a303016a96160e40134044a80e3b",
        "content": "import { combineReducers } from 'redux' import postsReducer from './postsReducer' const rootReducer = combineReducers({ posts: postsReducer, }) export default rootReducer",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "2f82bc0db49a2f28022ba43b3f9383b5",
        "content": "postsReducer",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a14fa2166ed698f3d04061f57e5ab9b9",
        "content": "loading",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9308ef711245f4213a779903b194f396",
        "content": "hasErrors",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "18958e30bdca0cfac8256824e570a89b",
        "content": "posts",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "084c5dbc6068175804e22de71490c137",
        "content": "export const initialState = { posts: [], loading: false, hasErrors: false, } export default function postsReducer(state = initialState, action) { switch (action.type) { default: return state } }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "084c5dbc6068175804e22de71490c137",
        "content": "export const initialState = { posts: [], loading: false, hasErrors: false, } export default function postsReducer(state = initialState, action) { switch (action.type) { default: return state } }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "f167f0d2262a808a784ea63ed0580e7f",
        "content": "<Provider>",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "9ac4d4bfd3f838722b0fbd18e6edcc7b",
        "content": "actions/postsActions.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "30261789eed3addbd2d54402dcf6fa01",
        "content": "getPosts",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "de920264f7b42f677fe4c113e10c12cb",
        "content": "getPostsSuccess",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d51e64d3152adb8753a1f3f05512d4cb",
        "content": "getPostsFailure",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a4fcd3963444ce25a9337059501020cf",
        "content": "// Create Redux action types export const GET_POSTS = 'GET_POSTS' export const GET_POSTS_SUCCESS = 'GET_POSTS_SUCCESS' export const GET_POSTS_FAILURE = 'GET_POSTS_FAILURE'",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "a4fcd3963444ce25a9337059501020cf",
        "content": "// Create Redux action types export const GET_POSTS = 'GET_POSTS' export const GET_POSTS_SUCCESS = 'GET_POSTS_SUCCESS' export const GET_POSTS_FAILURE = 'GET_POSTS_FAILURE'",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "2c2398fe5f6f5afbce4af0bc5cf9d412",
        "content": "// Create Redux action creators that return an action export const getPosts = () => ({ type: GET_POSTS, }) export const getPostsSuccess = (posts) => ({ type: GET_POSTS_SUCCESS, payload: posts, }) export const getPostsFailure = () => ({ type: GET_POSTS_FAILURE, })",
        "type": "code",
        "language": "js",
        "relevance": 0.7
      },
      {
        "id": "2c2398fe5f6f5afbce4af0bc5cf9d412",
        "content": "// Create Redux action creators that return an action export const getPosts = () => ({ type: GET_POSTS, }) export const getPostsSuccess = (posts) => ({ type: GET_POSTS_SUCCESS, payload: posts, }) export const getPostsFailure = () => ({ type: GET_POSTS_FAILURE, })",
        "type": "code",
        "language": "js",
        "relevance": 0.7
      },
      {
        "id": "6eca12438502fcf69468a4610cab7247",
        "content": "getPosts()",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "7c6e64aa012e4cab5654531a98d60c8a",
        "content": "try/catch",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d84a0a04f9d050d7f90227fee99a4473",
        "content": "// Combine them all in an asynchronous thunk export function fetchPosts() { return async (dispatch) => { dispatch(getPosts()) try { const response = await fetch('https://jsonplaceholder.typicode.com/posts') const data = await response.json() dispatch(getPostsSuccess(data)) } catch (error) { dispatch(getPostsFailure()) } } }",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "d84a0a04f9d050d7f90227fee99a4473",
        "content": "// Combine them all in an asynchronous thunk export function fetchPosts() { return async (dispatch) => { dispatch(getPosts()) try { const response = await fetch('https://jsonplaceholder.typicode.com/posts') const data = await response.json() dispatch(getPostsSuccess(data)) } catch (error) { dispatch(getPostsFailure()) } } }",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "e455bfc324713706fccc8ce2f8fa8a7a",
        "content": "export default function postsReducer(state = initialState, action) { switch (action.type) { default: return state } }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "e455bfc324713706fccc8ce2f8fa8a7a",
        "content": "export default function postsReducer(state = initialState, action) { switch (action.type) { default: return state } }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "ebc0100d3c40359698ebcb40e9d332d9",
        "content": "postsActions",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "43297f48d712b6ba490e207b7858725b",
        "content": "// Import all actions import * as actions from '../actions/postsActions'",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "43297f48d712b6ba490e207b7858725b",
        "content": "// Import all actions import * as actions from '../actions/postsActions'",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cd14c323902024e72c850aa828d634a7",
        "content": "case",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "463b614c2abde463443e55eac713cb59",
        "content": "GET_POSTS",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a14fa2166ed698f3d04061f57e5ab9b9",
        "content": "loading",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b326b5062b2f0e69046810717534cb09",
        "content": "true",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b5fce1cd9e62a34a2cd7adbf6197ec2b",
        "content": "case actions.GET_POSTS: return { ...state, loading: true }",
        "type": "code",
        "language": "js",
        "relevance": 0.4052631578947369
      },
      {
        "id": "b5fce1cd9e62a34a2cd7adbf6197ec2b",
        "content": "case actions.GET_POSTS: return { ...state, loading: true }",
        "type": "code",
        "language": "js",
        "relevance": 0.4052631578947369
      },
      {
        "id": "463b614c2abde463443e55eac713cb59",
        "content": "GET_POSTS",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "328af269a963c07b4247c22956a2bf98",
        "content": "GET_POSTS_SUCCESS",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "71538417edad5c2f3151d6c662b3b7ce",
        "content": "GET_POSTS_FAILURE",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "07af9e3cb6fdc50d75ab939d34080214",
        "content": "import * as actions from '../actions/postsActions' export const initialState = { posts: [], loading: false, hasErrors: false, } export default function postsReducer(state = initialState, action) { switch (action.type) { case actions.GET_POSTS: return { ...state, loading: true } case actions.GET_POSTS_SUCCESS: return { posts: action.payload, loading: false, hasErrors: false } case actions.GET_POSTS_FAILURE: return { ...state, loading: false, hasErrors: true } default: return state } }",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "07af9e3cb6fdc50d75ab939d34080214",
        "content": "import * as actions from '../actions/postsActions' export const initialState = { posts: [], loading: false, hasErrors: false, } export default function postsReducer(state = initialState, action) { switch (action.type) { case actions.GET_POSTS: return { ...state, loading: true } case actions.GET_POSTS_SUCCESS: return { posts: action.payload, loading: false, hasErrors: false } case actions.GET_POSTS_FAILURE: return { ...state, loading: false, hasErrors: true } default: return state } }",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "e7d46973956c20b9f22907bd0998b9d3",
        "content": "import React from 'react' import { BrowserRouter as Router, Switch, Route, Redirect } from 'react-router-dom' import DashboardPage from './pages/DashboardPage' import PostsPage from './pages/PostsPage' const App = () => { return ( <Router> <Switch> <Route exact path=\"/\" component={DashboardPage} /> <Route exact path=\"/posts\" component={PostsPage} /> <Redirect to=\"/\" /> </Switch> </Router> ) } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8105263157894738
      },
      {
        "id": "e7d46973956c20b9f22907bd0998b9d3",
        "content": "import React from 'react' import { BrowserRouter as Router, Switch, Route, Redirect } from 'react-router-dom' import DashboardPage from './pages/DashboardPage' import PostsPage from './pages/PostsPage' const App = () => { return ( <Router> <Switch> <Route exact path=\"/\" component={DashboardPage} /> <Route exact path=\"/posts\" component={PostsPage} /> <Redirect to=\"/\" /> </Switch> </Router> ) } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8105263157894738
      },
      {
        "id": "fbddacdc7442a8f9e54723fa1cc8cc79",
        "content": "import React from 'react' import { Link } from 'react-router-dom' const DashboardPage = () => ( <section> <h1>Dashboard</h1> <p>This is the dashboard.</p> <Link to=\"/posts\" className=\"button\"> View Posts </Link> </section> ) export default DashboardPage",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "fbddacdc7442a8f9e54723fa1cc8cc79",
        "content": "import React from 'react' import { Link } from 'react-router-dom' const DashboardPage = () => ( <section> <h1>Dashboard</h1> <p>This is the dashboard.</p> <Link to=\"/posts\" className=\"button\"> View Posts </Link> </section> ) export default DashboardPage",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "03d947a2158373c3b9d74325850cb8b9",
        "content": "Post",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2afc1957abc2e5fc0d9bc27770a6d30d",
        "content": "Post.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4725dcf446a342f1473a8228e42dfa48",
        "content": "components",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "22e6fb8c758d49c79be5bae26e101986",
        "content": "import React from 'react' export const Post = ({ post }) => ( <article className=\"post-excerpt\"> <h2>{post.title}</h2> <p>{post.body.substring(0, 100)}</p> </article> )",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "22e6fb8c758d49c79be5bae26e101986",
        "content": "import React from 'react' export const Post = ({ post }) => ( <article className=\"post-excerpt\"> <h2>{post.title}</h2> <p>{post.body.substring(0, 100)}</p> </article> )",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "b640a0ce465fa2a4150c36b305c1c11b",
        "content": "connect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1ffa815c34d64d742ab00d7346213902",
        "content": "react-redux",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "fc3c7e2fa66a9cf5067852ebcf9b7a92",
        "content": "import React from 'react' const PostsPage = () => { return ( <section> <h1>Posts</h1> </section> ) } export default PostsPage",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "fc3c7e2fa66a9cf5067852ebcf9b7a92",
        "content": "import React from 'react' const PostsPage = () => { return ( <section> <h1>Posts</h1> </section> ) } export default PostsPage",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "b640a0ce465fa2a4150c36b305c1c11b",
        "content": "connect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e14087a41eb4ebe25bef9fc2948ba273",
        "content": "mapStateToProps",
        "type": "code",
        "language": "text",
        "relevance": 0.5105263157894737
      },
      {
        "id": "b640a0ce465fa2a4150c36b305c1c11b",
        "content": "connect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a14fa2166ed698f3d04061f57e5ab9b9",
        "content": "loading",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "18958e30bdca0cfac8256824e570a89b",
        "content": "posts",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9308ef711245f4213a779903b194f396",
        "content": "hasErrors",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2f82bc0db49a2f28022ba43b3f9383b5",
        "content": "postsReducer",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "235572cec8f26b2c9fc4d94e7d0066b8",
        "content": "import React from 'react' import { connect } from 'react-redux' // Redux state is now in the props of the component const PostsPage = ({ loading, posts, hasErrors }) => { return ( <section> <h1>Posts</h1> </section> ) } // Map Redux state to React component propsconst mapStateToProps = (state) => ({ loading: state.posts.loading, posts: state.posts.posts, hasErrors: state.posts.hasErrors,})// Connect Redux to Reactexport default connect(mapStateToProps)(PostsPage)",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "235572cec8f26b2c9fc4d94e7d0066b8",
        "content": "import React from 'react' import { connect } from 'react-redux' // Redux state is now in the props of the component const PostsPage = ({ loading, posts, hasErrors }) => { return ( <section> <h1>Posts</h1> </section> ) } // Map Redux state to React component propsconst mapStateToProps = (state) => ({ loading: state.posts.loading, posts: state.posts.posts, hasErrors: state.posts.hasErrors,})// Connect Redux to Reactexport default connect(mapStateToProps)(PostsPage)",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "4d788ed0fdc7627374f53ce217a8a6c9",
        "content": "state => state.posts",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "d3ce3c8865b6e6cc8758cbd269d9cac7",
        "content": "fetchPosts",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9dddf2a4f7d94594ec2ea98407a410e1",
        "content": "dispatch",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d3ce3c8865b6e6cc8758cbd269d9cac7",
        "content": "fetchPosts",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9dddf2a4f7d94594ec2ea98407a410e1",
        "content": "dispatch",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c91a09b0f07ea482cd9ddb9f377d14e8",
        "content": "import React, { useEffect } from 'react'import { connect } from 'react-redux' // Bring in the asynchronous fetchPosts actionimport { fetchPosts } from '../actions/postsActions' const PostsPage = ({ dispatch, loading, posts, hasErrors }) => { useEffect(() => { dispatch(fetchPosts()) }, [dispatch]) return ( <section> <h1>Posts</h1> </section> ) } const mapStateToProps = (state) => ({ loading: state.posts.loading, posts: state.posts.posts, hasErrors: state.posts.hasErrors, }) export default connect(mapStateToProps)(PostsPage)",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "c91a09b0f07ea482cd9ddb9f377d14e8",
        "content": "import React, { useEffect } from 'react'import { connect } from 'react-redux' // Bring in the asynchronous fetchPosts actionimport { fetchPosts } from '../actions/postsActions' const PostsPage = ({ dispatch, loading, posts, hasErrors }) => { useEffect(() => { dispatch(fetchPosts()) }, [dispatch]) return ( <section> <h1>Posts</h1> </section> ) } const mapStateToProps = (state) => ({ loading: state.posts.loading, posts: state.posts.posts, hasErrors: state.posts.hasErrors, }) export default connect(mapStateToProps)(PostsPage)",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "475b81895f521ff9e1a79b743649b1ec",
        "content": "import React, { useEffect } from 'react' import { connect } from 'react-redux' import { fetchPosts } from '../actions/postsActions' import { Post } from '../components/Post' const PostsPage = ({ dispatch, loading, posts, hasErrors }) => { useEffect(() => { dispatch(fetchPosts()) }, [dispatch]) // Show loading, error, or success state const renderPosts = () => { if (loading) return <p>Loading posts...</p> if (hasErrors) return <p>Unable to display posts.</p> return posts.map((post) => <Post key={post.id} post={post} />) } return ( <section> <h1>Posts</h1> {renderPosts()} </section> ) } const mapStateToProps = (state) => ({ loading: state.posts.loading, posts: state.posts.posts, hasErrors: state.posts.hasErrors, }) export default connect(mapStateToProps)(PostsPage)",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "475b81895f521ff9e1a79b743649b1ec",
        "content": "import React, { useEffect } from 'react' import { connect } from 'react-redux' import { fetchPosts } from '../actions/postsActions' import { Post } from '../components/Post' const PostsPage = ({ dispatch, loading, posts, hasErrors }) => { useEffect(() => { dispatch(fetchPosts()) }, [dispatch]) // Show loading, error, or success state const renderPosts = () => { if (loading) return <p>Loading posts...</p> if (hasErrors) return <p>Unable to display posts.</p> return posts.map((post) => <Post key={post.id} post={post} />) } return ( <section> <h1>Posts</h1> {renderPosts()} </section> ) } const mapStateToProps = (state) => ({ loading: state.posts.loading, posts: state.posts.posts, hasErrors: state.posts.hasErrors, }) export default connect(mapStateToProps)(PostsPage)",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "fb615ed5c2724c80545e39376b9259cb",
        "content": "npm i reduxjs/toolkit",
        "type": "code",
        "language": "shell",
        "relevance": 0.30000000000000004
      },
      {
        "id": "fb615ed5c2724c80545e39376b9259cb",
        "content": "npm i reduxjs/toolkit",
        "type": "code",
        "language": "shell",
        "relevance": 0.30000000000000004
      },
      {
        "id": "48780f62be1149b547914a1ee68fa966",
        "content": "redux-thunk",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "8378cd91c18f0b160ca357f35fe043d4",
        "content": "redux-devtools-extension",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "be38c94741fa4715c450ceae8b9a5ae7",
        "content": "{ ...state }",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cd32db6e7a6e4d36d389a1b0a61cb9b3",
        "content": "configureStore",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cc258ed4fa61a08b3610f663fb7e2455",
        "content": "createStore",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4d6d419a95f1fc42a34363c88d6d5325",
        "content": "import React from 'react' import { render } from 'react-dom' import { configureStore } from ' reduxjs/toolkit'import { Provider } from 'react-redux' import App from './App' import rootReducer from './slices' import './index.css' const store = configureStore({ reducer: rootReducer }) render( <Provider store={store}> <App /> </Provider>, document.getElementById('root') )",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8052631578947369
      },
      {
        "id": "4d6d419a95f1fc42a34363c88d6d5325",
        "content": "import React from 'react' import { render } from 'react-dom' import { configureStore } from ' reduxjs/toolkit'import { Provider } from 'react-redux' import App from './App' import rootReducer from './slices' import './index.css' const store = configureStore({ reducer: rootReducer }) render( <Provider store={store}> <App /> </Provider>, document.getElementById('root') )",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8052631578947369
      },
      {
        "id": "f2cf7c1ba242c12be10c42df81bb60ba",
        "content": "slices",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "70f9d1ad651bdbd12fbdc8b026c70b98",
        "content": "initialState",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "50d596ce0102f9e7d63065799650f814",
        "content": "import { createSlice } from ' reduxjs/toolkit' export const initialState = { loading: false, hasErrors: false, posts: [], }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "50d596ce0102f9e7d63065799650f814",
        "content": "import { createSlice } from ' reduxjs/toolkit' export const initialState = { loading: false, hasErrors: false, posts: [], }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "30261789eed3addbd2d54402dcf6fa01",
        "content": "getPosts",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "de920264f7b42f677fe4c113e10c12cb",
        "content": "getPostsSuccess",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d51e64d3152adb8753a1f3f05512d4cb",
        "content": "getPostsFailure",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4c53f4e4a0511c9b961feb6d87e0a352",
        "content": "// A slice for posts with our three reducers const postsSlice = createSlice({ name: 'posts', initialState, reducers: { getPosts: (state) => { state.loading = true }, getPostsSuccess: (state, { payload }) => { state.posts = payload state.loading = false state.hasErrors = false }, getPostsFailure: (state) => { state.loading = false state.hasErrors = true }, }, })",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "4c53f4e4a0511c9b961feb6d87e0a352",
        "content": "// A slice for posts with our three reducers const postsSlice = createSlice({ name: 'posts', initialState, reducers: { getPosts: (state) => { state.loading = true }, getPostsSuccess: (state, { payload }) => { state.posts = payload state.loading = false state.hasErrors = false }, getPostsFailure: (state) => { state.loading = false state.hasErrors = true }, }, })",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "5b3c32009797feb79096d52e56a56b82",
        "content": "selector",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "b640a0ce465fa2a4150c36b305c1c11b",
        "content": "connect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7ed042522ae313887628d3e77dc4ed68",
        "content": "// Three actions generated from the slice export const { getPosts, getPostsSuccess, getPostsFailure } = postsSlice.actions // A selector export const postsSelector = (state) => state.posts // The reducer export default postsSlice.reducer // Asynchronous thunk action export function fetchPosts() { return async (dispatch) => { dispatch(getPosts()) try { const response = await fetch('https://jsonplaceholder.typicode.com/posts') const data = await response.json() dispatch(getPostsSuccess(data)) } catch (error) { dispatch(getPostsFailure()) } } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8105263157894738
      },
      {
        "id": "7ed042522ae313887628d3e77dc4ed68",
        "content": "// Three actions generated from the slice export const { getPosts, getPostsSuccess, getPostsFailure } = postsSlice.actions // A selector export const postsSelector = (state) => state.posts // The reducer export default postsSlice.reducer // Asynchronous thunk action export function fetchPosts() { return async (dispatch) => { dispatch(getPosts()) try { const response = await fetch('https://jsonplaceholder.typicode.com/posts') const data = await response.json() dispatch(getPostsSuccess(data)) } catch (error) { dispatch(getPostsFailure()) } } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8105263157894738
      },
      {
        "id": "e14087a41eb4ebe25bef9fc2948ba273",
        "content": "mapStateToProps",
        "type": "code",
        "language": "text",
        "relevance": 0.5105263157894737
      },
      {
        "id": "fcb3434e4e9bfb46457aa0b3479e32fd",
        "content": "connect()",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "68541b0987aec216d23962b37583144b",
        "content": "useDispatch",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "8bc5a9c74d7fcf59277c2a43fe568cc9",
        "content": "useSelector",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "1ffa815c34d64d742ab00d7346213902",
        "content": "react-redux",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "4301942948578c48f580301e9f68c997",
        "content": "PostsPage.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e8800f4d9b96e176408b35824adb6ef0",
        "content": "import React, { useEffect } from 'react' import { useDispatch, useSelector } from 'react-redux' import { fetchPosts, postsSelector } from '../slices/posts' import { Post } from '../components/Post' const PostsPage = () => { const dispatch = useDispatch() const { posts, loading, hasErrors } = useSelector(postsSelector) useEffect(() => { dispatch(fetchPosts()) }, [dispatch]) const renderPosts = () => { if (loading) return <p>Loading posts...</p> if (hasErrors) return <p>Unable to display posts.</p> return posts.map((post) => <Post key={post.id} post={post} excerpt />) } return ( <section> <h1>Posts</h1> {renderPosts()} </section> ) } export default PostsPage",
        "type": "code",
        "language": "jsx",
        "relevance": 1.1157894736842104
      },
      {
        "id": "e8800f4d9b96e176408b35824adb6ef0",
        "content": "import React, { useEffect } from 'react' import { useDispatch, useSelector } from 'react-redux' import { fetchPosts, postsSelector } from '../slices/posts' import { Post } from '../components/Post' const PostsPage = () => { const dispatch = useDispatch() const { posts, loading, hasErrors } = useSelector(postsSelector) useEffect(() => { dispatch(fetchPosts()) }, [dispatch]) const renderPosts = () => { if (loading) return <p>Loading posts...</p> if (hasErrors) return <p>Unable to display posts.</p> return posts.map((post) => <Post key={post.id} post={post} excerpt />) } return ( <section> <h1>Posts</h1> {renderPosts()} </section> ) } export default PostsPage",
        "type": "code",
        "language": "jsx",
        "relevance": 1.1157894736842104
      }
    ]
  },
  {
    "metadata": {
      "description": "Do you have experience using React? Have you heard of Redux, but you've put off learning it because it looks very complicated and all the…",
      "url": "https://www.taniarascia.com/redux-react-guide/#selecting-redux-state-in-a-react-component",
      "title": "How to Use Redux and React | Tania Rascia's Personal Website",
      "source_type": "web",
      "crawl_time": 1730107289.9567628,
      "keywords": [
        "sql",
        "web",
        "article",
        "extract",
        "development",
        "information",
        "react"
      ]
    },
    "relevance_score": 0.9331891891891891,
    "chunks": [
      {
        "content": "How to Use Redux and ReactDo you have experience usingReact? Have you heard ofRedux, but you've put off learning it because it looks very complicated and all the guides seem overwhelming? If that's the case, this is the article for you! Contain your fear of containing state and come along with me on this relatively painless journey.PrerequisitesYou must already know how to use React for this tutorial, as I will not be explaining any aspects of React itself.Familiarity withHTML & CSS.Familiarity withES6 syntax and features.Knowledge of React terminology:JSX, State, Components, Props, LifecycleandHooksKnowledge ofReact RouterKnowledge of asynchronous JavaScript andmaking API callsAlso, download Redux DevToolsfor Chromeorfor FireFox.GoalsIn this tutorial, we will build a small blog app. It will fetch posts and comments from an API. I've created the same app with both plain Redux, andRedux Toolkit(RTK), the officially sanctioned toolset for Redux. Here are the links to the source and demos of both the plain and RTK versions.React + Redux Application (Plain Redux)SourceDemo ApplicationReact + Redux Toolkit ApplicationSourceDemo ApplicationNote: The applications are pulling from a real API viaJSON Placeholder API. Due to rate limiting on CodeSandbox, the API may appear slow, but it has nothing to do with the Redux application itself. You can also clone the repository locally.We will learn:Whatis Redux andwhyyou might want to use itTheterminologyof Redux: actions, reducers, store, dispatch, connect, and containerMaking asynchronous API calls withRedux ThunkHow to make a small, real-world application with React and ReduxHow to use Redux Toolkit to simplify Redux app developmentWhat is Redux?Redux is a state container for JavaScript applications. Normally with React, you manage state at a component level, and pass state around via props. With Redux, the entire state of your application is managed in one immutable object. Every update to the Redux state results in a copy of sections of the state, plus the new change.Redux was originally created byDan AbramovandAndrew Clark.Why should I use Redux?Easily manage global state- access or update any part of the state from any Redux-connected componentEasily keep track of changes with Redux DevTools- any action or state change is tracked and easy to follow with Redux. The fact that the entire state of the application is tracked with each change means you can easily do time-travel debugging to move back and forth between changes.The downside to Redux is that there's a lot of initial boilerplate to set up and maintain (especially if you use plain Redux without Redux Toolkit). A smaller applicationmay not need Reduxand may instead benefit from simply usingthe Context APIfor global state needs.In my personal experience, I set up an application with Context alone, and later needed to convert everything over to Redux to make it more maintainable and organized.TerminologyUsually I don't like to just make a list of terms and definitions, but Redux has a few that are likely unfamiliar, so I'm just going to define them all up front to make it easy to refer back to them. Although you canskip to the beginning of the tutorial section, I think it would be good to read through all the definitions just to get exposure and an idea of them in your head first.ActionsReducersStoreDispatchConnectI'll just use the typical todo application, and the action of deleting a todo, for the examples.ActionsAnactionsends data from your application to the Redux store. An action is conventionally an object with two properties:typeand (optional)payload. The type is generally an uppercase string (assigned to a constant) that describes the action. The payload is additional data that may be passed.Action TypeconstDELETE_TODO='posts/deleteTodo'Action{type:DELETE_TODO,payload:id,} ction creatorsAnaction creatoris a function that returns an action.Action CreatorconstdeleteTodo=(id)=>({type:DELETE_TODO,payload:id})ReducersAreduceris a function that takes two parameters:stateandaction. A reducer is immutable and always returns a copy of the entire state. A reducer typically consists of aswitchstatement that goes through all the possible action types.ReducerconstinitialState={todos:[{id:1,text:'Eat'},{id:2,text:'Sleep'},],loading:false,hasErrors:false,} unctiontodoReducer(state=initialState,action){switch(action.type){caseDELETE_TODO:return{...state,todos:state.todos.filter((todo)=>todo.id!==action.payload),} efault:returnstate}} toreThe Redux application state lives in thestore, which is initialized with a reducer. When used with React, a<Provider>exists to wrap the application, and anything within the Provider can have access to Redux.Storeimport{createStore} rom'redux'import{Provider} rom'react-redux'importreducerfrom'./reducers'conststore=createStore(reducer)render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Dispatchdispatchis a method available on the store object that accepts an object which is used to update the Redux state. Usually, this object is the result of invoking an action creator.constComponent=({dispatch})=>{useEffect(()=>{dispatch(deleteTodo())},[dispatch])} onnectTheconnect()function is one typical way to connect React to Redux. A connected component is sometimes referred to as acontainer.Okay, that about covers it for the major terms of Redux. It can be overwhelming to read the terminology without any context, so let's begin.Getting StartedFor ease of getting started quickly, my example usesCreate React Appto set up the environment.npx create-react-app redux-tutorialcdredux-tutorialRedux requires a few dependencies.Redux- Core libraryReact Redux- React bindings for ReduxRedux Thunk- Async middleware for ReduxRedux DevTools Extension- Connects Redux app to Redux DevToolsYou canyarn addornpm ithem, and I'll be usingreact-router-domas well, but that's it for extra dependencies.npmi\\redux\\react-redux\\redux-thunk\\redux-devtools-extension\\react-router-domAnd delete all the boilerplate. We'll add everything we need from scratch instead.cdsrc&&rm*# move to src and delete all files withinWe'll make directories for Reduxreducersand Reduxactions, as well aspagesandcomponentswhich you should already be familiar with from React.mkdiractions components pages reducersAnd we'll bring backindex.js,App.js, andindex.css.touchindex.js index.css App.jsSo at this point your project directory tree looks like this.└── src/\n    ├── actions/\n    ├── components/\n    ├── pages/\n    ├── reducers/\n    ├── App.js\n    ├── index.css\n    └── index.jsFor theindex.cssfile, just take the contents ofthis gistand paste it. I intend only to go over functionality and not anything about style, so I just wrote some very basic styles to ensure the site looks decent enough.Now we have enough boilerplate to get started, so we'll begin working on the entrypoint.Setting up the Redux StoreWhen I first started learning Redux, it seemed so overwhelming because every app I looked at hadindex.jsset up a bit differently.",
        "chunk_type": "code_markup",
        "tag": "main",
        "score": 1.1219999999999999,
        "word_count": 933,
        "chunk_id": "657514346dca44a325e6412500ee416d",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "article",
            "development",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "After looking at a lot of the more up-to-date apps and taking the aspects that were common across all of them, I got a good feel for what should really be in a Redux app, and what is just people moving things around to be unique.There are plenty of tutorials out there that show you how to get a very basic Redux store with todos set up, but I don't find that very useful for knowing how to make a production level setup, so I'm going to set it up with everything you need from the get-go. Even so, there will be some opinionated aspects because Redux is very flexible.Inindex.js, we'll be bringing in a few things.createStore, to create the store that will maintain the Redux stateapplyMiddleware, to be able to use middleware, in this casethunkProvider, to wrap the entire application in Reduxthunk, a middleware that allows us to make asynchronous actions in ReduxcomposeWithDevTools, code that connects your app to Redux DevToolsindex.js// External importsimportReactfrom'react'import{render} rom'react-dom'import{createStore,applyMiddleware} rom'redux'import{Provider} rom'react-redux'importthunkfrom'redux-thunk'import{composeWithDevTools} rom'redux-devtools-extension'// Local importsimportAppfrom'./App'importrootReducerfrom'./reducers'// Assetsimport'./index.css'conststore=createStore(rootReducer,composeWithDevTools(applyMiddleware(thunk)))render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Put a component inApp.js. We'll modify this later, but we just want to get the app up and running for now.App.jsimportReactfrom'react'constApp=()=>{return<div>Hello, Redux</div>} xportdefaultAppBringing in reducersThe last thing to do is bring in the reducer. Areduceris a function that determines changes to Redux state. It is a pure function that returns a copy of the state with the new change.A neat feature of Redux is that we can have many reducers, and combine them all into one root reducer that the store uses, usingcombineReducers. This leads to us being able to easily organize our code while still having everything in one root state tree.Since this app will be like a blog, it will have a list of posts, and we'll put that in thepostsReducerin a moment. Having thiscombineReducersmethod allows us to bring whatever we want in - acommentsReducer, anauthReducer, and so on.Inreducers/index.js, create the file that will combine all reducers.reducers/index.jsimport{combineReducers} rom'redux'importpostsReducerfrom'./postsReducer'constrootReducer=combineReducers({posts:postsReducer,})exportdefaultrootReducerFinally, we'll make thepostsReducer. We can set it up with an initial state. Just like you might expect from a regular React component, we'll have aloadingandhasErrorsstate, as well as apostsarray, where all the posts will live. First we'll set it up with no actions in the switch, just a default case that returns the entire state.reducers/postsReducer.jsexportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow we at least have enough setup that the application will load without crashing.Redux DevToolsWith the application loading and the Redux<Provider>set up, we can take a look at Redux DevTools. After downloading it, it'll be a tab in your Developer Tools. If you click onState, you'll see the entire state of the application so far.There's not much in here yet, but Redux DevTools is amazing once you get to having a lot of reducers and actions. It keeps track of all changes to your app and makes debugging a breeze compared to plain React.Setting up Redux ActionsSo now we have a reducer for posts, but we don't have any actions, meaning the reducer will only return the state without modifying it in any way.Actionsare how we communicate with the Redux store. For this blog app, we're going to want to fetch posts from an API and put them in our Redux state.Since fetching posts is an asynchronous action, it will require the use of Redux thunk. Fortunately, we don't have to do anything special to use thunk beyond setting it up in the store, which we already did.Create aactions/postsActions.js. First, we'll define theaction typesas constants. This is not necessary, but is a common convention, and makes it easy to export the actions around and prevent typos. We want to do three things:getPosts- begin telling Redux we're going to fetch posts from an APIgetPostsSuccess- pass the posts to Redux on successful API callgetPostsFailure- inform Redux that an error was encountered during Redux on failed API callactions/postsActions.js// Create Redux action typesexportconstGET_POSTS='GET_POSTS'exportconstGET_POSTS_SUCCESS='GET_POSTS_SUCCESS'exportconstGET_POSTS_FAILURE='GET_POSTS_FAILURE'Then createaction creators, functions that return anaction, which consists of the type and an optional payload containing data.actions/postsActions.js// Create Redux action creators that return an actionexportconstgetPosts=()=>({type:GET_POSTS,})exportconstgetPostsSuccess=(posts)=>({type:GET_POSTS_SUCCESS,payload:posts,})exportconstgetPostsFailure=()=>({type:GET_POSTS_FAILURE,})Finally, make the asynchronous thunk action that combines all three of the above actions. When called, it will dispatch the initialgetPosts()action to inform Redux to prepare for an API call, then in atry/catch, do everything necessary to get the data, and dispatch a success or failure action as necessary.actions/postsActions.js// Combine them all in an asynchronous thunkexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} reat, we're all done with creating actions now! All that's left to do is tell the reducer what to do with the state on each action.Responding to actionsBack at our post reducer, we have a switch that isn't doing anything yet.reducers/postsReducer.jsexportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow that we have actions, we can bring them in from thepostsActionspage.// Import all actionsimport*asactionsfrom'../actions/postsActions'For each action, we'll make acase, that returns the entire state plus whatever change we're making to it. ForGET_POSTS, for example, all we want to do is tell the app to setloadingtotruesince we'll be making an API call.caseactions.GET_POSTS:return{...state,loading:true} ET_POSTS- begin loadingGET_POSTS_SUCCESS- the app has posts, no errors, and should stop loadingGET_POSTS_FAILURE- the app has errors and should stop loadingHere's the whole reducer.reducers/postsReducer.jsimport*asactionsfrom'../actions/postsActions'exportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){caseactions.GET_POSTS:return{...state,loading:true} aseactions.GET_POSTS_SUCCESS:return{posts:action.payload,loading:false,hasErrors:false} aseactions.GET_POSTS_FAILURE:return{...state,loading:false,hasErrors:true} efault:returnstate}} ow our actions and reducers are ready, so all that's left to do is connect everything to the React app.Connecting Redux to React ComponentsSince the demo app I've created uses React Router to have a few routes - a dashboard, a listing of all posts, and an individual posts page, I'll bring React Router in now. I'll just bring in the dashboard and all posts listing for this demo.App.jsimportReactfrom'react'import{BrowserRouterasRouter,Switch,Route,Redirect} rom'react-router-dom'importDashboardPagefrom'./pages/DashboardPage'importPostsPagefrom'./pages/PostsPage'constApp=()=>{return(<Router><Switch><Routeexactpath=\"/\"component={DashboardPage}/><Routeexactpath=\"/posts\"component={PostsPage}/><Redirectto=\"/\"/></Switch></Router>)} xportdefaultAppWe can create the dashboard page, which is just a regular React component.pages/DashboardPage.jsimportReactfrom'react'import{Link} rom'react-router-dom'constDashboardPage=()=>(<section><h1>Dashboard</h1><p>This is the dashboard.</p><Linkto=\"/posts\"className=\"button\">View Posts</Link></section>)exportdefaultDashboardPageFor each post, let's make aPostcomponent that will display the title and an excerpt of the text of the article. Make aPost.jsin thecomponentssubdirectory.components/Post.jsimportReactfrom'react'exportconstPost=({post})=>(<articleclassName=\"post-excerpt\"><h2>{post.title}</h2><p>{post.body.substring(0,100)}</p></article>)Components that do not connect to Redux are still important and useful for smaller, reusable areas, such as this Post component.Now the interesting part comes in for the posts page - bringing Redux into React. To do this we'll useconnectfromreact-redux. First, we'll just make a regular component for the page.pages/PostsPage.jsimportReactfrom'react'constPostsPage=()=>{return(<section><h1>Posts</h1></section>)} xportdefaultPostsPageThen we'll bring inconnect.",
        "chunk_type": "code_markup",
        "tag": "main",
        "score": 1.1219999999999999,
        "word_count": 1000,
        "chunk_id": "ce44a83cb22103e6a639d48b1d686d36",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Theconnect functionis a higher-order function that connects the Redux store to a React component. We'll pass a parameter calledmapStateToPropstoconnect. This aptly named function will take any state from the Redux store and pass it to the props of the React component. We'll bring inloading,posts, andhasErrorsfrom the ReduxpostsReducer.pages/PostsPage.jsimportReactfrom'react'import{connect} rom'react-redux'// Redux state is now in the props of the componentconstPostsPage=({loading,posts,hasErrors})=>{return(<section><h1>Posts</h1></section>)}// Map Redux state to React component propsconstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})// Connect Redux to Reactexportdefaultconnect(mapStateToProps)(PostsPage)Since this component uses state from the same reducer, we could also writestate => state.posts. However, learning how to write it the long way is useful to know in case you need to bring multiple reducers into the same component.Finally, we'll bring in the asynchronousfetchPostsfrom the actions, which is the action that combines the whole lifecycle of fetching all posts into one. UsinguseEffectfrom React, we'lldispatchfetchPostswhen the component mounts.dispatchwill automatically be available on a connected component.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'// Bring in the asynchronous fetchPosts actionimport{fetchPosts} rom'../actions/postsActions'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])return(<section><h1>Posts</h1></section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)All that's left to do at this point is display all three possible states of the page - whether it's loading, has an error, or successfully retrieved the posts from the API.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'import{fetchPosts} rom'../actions/postsActions'import{Post} rom'../components/Post'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])// Show loading, error, or success stateconstrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post}/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)And that's all - we now have a connected component, and are bringing in data from an API to our Redux store. Using Redux DevTools, we can see each action as it happens, and the changes (diff) after each state change.The EndThis is where the tutorial for creating an application with plain Redux ends. If you look at thesource code of the demo application, you'll see a lot has been added - a reducer and actions for a single post, and for comments.I would recommend completing your project so that it matches the demo app. There are no new concepts to be learned, but you will create two more reducers and actions, and see how to bring two states into one component for the single post page, which brings in one post as well as comments for that post.Redux ToolkitThere is one more thing I want to cover -Redux Toolkit. Redux Toolkit, or RTK, is a newer and easier official way to use Redux. You may notice that Redux has alotof boilerplate for setup and requires many more folders and files than plain React would. Some patterns have emerged to attempt to mitigate all that, such asRedux ducks pattern, but we can simplify it even more.View thesource of the demo Redux Toolkit application, which is the same application we just created with Redux, but using RTK. It is much simpler, with a drastic reduction in lines of code for all the same functionality.Using RTK just requires one dependency,@reduxjs/toolkit.npmi @reduxjs/toolkitAnd no longer requires you to install theredux-thunkorredux-devtools-extensiondependencies.Advantages to Redux ToolkitThe main advantages to using RTK are:Easier to set up (less dependencies)Reduction of boilerplate code (one slice vs. many files for actions and reducers)Sensible defaults (Redux Thunk, Redux DevTools built-in)The ability to usedirect state mutation, since RTK usesimmerunder the hood. This means you no longer need to return{ ...state } ith every reducer.StoreSince Redux Toolkit comes with a lot built-in already, like Redux DevTools and Redux Thunk, we no longer have to bring them into theindex.jsfile. Now we only needconfigureStore, instead ofcreateStore.index.jsimportReactfrom'react'import{render} rom'react-dom'import{configureStore} rom'@reduxjs/toolkit'import{Provider} rom'react-redux'importAppfrom'./App'importrootReducerfrom'./slices'import'./index.css'conststore=configureStore({reducer:rootReducer})render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))SlicesInstead of dealing with reducers, actions, and all as separate files and individually creating all those action types, RTK gives us the concept ofslices. Asliceautomatically generates reducers, action types, and action creators. As such, you'll only have to create one folder -slices.initialStatewill look the same.slices/posts.jsimport{createSlice} rom'@reduxjs/toolkit'exportconstinitialState={loading:false,hasErrors:false,posts:[],} he names of the reducers in the slice will also be the same -getPosts,getPostsSuccess, andgetPostsFailure. We'll make all the same changes, but note that we're no longer returning the entire state - we're just mutating state. It's still immutable under the hood, but this approach may be easier and faster for some. If preferred, you can still return the whole state as an object.slices/posts.js// A slice for posts with our three reducersconstpostsSlice=createSlice({name:'posts',initialState,reducers:{getPosts:(state)=>{state.loading=true},getPostsSuccess:(state,{payload})=>{state.posts=payload\n      state.loading=falsestate.hasErrors=false},getPostsFailure:(state)=>{state.loading=falsestate.hasErrors=true},},})The actions that get generated are the same, we just don't have to write them out individually anymore. From the same file, we can export all the actions, the reducer, the asynchronous thunk, and one new thing - aselector, which we'll use to access any of the state from a React component instead of usingconnect.slices/posts.js// Three actions generated from the sliceexportconst{getPosts,getPostsSuccess,getPostsFailure}=postsSlice.actions// A selectorexportconstpostsSelector=(state)=>state.posts// The reducerexportdefaultpostsSlice.reducer// Asynchronous thunk actionexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} electing Redux state in a React componentThe traditional approach, as we just learned, is to usemapStateToPropswith theconnect()function. This is still common in codebases and therefore worth learning. You can still use this approach with RTK, but the newer, React Hooks way of going about it is to useuseDispatchanduseSelectorfromreact-redux. This approach requires less code overall as well.As you can see in the updatedPostsPage.jsfile below, the Redux state is no longer available as props on the connected component, but from the selector we exported in the slice.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{useDispatch,useSelector} rom'react-redux'import{fetchPosts,postsSelector} rom'../slices/posts'import{Post} rom'../components/Post'constPostsPage=()=>{constdispatch=useDispatch()const{posts,loading,hasErrors}=useSelector(postsSelector)useEffect(()=>{dispatch(fetchPosts())},[dispatch])constrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post} xcerpt/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} xportdefaultPostsPageNow we have the same app as before with a few updates from Redux Toolkit, and a lot less code to maintain.ConclusionWe did it! If you followed along with me through this whole tutorial, you should have a really good feel for Redux now, both the old-fashioned way and using Redux Toolkit to simplify things. To summarize, Redux allows us to easily manage global state in a React application. We can access and update the state from anywhere, and easily debug the entire state of an application with Redux Devtools.You can place most of the state of your application in Redux, but certain areas of an app, such as forms as they are being updated, still make sense to keep in the React component state itself until the form is officially submitted.I hope you enjoyed this article!",
        "chunk_type": "code_markup",
        "tag": "main",
        "score": 1.1219999999999999,
        "word_count": 962,
        "chunk_id": "33861c3fc43be5f54517d6f1ff94d72e",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "It was a lot of work to put together two complete demo applications and run through the whole thing here, and the article ran pretty long, but hopefully this is your one-stop shop for learning all beginner and intermediate Redux concepts. Please let me know what you think and share the article if it helped you out, and donations are always welcome!About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:March 09, 2020Category:TechnicalTagsreduxreacttutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "example",
        "tag": "main",
        "score": 1.1219999999999999,
        "word_count": 115,
        "chunk_id": "96791525f7e53af6b5369b2eec9f621c",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "javascript"
          ]
        }
      },
      {
        "content": "How to Use Redux and ReactDo you have experience usingReact? Have you heard ofRedux, but you've put off learning it because it looks very complicated and all the guides seem overwhelming? If that's the case, this is the article for you! Contain your fear of containing state and come along with me on this relatively painless journey.PrerequisitesYou must already know how to use React for this tutorial, as I will not be explaining any aspects of React itself.Familiarity withHTML & CSS.Familiarity withES6 syntax and features.Knowledge of React terminology:JSX, State, Components, Props, LifecycleandHooksKnowledge ofReact RouterKnowledge of asynchronous JavaScript andmaking API callsAlso, download Redux DevToolsfor Chromeorfor FireFox.GoalsIn this tutorial, we will build a small blog app. It will fetch posts and comments from an API. I've created the same app with both plain Redux, andRedux Toolkit(RTK), the officially sanctioned toolset for Redux. Here are the links to the source and demos of both the plain and RTK versions.React + Redux Application (Plain Redux)SourceDemo ApplicationReact + Redux Toolkit ApplicationSourceDemo ApplicationNote: The applications are pulling from a real API viaJSON Placeholder API. Due to rate limiting on CodeSandbox, the API may appear slow, but it has nothing to do with the Redux application itself. You can also clone the repository locally.We will learn:Whatis Redux andwhyyou might want to use itTheterminologyof Redux: actions, reducers, store, dispatch, connect, and containerMaking asynchronous API calls withRedux ThunkHow to make a small, real-world application with React and ReduxHow to use Redux Toolkit to simplify Redux app developmentWhat is Redux?Redux is a state container for JavaScript applications. Normally with React, you manage state at a component level, and pass state around via props. With Redux, the entire state of your application is managed in one immutable object. Every update to the Redux state results in a copy of sections of the state, plus the new change.Redux was originally created byDan AbramovandAndrew Clark.Why should I use Redux?Easily manage global state- access or update any part of the state from any Redux-connected componentEasily keep track of changes with Redux DevTools- any action or state change is tracked and easy to follow with Redux. The fact that the entire state of the application is tracked with each change means you can easily do time-travel debugging to move back and forth between changes.The downside to Redux is that there's a lot of initial boilerplate to set up and maintain (especially if you use plain Redux without Redux Toolkit). A smaller applicationmay not need Reduxand may instead benefit from simply usingthe Context APIfor global state needs.In my personal experience, I set up an application with Context alone, and later needed to convert everything over to Redux to make it more maintainable and organized.TerminologyUsually I don't like to just make a list of terms and definitions, but Redux has a few that are likely unfamiliar, so I'm just going to define them all up front to make it easy to refer back to them. Although you canskip to the beginning of the tutorial section, I think it would be good to read through all the definitions just to get exposure and an idea of them in your head first.ActionsReducersStoreDispatchConnectI'll just use the typical todo application, and the action of deleting a todo, for the examples.ActionsAnactionsends data from your application to the Redux store. An action is conventionally an object with two properties:typeand (optional)payload. The type is generally an uppercase string (assigned to a constant) that describes the action. The payload is additional data that may be passed.Action TypeconstDELETE_TODO='posts/deleteTodo'Action{type:DELETE_TODO,payload:id,} ction creatorsAnaction creatoris a function that returns an action.Action CreatorconstdeleteTodo=(id)=>({type:DELETE_TODO,payload:id})ReducersAreduceris a function that takes two parameters:stateandaction. A reducer is immutable and always returns a copy of the entire state. A reducer typically consists of aswitchstatement that goes through all the possible action types.ReducerconstinitialState={todos:[{id:1,text:'Eat'},{id:2,text:'Sleep'},],loading:false,hasErrors:false,} unctiontodoReducer(state=initialState,action){switch(action.type){caseDELETE_TODO:return{...state,todos:state.todos.filter((todo)=>todo.id!==action.payload),} efault:returnstate}} toreThe Redux application state lives in thestore, which is initialized with a reducer. When used with React, a<Provider>exists to wrap the application, and anything within the Provider can have access to Redux.Storeimport{createStore} rom'redux'import{Provider} rom'react-redux'importreducerfrom'./reducers'conststore=createStore(reducer)render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Dispatchdispatchis a method available on the store object that accepts an object which is used to update the Redux state. Usually, this object is the result of invoking an action creator.constComponent=({dispatch})=>{useEffect(()=>{dispatch(deleteTodo())},[dispatch])} onnectTheconnect()function is one typical way to connect React to Redux. A connected component is sometimes referred to as acontainer.Okay, that about covers it for the major terms of Redux. It can be overwhelming to read the terminology without any context, so let's begin.Getting StartedFor ease of getting started quickly, my example usesCreate React Appto set up the environment.npx create-react-app redux-tutorialcdredux-tutorialRedux requires a few dependencies.Redux- Core libraryReact Redux- React bindings for ReduxRedux Thunk- Async middleware for ReduxRedux DevTools Extension- Connects Redux app to Redux DevToolsYou canyarn addornpm ithem, and I'll be usingreact-router-domas well, but that's it for extra dependencies.npmi\\redux\\react-redux\\redux-thunk\\redux-devtools-extension\\react-router-domAnd delete all the boilerplate. We'll add everything we need from scratch instead.cdsrc&&rm*# move to src and delete all files withinWe'll make directories for Reduxreducersand Reduxactions, as well aspagesandcomponentswhich you should already be familiar with from React.mkdiractions components pages reducersAnd we'll bring backindex.js,App.js, andindex.css.touchindex.js index.css App.jsSo at this point your project directory tree looks like this.└── src/\n    ├── actions/\n    ├── components/\n    ├── pages/\n    ├── reducers/\n    ├── App.js\n    ├── index.css\n    └── index.jsFor theindex.cssfile, just take the contents ofthis gistand paste it. I intend only to go over functionality and not anything about style, so I just wrote some very basic styles to ensure the site looks decent enough.Now we have enough boilerplate to get started, so we'll begin working on the entrypoint.Setting up the Redux StoreWhen I first started learning Redux, it seemed so overwhelming because every app I looked at hadindex.jsset up a bit differently.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 933,
        "chunk_id": "657514346dca44a325e6412500ee416d",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "development",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "After looking at a lot of the more up-to-date apps and taking the aspects that were common across all of them, I got a good feel for what should really be in a Redux app, and what is just people moving things around to be unique.There are plenty of tutorials out there that show you how to get a very basic Redux store with todos set up, but I don't find that very useful for knowing how to make a production level setup, so I'm going to set it up with everything you need from the get-go. Even so, there will be some opinionated aspects because Redux is very flexible.Inindex.js, we'll be bringing in a few things.createStore, to create the store that will maintain the Redux stateapplyMiddleware, to be able to use middleware, in this casethunkProvider, to wrap the entire application in Reduxthunk, a middleware that allows us to make asynchronous actions in ReduxcomposeWithDevTools, code that connects your app to Redux DevToolsindex.js// External importsimportReactfrom'react'import{render} rom'react-dom'import{createStore,applyMiddleware} rom'redux'import{Provider} rom'react-redux'importthunkfrom'redux-thunk'import{composeWithDevTools} rom'redux-devtools-extension'// Local importsimportAppfrom'./App'importrootReducerfrom'./reducers'// Assetsimport'./index.css'conststore=createStore(rootReducer,composeWithDevTools(applyMiddleware(thunk)))render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Put a component inApp.js. We'll modify this later, but we just want to get the app up and running for now.App.jsimportReactfrom'react'constApp=()=>{return<div>Hello, Redux</div>} xportdefaultAppBringing in reducersThe last thing to do is bring in the reducer. Areduceris a function that determines changes to Redux state. It is a pure function that returns a copy of the state with the new change.A neat feature of Redux is that we can have many reducers, and combine them all into one root reducer that the store uses, usingcombineReducers. This leads to us being able to easily organize our code while still having everything in one root state tree.Since this app will be like a blog, it will have a list of posts, and we'll put that in thepostsReducerin a moment. Having thiscombineReducersmethod allows us to bring whatever we want in - acommentsReducer, anauthReducer, and so on.Inreducers/index.js, create the file that will combine all reducers.reducers/index.jsimport{combineReducers} rom'redux'importpostsReducerfrom'./postsReducer'constrootReducer=combineReducers({posts:postsReducer,})exportdefaultrootReducerFinally, we'll make thepostsReducer. We can set it up with an initial state. Just like you might expect from a regular React component, we'll have aloadingandhasErrorsstate, as well as apostsarray, where all the posts will live. First we'll set it up with no actions in the switch, just a default case that returns the entire state.reducers/postsReducer.jsexportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow we at least have enough setup that the application will load without crashing.Redux DevToolsWith the application loading and the Redux<Provider>set up, we can take a look at Redux DevTools. After downloading it, it'll be a tab in your Developer Tools. If you click onState, you'll see the entire state of the application so far.There's not much in here yet, but Redux DevTools is amazing once you get to having a lot of reducers and actions. It keeps track of all changes to your app and makes debugging a breeze compared to plain React.Setting up Redux ActionsSo now we have a reducer for posts, but we don't have any actions, meaning the reducer will only return the state without modifying it in any way.Actionsare how we communicate with the Redux store. For this blog app, we're going to want to fetch posts from an API and put them in our Redux state.Since fetching posts is an asynchronous action, it will require the use of Redux thunk. Fortunately, we don't have to do anything special to use thunk beyond setting it up in the store, which we already did.Create aactions/postsActions.js. First, we'll define theaction typesas constants. This is not necessary, but is a common convention, and makes it easy to export the actions around and prevent typos. We want to do three things:getPosts- begin telling Redux we're going to fetch posts from an APIgetPostsSuccess- pass the posts to Redux on successful API callgetPostsFailure- inform Redux that an error was encountered during Redux on failed API callactions/postsActions.js// Create Redux action typesexportconstGET_POSTS='GET_POSTS'exportconstGET_POSTS_SUCCESS='GET_POSTS_SUCCESS'exportconstGET_POSTS_FAILURE='GET_POSTS_FAILURE'Then createaction creators, functions that return anaction, which consists of the type and an optional payload containing data.actions/postsActions.js// Create Redux action creators that return an actionexportconstgetPosts=()=>({type:GET_POSTS,})exportconstgetPostsSuccess=(posts)=>({type:GET_POSTS_SUCCESS,payload:posts,})exportconstgetPostsFailure=()=>({type:GET_POSTS_FAILURE,})Finally, make the asynchronous thunk action that combines all three of the above actions. When called, it will dispatch the initialgetPosts()action to inform Redux to prepare for an API call, then in atry/catch, do everything necessary to get the data, and dispatch a success or failure action as necessary.actions/postsActions.js// Combine them all in an asynchronous thunkexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} reat, we're all done with creating actions now! All that's left to do is tell the reducer what to do with the state on each action.Responding to actionsBack at our post reducer, we have a switch that isn't doing anything yet.reducers/postsReducer.jsexportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow that we have actions, we can bring them in from thepostsActionspage.// Import all actionsimport*asactionsfrom'../actions/postsActions'For each action, we'll make acase, that returns the entire state plus whatever change we're making to it. ForGET_POSTS, for example, all we want to do is tell the app to setloadingtotruesince we'll be making an API call.caseactions.GET_POSTS:return{...state,loading:true} ET_POSTS- begin loadingGET_POSTS_SUCCESS- the app has posts, no errors, and should stop loadingGET_POSTS_FAILURE- the app has errors and should stop loadingHere's the whole reducer.reducers/postsReducer.jsimport*asactionsfrom'../actions/postsActions'exportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){caseactions.GET_POSTS:return{...state,loading:true} aseactions.GET_POSTS_SUCCESS:return{posts:action.payload,loading:false,hasErrors:false} aseactions.GET_POSTS_FAILURE:return{...state,loading:false,hasErrors:true} efault:returnstate}} ow our actions and reducers are ready, so all that's left to do is connect everything to the React app.Connecting Redux to React ComponentsSince the demo app I've created uses React Router to have a few routes - a dashboard, a listing of all posts, and an individual posts page, I'll bring React Router in now. I'll just bring in the dashboard and all posts listing for this demo.App.jsimportReactfrom'react'import{BrowserRouterasRouter,Switch,Route,Redirect} rom'react-router-dom'importDashboardPagefrom'./pages/DashboardPage'importPostsPagefrom'./pages/PostsPage'constApp=()=>{return(<Router><Switch><Routeexactpath=\"/\"component={DashboardPage}/><Routeexactpath=\"/posts\"component={PostsPage}/><Redirectto=\"/\"/></Switch></Router>)} xportdefaultAppWe can create the dashboard page, which is just a regular React component.pages/DashboardPage.jsimportReactfrom'react'import{Link} rom'react-router-dom'constDashboardPage=()=>(<section><h1>Dashboard</h1><p>This is the dashboard.</p><Linkto=\"/posts\"className=\"button\">View Posts</Link></section>)exportdefaultDashboardPageFor each post, let's make aPostcomponent that will display the title and an excerpt of the text of the article. Make aPost.jsin thecomponentssubdirectory.components/Post.jsimportReactfrom'react'exportconstPost=({post})=>(<articleclassName=\"post-excerpt\"><h2>{post.title}</h2><p>{post.body.substring(0,100)}</p></article>)Components that do not connect to Redux are still important and useful for smaller, reusable areas, such as this Post component.Now the interesting part comes in for the posts page - bringing Redux into React. To do this we'll useconnectfromreact-redux. First, we'll just make a regular component for the page.pages/PostsPage.jsimportReactfrom'react'constPostsPage=()=>{return(<section><h1>Posts</h1></section>)} xportdefaultPostsPageThen we'll bring inconnect.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 1000,
        "chunk_id": "ce44a83cb22103e6a639d48b1d686d36",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Theconnect functionis a higher-order function that connects the Redux store to a React component. We'll pass a parameter calledmapStateToPropstoconnect. This aptly named function will take any state from the Redux store and pass it to the props of the React component. We'll bring inloading,posts, andhasErrorsfrom the ReduxpostsReducer.pages/PostsPage.jsimportReactfrom'react'import{connect} rom'react-redux'// Redux state is now in the props of the componentconstPostsPage=({loading,posts,hasErrors})=>{return(<section><h1>Posts</h1></section>)}// Map Redux state to React component propsconstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})// Connect Redux to Reactexportdefaultconnect(mapStateToProps)(PostsPage)Since this component uses state from the same reducer, we could also writestate => state.posts. However, learning how to write it the long way is useful to know in case you need to bring multiple reducers into the same component.Finally, we'll bring in the asynchronousfetchPostsfrom the actions, which is the action that combines the whole lifecycle of fetching all posts into one. UsinguseEffectfrom React, we'lldispatchfetchPostswhen the component mounts.dispatchwill automatically be available on a connected component.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'// Bring in the asynchronous fetchPosts actionimport{fetchPosts} rom'../actions/postsActions'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])return(<section><h1>Posts</h1></section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)All that's left to do at this point is display all three possible states of the page - whether it's loading, has an error, or successfully retrieved the posts from the API.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'import{fetchPosts} rom'../actions/postsActions'import{Post} rom'../components/Post'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])// Show loading, error, or success stateconstrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post}/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)And that's all - we now have a connected component, and are bringing in data from an API to our Redux store. Using Redux DevTools, we can see each action as it happens, and the changes (diff) after each state change.The EndThis is where the tutorial for creating an application with plain Redux ends. If you look at thesource code of the demo application, you'll see a lot has been added - a reducer and actions for a single post, and for comments.I would recommend completing your project so that it matches the demo app. There are no new concepts to be learned, but you will create two more reducers and actions, and see how to bring two states into one component for the single post page, which brings in one post as well as comments for that post.Redux ToolkitThere is one more thing I want to cover -Redux Toolkit. Redux Toolkit, or RTK, is a newer and easier official way to use Redux. You may notice that Redux has alotof boilerplate for setup and requires many more folders and files than plain React would. Some patterns have emerged to attempt to mitigate all that, such asRedux ducks pattern, but we can simplify it even more.View thesource of the demo Redux Toolkit application, which is the same application we just created with Redux, but using RTK. It is much simpler, with a drastic reduction in lines of code for all the same functionality.Using RTK just requires one dependency,@reduxjs/toolkit.npmi @reduxjs/toolkitAnd no longer requires you to install theredux-thunkorredux-devtools-extensiondependencies.Advantages to Redux ToolkitThe main advantages to using RTK are:Easier to set up (less dependencies)Reduction of boilerplate code (one slice vs. many files for actions and reducers)Sensible defaults (Redux Thunk, Redux DevTools built-in)The ability to usedirect state mutation, since RTK usesimmerunder the hood. This means you no longer need to return{ ...state } ith every reducer.StoreSince Redux Toolkit comes with a lot built-in already, like Redux DevTools and Redux Thunk, we no longer have to bring them into theindex.jsfile. Now we only needconfigureStore, instead ofcreateStore.index.jsimportReactfrom'react'import{render} rom'react-dom'import{configureStore} rom'@reduxjs/toolkit'import{Provider} rom'react-redux'importAppfrom'./App'importrootReducerfrom'./slices'import'./index.css'conststore=configureStore({reducer:rootReducer})render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))SlicesInstead of dealing with reducers, actions, and all as separate files and individually creating all those action types, RTK gives us the concept ofslices. Asliceautomatically generates reducers, action types, and action creators. As such, you'll only have to create one folder -slices.initialStatewill look the same.slices/posts.jsimport{createSlice} rom'@reduxjs/toolkit'exportconstinitialState={loading:false,hasErrors:false,posts:[],} he names of the reducers in the slice will also be the same -getPosts,getPostsSuccess, andgetPostsFailure. We'll make all the same changes, but note that we're no longer returning the entire state - we're just mutating state. It's still immutable under the hood, but this approach may be easier and faster for some. If preferred, you can still return the whole state as an object.slices/posts.js// A slice for posts with our three reducersconstpostsSlice=createSlice({name:'posts',initialState,reducers:{getPosts:(state)=>{state.loading=true},getPostsSuccess:(state,{payload})=>{state.posts=payload\n      state.loading=falsestate.hasErrors=false},getPostsFailure:(state)=>{state.loading=falsestate.hasErrors=true},},})The actions that get generated are the same, we just don't have to write them out individually anymore. From the same file, we can export all the actions, the reducer, the asynchronous thunk, and one new thing - aselector, which we'll use to access any of the state from a React component instead of usingconnect.slices/posts.js// Three actions generated from the sliceexportconst{getPosts,getPostsSuccess,getPostsFailure}=postsSlice.actions// A selectorexportconstpostsSelector=(state)=>state.posts// The reducerexportdefaultpostsSlice.reducer// Asynchronous thunk actionexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} electing Redux state in a React componentThe traditional approach, as we just learned, is to usemapStateToPropswith theconnect()function. This is still common in codebases and therefore worth learning. You can still use this approach with RTK, but the newer, React Hooks way of going about it is to useuseDispatchanduseSelectorfromreact-redux. This approach requires less code overall as well.As you can see in the updatedPostsPage.jsfile below, the Redux state is no longer available as props on the connected component, but from the selector we exported in the slice.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{useDispatch,useSelector} rom'react-redux'import{fetchPosts,postsSelector} rom'../slices/posts'import{Post} rom'../components/Post'constPostsPage=()=>{constdispatch=useDispatch()const{posts,loading,hasErrors}=useSelector(postsSelector)useEffect(()=>{dispatch(fetchPosts())},[dispatch])constrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post} xcerpt/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} xportdefaultPostsPageNow we have the same app as before with a few updates from Redux Toolkit, and a lot less code to maintain.ConclusionWe did it! If you followed along with me through this whole tutorial, you should have a really good feel for Redux now, both the old-fashioned way and using Redux Toolkit to simplify things. To summarize, Redux allows us to easily manage global state in a React application. We can access and update the state from anywhere, and easily debug the entire state of an application with Redux Devtools.You can place most of the state of your application in Redux, but certain areas of an app, such as forms as they are being updated, still make sense to keep in the React component state itself until the form is officially submitted.I hope you enjoyed this article!",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 962,
        "chunk_id": "33861c3fc43be5f54517d6f1ff94d72e",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "It was a lot of work to put together two complete demo applications and run through the whole thing here, and the article ran pretty long, but hopefully this is your one-stop shop for learning all beginner and intermediate Redux concepts. Please let me know what you think and share the article if it helped you out, and donations are always welcome!About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:March 09, 2020Category:TechnicalTagsreduxreacttutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "example",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 115,
        "chunk_id": "96791525f7e53af6b5369b2eec9f621c",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "javascript"
          ]
        }
      },
      {
        "content": "How to Use Redux and ReactDo you have experience usingReact? Have you heard ofRedux, but you've put off learning it because it looks very complicated and all the guides seem overwhelming? If that's the case, this is the article for you! Contain your fear of containing state and come along with me on this relatively painless journey.PrerequisitesYou must already know how to use React for this tutorial, as I will not be explaining any aspects of React itself.Familiarity withHTML & CSS.Familiarity withES6 syntax and features.Knowledge of React terminology:JSX, State, Components, Props, LifecycleandHooksKnowledge ofReact RouterKnowledge of asynchronous JavaScript andmaking API callsAlso, download Redux DevToolsfor Chromeorfor FireFox.GoalsIn this tutorial, we will build a small blog app. It will fetch posts and comments from an API. I've created the same app with both plain Redux, andRedux Toolkit(RTK), the officially sanctioned toolset for Redux. Here are the links to the source and demos of both the plain and RTK versions.React + Redux Application (Plain Redux)SourceDemo ApplicationReact + Redux Toolkit ApplicationSourceDemo ApplicationNote: The applications are pulling from a real API viaJSON Placeholder API. Due to rate limiting on CodeSandbox, the API may appear slow, but it has nothing to do with the Redux application itself. You can also clone the repository locally.We will learn:Whatis Redux andwhyyou might want to use itTheterminologyof Redux: actions, reducers, store, dispatch, connect, and containerMaking asynchronous API calls withRedux ThunkHow to make a small, real-world application with React and ReduxHow to use Redux Toolkit to simplify Redux app developmentWhat is Redux?Redux is a state container for JavaScript applications. Normally with React, you manage state at a component level, and pass state around via props. With Redux, the entire state of your application is managed in one immutable object. Every update to the Redux state results in a copy of sections of the state, plus the new change.Redux was originally created byDan AbramovandAndrew Clark.Why should I use Redux?Easily manage global state- access or update any part of the state from any Redux-connected componentEasily keep track of changes with Redux DevTools- any action or state change is tracked and easy to follow with Redux. The fact that the entire state of the application is tracked with each change means you can easily do time-travel debugging to move back and forth between changes.The downside to Redux is that there's a lot of initial boilerplate to set up and maintain (especially if you use plain Redux without Redux Toolkit). A smaller applicationmay not need Reduxand may instead benefit from simply usingthe Context APIfor global state needs.In my personal experience, I set up an application with Context alone, and later needed to convert everything over to Redux to make it more maintainable and organized.TerminologyUsually I don't like to just make a list of terms and definitions, but Redux has a few that are likely unfamiliar, so I'm just going to define them all up front to make it easy to refer back to them. Although you canskip to the beginning of the tutorial section, I think it would be good to read through all the definitions just to get exposure and an idea of them in your head first.ActionsReducersStoreDispatchConnectI'll just use the typical todo application, and the action of deleting a todo, for the examples.ActionsAnactionsends data from your application to the Redux store. An action is conventionally an object with two properties:typeand (optional)payload. The type is generally an uppercase string (assigned to a constant) that describes the action. The payload is additional data that may be passed.Action TypeconstDELETE_TODO='posts/deleteTodo'Action{type:DELETE_TODO,payload:id,} ction creatorsAnaction creatoris a function that returns an action.Action CreatorconstdeleteTodo=(id)=>({type:DELETE_TODO,payload:id})ReducersAreduceris a function that takes two parameters:stateandaction. A reducer is immutable and always returns a copy of the entire state. A reducer typically consists of aswitchstatement that goes through all the possible action types.ReducerconstinitialState={todos:[{id:1,text:'Eat'},{id:2,text:'Sleep'},],loading:false,hasErrors:false,} unctiontodoReducer(state=initialState,action){switch(action.type){caseDELETE_TODO:return{...state,todos:state.todos.filter((todo)=>todo.id!==action.payload),} efault:returnstate}} toreThe Redux application state lives in thestore, which is initialized with a reducer. When used with React, a<Provider>exists to wrap the application, and anything within the Provider can have access to Redux.Storeimport{createStore} rom'redux'import{Provider} rom'react-redux'importreducerfrom'./reducers'conststore=createStore(reducer)render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Dispatchdispatchis a method available on the store object that accepts an object which is used to update the Redux state. Usually, this object is the result of invoking an action creator.constComponent=({dispatch})=>{useEffect(()=>{dispatch(deleteTodo())},[dispatch])} onnectTheconnect()function is one typical way to connect React to Redux. A connected component is sometimes referred to as acontainer.Okay, that about covers it for the major terms of Redux. It can be overwhelming to read the terminology without any context, so let's begin.Getting StartedFor ease of getting started quickly, my example usesCreate React Appto set up the environment.npx create-react-app redux-tutorialcdredux-tutorialRedux requires a few dependencies.Redux- Core libraryReact Redux- React bindings for ReduxRedux Thunk- Async middleware for ReduxRedux DevTools Extension- Connects Redux app to Redux DevToolsYou canyarn addornpm ithem, and I'll be usingreact-router-domas well, but that's it for extra dependencies.npmi\\redux\\react-redux\\redux-thunk\\redux-devtools-extension\\react-router-domAnd delete all the boilerplate. We'll add everything we need from scratch instead.cdsrc&&rm*# move to src and delete all files withinWe'll make directories for Reduxreducersand Reduxactions, as well aspagesandcomponentswhich you should already be familiar with from React.mkdiractions components pages reducersAnd we'll bring backindex.js,App.js, andindex.css.touchindex.js index.css App.jsSo at this point your project directory tree looks like this.└── src/\n    ├── actions/\n    ├── components/\n    ├── pages/\n    ├── reducers/\n    ├── App.js\n    ├── index.css\n    └── index.jsFor theindex.cssfile, just take the contents ofthis gistand paste it. I intend only to go over functionality and not anything about style, so I just wrote some very basic styles to ensure the site looks decent enough.Now we have enough boilerplate to get started, so we'll begin working on the entrypoint.Setting up the Redux StoreWhen I first started learning Redux, it seemed so overwhelming because every app I looked at hadindex.jsset up a bit differently.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 933,
        "chunk_id": "657514346dca44a325e6412500ee416d",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "development",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "After looking at a lot of the more up-to-date apps and taking the aspects that were common across all of them, I got a good feel for what should really be in a Redux app, and what is just people moving things around to be unique.There are plenty of tutorials out there that show you how to get a very basic Redux store with todos set up, but I don't find that very useful for knowing how to make a production level setup, so I'm going to set it up with everything you need from the get-go. Even so, there will be some opinionated aspects because Redux is very flexible.Inindex.js, we'll be bringing in a few things.createStore, to create the store that will maintain the Redux stateapplyMiddleware, to be able to use middleware, in this casethunkProvider, to wrap the entire application in Reduxthunk, a middleware that allows us to make asynchronous actions in ReduxcomposeWithDevTools, code that connects your app to Redux DevToolsindex.js// External importsimportReactfrom'react'import{render} rom'react-dom'import{createStore,applyMiddleware} rom'redux'import{Provider} rom'react-redux'importthunkfrom'redux-thunk'import{composeWithDevTools} rom'redux-devtools-extension'// Local importsimportAppfrom'./App'importrootReducerfrom'./reducers'// Assetsimport'./index.css'conststore=createStore(rootReducer,composeWithDevTools(applyMiddleware(thunk)))render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Put a component inApp.js. We'll modify this later, but we just want to get the app up and running for now.App.jsimportReactfrom'react'constApp=()=>{return<div>Hello, Redux</div>} xportdefaultAppBringing in reducersThe last thing to do is bring in the reducer. Areduceris a function that determines changes to Redux state. It is a pure function that returns a copy of the state with the new change.A neat feature of Redux is that we can have many reducers, and combine them all into one root reducer that the store uses, usingcombineReducers. This leads to us being able to easily organize our code while still having everything in one root state tree.Since this app will be like a blog, it will have a list of posts, and we'll put that in thepostsReducerin a moment. Having thiscombineReducersmethod allows us to bring whatever we want in - acommentsReducer, anauthReducer, and so on.Inreducers/index.js, create the file that will combine all reducers.reducers/index.jsimport{combineReducers} rom'redux'importpostsReducerfrom'./postsReducer'constrootReducer=combineReducers({posts:postsReducer,})exportdefaultrootReducerFinally, we'll make thepostsReducer. We can set it up with an initial state. Just like you might expect from a regular React component, we'll have aloadingandhasErrorsstate, as well as apostsarray, where all the posts will live. First we'll set it up with no actions in the switch, just a default case that returns the entire state.reducers/postsReducer.jsexportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow we at least have enough setup that the application will load without crashing.Redux DevToolsWith the application loading and the Redux<Provider>set up, we can take a look at Redux DevTools. After downloading it, it'll be a tab in your Developer Tools. If you click onState, you'll see the entire state of the application so far.There's not much in here yet, but Redux DevTools is amazing once you get to having a lot of reducers and actions. It keeps track of all changes to your app and makes debugging a breeze compared to plain React.Setting up Redux ActionsSo now we have a reducer for posts, but we don't have any actions, meaning the reducer will only return the state without modifying it in any way.Actionsare how we communicate with the Redux store. For this blog app, we're going to want to fetch posts from an API and put them in our Redux state.Since fetching posts is an asynchronous action, it will require the use of Redux thunk. Fortunately, we don't have to do anything special to use thunk beyond setting it up in the store, which we already did.Create aactions/postsActions.js. First, we'll define theaction typesas constants. This is not necessary, but is a common convention, and makes it easy to export the actions around and prevent typos. We want to do three things:getPosts- begin telling Redux we're going to fetch posts from an APIgetPostsSuccess- pass the posts to Redux on successful API callgetPostsFailure- inform Redux that an error was encountered during Redux on failed API callactions/postsActions.js// Create Redux action typesexportconstGET_POSTS='GET_POSTS'exportconstGET_POSTS_SUCCESS='GET_POSTS_SUCCESS'exportconstGET_POSTS_FAILURE='GET_POSTS_FAILURE'Then createaction creators, functions that return anaction, which consists of the type and an optional payload containing data.actions/postsActions.js// Create Redux action creators that return an actionexportconstgetPosts=()=>({type:GET_POSTS,})exportconstgetPostsSuccess=(posts)=>({type:GET_POSTS_SUCCESS,payload:posts,})exportconstgetPostsFailure=()=>({type:GET_POSTS_FAILURE,})Finally, make the asynchronous thunk action that combines all three of the above actions. When called, it will dispatch the initialgetPosts()action to inform Redux to prepare for an API call, then in atry/catch, do everything necessary to get the data, and dispatch a success or failure action as necessary.actions/postsActions.js// Combine them all in an asynchronous thunkexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} reat, we're all done with creating actions now! All that's left to do is tell the reducer what to do with the state on each action.Responding to actionsBack at our post reducer, we have a switch that isn't doing anything yet.reducers/postsReducer.jsexportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow that we have actions, we can bring them in from thepostsActionspage.// Import all actionsimport*asactionsfrom'../actions/postsActions'For each action, we'll make acase, that returns the entire state plus whatever change we're making to it. ForGET_POSTS, for example, all we want to do is tell the app to setloadingtotruesince we'll be making an API call.caseactions.GET_POSTS:return{...state,loading:true} ET_POSTS- begin loadingGET_POSTS_SUCCESS- the app has posts, no errors, and should stop loadingGET_POSTS_FAILURE- the app has errors and should stop loadingHere's the whole reducer.reducers/postsReducer.jsimport*asactionsfrom'../actions/postsActions'exportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){caseactions.GET_POSTS:return{...state,loading:true} aseactions.GET_POSTS_SUCCESS:return{posts:action.payload,loading:false,hasErrors:false} aseactions.GET_POSTS_FAILURE:return{...state,loading:false,hasErrors:true} efault:returnstate}} ow our actions and reducers are ready, so all that's left to do is connect everything to the React app.Connecting Redux to React ComponentsSince the demo app I've created uses React Router to have a few routes - a dashboard, a listing of all posts, and an individual posts page, I'll bring React Router in now. I'll just bring in the dashboard and all posts listing for this demo.App.jsimportReactfrom'react'import{BrowserRouterasRouter,Switch,Route,Redirect} rom'react-router-dom'importDashboardPagefrom'./pages/DashboardPage'importPostsPagefrom'./pages/PostsPage'constApp=()=>{return(<Router><Switch><Routeexactpath=\"/\"component={DashboardPage}/><Routeexactpath=\"/posts\"component={PostsPage}/><Redirectto=\"/\"/></Switch></Router>)} xportdefaultAppWe can create the dashboard page, which is just a regular React component.pages/DashboardPage.jsimportReactfrom'react'import{Link} rom'react-router-dom'constDashboardPage=()=>(<section><h1>Dashboard</h1><p>This is the dashboard.</p><Linkto=\"/posts\"className=\"button\">View Posts</Link></section>)exportdefaultDashboardPageFor each post, let's make aPostcomponent that will display the title and an excerpt of the text of the article. Make aPost.jsin thecomponentssubdirectory.components/Post.jsimportReactfrom'react'exportconstPost=({post})=>(<articleclassName=\"post-excerpt\"><h2>{post.title}</h2><p>{post.body.substring(0,100)}</p></article>)Components that do not connect to Redux are still important and useful for smaller, reusable areas, such as this Post component.Now the interesting part comes in for the posts page - bringing Redux into React. To do this we'll useconnectfromreact-redux. First, we'll just make a regular component for the page.pages/PostsPage.jsimportReactfrom'react'constPostsPage=()=>{return(<section><h1>Posts</h1></section>)} xportdefaultPostsPageThen we'll bring inconnect.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 1000,
        "chunk_id": "ce44a83cb22103e6a639d48b1d686d36",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Theconnect functionis a higher-order function that connects the Redux store to a React component. We'll pass a parameter calledmapStateToPropstoconnect. This aptly named function will take any state from the Redux store and pass it to the props of the React component. We'll bring inloading,posts, andhasErrorsfrom the ReduxpostsReducer.pages/PostsPage.jsimportReactfrom'react'import{connect} rom'react-redux'// Redux state is now in the props of the componentconstPostsPage=({loading,posts,hasErrors})=>{return(<section><h1>Posts</h1></section>)}// Map Redux state to React component propsconstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})// Connect Redux to Reactexportdefaultconnect(mapStateToProps)(PostsPage)Since this component uses state from the same reducer, we could also writestate => state.posts. However, learning how to write it the long way is useful to know in case you need to bring multiple reducers into the same component.Finally, we'll bring in the asynchronousfetchPostsfrom the actions, which is the action that combines the whole lifecycle of fetching all posts into one. UsinguseEffectfrom React, we'lldispatchfetchPostswhen the component mounts.dispatchwill automatically be available on a connected component.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'// Bring in the asynchronous fetchPosts actionimport{fetchPosts} rom'../actions/postsActions'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])return(<section><h1>Posts</h1></section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)All that's left to do at this point is display all three possible states of the page - whether it's loading, has an error, or successfully retrieved the posts from the API.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'import{fetchPosts} rom'../actions/postsActions'import{Post} rom'../components/Post'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])// Show loading, error, or success stateconstrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post}/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)And that's all - we now have a connected component, and are bringing in data from an API to our Redux store. Using Redux DevTools, we can see each action as it happens, and the changes (diff) after each state change.The EndThis is where the tutorial for creating an application with plain Redux ends. If you look at thesource code of the demo application, you'll see a lot has been added - a reducer and actions for a single post, and for comments.I would recommend completing your project so that it matches the demo app. There are no new concepts to be learned, but you will create two more reducers and actions, and see how to bring two states into one component for the single post page, which brings in one post as well as comments for that post.Redux ToolkitThere is one more thing I want to cover -Redux Toolkit. Redux Toolkit, or RTK, is a newer and easier official way to use Redux. You may notice that Redux has alotof boilerplate for setup and requires many more folders and files than plain React would. Some patterns have emerged to attempt to mitigate all that, such asRedux ducks pattern, but we can simplify it even more.View thesource of the demo Redux Toolkit application, which is the same application we just created with Redux, but using RTK. It is much simpler, with a drastic reduction in lines of code for all the same functionality.Using RTK just requires one dependency,@reduxjs/toolkit.npmi @reduxjs/toolkitAnd no longer requires you to install theredux-thunkorredux-devtools-extensiondependencies.Advantages to Redux ToolkitThe main advantages to using RTK are:Easier to set up (less dependencies)Reduction of boilerplate code (one slice vs. many files for actions and reducers)Sensible defaults (Redux Thunk, Redux DevTools built-in)The ability to usedirect state mutation, since RTK usesimmerunder the hood. This means you no longer need to return{ ...state } ith every reducer.StoreSince Redux Toolkit comes with a lot built-in already, like Redux DevTools and Redux Thunk, we no longer have to bring them into theindex.jsfile. Now we only needconfigureStore, instead ofcreateStore.index.jsimportReactfrom'react'import{render} rom'react-dom'import{configureStore} rom'@reduxjs/toolkit'import{Provider} rom'react-redux'importAppfrom'./App'importrootReducerfrom'./slices'import'./index.css'conststore=configureStore({reducer:rootReducer})render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))SlicesInstead of dealing with reducers, actions, and all as separate files and individually creating all those action types, RTK gives us the concept ofslices. Asliceautomatically generates reducers, action types, and action creators. As such, you'll only have to create one folder -slices.initialStatewill look the same.slices/posts.jsimport{createSlice} rom'@reduxjs/toolkit'exportconstinitialState={loading:false,hasErrors:false,posts:[],} he names of the reducers in the slice will also be the same -getPosts,getPostsSuccess, andgetPostsFailure. We'll make all the same changes, but note that we're no longer returning the entire state - we're just mutating state. It's still immutable under the hood, but this approach may be easier and faster for some. If preferred, you can still return the whole state as an object.slices/posts.js// A slice for posts with our three reducersconstpostsSlice=createSlice({name:'posts',initialState,reducers:{getPosts:(state)=>{state.loading=true},getPostsSuccess:(state,{payload})=>{state.posts=payload\n      state.loading=falsestate.hasErrors=false},getPostsFailure:(state)=>{state.loading=falsestate.hasErrors=true},},})The actions that get generated are the same, we just don't have to write them out individually anymore. From the same file, we can export all the actions, the reducer, the asynchronous thunk, and one new thing - aselector, which we'll use to access any of the state from a React component instead of usingconnect.slices/posts.js// Three actions generated from the sliceexportconst{getPosts,getPostsSuccess,getPostsFailure}=postsSlice.actions// A selectorexportconstpostsSelector=(state)=>state.posts// The reducerexportdefaultpostsSlice.reducer// Asynchronous thunk actionexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} electing Redux state in a React componentThe traditional approach, as we just learned, is to usemapStateToPropswith theconnect()function. This is still common in codebases and therefore worth learning. You can still use this approach with RTK, but the newer, React Hooks way of going about it is to useuseDispatchanduseSelectorfromreact-redux. This approach requires less code overall as well.As you can see in the updatedPostsPage.jsfile below, the Redux state is no longer available as props on the connected component, but from the selector we exported in the slice.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{useDispatch,useSelector} rom'react-redux'import{fetchPosts,postsSelector} rom'../slices/posts'import{Post} rom'../components/Post'constPostsPage=()=>{constdispatch=useDispatch()const{posts,loading,hasErrors}=useSelector(postsSelector)useEffect(()=>{dispatch(fetchPosts())},[dispatch])constrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post} xcerpt/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} xportdefaultPostsPageNow we have the same app as before with a few updates from Redux Toolkit, and a lot less code to maintain.ConclusionWe did it! If you followed along with me through this whole tutorial, you should have a really good feel for Redux now, both the old-fashioned way and using Redux Toolkit to simplify things. To summarize, Redux allows us to easily manage global state in a React application. We can access and update the state from anywhere, and easily debug the entire state of an application with Redux Devtools.You can place most of the state of your application in Redux, but certain areas of an app, such as forms as they are being updated, still make sense to keep in the React component state itself until the form is officially submitted.I hope you enjoyed this article!",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 962,
        "chunk_id": "33861c3fc43be5f54517d6f1ff94d72e",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "It was a lot of work to put together two complete demo applications and run through the whole thing here, and the article ran pretty long, but hopefully this is your one-stop shop for learning all beginner and intermediate Redux concepts. Please let me know what you think and share the article if it helped you out, and donations are always welcome!About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:March 09, 2020Category:TechnicalTagsreduxreacttutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "example",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 115,
        "chunk_id": "96791525f7e53af6b5369b2eec9f621c",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "javascript"
          ]
        }
      },
      {
        "content": "How to Use Redux and ReactDo you have experience usingReact? Have you heard ofRedux, but you've put off learning it because it looks very complicated and all the guides seem overwhelming? If that's the case, this is the article for you! Contain your fear of containing state and come along with me on this relatively painless journey.PrerequisitesYou must already know how to use React for this tutorial, as I will not be explaining any aspects of React itself.Familiarity withHTML & CSS.Familiarity withES6 syntax and features.Knowledge of React terminology:JSX, State, Components, Props, LifecycleandHooksKnowledge ofReact RouterKnowledge of asynchronous JavaScript andmaking API callsAlso, download Redux DevToolsfor Chromeorfor FireFox.GoalsIn this tutorial, we will build a small blog app. It will fetch posts and comments from an API. I've created the same app with both plain Redux, andRedux Toolkit(RTK), the officially sanctioned toolset for Redux. Here are the links to the source and demos of both the plain and RTK versions.React + Redux Application (Plain Redux)SourceDemo ApplicationReact + Redux Toolkit ApplicationSourceDemo ApplicationNote: The applications are pulling from a real API viaJSON Placeholder API. Due to rate limiting on CodeSandbox, the API may appear slow, but it has nothing to do with the Redux application itself. You can also clone the repository locally.We will learn:Whatis Redux andwhyyou might want to use itTheterminologyof Redux: actions, reducers, store, dispatch, connect, and containerMaking asynchronous API calls withRedux ThunkHow to make a small, real-world application with React and ReduxHow to use Redux Toolkit to simplify Redux app developmentWhat is Redux?Redux is a state container for JavaScript applications. Normally with React, you manage state at a component level, and pass state around via props. With Redux, the entire state of your application is managed in one immutable object. Every update to the Redux state results in a copy of sections of the state, plus the new change.Redux was originally created byDan AbramovandAndrew Clark.Why should I use Redux?Easily manage global state- access or update any part of the state from any Redux-connected componentEasily keep track of changes with Redux DevTools- any action or state change is tracked and easy to follow with Redux. The fact that the entire state of the application is tracked with each change means you can easily do time-travel debugging to move back and forth between changes.The downside to Redux is that there's a lot of initial boilerplate to set up and maintain (especially if you use plain Redux without Redux Toolkit). A smaller applicationmay not need Reduxand may instead benefit from simply usingthe Context APIfor global state needs.In my personal experience, I set up an application with Context alone, and later needed to convert everything over to Redux to make it more maintainable and organized.TerminologyUsually I don't like to just make a list of terms and definitions, but Redux has a few that are likely unfamiliar, so I'm just going to define them all up front to make it easy to refer back to them. Although you canskip to the beginning of the tutorial section, I think it would be good to read through all the definitions just to get exposure and an idea of them in your head first.ActionsReducersStoreDispatchConnectI'll just use the typical todo application, and the action of deleting a todo, for the examples.ActionsAnactionsends data from your application to the Redux store. An action is conventionally an object with two properties:typeand (optional)payload. The type is generally an uppercase string (assigned to a constant) that describes the action. The payload is additional data that may be passed.Action TypeconstDELETE_TODO='posts/deleteTodo'Action{type:DELETE_TODO,payload:id,} ction creatorsAnaction creatoris a function that returns an action.Action CreatorconstdeleteTodo=(id)=>({type:DELETE_TODO,payload:id})ReducersAreduceris a function that takes two parameters:stateandaction. A reducer is immutable and always returns a copy of the entire state. A reducer typically consists of aswitchstatement that goes through all the possible action types.ReducerconstinitialState={todos:[{id:1,text:'Eat'},{id:2,text:'Sleep'},],loading:false,hasErrors:false,} unctiontodoReducer(state=initialState,action){switch(action.type){caseDELETE_TODO:return{...state,todos:state.todos.filter((todo)=>todo.id!==action.payload),} efault:returnstate}} toreThe Redux application state lives in thestore, which is initialized with a reducer. When used with React, a<Provider>exists to wrap the application, and anything within the Provider can have access to Redux.Storeimport{createStore} rom'redux'import{Provider} rom'react-redux'importreducerfrom'./reducers'conststore=createStore(reducer)render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Dispatchdispatchis a method available on the store object that accepts an object which is used to update the Redux state. Usually, this object is the result of invoking an action creator.constComponent=({dispatch})=>{useEffect(()=>{dispatch(deleteTodo())},[dispatch])} onnectTheconnect()function is one typical way to connect React to Redux. A connected component is sometimes referred to as acontainer.Okay, that about covers it for the major terms of Redux. It can be overwhelming to read the terminology without any context, so let's begin.Getting StartedFor ease of getting started quickly, my example usesCreate React Appto set up the environment.npx create-react-app redux-tutorialcdredux-tutorialRedux requires a few dependencies.Redux- Core libraryReact Redux- React bindings for ReduxRedux Thunk- Async middleware for ReduxRedux DevTools Extension- Connects Redux app to Redux DevToolsYou canyarn addornpm ithem, and I'll be usingreact-router-domas well, but that's it for extra dependencies.npmi\\redux\\react-redux\\redux-thunk\\redux-devtools-extension\\react-router-domAnd delete all the boilerplate. We'll add everything we need from scratch instead.cdsrc&&rm*# move to src and delete all files withinWe'll make directories for Reduxreducersand Reduxactions, as well aspagesandcomponentswhich you should already be familiar with from React.mkdiractions components pages reducersAnd we'll bring backindex.js,App.js, andindex.css.touchindex.js index.css App.jsSo at this point your project directory tree looks like this.└── src/\n    ├── actions/\n    ├── components/\n    ├── pages/\n    ├── reducers/\n    ├── App.js\n    ├── index.css\n    └── index.jsFor theindex.cssfile, just take the contents ofthis gistand paste it. I intend only to go over functionality and not anything about style, so I just wrote some very basic styles to ensure the site looks decent enough.Now we have enough boilerplate to get started, so we'll begin working on the entrypoint.Setting up the Redux StoreWhen I first started learning Redux, it seemed so overwhelming because every app I looked at hadindex.jsset up a bit differently.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 933,
        "chunk_id": "657514346dca44a325e6412500ee416d",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "development",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "After looking at a lot of the more up-to-date apps and taking the aspects that were common across all of them, I got a good feel for what should really be in a Redux app, and what is just people moving things around to be unique.There are plenty of tutorials out there that show you how to get a very basic Redux store with todos set up, but I don't find that very useful for knowing how to make a production level setup, so I'm going to set it up with everything you need from the get-go. Even so, there will be some opinionated aspects because Redux is very flexible.Inindex.js, we'll be bringing in a few things.createStore, to create the store that will maintain the Redux stateapplyMiddleware, to be able to use middleware, in this casethunkProvider, to wrap the entire application in Reduxthunk, a middleware that allows us to make asynchronous actions in ReduxcomposeWithDevTools, code that connects your app to Redux DevToolsindex.js// External importsimportReactfrom'react'import{render} rom'react-dom'import{createStore,applyMiddleware} rom'redux'import{Provider} rom'react-redux'importthunkfrom'redux-thunk'import{composeWithDevTools} rom'redux-devtools-extension'// Local importsimportAppfrom'./App'importrootReducerfrom'./reducers'// Assetsimport'./index.css'conststore=createStore(rootReducer,composeWithDevTools(applyMiddleware(thunk)))render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Put a component inApp.js. We'll modify this later, but we just want to get the app up and running for now.App.jsimportReactfrom'react'constApp=()=>{return<div>Hello, Redux</div>} xportdefaultAppBringing in reducersThe last thing to do is bring in the reducer. Areduceris a function that determines changes to Redux state. It is a pure function that returns a copy of the state with the new change.A neat feature of Redux is that we can have many reducers, and combine them all into one root reducer that the store uses, usingcombineReducers. This leads to us being able to easily organize our code while still having everything in one root state tree.Since this app will be like a blog, it will have a list of posts, and we'll put that in thepostsReducerin a moment. Having thiscombineReducersmethod allows us to bring whatever we want in - acommentsReducer, anauthReducer, and so on.Inreducers/index.js, create the file that will combine all reducers.reducers/index.jsimport{combineReducers} rom'redux'importpostsReducerfrom'./postsReducer'constrootReducer=combineReducers({posts:postsReducer,})exportdefaultrootReducerFinally, we'll make thepostsReducer. We can set it up with an initial state. Just like you might expect from a regular React component, we'll have aloadingandhasErrorsstate, as well as apostsarray, where all the posts will live. First we'll set it up with no actions in the switch, just a default case that returns the entire state.reducers/postsReducer.jsexportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow we at least have enough setup that the application will load without crashing.Redux DevToolsWith the application loading and the Redux<Provider>set up, we can take a look at Redux DevTools. After downloading it, it'll be a tab in your Developer Tools. If you click onState, you'll see the entire state of the application so far.There's not much in here yet, but Redux DevTools is amazing once you get to having a lot of reducers and actions. It keeps track of all changes to your app and makes debugging a breeze compared to plain React.Setting up Redux ActionsSo now we have a reducer for posts, but we don't have any actions, meaning the reducer will only return the state without modifying it in any way.Actionsare how we communicate with the Redux store. For this blog app, we're going to want to fetch posts from an API and put them in our Redux state.Since fetching posts is an asynchronous action, it will require the use of Redux thunk. Fortunately, we don't have to do anything special to use thunk beyond setting it up in the store, which we already did.Create aactions/postsActions.js. First, we'll define theaction typesas constants. This is not necessary, but is a common convention, and makes it easy to export the actions around and prevent typos. We want to do three things:getPosts- begin telling Redux we're going to fetch posts from an APIgetPostsSuccess- pass the posts to Redux on successful API callgetPostsFailure- inform Redux that an error was encountered during Redux on failed API callactions/postsActions.js// Create Redux action typesexportconstGET_POSTS='GET_POSTS'exportconstGET_POSTS_SUCCESS='GET_POSTS_SUCCESS'exportconstGET_POSTS_FAILURE='GET_POSTS_FAILURE'Then createaction creators, functions that return anaction, which consists of the type and an optional payload containing data.actions/postsActions.js// Create Redux action creators that return an actionexportconstgetPosts=()=>({type:GET_POSTS,})exportconstgetPostsSuccess=(posts)=>({type:GET_POSTS_SUCCESS,payload:posts,})exportconstgetPostsFailure=()=>({type:GET_POSTS_FAILURE,})Finally, make the asynchronous thunk action that combines all three of the above actions. When called, it will dispatch the initialgetPosts()action to inform Redux to prepare for an API call, then in atry/catch, do everything necessary to get the data, and dispatch a success or failure action as necessary.actions/postsActions.js// Combine them all in an asynchronous thunkexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} reat, we're all done with creating actions now! All that's left to do is tell the reducer what to do with the state on each action.Responding to actionsBack at our post reducer, we have a switch that isn't doing anything yet.reducers/postsReducer.jsexportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow that we have actions, we can bring them in from thepostsActionspage.// Import all actionsimport*asactionsfrom'../actions/postsActions'For each action, we'll make acase, that returns the entire state plus whatever change we're making to it. ForGET_POSTS, for example, all we want to do is tell the app to setloadingtotruesince we'll be making an API call.caseactions.GET_POSTS:return{...state,loading:true} ET_POSTS- begin loadingGET_POSTS_SUCCESS- the app has posts, no errors, and should stop loadingGET_POSTS_FAILURE- the app has errors and should stop loadingHere's the whole reducer.reducers/postsReducer.jsimport*asactionsfrom'../actions/postsActions'exportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){caseactions.GET_POSTS:return{...state,loading:true} aseactions.GET_POSTS_SUCCESS:return{posts:action.payload,loading:false,hasErrors:false} aseactions.GET_POSTS_FAILURE:return{...state,loading:false,hasErrors:true} efault:returnstate}} ow our actions and reducers are ready, so all that's left to do is connect everything to the React app.Connecting Redux to React ComponentsSince the demo app I've created uses React Router to have a few routes - a dashboard, a listing of all posts, and an individual posts page, I'll bring React Router in now. I'll just bring in the dashboard and all posts listing for this demo.App.jsimportReactfrom'react'import{BrowserRouterasRouter,Switch,Route,Redirect} rom'react-router-dom'importDashboardPagefrom'./pages/DashboardPage'importPostsPagefrom'./pages/PostsPage'constApp=()=>{return(<Router><Switch><Routeexactpath=\"/\"component={DashboardPage}/><Routeexactpath=\"/posts\"component={PostsPage}/><Redirectto=\"/\"/></Switch></Router>)} xportdefaultAppWe can create the dashboard page, which is just a regular React component.pages/DashboardPage.jsimportReactfrom'react'import{Link} rom'react-router-dom'constDashboardPage=()=>(<section><h1>Dashboard</h1><p>This is the dashboard.</p><Linkto=\"/posts\"className=\"button\">View Posts</Link></section>)exportdefaultDashboardPageFor each post, let's make aPostcomponent that will display the title and an excerpt of the text of the article. Make aPost.jsin thecomponentssubdirectory.components/Post.jsimportReactfrom'react'exportconstPost=({post})=>(<articleclassName=\"post-excerpt\"><h2>{post.title}</h2><p>{post.body.substring(0,100)}</p></article>)Components that do not connect to Redux are still important and useful for smaller, reusable areas, such as this Post component.Now the interesting part comes in for the posts page - bringing Redux into React. To do this we'll useconnectfromreact-redux. First, we'll just make a regular component for the page.pages/PostsPage.jsimportReactfrom'react'constPostsPage=()=>{return(<section><h1>Posts</h1></section>)} xportdefaultPostsPageThen we'll bring inconnect.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 1000,
        "chunk_id": "ce44a83cb22103e6a639d48b1d686d36",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Theconnect functionis a higher-order function that connects the Redux store to a React component. We'll pass a parameter calledmapStateToPropstoconnect. This aptly named function will take any state from the Redux store and pass it to the props of the React component. We'll bring inloading,posts, andhasErrorsfrom the ReduxpostsReducer.pages/PostsPage.jsimportReactfrom'react'import{connect} rom'react-redux'// Redux state is now in the props of the componentconstPostsPage=({loading,posts,hasErrors})=>{return(<section><h1>Posts</h1></section>)}// Map Redux state to React component propsconstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})// Connect Redux to Reactexportdefaultconnect(mapStateToProps)(PostsPage)Since this component uses state from the same reducer, we could also writestate => state.posts. However, learning how to write it the long way is useful to know in case you need to bring multiple reducers into the same component.Finally, we'll bring in the asynchronousfetchPostsfrom the actions, which is the action that combines the whole lifecycle of fetching all posts into one. UsinguseEffectfrom React, we'lldispatchfetchPostswhen the component mounts.dispatchwill automatically be available on a connected component.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'// Bring in the asynchronous fetchPosts actionimport{fetchPosts} rom'../actions/postsActions'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])return(<section><h1>Posts</h1></section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)All that's left to do at this point is display all three possible states of the page - whether it's loading, has an error, or successfully retrieved the posts from the API.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'import{fetchPosts} rom'../actions/postsActions'import{Post} rom'../components/Post'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])// Show loading, error, or success stateconstrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post}/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)And that's all - we now have a connected component, and are bringing in data from an API to our Redux store. Using Redux DevTools, we can see each action as it happens, and the changes (diff) after each state change.The EndThis is where the tutorial for creating an application with plain Redux ends. If you look at thesource code of the demo application, you'll see a lot has been added - a reducer and actions for a single post, and for comments.I would recommend completing your project so that it matches the demo app. There are no new concepts to be learned, but you will create two more reducers and actions, and see how to bring two states into one component for the single post page, which brings in one post as well as comments for that post.Redux ToolkitThere is one more thing I want to cover -Redux Toolkit. Redux Toolkit, or RTK, is a newer and easier official way to use Redux. You may notice that Redux has alotof boilerplate for setup and requires many more folders and files than plain React would. Some patterns have emerged to attempt to mitigate all that, such asRedux ducks pattern, but we can simplify it even more.View thesource of the demo Redux Toolkit application, which is the same application we just created with Redux, but using RTK. It is much simpler, with a drastic reduction in lines of code for all the same functionality.Using RTK just requires one dependency,@reduxjs/toolkit.npmi @reduxjs/toolkitAnd no longer requires you to install theredux-thunkorredux-devtools-extensiondependencies.Advantages to Redux ToolkitThe main advantages to using RTK are:Easier to set up (less dependencies)Reduction of boilerplate code (one slice vs. many files for actions and reducers)Sensible defaults (Redux Thunk, Redux DevTools built-in)The ability to usedirect state mutation, since RTK usesimmerunder the hood. This means you no longer need to return{ ...state } ith every reducer.StoreSince Redux Toolkit comes with a lot built-in already, like Redux DevTools and Redux Thunk, we no longer have to bring them into theindex.jsfile. Now we only needconfigureStore, instead ofcreateStore.index.jsimportReactfrom'react'import{render} rom'react-dom'import{configureStore} rom'@reduxjs/toolkit'import{Provider} rom'react-redux'importAppfrom'./App'importrootReducerfrom'./slices'import'./index.css'conststore=configureStore({reducer:rootReducer})render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))SlicesInstead of dealing with reducers, actions, and all as separate files and individually creating all those action types, RTK gives us the concept ofslices. Asliceautomatically generates reducers, action types, and action creators. As such, you'll only have to create one folder -slices.initialStatewill look the same.slices/posts.jsimport{createSlice} rom'@reduxjs/toolkit'exportconstinitialState={loading:false,hasErrors:false,posts:[],} he names of the reducers in the slice will also be the same -getPosts,getPostsSuccess, andgetPostsFailure. We'll make all the same changes, but note that we're no longer returning the entire state - we're just mutating state. It's still immutable under the hood, but this approach may be easier and faster for some. If preferred, you can still return the whole state as an object.slices/posts.js// A slice for posts with our three reducersconstpostsSlice=createSlice({name:'posts',initialState,reducers:{getPosts:(state)=>{state.loading=true},getPostsSuccess:(state,{payload})=>{state.posts=payload\n      state.loading=falsestate.hasErrors=false},getPostsFailure:(state)=>{state.loading=falsestate.hasErrors=true},},})The actions that get generated are the same, we just don't have to write them out individually anymore. From the same file, we can export all the actions, the reducer, the asynchronous thunk, and one new thing - aselector, which we'll use to access any of the state from a React component instead of usingconnect.slices/posts.js// Three actions generated from the sliceexportconst{getPosts,getPostsSuccess,getPostsFailure}=postsSlice.actions// A selectorexportconstpostsSelector=(state)=>state.posts// The reducerexportdefaultpostsSlice.reducer// Asynchronous thunk actionexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} electing Redux state in a React componentThe traditional approach, as we just learned, is to usemapStateToPropswith theconnect()function. This is still common in codebases and therefore worth learning. You can still use this approach with RTK, but the newer, React Hooks way of going about it is to useuseDispatchanduseSelectorfromreact-redux. This approach requires less code overall as well.As you can see in the updatedPostsPage.jsfile below, the Redux state is no longer available as props on the connected component, but from the selector we exported in the slice.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{useDispatch,useSelector} rom'react-redux'import{fetchPosts,postsSelector} rom'../slices/posts'import{Post} rom'../components/Post'constPostsPage=()=>{constdispatch=useDispatch()const{posts,loading,hasErrors}=useSelector(postsSelector)useEffect(()=>{dispatch(fetchPosts())},[dispatch])constrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post} xcerpt/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} xportdefaultPostsPageNow we have the same app as before with a few updates from Redux Toolkit, and a lot less code to maintain.ConclusionWe did it! If you followed along with me through this whole tutorial, you should have a really good feel for Redux now, both the old-fashioned way and using Redux Toolkit to simplify things. To summarize, Redux allows us to easily manage global state in a React application. We can access and update the state from anywhere, and easily debug the entire state of an application with Redux Devtools.You can place most of the state of your application in Redux, but certain areas of an app, such as forms as they are being updated, still make sense to keep in the React component state itself until the form is officially submitted.I hope you enjoyed this article!",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 962,
        "chunk_id": "33861c3fc43be5f54517d6f1ff94d72e",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "It was a lot of work to put together two complete demo applications and run through the whole thing here, and the article ran pretty long, but hopefully this is your one-stop shop for learning all beginner and intermediate Redux concepts. Please let me know what you think and share the article if it helped you out, and donations are always welcome!About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:March 09, 2020Category:TechnicalTagsreduxreacttutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "example",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 115,
        "chunk_id": "96791525f7e53af6b5369b2eec9f621c",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "javascript"
          ]
        }
      },
      {
        "content": "How to Use Redux and ReactDo you have experience usingReact? Have you heard ofRedux, but you've put off learning it because it looks very complicated and all the guides seem overwhelming? If that's the case, this is the article for you! Contain your fear of containing state and come along with me on this relatively painless journey.PrerequisitesYou must already know how to use React for this tutorial, as I will not be explaining any aspects of React itself.Familiarity withHTML & CSS.Familiarity withES6 syntax and features.Knowledge of React terminology:JSX, State, Components, Props, LifecycleandHooksKnowledge ofReact RouterKnowledge of asynchronous JavaScript andmaking API callsAlso, download Redux DevToolsfor Chromeorfor FireFox.GoalsIn this tutorial, we will build a small blog app. It will fetch posts and comments from an API. I've created the same app with both plain Redux, andRedux Toolkit(RTK), the officially sanctioned toolset for Redux. Here are the links to the source and demos of both the plain and RTK versions.React + Redux Application (Plain Redux)SourceDemo ApplicationReact + Redux Toolkit ApplicationSourceDemo ApplicationNote: The applications are pulling from a real API viaJSON Placeholder API. Due to rate limiting on CodeSandbox, the API may appear slow, but it has nothing to do with the Redux application itself. You can also clone the repository locally.We will learn:Whatis Redux andwhyyou might want to use itTheterminologyof Redux: actions, reducers, store, dispatch, connect, and containerMaking asynchronous API calls withRedux ThunkHow to make a small, real-world application with React and ReduxHow to use Redux Toolkit to simplify Redux app developmentWhat is Redux?Redux is a state container for JavaScript applications. Normally with React, you manage state at a component level, and pass state around via props. With Redux, the entire state of your application is managed in one immutable object. Every update to the Redux state results in a copy of sections of the state, plus the new change.Redux was originally created byDan AbramovandAndrew Clark.Why should I use Redux?Easily manage global state- access or update any part of the state from any Redux-connected componentEasily keep track of changes with Redux DevTools- any action or state change is tracked and easy to follow with Redux. The fact that the entire state of the application is tracked with each change means you can easily do time-travel debugging to move back and forth between changes.The downside to Redux is that there's a lot of initial boilerplate to set up and maintain (especially if you use plain Redux without Redux Toolkit). A smaller applicationmay not need Reduxand may instead benefit from simply usingthe Context APIfor global state needs.In my personal experience, I set up an application with Context alone, and later needed to convert everything over to Redux to make it more maintainable and organized.TerminologyUsually I don't like to just make a list of terms and definitions, but Redux has a few that are likely unfamiliar, so I'm just going to define them all up front to make it easy to refer back to them. Although you canskip to the beginning of the tutorial section, I think it would be good to read through all the definitions just to get exposure and an idea of them in your head first.ActionsReducersStoreDispatchConnectI'll just use the typical todo application, and the action of deleting a todo, for the examples.ActionsAnactionsends data from your application to the Redux store. An action is conventionally an object with two properties:typeand (optional)payload. The type is generally an uppercase string (assigned to a constant) that describes the action. The payload is additional data that may be passed.Action TypeconstDELETE_TODO='posts/deleteTodo'Action{type:DELETE_TODO,payload:id,} ction creatorsAnaction creatoris a function that returns an action.Action CreatorconstdeleteTodo=(id)=>({type:DELETE_TODO,payload:id})ReducersAreduceris a function that takes two parameters:stateandaction. A reducer is immutable and always returns a copy of the entire state. A reducer typically consists of aswitchstatement that goes through all the possible action types.ReducerconstinitialState={todos:[{id:1,text:'Eat'},{id:2,text:'Sleep'},],loading:false,hasErrors:false,} unctiontodoReducer(state=initialState,action){switch(action.type){caseDELETE_TODO:return{...state,todos:state.todos.filter((todo)=>todo.id!==action.payload),} efault:returnstate}} toreThe Redux application state lives in thestore, which is initialized with a reducer. When used with React, a<Provider>exists to wrap the application, and anything within the Provider can have access to Redux.Storeimport{createStore} rom'redux'import{Provider} rom'react-redux'importreducerfrom'./reducers'conststore=createStore(reducer)render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Dispatchdispatchis a method available on the store object that accepts an object which is used to update the Redux state. Usually, this object is the result of invoking an action creator.constComponent=({dispatch})=>{useEffect(()=>{dispatch(deleteTodo())},[dispatch])} onnectTheconnect()function is one typical way to connect React to Redux. A connected component is sometimes referred to as acontainer.Okay, that about covers it for the major terms of Redux. It can be overwhelming to read the terminology without any context, so let's begin.Getting StartedFor ease of getting started quickly, my example usesCreate React Appto set up the environment.npx create-react-app redux-tutorialcdredux-tutorialRedux requires a few dependencies.Redux- Core libraryReact Redux- React bindings for ReduxRedux Thunk- Async middleware for ReduxRedux DevTools Extension- Connects Redux app to Redux DevToolsYou canyarn addornpm ithem, and I'll be usingreact-router-domas well, but that's it for extra dependencies.npmi\\redux\\react-redux\\redux-thunk\\redux-devtools-extension\\react-router-domAnd delete all the boilerplate. We'll add everything we need from scratch instead.cdsrc&&rm*# move to src and delete all files withinWe'll make directories for Reduxreducersand Reduxactions, as well aspagesandcomponentswhich you should already be familiar with from React.mkdiractions components pages reducersAnd we'll bring backindex.js,App.js, andindex.css.touchindex.js index.css App.jsSo at this point your project directory tree looks like this.└── src/\n    ├── actions/\n    ├── components/\n    ├── pages/\n    ├── reducers/\n    ├── App.js\n    ├── index.css\n    └── index.jsFor theindex.cssfile, just take the contents ofthis gistand paste it. I intend only to go over functionality and not anything about style, so I just wrote some very basic styles to ensure the site looks decent enough.Now we have enough boilerplate to get started, so we'll begin working on the entrypoint.Setting up the Redux StoreWhen I first started learning Redux, it seemed so overwhelming because every app I looked at hadindex.jsset up a bit differently.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 933,
        "chunk_id": "657514346dca44a325e6412500ee416d",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "development",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "After looking at a lot of the more up-to-date apps and taking the aspects that were common across all of them, I got a good feel for what should really be in a Redux app, and what is just people moving things around to be unique.There are plenty of tutorials out there that show you how to get a very basic Redux store with todos set up, but I don't find that very useful for knowing how to make a production level setup, so I'm going to set it up with everything you need from the get-go. Even so, there will be some opinionated aspects because Redux is very flexible.Inindex.js, we'll be bringing in a few things.createStore, to create the store that will maintain the Redux stateapplyMiddleware, to be able to use middleware, in this casethunkProvider, to wrap the entire application in Reduxthunk, a middleware that allows us to make asynchronous actions in ReduxcomposeWithDevTools, code that connects your app to Redux DevToolsindex.js// External importsimportReactfrom'react'import{render} rom'react-dom'import{createStore,applyMiddleware} rom'redux'import{Provider} rom'react-redux'importthunkfrom'redux-thunk'import{composeWithDevTools} rom'redux-devtools-extension'// Local importsimportAppfrom'./App'importrootReducerfrom'./reducers'// Assetsimport'./index.css'conststore=createStore(rootReducer,composeWithDevTools(applyMiddleware(thunk)))render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Put a component inApp.js. We'll modify this later, but we just want to get the app up and running for now.App.jsimportReactfrom'react'constApp=()=>{return<div>Hello, Redux</div>} xportdefaultAppBringing in reducersThe last thing to do is bring in the reducer. Areduceris a function that determines changes to Redux state. It is a pure function that returns a copy of the state with the new change.A neat feature of Redux is that we can have many reducers, and combine them all into one root reducer that the store uses, usingcombineReducers. This leads to us being able to easily organize our code while still having everything in one root state tree.Since this app will be like a blog, it will have a list of posts, and we'll put that in thepostsReducerin a moment. Having thiscombineReducersmethod allows us to bring whatever we want in - acommentsReducer, anauthReducer, and so on.Inreducers/index.js, create the file that will combine all reducers.reducers/index.jsimport{combineReducers} rom'redux'importpostsReducerfrom'./postsReducer'constrootReducer=combineReducers({posts:postsReducer,})exportdefaultrootReducerFinally, we'll make thepostsReducer. We can set it up with an initial state. Just like you might expect from a regular React component, we'll have aloadingandhasErrorsstate, as well as apostsarray, where all the posts will live. First we'll set it up with no actions in the switch, just a default case that returns the entire state.reducers/postsReducer.jsexportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow we at least have enough setup that the application will load without crashing.Redux DevToolsWith the application loading and the Redux<Provider>set up, we can take a look at Redux DevTools. After downloading it, it'll be a tab in your Developer Tools. If you click onState, you'll see the entire state of the application so far.There's not much in here yet, but Redux DevTools is amazing once you get to having a lot of reducers and actions. It keeps track of all changes to your app and makes debugging a breeze compared to plain React.Setting up Redux ActionsSo now we have a reducer for posts, but we don't have any actions, meaning the reducer will only return the state without modifying it in any way.Actionsare how we communicate with the Redux store. For this blog app, we're going to want to fetch posts from an API and put them in our Redux state.Since fetching posts is an asynchronous action, it will require the use of Redux thunk. Fortunately, we don't have to do anything special to use thunk beyond setting it up in the store, which we already did.Create aactions/postsActions.js. First, we'll define theaction typesas constants. This is not necessary, but is a common convention, and makes it easy to export the actions around and prevent typos. We want to do three things:getPosts- begin telling Redux we're going to fetch posts from an APIgetPostsSuccess- pass the posts to Redux on successful API callgetPostsFailure- inform Redux that an error was encountered during Redux on failed API callactions/postsActions.js// Create Redux action typesexportconstGET_POSTS='GET_POSTS'exportconstGET_POSTS_SUCCESS='GET_POSTS_SUCCESS'exportconstGET_POSTS_FAILURE='GET_POSTS_FAILURE'Then createaction creators, functions that return anaction, which consists of the type and an optional payload containing data.actions/postsActions.js// Create Redux action creators that return an actionexportconstgetPosts=()=>({type:GET_POSTS,})exportconstgetPostsSuccess=(posts)=>({type:GET_POSTS_SUCCESS,payload:posts,})exportconstgetPostsFailure=()=>({type:GET_POSTS_FAILURE,})Finally, make the asynchronous thunk action that combines all three of the above actions. When called, it will dispatch the initialgetPosts()action to inform Redux to prepare for an API call, then in atry/catch, do everything necessary to get the data, and dispatch a success or failure action as necessary.actions/postsActions.js// Combine them all in an asynchronous thunkexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} reat, we're all done with creating actions now! All that's left to do is tell the reducer what to do with the state on each action.Responding to actionsBack at our post reducer, we have a switch that isn't doing anything yet.reducers/postsReducer.jsexportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow that we have actions, we can bring them in from thepostsActionspage.// Import all actionsimport*asactionsfrom'../actions/postsActions'For each action, we'll make acase, that returns the entire state plus whatever change we're making to it. ForGET_POSTS, for example, all we want to do is tell the app to setloadingtotruesince we'll be making an API call.caseactions.GET_POSTS:return{...state,loading:true} ET_POSTS- begin loadingGET_POSTS_SUCCESS- the app has posts, no errors, and should stop loadingGET_POSTS_FAILURE- the app has errors and should stop loadingHere's the whole reducer.reducers/postsReducer.jsimport*asactionsfrom'../actions/postsActions'exportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){caseactions.GET_POSTS:return{...state,loading:true} aseactions.GET_POSTS_SUCCESS:return{posts:action.payload,loading:false,hasErrors:false} aseactions.GET_POSTS_FAILURE:return{...state,loading:false,hasErrors:true} efault:returnstate}} ow our actions and reducers are ready, so all that's left to do is connect everything to the React app.Connecting Redux to React ComponentsSince the demo app I've created uses React Router to have a few routes - a dashboard, a listing of all posts, and an individual posts page, I'll bring React Router in now. I'll just bring in the dashboard and all posts listing for this demo.App.jsimportReactfrom'react'import{BrowserRouterasRouter,Switch,Route,Redirect} rom'react-router-dom'importDashboardPagefrom'./pages/DashboardPage'importPostsPagefrom'./pages/PostsPage'constApp=()=>{return(<Router><Switch><Routeexactpath=\"/\"component={DashboardPage}/><Routeexactpath=\"/posts\"component={PostsPage}/><Redirectto=\"/\"/></Switch></Router>)} xportdefaultAppWe can create the dashboard page, which is just a regular React component.pages/DashboardPage.jsimportReactfrom'react'import{Link} rom'react-router-dom'constDashboardPage=()=>(<section><h1>Dashboard</h1><p>This is the dashboard.</p><Linkto=\"/posts\"className=\"button\">View Posts</Link></section>)exportdefaultDashboardPageFor each post, let's make aPostcomponent that will display the title and an excerpt of the text of the article. Make aPost.jsin thecomponentssubdirectory.components/Post.jsimportReactfrom'react'exportconstPost=({post})=>(<articleclassName=\"post-excerpt\"><h2>{post.title}</h2><p>{post.body.substring(0,100)}</p></article>)Components that do not connect to Redux are still important and useful for smaller, reusable areas, such as this Post component.Now the interesting part comes in for the posts page - bringing Redux into React. To do this we'll useconnectfromreact-redux. First, we'll just make a regular component for the page.pages/PostsPage.jsimportReactfrom'react'constPostsPage=()=>{return(<section><h1>Posts</h1></section>)} xportdefaultPostsPageThen we'll bring inconnect.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 1000,
        "chunk_id": "ce44a83cb22103e6a639d48b1d686d36",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Theconnect functionis a higher-order function that connects the Redux store to a React component. We'll pass a parameter calledmapStateToPropstoconnect. This aptly named function will take any state from the Redux store and pass it to the props of the React component. We'll bring inloading,posts, andhasErrorsfrom the ReduxpostsReducer.pages/PostsPage.jsimportReactfrom'react'import{connect} rom'react-redux'// Redux state is now in the props of the componentconstPostsPage=({loading,posts,hasErrors})=>{return(<section><h1>Posts</h1></section>)}// Map Redux state to React component propsconstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})// Connect Redux to Reactexportdefaultconnect(mapStateToProps)(PostsPage)Since this component uses state from the same reducer, we could also writestate => state.posts. However, learning how to write it the long way is useful to know in case you need to bring multiple reducers into the same component.Finally, we'll bring in the asynchronousfetchPostsfrom the actions, which is the action that combines the whole lifecycle of fetching all posts into one. UsinguseEffectfrom React, we'lldispatchfetchPostswhen the component mounts.dispatchwill automatically be available on a connected component.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'// Bring in the asynchronous fetchPosts actionimport{fetchPosts} rom'../actions/postsActions'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])return(<section><h1>Posts</h1></section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)All that's left to do at this point is display all three possible states of the page - whether it's loading, has an error, or successfully retrieved the posts from the API.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'import{fetchPosts} rom'../actions/postsActions'import{Post} rom'../components/Post'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])// Show loading, error, or success stateconstrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post}/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)And that's all - we now have a connected component, and are bringing in data from an API to our Redux store. Using Redux DevTools, we can see each action as it happens, and the changes (diff) after each state change.The EndThis is where the tutorial for creating an application with plain Redux ends. If you look at thesource code of the demo application, you'll see a lot has been added - a reducer and actions for a single post, and for comments.I would recommend completing your project so that it matches the demo app. There are no new concepts to be learned, but you will create two more reducers and actions, and see how to bring two states into one component for the single post page, which brings in one post as well as comments for that post.Redux ToolkitThere is one more thing I want to cover -Redux Toolkit. Redux Toolkit, or RTK, is a newer and easier official way to use Redux. You may notice that Redux has alotof boilerplate for setup and requires many more folders and files than plain React would. Some patterns have emerged to attempt to mitigate all that, such asRedux ducks pattern, but we can simplify it even more.View thesource of the demo Redux Toolkit application, which is the same application we just created with Redux, but using RTK. It is much simpler, with a drastic reduction in lines of code for all the same functionality.Using RTK just requires one dependency,@reduxjs/toolkit.npmi @reduxjs/toolkitAnd no longer requires you to install theredux-thunkorredux-devtools-extensiondependencies.Advantages to Redux ToolkitThe main advantages to using RTK are:Easier to set up (less dependencies)Reduction of boilerplate code (one slice vs. many files for actions and reducers)Sensible defaults (Redux Thunk, Redux DevTools built-in)The ability to usedirect state mutation, since RTK usesimmerunder the hood. This means you no longer need to return{ ...state } ith every reducer.StoreSince Redux Toolkit comes with a lot built-in already, like Redux DevTools and Redux Thunk, we no longer have to bring them into theindex.jsfile. Now we only needconfigureStore, instead ofcreateStore.index.jsimportReactfrom'react'import{render} rom'react-dom'import{configureStore} rom'@reduxjs/toolkit'import{Provider} rom'react-redux'importAppfrom'./App'importrootReducerfrom'./slices'import'./index.css'conststore=configureStore({reducer:rootReducer})render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))SlicesInstead of dealing with reducers, actions, and all as separate files and individually creating all those action types, RTK gives us the concept ofslices. Asliceautomatically generates reducers, action types, and action creators. As such, you'll only have to create one folder -slices.initialStatewill look the same.slices/posts.jsimport{createSlice} rom'@reduxjs/toolkit'exportconstinitialState={loading:false,hasErrors:false,posts:[],} he names of the reducers in the slice will also be the same -getPosts,getPostsSuccess, andgetPostsFailure. We'll make all the same changes, but note that we're no longer returning the entire state - we're just mutating state. It's still immutable under the hood, but this approach may be easier and faster for some. If preferred, you can still return the whole state as an object.slices/posts.js// A slice for posts with our three reducersconstpostsSlice=createSlice({name:'posts',initialState,reducers:{getPosts:(state)=>{state.loading=true},getPostsSuccess:(state,{payload})=>{state.posts=payload\n      state.loading=falsestate.hasErrors=false},getPostsFailure:(state)=>{state.loading=falsestate.hasErrors=true},},})The actions that get generated are the same, we just don't have to write them out individually anymore. From the same file, we can export all the actions, the reducer, the asynchronous thunk, and one new thing - aselector, which we'll use to access any of the state from a React component instead of usingconnect.slices/posts.js// Three actions generated from the sliceexportconst{getPosts,getPostsSuccess,getPostsFailure}=postsSlice.actions// A selectorexportconstpostsSelector=(state)=>state.posts// The reducerexportdefaultpostsSlice.reducer// Asynchronous thunk actionexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} electing Redux state in a React componentThe traditional approach, as we just learned, is to usemapStateToPropswith theconnect()function. This is still common in codebases and therefore worth learning. You can still use this approach with RTK, but the newer, React Hooks way of going about it is to useuseDispatchanduseSelectorfromreact-redux. This approach requires less code overall as well.As you can see in the updatedPostsPage.jsfile below, the Redux state is no longer available as props on the connected component, but from the selector we exported in the slice.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{useDispatch,useSelector} rom'react-redux'import{fetchPosts,postsSelector} rom'../slices/posts'import{Post} rom'../components/Post'constPostsPage=()=>{constdispatch=useDispatch()const{posts,loading,hasErrors}=useSelector(postsSelector)useEffect(()=>{dispatch(fetchPosts())},[dispatch])constrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post} xcerpt/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} xportdefaultPostsPageNow we have the same app as before with a few updates from Redux Toolkit, and a lot less code to maintain.ConclusionWe did it! If you followed along with me through this whole tutorial, you should have a really good feel for Redux now, both the old-fashioned way and using Redux Toolkit to simplify things. To summarize, Redux allows us to easily manage global state in a React application. We can access and update the state from anywhere, and easily debug the entire state of an application with Redux Devtools.You can place most of the state of your application in Redux, but certain areas of an app, such as forms as they are being updated, still make sense to keep in the React component state itself until the form is officially submitted.I hope you enjoyed this article!",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 962,
        "chunk_id": "33861c3fc43be5f54517d6f1ff94d72e",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "It was a lot of work to put together two complete demo applications and run through the whole thing here, and the article ran pretty long, but hopefully this is your one-stop shop for learning all beginner and intermediate Redux concepts. Please let me know what you think and share the article if it helped you out, and donations are always welcome!About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:March 09, 2020Category:TechnicalTagsreduxreacttutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "example",
        "tag": "div",
        "score": 1.1219999999999999,
        "word_count": 115,
        "chunk_id": "96791525f7e53af6b5369b2eec9f621c",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "javascript"
          ]
        }
      },
      {
        "content": "Do you have experience usingReact? Have you heard ofRedux, but you've put off learning it because it looks very complicated and all the guides seem overwhelming? If that's the case, this is the article for you! Contain your fear of containing state and come along with me on this relatively painless journey.PrerequisitesYou must already know how to use React for this tutorial, as I will not be explaining any aspects of React itself.Familiarity withHTML & CSS.Familiarity withES6 syntax and features.Knowledge of React terminology:JSX, State, Components, Props, LifecycleandHooksKnowledge ofReact RouterKnowledge of asynchronous JavaScript andmaking API callsAlso, download Redux DevToolsfor Chromeorfor FireFox.GoalsIn this tutorial, we will build a small blog app. It will fetch posts and comments from an API. I've created the same app with both plain Redux, andRedux Toolkit(RTK), the officially sanctioned toolset for Redux. Here are the links to the source and demos of both the plain and RTK versions.React + Redux Application (Plain Redux)SourceDemo ApplicationReact + Redux Toolkit ApplicationSourceDemo ApplicationNote: The applications are pulling from a real API viaJSON Placeholder API. Due to rate limiting on CodeSandbox, the API may appear slow, but it has nothing to do with the Redux application itself. You can also clone the repository locally.We will learn:Whatis Redux andwhyyou might want to use itTheterminologyof Redux: actions, reducers, store, dispatch, connect, and containerMaking asynchronous API calls withRedux ThunkHow to make a small, real-world application with React and ReduxHow to use Redux Toolkit to simplify Redux app developmentWhat is Redux?Redux is a state container for JavaScript applications. Normally with React, you manage state at a component level, and pass state around via props. With Redux, the entire state of your application is managed in one immutable object. Every update to the Redux state results in a copy of sections of the state, plus the new change.Redux was originally created byDan AbramovandAndrew Clark.Why should I use Redux?Easily manage global state- access or update any part of the state from any Redux-connected componentEasily keep track of changes with Redux DevTools- any action or state change is tracked and easy to follow with Redux. The fact that the entire state of the application is tracked with each change means you can easily do time-travel debugging to move back and forth between changes.The downside to Redux is that there's a lot of initial boilerplate to set up and maintain (especially if you use plain Redux without Redux Toolkit). A smaller applicationmay not need Reduxand may instead benefit from simply usingthe Context APIfor global state needs.In my personal experience, I set up an application with Context alone, and later needed to convert everything over to Redux to make it more maintainable and organized.TerminologyUsually I don't like to just make a list of terms and definitions, but Redux has a few that are likely unfamiliar, so I'm just going to define them all up front to make it easy to refer back to them. Although you canskip to the beginning of the tutorial section, I think it would be good to read through all the definitions just to get exposure and an idea of them in your head first.ActionsReducersStoreDispatchConnectI'll just use the typical todo application, and the action of deleting a todo, for the examples.ActionsAnactionsends data from your application to the Redux store. An action is conventionally an object with two properties:typeand (optional)payload. The type is generally an uppercase string (assigned to a constant) that describes the action. The payload is additional data that may be passed.Action TypeconstDELETE_TODO='posts/deleteTodo'Action{type:DELETE_TODO,payload:id,} ction creatorsAnaction creatoris a function that returns an action.Action CreatorconstdeleteTodo=(id)=>({type:DELETE_TODO,payload:id})ReducersAreduceris a function that takes two parameters:stateandaction. A reducer is immutable and always returns a copy of the entire state. A reducer typically consists of aswitchstatement that goes through all the possible action types.ReducerconstinitialState={todos:[{id:1,text:'Eat'},{id:2,text:'Sleep'},],loading:false,hasErrors:false,} unctiontodoReducer(state=initialState,action){switch(action.type){caseDELETE_TODO:return{...state,todos:state.todos.filter((todo)=>todo.id!==action.payload),} efault:returnstate}} toreThe Redux application state lives in thestore, which is initialized with a reducer. When used with React, a<Provider>exists to wrap the application, and anything within the Provider can have access to Redux.Storeimport{createStore} rom'redux'import{Provider} rom'react-redux'importreducerfrom'./reducers'conststore=createStore(reducer)render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Dispatchdispatchis a method available on the store object that accepts an object which is used to update the Redux state. Usually, this object is the result of invoking an action creator.constComponent=({dispatch})=>{useEffect(()=>{dispatch(deleteTodo())},[dispatch])} onnectTheconnect()function is one typical way to connect React to Redux. A connected component is sometimes referred to as acontainer.Okay, that about covers it for the major terms of Redux. It can be overwhelming to read the terminology without any context, so let's begin.Getting StartedFor ease of getting started quickly, my example usesCreate React Appto set up the environment.npx create-react-app redux-tutorialcdredux-tutorialRedux requires a few dependencies.Redux- Core libraryReact Redux- React bindings for ReduxRedux Thunk- Async middleware for ReduxRedux DevTools Extension- Connects Redux app to Redux DevToolsYou canyarn addornpm ithem, and I'll be usingreact-router-domas well, but that's it for extra dependencies.npmi\\redux\\react-redux\\redux-thunk\\redux-devtools-extension\\react-router-domAnd delete all the boilerplate. We'll add everything we need from scratch instead.cdsrc&&rm*# move to src and delete all files withinWe'll make directories for Reduxreducersand Reduxactions, as well aspagesandcomponentswhich you should already be familiar with from React.mkdiractions components pages reducersAnd we'll bring backindex.js,App.js, andindex.css.touchindex.js index.css App.jsSo at this point your project directory tree looks like this.└── src/\n    ├── actions/\n    ├── components/\n    ├── pages/\n    ├── reducers/\n    ├── App.js\n    ├── index.css\n    └── index.jsFor theindex.cssfile, just take the contents ofthis gistand paste it. I intend only to go over functionality and not anything about style, so I just wrote some very basic styles to ensure the site looks decent enough.Now we have enough boilerplate to get started, so we'll begin working on the entrypoint.Setting up the Redux StoreWhen I first started learning Redux, it seemed so overwhelming because every app I looked at hadindex.jsset up a bit differently.",
        "chunk_type": "code_markup",
        "tag": "section",
        "score": 0.9950000000000001,
        "word_count": 928,
        "chunk_id": "6f17d1ad6b267106210d686119946326",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "article",
            "development",
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "After looking at a lot of the more up-to-date apps and taking the aspects that were common across all of them, I got a good feel for what should really be in a Redux app, and what is just people moving things around to be unique.There are plenty of tutorials out there that show you how to get a very basic Redux store with todos set up, but I don't find that very useful for knowing how to make a production level setup, so I'm going to set it up with everything you need from the get-go. Even so, there will be some opinionated aspects because Redux is very flexible.Inindex.js, we'll be bringing in a few things.createStore, to create the store that will maintain the Redux stateapplyMiddleware, to be able to use middleware, in this casethunkProvider, to wrap the entire application in Reduxthunk, a middleware that allows us to make asynchronous actions in ReduxcomposeWithDevTools, code that connects your app to Redux DevToolsindex.js// External importsimportReactfrom'react'import{render} rom'react-dom'import{createStore,applyMiddleware} rom'redux'import{Provider} rom'react-redux'importthunkfrom'redux-thunk'import{composeWithDevTools} rom'redux-devtools-extension'// Local importsimportAppfrom'./App'importrootReducerfrom'./reducers'// Assetsimport'./index.css'conststore=createStore(rootReducer,composeWithDevTools(applyMiddleware(thunk)))render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Put a component inApp.js. We'll modify this later, but we just want to get the app up and running for now.App.jsimportReactfrom'react'constApp=()=>{return<div>Hello, Redux</div>} xportdefaultAppBringing in reducersThe last thing to do is bring in the reducer. Areduceris a function that determines changes to Redux state. It is a pure function that returns a copy of the state with the new change.A neat feature of Redux is that we can have many reducers, and combine them all into one root reducer that the store uses, usingcombineReducers. This leads to us being able to easily organize our code while still having everything in one root state tree.Since this app will be like a blog, it will have a list of posts, and we'll put that in thepostsReducerin a moment. Having thiscombineReducersmethod allows us to bring whatever we want in - acommentsReducer, anauthReducer, and so on.Inreducers/index.js, create the file that will combine all reducers.reducers/index.jsimport{combineReducers} rom'redux'importpostsReducerfrom'./postsReducer'constrootReducer=combineReducers({posts:postsReducer,})exportdefaultrootReducerFinally, we'll make thepostsReducer. We can set it up with an initial state. Just like you might expect from a regular React component, we'll have aloadingandhasErrorsstate, as well as apostsarray, where all the posts will live. First we'll set it up with no actions in the switch, just a default case that returns the entire state.reducers/postsReducer.jsexportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow we at least have enough setup that the application will load without crashing.Redux DevToolsWith the application loading and the Redux<Provider>set up, we can take a look at Redux DevTools. After downloading it, it'll be a tab in your Developer Tools. If you click onState, you'll see the entire state of the application so far.There's not much in here yet, but Redux DevTools is amazing once you get to having a lot of reducers and actions. It keeps track of all changes to your app and makes debugging a breeze compared to plain React.Setting up Redux ActionsSo now we have a reducer for posts, but we don't have any actions, meaning the reducer will only return the state without modifying it in any way.Actionsare how we communicate with the Redux store. For this blog app, we're going to want to fetch posts from an API and put them in our Redux state.Since fetching posts is an asynchronous action, it will require the use of Redux thunk. Fortunately, we don't have to do anything special to use thunk beyond setting it up in the store, which we already did.Create aactions/postsActions.js. First, we'll define theaction typesas constants. This is not necessary, but is a common convention, and makes it easy to export the actions around and prevent typos. We want to do three things:getPosts- begin telling Redux we're going to fetch posts from an APIgetPostsSuccess- pass the posts to Redux on successful API callgetPostsFailure- inform Redux that an error was encountered during Redux on failed API callactions/postsActions.js// Create Redux action typesexportconstGET_POSTS='GET_POSTS'exportconstGET_POSTS_SUCCESS='GET_POSTS_SUCCESS'exportconstGET_POSTS_FAILURE='GET_POSTS_FAILURE'Then createaction creators, functions that return anaction, which consists of the type and an optional payload containing data.actions/postsActions.js// Create Redux action creators that return an actionexportconstgetPosts=()=>({type:GET_POSTS,})exportconstgetPostsSuccess=(posts)=>({type:GET_POSTS_SUCCESS,payload:posts,})exportconstgetPostsFailure=()=>({type:GET_POSTS_FAILURE,})Finally, make the asynchronous thunk action that combines all three of the above actions. When called, it will dispatch the initialgetPosts()action to inform Redux to prepare for an API call, then in atry/catch, do everything necessary to get the data, and dispatch a success or failure action as necessary.actions/postsActions.js// Combine them all in an asynchronous thunkexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} reat, we're all done with creating actions now! All that's left to do is tell the reducer what to do with the state on each action.Responding to actionsBack at our post reducer, we have a switch that isn't doing anything yet.reducers/postsReducer.jsexportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow that we have actions, we can bring them in from thepostsActionspage.// Import all actionsimport*asactionsfrom'../actions/postsActions'For each action, we'll make acase, that returns the entire state plus whatever change we're making to it. ForGET_POSTS, for example, all we want to do is tell the app to setloadingtotruesince we'll be making an API call.caseactions.GET_POSTS:return{...state,loading:true} ET_POSTS- begin loadingGET_POSTS_SUCCESS- the app has posts, no errors, and should stop loadingGET_POSTS_FAILURE- the app has errors and should stop loadingHere's the whole reducer.reducers/postsReducer.jsimport*asactionsfrom'../actions/postsActions'exportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){caseactions.GET_POSTS:return{...state,loading:true} aseactions.GET_POSTS_SUCCESS:return{posts:action.payload,loading:false,hasErrors:false} aseactions.GET_POSTS_FAILURE:return{...state,loading:false,hasErrors:true} efault:returnstate}} ow our actions and reducers are ready, so all that's left to do is connect everything to the React app.Connecting Redux to React ComponentsSince the demo app I've created uses React Router to have a few routes - a dashboard, a listing of all posts, and an individual posts page, I'll bring React Router in now. I'll just bring in the dashboard and all posts listing for this demo.App.jsimportReactfrom'react'import{BrowserRouterasRouter,Switch,Route,Redirect} rom'react-router-dom'importDashboardPagefrom'./pages/DashboardPage'importPostsPagefrom'./pages/PostsPage'constApp=()=>{return(<Router><Switch><Routeexactpath=\"/\"component={DashboardPage}/><Routeexactpath=\"/posts\"component={PostsPage}/><Redirectto=\"/\"/></Switch></Router>)} xportdefaultAppWe can create the dashboard page, which is just a regular React component.pages/DashboardPage.jsimportReactfrom'react'import{Link} rom'react-router-dom'constDashboardPage=()=>(<section><h1>Dashboard</h1><p>This is the dashboard.</p><Linkto=\"/posts\"className=\"button\">View Posts</Link></section>)exportdefaultDashboardPageFor each post, let's make aPostcomponent that will display the title and an excerpt of the text of the article. Make aPost.jsin thecomponentssubdirectory.components/Post.jsimportReactfrom'react'exportconstPost=({post})=>(<articleclassName=\"post-excerpt\"><h2>{post.title}</h2><p>{post.body.substring(0,100)}</p></article>)Components that do not connect to Redux are still important and useful for smaller, reusable areas, such as this Post component.Now the interesting part comes in for the posts page - bringing Redux into React. To do this we'll useconnectfromreact-redux. First, we'll just make a regular component for the page.pages/PostsPage.jsimportReactfrom'react'constPostsPage=()=>{return(<section><h1>Posts</h1></section>)} xportdefaultPostsPageThen we'll bring inconnect.",
        "chunk_type": "code_markup",
        "tag": "section",
        "score": 0.9950000000000001,
        "word_count": 1000,
        "chunk_id": "ce44a83cb22103e6a639d48b1d686d36",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Theconnect functionis a higher-order function that connects the Redux store to a React component. We'll pass a parameter calledmapStateToPropstoconnect. This aptly named function will take any state from the Redux store and pass it to the props of the React component. We'll bring inloading,posts, andhasErrorsfrom the ReduxpostsReducer.pages/PostsPage.jsimportReactfrom'react'import{connect} rom'react-redux'// Redux state is now in the props of the componentconstPostsPage=({loading,posts,hasErrors})=>{return(<section><h1>Posts</h1></section>)}// Map Redux state to React component propsconstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})// Connect Redux to Reactexportdefaultconnect(mapStateToProps)(PostsPage)Since this component uses state from the same reducer, we could also writestate => state.posts. However, learning how to write it the long way is useful to know in case you need to bring multiple reducers into the same component.Finally, we'll bring in the asynchronousfetchPostsfrom the actions, which is the action that combines the whole lifecycle of fetching all posts into one. UsinguseEffectfrom React, we'lldispatchfetchPostswhen the component mounts.dispatchwill automatically be available on a connected component.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'// Bring in the asynchronous fetchPosts actionimport{fetchPosts} rom'../actions/postsActions'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])return(<section><h1>Posts</h1></section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)All that's left to do at this point is display all three possible states of the page - whether it's loading, has an error, or successfully retrieved the posts from the API.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'import{fetchPosts} rom'../actions/postsActions'import{Post} rom'../components/Post'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])// Show loading, error, or success stateconstrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post}/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)And that's all - we now have a connected component, and are bringing in data from an API to our Redux store. Using Redux DevTools, we can see each action as it happens, and the changes (diff) after each state change.The EndThis is where the tutorial for creating an application with plain Redux ends. If you look at thesource code of the demo application, you'll see a lot has been added - a reducer and actions for a single post, and for comments.I would recommend completing your project so that it matches the demo app. There are no new concepts to be learned, but you will create two more reducers and actions, and see how to bring two states into one component for the single post page, which brings in one post as well as comments for that post.Redux ToolkitThere is one more thing I want to cover -Redux Toolkit. Redux Toolkit, or RTK, is a newer and easier official way to use Redux. You may notice that Redux has alotof boilerplate for setup and requires many more folders and files than plain React would. Some patterns have emerged to attempt to mitigate all that, such asRedux ducks pattern, but we can simplify it even more.View thesource of the demo Redux Toolkit application, which is the same application we just created with Redux, but using RTK. It is much simpler, with a drastic reduction in lines of code for all the same functionality.Using RTK just requires one dependency,@reduxjs/toolkit.npmi @reduxjs/toolkitAnd no longer requires you to install theredux-thunkorredux-devtools-extensiondependencies.Advantages to Redux ToolkitThe main advantages to using RTK are:Easier to set up (less dependencies)Reduction of boilerplate code (one slice vs. many files for actions and reducers)Sensible defaults (Redux Thunk, Redux DevTools built-in)The ability to usedirect state mutation, since RTK usesimmerunder the hood. This means you no longer need to return{ ...state } ith every reducer.StoreSince Redux Toolkit comes with a lot built-in already, like Redux DevTools and Redux Thunk, we no longer have to bring them into theindex.jsfile. Now we only needconfigureStore, instead ofcreateStore.index.jsimportReactfrom'react'import{render} rom'react-dom'import{configureStore} rom'@reduxjs/toolkit'import{Provider} rom'react-redux'importAppfrom'./App'importrootReducerfrom'./slices'import'./index.css'conststore=configureStore({reducer:rootReducer})render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))SlicesInstead of dealing with reducers, actions, and all as separate files and individually creating all those action types, RTK gives us the concept ofslices. Asliceautomatically generates reducers, action types, and action creators. As such, you'll only have to create one folder -slices.initialStatewill look the same.slices/posts.jsimport{createSlice} rom'@reduxjs/toolkit'exportconstinitialState={loading:false,hasErrors:false,posts:[],} he names of the reducers in the slice will also be the same -getPosts,getPostsSuccess, andgetPostsFailure. We'll make all the same changes, but note that we're no longer returning the entire state - we're just mutating state. It's still immutable under the hood, but this approach may be easier and faster for some. If preferred, you can still return the whole state as an object.slices/posts.js// A slice for posts with our three reducersconstpostsSlice=createSlice({name:'posts',initialState,reducers:{getPosts:(state)=>{state.loading=true},getPostsSuccess:(state,{payload})=>{state.posts=payload\n      state.loading=falsestate.hasErrors=false},getPostsFailure:(state)=>{state.loading=falsestate.hasErrors=true},},})The actions that get generated are the same, we just don't have to write them out individually anymore. From the same file, we can export all the actions, the reducer, the asynchronous thunk, and one new thing - aselector, which we'll use to access any of the state from a React component instead of usingconnect.slices/posts.js// Three actions generated from the sliceexportconst{getPosts,getPostsSuccess,getPostsFailure}=postsSlice.actions// A selectorexportconstpostsSelector=(state)=>state.posts// The reducerexportdefaultpostsSlice.reducer// Asynchronous thunk actionexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} electing Redux state in a React componentThe traditional approach, as we just learned, is to usemapStateToPropswith theconnect()function. This is still common in codebases and therefore worth learning. You can still use this approach with RTK, but the newer, React Hooks way of going about it is to useuseDispatchanduseSelectorfromreact-redux. This approach requires less code overall as well.As you can see in the updatedPostsPage.jsfile below, the Redux state is no longer available as props on the connected component, but from the selector we exported in the slice.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{useDispatch,useSelector} rom'react-redux'import{fetchPosts,postsSelector} rom'../slices/posts'import{Post} rom'../components/Post'constPostsPage=()=>{constdispatch=useDispatch()const{posts,loading,hasErrors}=useSelector(postsSelector)useEffect(()=>{dispatch(fetchPosts())},[dispatch])constrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post} xcerpt/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} xportdefaultPostsPageNow we have the same app as before with a few updates from Redux Toolkit, and a lot less code to maintain.ConclusionWe did it! If you followed along with me through this whole tutorial, you should have a really good feel for Redux now, both the old-fashioned way and using Redux Toolkit to simplify things. To summarize, Redux allows us to easily manage global state in a React application. We can access and update the state from anywhere, and easily debug the entire state of an application with Redux Devtools.You can place most of the state of your application in Redux, but certain areas of an app, such as forms as they are being updated, still make sense to keep in the React component state itself until the form is officially submitted.I hope you enjoyed this article!",
        "chunk_type": "code_markup",
        "tag": "section",
        "score": 0.9950000000000001,
        "word_count": 962,
        "chunk_id": "33861c3fc43be5f54517d6f1ff94d72e",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "It was a lot of work to put together two complete demo applications and run through the whole thing here, and the article ran pretty long, but hopefully this is your one-stop shop for learning all beginner and intermediate Redux concepts. Please let me know what you think and share the article if it helped you out, and donations are always welcome!",
        "chunk_type": "text",
        "tag": "section",
        "score": 0.9950000000000001,
        "word_count": 62,
        "chunk_id": "3844023a704de7c7fddf3e35d714cd7b",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "article"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "javascript"
          ]
        }
      },
      {
        "content": "Do you have experience usingReact? Have you heard ofRedux, but you've put off learning it because it looks very complicated and all the guides seem overwhelming? If that's the case, this is the article for you! Contain your fear of containing state and come along with me on this relatively painless journey.PrerequisitesYou must already know how to use React for this tutorial, as I will not be explaining any aspects of React itself.Familiarity withHTML & CSS.Familiarity withES6 syntax and features.Knowledge of React terminology:JSX, State, Components, Props, LifecycleandHooksKnowledge ofReact RouterKnowledge of asynchronous JavaScript andmaking API callsAlso, download Redux DevToolsfor Chromeorfor FireFox.GoalsIn this tutorial, we will build a small blog app. It will fetch posts and comments from an API. I've created the same app with both plain Redux, andRedux Toolkit(RTK), the officially sanctioned toolset for Redux. Here are the links to the source and demos of both the plain and RTK versions.React + Redux Application (Plain Redux)SourceDemo ApplicationReact + Redux Toolkit ApplicationSourceDemo ApplicationNote: The applications are pulling from a real API viaJSON Placeholder API. Due to rate limiting on CodeSandbox, the API may appear slow, but it has nothing to do with the Redux application itself. You can also clone the repository locally.We will learn:Whatis Redux andwhyyou might want to use itTheterminologyof Redux: actions, reducers, store, dispatch, connect, and containerMaking asynchronous API calls withRedux ThunkHow to make a small, real-world application with React and ReduxHow to use Redux Toolkit to simplify Redux app developmentWhat is Redux?Redux is a state container for JavaScript applications. Normally with React, you manage state at a component level, and pass state around via props. With Redux, the entire state of your application is managed in one immutable object. Every update to the Redux state results in a copy of sections of the state, plus the new change.Redux was originally created byDan AbramovandAndrew Clark.Why should I use Redux?Easily manage global state- access or update any part of the state from any Redux-connected componentEasily keep track of changes with Redux DevTools- any action or state change is tracked and easy to follow with Redux. The fact that the entire state of the application is tracked with each change means you can easily do time-travel debugging to move back and forth between changes.The downside to Redux is that there's a lot of initial boilerplate to set up and maintain (especially if you use plain Redux without Redux Toolkit). A smaller applicationmay not need Reduxand may instead benefit from simply usingthe Context APIfor global state needs.In my personal experience, I set up an application with Context alone, and later needed to convert everything over to Redux to make it more maintainable and organized.TerminologyUsually I don't like to just make a list of terms and definitions, but Redux has a few that are likely unfamiliar, so I'm just going to define them all up front to make it easy to refer back to them. Although you canskip to the beginning of the tutorial section, I think it would be good to read through all the definitions just to get exposure and an idea of them in your head first.ActionsReducersStoreDispatchConnectI'll just use the typical todo application, and the action of deleting a todo, for the examples.ActionsAnactionsends data from your application to the Redux store. An action is conventionally an object with two properties:typeand (optional)payload. The type is generally an uppercase string (assigned to a constant) that describes the action. The payload is additional data that may be passed.Action TypeconstDELETE_TODO='posts/deleteTodo'Action{type:DELETE_TODO,payload:id,} ction creatorsAnaction creatoris a function that returns an action.Action CreatorconstdeleteTodo=(id)=>({type:DELETE_TODO,payload:id})ReducersAreduceris a function that takes two parameters:stateandaction. A reducer is immutable and always returns a copy of the entire state. A reducer typically consists of aswitchstatement that goes through all the possible action types.ReducerconstinitialState={todos:[{id:1,text:'Eat'},{id:2,text:'Sleep'},],loading:false,hasErrors:false,} unctiontodoReducer(state=initialState,action){switch(action.type){caseDELETE_TODO:return{...state,todos:state.todos.filter((todo)=>todo.id!==action.payload),} efault:returnstate}} toreThe Redux application state lives in thestore, which is initialized with a reducer. When used with React, a<Provider>exists to wrap the application, and anything within the Provider can have access to Redux.Storeimport{createStore} rom'redux'import{Provider} rom'react-redux'importreducerfrom'./reducers'conststore=createStore(reducer)render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Dispatchdispatchis a method available on the store object that accepts an object which is used to update the Redux state. Usually, this object is the result of invoking an action creator.constComponent=({dispatch})=>{useEffect(()=>{dispatch(deleteTodo())},[dispatch])} onnectTheconnect()function is one typical way to connect React to Redux. A connected component is sometimes referred to as acontainer.Okay, that about covers it for the major terms of Redux. It can be overwhelming to read the terminology without any context, so let's begin.Getting StartedFor ease of getting started quickly, my example usesCreate React Appto set up the environment.npx create-react-app redux-tutorialcdredux-tutorialRedux requires a few dependencies.Redux- Core libraryReact Redux- React bindings for ReduxRedux Thunk- Async middleware for ReduxRedux DevTools Extension- Connects Redux app to Redux DevToolsYou canyarn addornpm ithem, and I'll be usingreact-router-domas well, but that's it for extra dependencies.npmi\\redux\\react-redux\\redux-thunk\\redux-devtools-extension\\react-router-domAnd delete all the boilerplate. We'll add everything we need from scratch instead.cdsrc&&rm*# move to src and delete all files withinWe'll make directories for Reduxreducersand Reduxactions, as well aspagesandcomponentswhich you should already be familiar with from React.mkdiractions components pages reducersAnd we'll bring backindex.js,App.js, andindex.css.touchindex.js index.css App.jsSo at this point your project directory tree looks like this.└── src/\n    ├── actions/\n    ├── components/\n    ├── pages/\n    ├── reducers/\n    ├── App.js\n    ├── index.css\n    └── index.jsFor theindex.cssfile, just take the contents ofthis gistand paste it. I intend only to go over functionality and not anything about style, so I just wrote some very basic styles to ensure the site looks decent enough.Now we have enough boilerplate to get started, so we'll begin working on the entrypoint.Setting up the Redux StoreWhen I first started learning Redux, it seemed so overwhelming because every app I looked at hadindex.jsset up a bit differently.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.9950000000000001,
        "word_count": 928,
        "chunk_id": "6f17d1ad6b267106210d686119946326",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "development",
            "react"
          ],
          "attributes": {
            "id": "/redux-react-guide/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "After looking at a lot of the more up-to-date apps and taking the aspects that were common across all of them, I got a good feel for what should really be in a Redux app, and what is just people moving things around to be unique.There are plenty of tutorials out there that show you how to get a very basic Redux store with todos set up, but I don't find that very useful for knowing how to make a production level setup, so I'm going to set it up with everything you need from the get-go. Even so, there will be some opinionated aspects because Redux is very flexible.Inindex.js, we'll be bringing in a few things.createStore, to create the store that will maintain the Redux stateapplyMiddleware, to be able to use middleware, in this casethunkProvider, to wrap the entire application in Reduxthunk, a middleware that allows us to make asynchronous actions in ReduxcomposeWithDevTools, code that connects your app to Redux DevToolsindex.js// External importsimportReactfrom'react'import{render} rom'react-dom'import{createStore,applyMiddleware} rom'redux'import{Provider} rom'react-redux'importthunkfrom'redux-thunk'import{composeWithDevTools} rom'redux-devtools-extension'// Local importsimportAppfrom'./App'importrootReducerfrom'./reducers'// Assetsimport'./index.css'conststore=createStore(rootReducer,composeWithDevTools(applyMiddleware(thunk)))render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))Put a component inApp.js. We'll modify this later, but we just want to get the app up and running for now.App.jsimportReactfrom'react'constApp=()=>{return<div>Hello, Redux</div>} xportdefaultAppBringing in reducersThe last thing to do is bring in the reducer. Areduceris a function that determines changes to Redux state. It is a pure function that returns a copy of the state with the new change.A neat feature of Redux is that we can have many reducers, and combine them all into one root reducer that the store uses, usingcombineReducers. This leads to us being able to easily organize our code while still having everything in one root state tree.Since this app will be like a blog, it will have a list of posts, and we'll put that in thepostsReducerin a moment. Having thiscombineReducersmethod allows us to bring whatever we want in - acommentsReducer, anauthReducer, and so on.Inreducers/index.js, create the file that will combine all reducers.reducers/index.jsimport{combineReducers} rom'redux'importpostsReducerfrom'./postsReducer'constrootReducer=combineReducers({posts:postsReducer,})exportdefaultrootReducerFinally, we'll make thepostsReducer. We can set it up with an initial state. Just like you might expect from a regular React component, we'll have aloadingandhasErrorsstate, as well as apostsarray, where all the posts will live. First we'll set it up with no actions in the switch, just a default case that returns the entire state.reducers/postsReducer.jsexportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow we at least have enough setup that the application will load without crashing.Redux DevToolsWith the application loading and the Redux<Provider>set up, we can take a look at Redux DevTools. After downloading it, it'll be a tab in your Developer Tools. If you click onState, you'll see the entire state of the application so far.There's not much in here yet, but Redux DevTools is amazing once you get to having a lot of reducers and actions. It keeps track of all changes to your app and makes debugging a breeze compared to plain React.Setting up Redux ActionsSo now we have a reducer for posts, but we don't have any actions, meaning the reducer will only return the state without modifying it in any way.Actionsare how we communicate with the Redux store. For this blog app, we're going to want to fetch posts from an API and put them in our Redux state.Since fetching posts is an asynchronous action, it will require the use of Redux thunk. Fortunately, we don't have to do anything special to use thunk beyond setting it up in the store, which we already did.Create aactions/postsActions.js. First, we'll define theaction typesas constants. This is not necessary, but is a common convention, and makes it easy to export the actions around and prevent typos. We want to do three things:getPosts- begin telling Redux we're going to fetch posts from an APIgetPostsSuccess- pass the posts to Redux on successful API callgetPostsFailure- inform Redux that an error was encountered during Redux on failed API callactions/postsActions.js// Create Redux action typesexportconstGET_POSTS='GET_POSTS'exportconstGET_POSTS_SUCCESS='GET_POSTS_SUCCESS'exportconstGET_POSTS_FAILURE='GET_POSTS_FAILURE'Then createaction creators, functions that return anaction, which consists of the type and an optional payload containing data.actions/postsActions.js// Create Redux action creators that return an actionexportconstgetPosts=()=>({type:GET_POSTS,})exportconstgetPostsSuccess=(posts)=>({type:GET_POSTS_SUCCESS,payload:posts,})exportconstgetPostsFailure=()=>({type:GET_POSTS_FAILURE,})Finally, make the asynchronous thunk action that combines all three of the above actions. When called, it will dispatch the initialgetPosts()action to inform Redux to prepare for an API call, then in atry/catch, do everything necessary to get the data, and dispatch a success or failure action as necessary.actions/postsActions.js// Combine them all in an asynchronous thunkexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} reat, we're all done with creating actions now! All that's left to do is tell the reducer what to do with the state on each action.Responding to actionsBack at our post reducer, we have a switch that isn't doing anything yet.reducers/postsReducer.jsexportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){default:returnstate}} ow that we have actions, we can bring them in from thepostsActionspage.// Import all actionsimport*asactionsfrom'../actions/postsActions'For each action, we'll make acase, that returns the entire state plus whatever change we're making to it. ForGET_POSTS, for example, all we want to do is tell the app to setloadingtotruesince we'll be making an API call.caseactions.GET_POSTS:return{...state,loading:true} ET_POSTS- begin loadingGET_POSTS_SUCCESS- the app has posts, no errors, and should stop loadingGET_POSTS_FAILURE- the app has errors and should stop loadingHere's the whole reducer.reducers/postsReducer.jsimport*asactionsfrom'../actions/postsActions'exportconstinitialState={posts:[],loading:false,hasErrors:false,} xportdefaultfunctionpostsReducer(state=initialState,action){switch(action.type){caseactions.GET_POSTS:return{...state,loading:true} aseactions.GET_POSTS_SUCCESS:return{posts:action.payload,loading:false,hasErrors:false} aseactions.GET_POSTS_FAILURE:return{...state,loading:false,hasErrors:true} efault:returnstate}} ow our actions and reducers are ready, so all that's left to do is connect everything to the React app.Connecting Redux to React ComponentsSince the demo app I've created uses React Router to have a few routes - a dashboard, a listing of all posts, and an individual posts page, I'll bring React Router in now. I'll just bring in the dashboard and all posts listing for this demo.App.jsimportReactfrom'react'import{BrowserRouterasRouter,Switch,Route,Redirect} rom'react-router-dom'importDashboardPagefrom'./pages/DashboardPage'importPostsPagefrom'./pages/PostsPage'constApp=()=>{return(<Router><Switch><Routeexactpath=\"/\"component={DashboardPage}/><Routeexactpath=\"/posts\"component={PostsPage}/><Redirectto=\"/\"/></Switch></Router>)} xportdefaultAppWe can create the dashboard page, which is just a regular React component.pages/DashboardPage.jsimportReactfrom'react'import{Link} rom'react-router-dom'constDashboardPage=()=>(<section><h1>Dashboard</h1><p>This is the dashboard.</p><Linkto=\"/posts\"className=\"button\">View Posts</Link></section>)exportdefaultDashboardPageFor each post, let's make aPostcomponent that will display the title and an excerpt of the text of the article. Make aPost.jsin thecomponentssubdirectory.components/Post.jsimportReactfrom'react'exportconstPost=({post})=>(<articleclassName=\"post-excerpt\"><h2>{post.title}</h2><p>{post.body.substring(0,100)}</p></article>)Components that do not connect to Redux are still important and useful for smaller, reusable areas, such as this Post component.Now the interesting part comes in for the posts page - bringing Redux into React. To do this we'll useconnectfromreact-redux. First, we'll just make a regular component for the page.pages/PostsPage.jsimportReactfrom'react'constPostsPage=()=>{return(<section><h1>Posts</h1></section>)} xportdefaultPostsPageThen we'll bring inconnect.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.9950000000000001,
        "word_count": 1000,
        "chunk_id": "ce44a83cb22103e6a639d48b1d686d36",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "id": "/redux-react-guide/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "Theconnect functionis a higher-order function that connects the Redux store to a React component. We'll pass a parameter calledmapStateToPropstoconnect. This aptly named function will take any state from the Redux store and pass it to the props of the React component. We'll bring inloading,posts, andhasErrorsfrom the ReduxpostsReducer.pages/PostsPage.jsimportReactfrom'react'import{connect} rom'react-redux'// Redux state is now in the props of the componentconstPostsPage=({loading,posts,hasErrors})=>{return(<section><h1>Posts</h1></section>)}// Map Redux state to React component propsconstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})// Connect Redux to Reactexportdefaultconnect(mapStateToProps)(PostsPage)Since this component uses state from the same reducer, we could also writestate => state.posts. However, learning how to write it the long way is useful to know in case you need to bring multiple reducers into the same component.Finally, we'll bring in the asynchronousfetchPostsfrom the actions, which is the action that combines the whole lifecycle of fetching all posts into one. UsinguseEffectfrom React, we'lldispatchfetchPostswhen the component mounts.dispatchwill automatically be available on a connected component.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'// Bring in the asynchronous fetchPosts actionimport{fetchPosts} rom'../actions/postsActions'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])return(<section><h1>Posts</h1></section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)All that's left to do at this point is display all three possible states of the page - whether it's loading, has an error, or successfully retrieved the posts from the API.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{connect} rom'react-redux'import{fetchPosts} rom'../actions/postsActions'import{Post} rom'../components/Post'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])// Show loading, error, or success stateconstrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post}/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)And that's all - we now have a connected component, and are bringing in data from an API to our Redux store. Using Redux DevTools, we can see each action as it happens, and the changes (diff) after each state change.The EndThis is where the tutorial for creating an application with plain Redux ends. If you look at thesource code of the demo application, you'll see a lot has been added - a reducer and actions for a single post, and for comments.I would recommend completing your project so that it matches the demo app. There are no new concepts to be learned, but you will create two more reducers and actions, and see how to bring two states into one component for the single post page, which brings in one post as well as comments for that post.Redux ToolkitThere is one more thing I want to cover -Redux Toolkit. Redux Toolkit, or RTK, is a newer and easier official way to use Redux. You may notice that Redux has alotof boilerplate for setup and requires many more folders and files than plain React would. Some patterns have emerged to attempt to mitigate all that, such asRedux ducks pattern, but we can simplify it even more.View thesource of the demo Redux Toolkit application, which is the same application we just created with Redux, but using RTK. It is much simpler, with a drastic reduction in lines of code for all the same functionality.Using RTK just requires one dependency,@reduxjs/toolkit.npmi @reduxjs/toolkitAnd no longer requires you to install theredux-thunkorredux-devtools-extensiondependencies.Advantages to Redux ToolkitThe main advantages to using RTK are:Easier to set up (less dependencies)Reduction of boilerplate code (one slice vs. many files for actions and reducers)Sensible defaults (Redux Thunk, Redux DevTools built-in)The ability to usedirect state mutation, since RTK usesimmerunder the hood. This means you no longer need to return{ ...state } ith every reducer.StoreSince Redux Toolkit comes with a lot built-in already, like Redux DevTools and Redux Thunk, we no longer have to bring them into theindex.jsfile. Now we only needconfigureStore, instead ofcreateStore.index.jsimportReactfrom'react'import{render} rom'react-dom'import{configureStore} rom'@reduxjs/toolkit'import{Provider} rom'react-redux'importAppfrom'./App'importrootReducerfrom'./slices'import'./index.css'conststore=configureStore({reducer:rootReducer})render(<Providerstore={store}><App/></Provider>,document.getElementById('root'))SlicesInstead of dealing with reducers, actions, and all as separate files and individually creating all those action types, RTK gives us the concept ofslices. Asliceautomatically generates reducers, action types, and action creators. As such, you'll only have to create one folder -slices.initialStatewill look the same.slices/posts.jsimport{createSlice} rom'@reduxjs/toolkit'exportconstinitialState={loading:false,hasErrors:false,posts:[],} he names of the reducers in the slice will also be the same -getPosts,getPostsSuccess, andgetPostsFailure. We'll make all the same changes, but note that we're no longer returning the entire state - we're just mutating state. It's still immutable under the hood, but this approach may be easier and faster for some. If preferred, you can still return the whole state as an object.slices/posts.js// A slice for posts with our three reducersconstpostsSlice=createSlice({name:'posts',initialState,reducers:{getPosts:(state)=>{state.loading=true},getPostsSuccess:(state,{payload})=>{state.posts=payload\n      state.loading=falsestate.hasErrors=false},getPostsFailure:(state)=>{state.loading=falsestate.hasErrors=true},},})The actions that get generated are the same, we just don't have to write them out individually anymore. From the same file, we can export all the actions, the reducer, the asynchronous thunk, and one new thing - aselector, which we'll use to access any of the state from a React component instead of usingconnect.slices/posts.js// Three actions generated from the sliceexportconst{getPosts,getPostsSuccess,getPostsFailure}=postsSlice.actions// A selectorexportconstpostsSelector=(state)=>state.posts// The reducerexportdefaultpostsSlice.reducer// Asynchronous thunk actionexportfunctionfetchPosts(){returnasync(dispatch)=>{dispatch(getPosts())try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/posts')constdata=awaitresponse.json()dispatch(getPostsSuccess(data))} atch(error){dispatch(getPostsFailure())}}} electing Redux state in a React componentThe traditional approach, as we just learned, is to usemapStateToPropswith theconnect()function. This is still common in codebases and therefore worth learning. You can still use this approach with RTK, but the newer, React Hooks way of going about it is to useuseDispatchanduseSelectorfromreact-redux. This approach requires less code overall as well.As you can see in the updatedPostsPage.jsfile below, the Redux state is no longer available as props on the connected component, but from the selector we exported in the slice.pages/PostsPage.jsimportReact,{useEffect} rom'react'import{useDispatch,useSelector} rom'react-redux'import{fetchPosts,postsSelector} rom'../slices/posts'import{Post} rom'../components/Post'constPostsPage=()=>{constdispatch=useDispatch()const{posts,loading,hasErrors}=useSelector(postsSelector)useEffect(()=>{dispatch(fetchPosts())},[dispatch])constrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post} xcerpt/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} xportdefaultPostsPageNow we have the same app as before with a few updates from Redux Toolkit, and a lot less code to maintain.ConclusionWe did it! If you followed along with me through this whole tutorial, you should have a really good feel for Redux now, both the old-fashioned way and using Redux Toolkit to simplify things. To summarize, Redux allows us to easily manage global state in a React application. We can access and update the state from anywhere, and easily debug the entire state of an application with Redux Devtools.You can place most of the state of your application in Redux, but certain areas of an app, such as forms as they are being updated, still make sense to keep in the React component state itself until the form is officially submitted.I hope you enjoyed this article!",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.9950000000000001,
        "word_count": 962,
        "chunk_id": "33861c3fc43be5f54517d6f1ff94d72e",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {
            "id": "/redux-react-guide/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "It was a lot of work to put together two complete demo applications and run through the whole thing here, and the article ran pretty long, but hopefully this is your one-stop shop for learning all beginner and intermediate Redux concepts. Please let me know what you think and share the article if it helped you out, and donations are always welcome!",
        "chunk_type": "text",
        "tag": "div",
        "score": 0.9950000000000001,
        "word_count": 62,
        "chunk_id": "3844023a704de7c7fddf3e35d714cd7b",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "article"
          ],
          "attributes": {
            "id": "/redux-react-guide/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "javascript"
          ]
        }
      },
      {
        "content": "Do you have experience usingReact? Have you heard ofRedux, but you've put off learning it because it looks very complicated and all the guides seem overwhelming? If that's the case, this is the article for you! Contain your fear of containing state and come along with me on this relatively painless journey.",
        "chunk_type": "technical_content",
        "tag": "p",
        "score": 0.386,
        "word_count": 52,
        "chunk_id": "74005d77e435b33461b3b72655049d0f",
        "metadata": {
          "source_tag": "p",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react"
          ]
        }
      },
      {
        "content": "About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:March 09, 2020Category:TechnicalTagsreduxreacttutorialNewsletterSubscribe to the Newsletter",
        "chunk_type": "example",
        "tag": "aside",
        "score": 0.43200000000000005,
        "word_count": 54,
        "chunk_id": "443bfc0c2f4009bcea7ab86d113fc715",
        "metadata": {
          "source_tag": "aside",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "post-sidebar"
            ]
          },
          "technical_indicators": [
            "javascript"
          ]
        }
      },
      {
        "content": "Whatis Redux andwhyyou might want to use itTheterminologyof Redux: actions, reducers, store, dispatch, connect, and containerMaking asynchronous API calls withRedux ThunkHow to make a small, real-world application with React and ReduxHow to use Redux Toolkit to simplify Redux app development",
        "chunk_type": "technical_content",
        "tag": "ul",
        "score": 0.382,
        "word_count": 40,
        "chunk_id": "1c233dade0037b0d796185d76b362849",
        "metadata": {
          "source_tag": "ul",
          "keywords_found": [
            "development",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "javascript",
            "api"
          ]
        }
      },
      {
        "content": "importReactfrom'react'import{connect} rom'react-redux'// Redux state is now in the props of the componentconstPostsPage=({loading,posts,hasErrors})=>{return(<section><h1>Posts</h1></section>)}// Map Redux state to React component propsconstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})// Connect Redux to Reactexportdefaultconnect(mapStateToProps)(PostsPage)",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.381,
        "word_count": 23,
        "chunk_id": "fefddd005870f062fb11001a84053212",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "jsx"
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "importReactfrom'react'import{connect} rom'react-redux'// Redux state is now in the props of the componentconstPostsPage=({loading,posts,hasErrors})=>{return(<section><h1>Posts</h1></section>)}// Map Redux state to React component propsconstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})// Connect Redux to Reactexportdefaultconnect(mapStateToProps)(PostsPage)",
        "chunk_type": "code_markup",
        "tag": "pre",
        "score": 0.381,
        "word_count": 23,
        "chunk_id": "fefddd005870f062fb11001a84053212",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-jsx"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "importReactfrom'react'import{connect} rom'react-redux'// Redux state is now in the props of the componentconstPostsPage=({loading,posts,hasErrors})=>{return(<section><h1>Posts</h1></section>)}// Map Redux state to React component propsconstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})// Connect Redux to Reactexportdefaultconnect(mapStateToProps)(PostsPage)",
        "chunk_type": "code_markup",
        "tag": "code",
        "score": 0.381,
        "word_count": 23,
        "chunk_id": "fefddd005870f062fb11001a84053212",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-jsx"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "importReact,{useEffect} rom'react'import{connect} rom'react-redux'import{fetchPosts} rom'../actions/postsActions'import{Post} rom'../components/Post'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])// Show loading, error, or success stateconstrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post}/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.595,
        "word_count": 18,
        "chunk_id": "d2c6446d787088ecd2e8e2a217aa857f",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "jsx"
          },
          "technical_indicators": [
            "react",
            "javascript"
          ]
        }
      },
      {
        "content": "importReact,{useEffect} rom'react'import{connect} rom'react-redux'import{fetchPosts} rom'../actions/postsActions'import{Post} rom'../components/Post'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])// Show loading, error, or success stateconstrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post}/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)",
        "chunk_type": "code_markup",
        "tag": "pre",
        "score": 0.595,
        "word_count": 18,
        "chunk_id": "d2c6446d787088ecd2e8e2a217aa857f",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-jsx"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript"
          ]
        }
      },
      {
        "content": "importReact,{useEffect} rom'react'import{connect} rom'react-redux'import{fetchPosts} rom'../actions/postsActions'import{Post} rom'../components/Post'constPostsPage=({dispatch,loading,posts,hasErrors})=>{useEffect(()=>{dispatch(fetchPosts())},[dispatch])// Show loading, error, or success stateconstrenderPosts=()=>{if(loading)return<p>Loading posts...</p>if(hasErrors)return<p>Unable to display posts.</p>returnposts.map((post)=><Postkey={post.id} ost={post}/>)} eturn(<section><h1>Posts</h1>{renderPosts()}</section>)} onstmapStateToProps=(state)=>({loading:state.posts.loading,posts:state.posts.posts,hasErrors:state.posts.hasErrors,})exportdefaultconnect(mapStateToProps)(PostsPage)",
        "chunk_type": "code_markup",
        "tag": "code",
        "score": 0.595,
        "word_count": 18,
        "chunk_id": "d2c6446d787088ecd2e8e2a217aa857f",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-jsx"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript"
          ]
        }
      }
    ],
    "chunk_count": 37,
    "content_types": [
      "text",
      "code_markup",
      "technical_content",
      "example"
    ],
    "technical_concepts": [
      "javascript",
      "sql",
      "data",
      "api",
      "react"
    ],
    "crawl_metadata": {},
    "technical_content": [
      {
        "id": "599dcce2998a6b40b1e38e8c6006cb0a",
        "content": "type",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "321c3cf486ed509164edec1e1981fec8",
        "content": "payload",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9d751262de89d556cc1d3c6cc6c96005",
        "content": "const DELETE_TODO = 'posts/deleteTodo'",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9d751262de89d556cc1d3c6cc6c96005",
        "content": "const DELETE_TODO = 'posts/deleteTodo'",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "bdc525db8795fbd198b4890ecf9477d9",
        "content": "{ type: DELETE_TODO, payload: id, }",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "bdc525db8795fbd198b4890ecf9477d9",
        "content": "{ type: DELETE_TODO, payload: id, }",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "d8eee56ea1e697a426953e6fb72940a9",
        "content": "const deleteTodo = (id) => ({ type: DELETE_TODO, payload: id })",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "d8eee56ea1e697a426953e6fb72940a9",
        "content": "const deleteTodo = (id) => ({ type: DELETE_TODO, payload: id })",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "9ed39e2ea931586b6a985a6942ef573e",
        "content": "state",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "418c5509e2171d55b0aee5c2ea4442b5",
        "content": "action",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b36eb6a54154f7301f004e1e61c87ce8",
        "content": "switch",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "8b6d581bf88a33ab1439e0ee6b299613",
        "content": "const initialState = { todos: [ { id: 1, text: 'Eat' }, { id: 2, text: 'Sleep' }, ], loading: false, hasErrors: false, } function todoReducer(state = initialState, action) { switch (action.type) { case DELETE_TODO: return { ...state, todos: state.todos.filter((todo) => todo.id !== action.payload), } default: return state } }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "8b6d581bf88a33ab1439e0ee6b299613",
        "content": "const initialState = { todos: [ { id: 1, text: 'Eat' }, { id: 2, text: 'Sleep' }, ], loading: false, hasErrors: false, } function todoReducer(state = initialState, action) { switch (action.type) { case DELETE_TODO: return { ...state, todos: state.todos.filter((todo) => todo.id !== action.payload), } default: return state } }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "f167f0d2262a808a784ea63ed0580e7f",
        "content": "<Provider>",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "7282a352f5ebc05a49e8f7ddefacb887",
        "content": "import { createStore } from 'redux' import { Provider } from 'react-redux' import reducer from './reducers' const store = createStore(reducer) render( <Provider store={store}> <App /> </Provider>, document.getElementById('root') )",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "7282a352f5ebc05a49e8f7ddefacb887",
        "content": "import { createStore } from 'redux' import { Provider } from 'react-redux' import reducer from './reducers' const store = createStore(reducer) render( <Provider store={store}> <App /> </Provider>, document.getElementById('root') )",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "9dddf2a4f7d94594ec2ea98407a410e1",
        "content": "dispatch",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "48288914e5f9b6638fa205ae1aac154c",
        "content": "const Component = ({ dispatch }) => { useEffect(() => { dispatch(deleteTodo()) }, [dispatch]) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "48288914e5f9b6638fa205ae1aac154c",
        "content": "const Component = ({ dispatch }) => { useEffect(() => { dispatch(deleteTodo()) }, [dispatch]) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "fcb3434e4e9bfb46457aa0b3479e32fd",
        "content": "connect()",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "742b9ebeae6261f38d825a387a0fd25d",
        "content": "npx create-react-app redux-tutorial cd redux-tutorial",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "742b9ebeae6261f38d825a387a0fd25d",
        "content": "npx create-react-app redux-tutorial cd redux-tutorial",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "854acd1adb599f742ed225ce81711546",
        "content": "yarn add",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7d1654a2281de41eb75e98be8d776d2f",
        "content": "npm i",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "282dc9a83be8c24556288cbd9e645a4d",
        "content": "react-router-dom",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "9a2780b67d07c6d0f491e7f268b6e769",
        "content": "npm i redux react-redux redux-thunk redux-devtools-extension react-router-dom",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "9a2780b67d07c6d0f491e7f268b6e769",
        "content": "npm i redux react-redux redux-thunk redux-devtools-extension react-router-dom",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "c62fa1b38d72e4ba346d90dfe93da927",
        "content": "cd src rm * move to src and delete all files within",
        "type": "code",
        "language": "shell",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c62fa1b38d72e4ba346d90dfe93da927",
        "content": "cd src rm * move to src and delete all files within",
        "type": "code",
        "language": "shell",
        "relevance": 0.30000000000000004
      },
      {
        "id": "8d406160bb69e3708551729e3294d46b",
        "content": "reducers",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "ebb67a4271abe715344471b0f16321f6",
        "content": "actions",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b3b32a2d422265cd25c3323ed0157f81",
        "content": "pages",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4725dcf446a342f1473a8228e42dfa48",
        "content": "components",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "133d1fc5cb811ffd38fa5d65790846e1",
        "content": "mkdir actions components pages reducers",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "133d1fc5cb811ffd38fa5d65790846e1",
        "content": "mkdir actions components pages reducers",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "958f6f56cd42c904603d226cd36a57b6",
        "content": "App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "bca1542f88ef8253c16b452e9ad09f98",
        "content": "index.css",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "97e1cf126ab47607d6f90c50657044dc",
        "content": "touch index.js index.css App.js",
        "type": "code",
        "language": "shell",
        "relevance": 0.30000000000000004
      },
      {
        "id": "97e1cf126ab47607d6f90c50657044dc",
        "content": "touch index.js index.css App.js",
        "type": "code",
        "language": "shell",
        "relevance": 0.30000000000000004
      },
      {
        "id": "62df2e4ec3a1a2e507b141c4f0f7c8ad",
        "content": "src/ actions/ components/ pages/ reducers/ App.js index.css index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "62df2e4ec3a1a2e507b141c4f0f7c8ad",
        "content": "src/ actions/ components/ pages/ reducers/ App.js index.css index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "bca1542f88ef8253c16b452e9ad09f98",
        "content": "index.css",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cc258ed4fa61a08b3610f663fb7e2455",
        "content": "createStore",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1f90098366bb33536f4133cf056d6930",
        "content": "applyMiddleware",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "230e216f8d80e5d88c91310f149b6112",
        "content": "thunk",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "27703c8f150ac4bb0a3a83a7857353af",
        "content": "Provider",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "230e216f8d80e5d88c91310f149b6112",
        "content": "thunk",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5716284a7703388721696c447f5c2155",
        "content": "composeWithDevTools",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2276eb19fbad6f5bafebccdba475ba9c",
        "content": "// External imports import React from 'react' import { render } from 'react-dom' import { createStore, applyMiddleware } from 'redux' import { Provider } from 'react-redux' import thunk from 'redux-thunk' import { composeWithDevTools } from 'redux-devtools-extension' // Local imports import App from './App' import rootReducer from './reducers' // Assets import './index.css' const store = createStore(rootReducer, composeWithDevTools(applyMiddleware(thunk))) render( <Provider store={store}> <App /> </Provider>, document.getElementById('root') )",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7052631578947368
      },
      {
        "id": "2276eb19fbad6f5bafebccdba475ba9c",
        "content": "// External imports import React from 'react' import { render } from 'react-dom' import { createStore, applyMiddleware } from 'redux' import { Provider } from 'react-redux' import thunk from 'redux-thunk' import { composeWithDevTools } from 'redux-devtools-extension' // Local imports import App from './App' import rootReducer from './reducers' // Assets import './index.css' const store = createStore(rootReducer, composeWithDevTools(applyMiddleware(thunk))) render( <Provider store={store}> <App /> </Provider>, document.getElementById('root') )",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7052631578947368
      },
      {
        "id": "958f6f56cd42c904603d226cd36a57b6",
        "content": "App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "689505e1b2c57da382e58a5863688750",
        "content": "import React from 'react' const App = () => { return <div>Hello, Redux</div> } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "689505e1b2c57da382e58a5863688750",
        "content": "import React from 'react' const App = () => { return <div>Hello, Redux</div> } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "4b7dbab04392cd22a1fec72b0a1831ce",
        "content": "combineReducers",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2f82bc0db49a2f28022ba43b3f9383b5",
        "content": "postsReducer",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4b7dbab04392cd22a1fec72b0a1831ce",
        "content": "combineReducers",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d4e46256d55b452727da000816bcf316",
        "content": "commentsReducer",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "22221abcba75d1e5861a418a83e62e92",
        "content": "authReducer",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "ff660260591e4b988922cc7179fafdc2",
        "content": "reducers/index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c4c3a303016a96160e40134044a80e3b",
        "content": "import { combineReducers } from 'redux' import postsReducer from './postsReducer' const rootReducer = combineReducers({ posts: postsReducer, }) export default rootReducer",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "c4c3a303016a96160e40134044a80e3b",
        "content": "import { combineReducers } from 'redux' import postsReducer from './postsReducer' const rootReducer = combineReducers({ posts: postsReducer, }) export default rootReducer",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "2f82bc0db49a2f28022ba43b3f9383b5",
        "content": "postsReducer",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a14fa2166ed698f3d04061f57e5ab9b9",
        "content": "loading",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9308ef711245f4213a779903b194f396",
        "content": "hasErrors",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "18958e30bdca0cfac8256824e570a89b",
        "content": "posts",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "084c5dbc6068175804e22de71490c137",
        "content": "export const initialState = { posts: [], loading: false, hasErrors: false, } export default function postsReducer(state = initialState, action) { switch (action.type) { default: return state } }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "084c5dbc6068175804e22de71490c137",
        "content": "export const initialState = { posts: [], loading: false, hasErrors: false, } export default function postsReducer(state = initialState, action) { switch (action.type) { default: return state } }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "f167f0d2262a808a784ea63ed0580e7f",
        "content": "<Provider>",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "9ac4d4bfd3f838722b0fbd18e6edcc7b",
        "content": "actions/postsActions.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "30261789eed3addbd2d54402dcf6fa01",
        "content": "getPosts",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "de920264f7b42f677fe4c113e10c12cb",
        "content": "getPostsSuccess",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d51e64d3152adb8753a1f3f05512d4cb",
        "content": "getPostsFailure",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a4fcd3963444ce25a9337059501020cf",
        "content": "// Create Redux action types export const GET_POSTS = 'GET_POSTS' export const GET_POSTS_SUCCESS = 'GET_POSTS_SUCCESS' export const GET_POSTS_FAILURE = 'GET_POSTS_FAILURE'",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "a4fcd3963444ce25a9337059501020cf",
        "content": "// Create Redux action types export const GET_POSTS = 'GET_POSTS' export const GET_POSTS_SUCCESS = 'GET_POSTS_SUCCESS' export const GET_POSTS_FAILURE = 'GET_POSTS_FAILURE'",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "2c2398fe5f6f5afbce4af0bc5cf9d412",
        "content": "// Create Redux action creators that return an action export const getPosts = () => ({ type: GET_POSTS, }) export const getPostsSuccess = (posts) => ({ type: GET_POSTS_SUCCESS, payload: posts, }) export const getPostsFailure = () => ({ type: GET_POSTS_FAILURE, })",
        "type": "code",
        "language": "js",
        "relevance": 0.7
      },
      {
        "id": "2c2398fe5f6f5afbce4af0bc5cf9d412",
        "content": "// Create Redux action creators that return an action export const getPosts = () => ({ type: GET_POSTS, }) export const getPostsSuccess = (posts) => ({ type: GET_POSTS_SUCCESS, payload: posts, }) export const getPostsFailure = () => ({ type: GET_POSTS_FAILURE, })",
        "type": "code",
        "language": "js",
        "relevance": 0.7
      },
      {
        "id": "6eca12438502fcf69468a4610cab7247",
        "content": "getPosts()",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "7c6e64aa012e4cab5654531a98d60c8a",
        "content": "try/catch",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d84a0a04f9d050d7f90227fee99a4473",
        "content": "// Combine them all in an asynchronous thunk export function fetchPosts() { return async (dispatch) => { dispatch(getPosts()) try { const response = await fetch('https://jsonplaceholder.typicode.com/posts') const data = await response.json() dispatch(getPostsSuccess(data)) } catch (error) { dispatch(getPostsFailure()) } } }",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "d84a0a04f9d050d7f90227fee99a4473",
        "content": "// Combine them all in an asynchronous thunk export function fetchPosts() { return async (dispatch) => { dispatch(getPosts()) try { const response = await fetch('https://jsonplaceholder.typicode.com/posts') const data = await response.json() dispatch(getPostsSuccess(data)) } catch (error) { dispatch(getPostsFailure()) } } }",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "e455bfc324713706fccc8ce2f8fa8a7a",
        "content": "export default function postsReducer(state = initialState, action) { switch (action.type) { default: return state } }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "e455bfc324713706fccc8ce2f8fa8a7a",
        "content": "export default function postsReducer(state = initialState, action) { switch (action.type) { default: return state } }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "ebc0100d3c40359698ebcb40e9d332d9",
        "content": "postsActions",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "43297f48d712b6ba490e207b7858725b",
        "content": "// Import all actions import * as actions from '../actions/postsActions'",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "43297f48d712b6ba490e207b7858725b",
        "content": "// Import all actions import * as actions from '../actions/postsActions'",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cd14c323902024e72c850aa828d634a7",
        "content": "case",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "463b614c2abde463443e55eac713cb59",
        "content": "GET_POSTS",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a14fa2166ed698f3d04061f57e5ab9b9",
        "content": "loading",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b326b5062b2f0e69046810717534cb09",
        "content": "true",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b5fce1cd9e62a34a2cd7adbf6197ec2b",
        "content": "case actions.GET_POSTS: return { ...state, loading: true }",
        "type": "code",
        "language": "js",
        "relevance": 0.4052631578947369
      },
      {
        "id": "b5fce1cd9e62a34a2cd7adbf6197ec2b",
        "content": "case actions.GET_POSTS: return { ...state, loading: true }",
        "type": "code",
        "language": "js",
        "relevance": 0.4052631578947369
      },
      {
        "id": "463b614c2abde463443e55eac713cb59",
        "content": "GET_POSTS",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "328af269a963c07b4247c22956a2bf98",
        "content": "GET_POSTS_SUCCESS",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "71538417edad5c2f3151d6c662b3b7ce",
        "content": "GET_POSTS_FAILURE",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "07af9e3cb6fdc50d75ab939d34080214",
        "content": "import * as actions from '../actions/postsActions' export const initialState = { posts: [], loading: false, hasErrors: false, } export default function postsReducer(state = initialState, action) { switch (action.type) { case actions.GET_POSTS: return { ...state, loading: true } case actions.GET_POSTS_SUCCESS: return { posts: action.payload, loading: false, hasErrors: false } case actions.GET_POSTS_FAILURE: return { ...state, loading: false, hasErrors: true } default: return state } }",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "07af9e3cb6fdc50d75ab939d34080214",
        "content": "import * as actions from '../actions/postsActions' export const initialState = { posts: [], loading: false, hasErrors: false, } export default function postsReducer(state = initialState, action) { switch (action.type) { case actions.GET_POSTS: return { ...state, loading: true } case actions.GET_POSTS_SUCCESS: return { posts: action.payload, loading: false, hasErrors: false } case actions.GET_POSTS_FAILURE: return { ...state, loading: false, hasErrors: true } default: return state } }",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "e7d46973956c20b9f22907bd0998b9d3",
        "content": "import React from 'react' import { BrowserRouter as Router, Switch, Route, Redirect } from 'react-router-dom' import DashboardPage from './pages/DashboardPage' import PostsPage from './pages/PostsPage' const App = () => { return ( <Router> <Switch> <Route exact path=\"/\" component={DashboardPage} /> <Route exact path=\"/posts\" component={PostsPage} /> <Redirect to=\"/\" /> </Switch> </Router> ) } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8105263157894738
      },
      {
        "id": "e7d46973956c20b9f22907bd0998b9d3",
        "content": "import React from 'react' import { BrowserRouter as Router, Switch, Route, Redirect } from 'react-router-dom' import DashboardPage from './pages/DashboardPage' import PostsPage from './pages/PostsPage' const App = () => { return ( <Router> <Switch> <Route exact path=\"/\" component={DashboardPage} /> <Route exact path=\"/posts\" component={PostsPage} /> <Redirect to=\"/\" /> </Switch> </Router> ) } export default App",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8105263157894738
      },
      {
        "id": "fbddacdc7442a8f9e54723fa1cc8cc79",
        "content": "import React from 'react' import { Link } from 'react-router-dom' const DashboardPage = () => ( <section> <h1>Dashboard</h1> <p>This is the dashboard.</p> <Link to=\"/posts\" className=\"button\"> View Posts </Link> </section> ) export default DashboardPage",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "fbddacdc7442a8f9e54723fa1cc8cc79",
        "content": "import React from 'react' import { Link } from 'react-router-dom' const DashboardPage = () => ( <section> <h1>Dashboard</h1> <p>This is the dashboard.</p> <Link to=\"/posts\" className=\"button\"> View Posts </Link> </section> ) export default DashboardPage",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "03d947a2158373c3b9d74325850cb8b9",
        "content": "Post",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2afc1957abc2e5fc0d9bc27770a6d30d",
        "content": "Post.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4725dcf446a342f1473a8228e42dfa48",
        "content": "components",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "22e6fb8c758d49c79be5bae26e101986",
        "content": "import React from 'react' export const Post = ({ post }) => ( <article className=\"post-excerpt\"> <h2>{post.title}</h2> <p>{post.body.substring(0, 100)}</p> </article> )",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "22e6fb8c758d49c79be5bae26e101986",
        "content": "import React from 'react' export const Post = ({ post }) => ( <article className=\"post-excerpt\"> <h2>{post.title}</h2> <p>{post.body.substring(0, 100)}</p> </article> )",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "b640a0ce465fa2a4150c36b305c1c11b",
        "content": "connect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1ffa815c34d64d742ab00d7346213902",
        "content": "react-redux",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "fc3c7e2fa66a9cf5067852ebcf9b7a92",
        "content": "import React from 'react' const PostsPage = () => { return ( <section> <h1>Posts</h1> </section> ) } export default PostsPage",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "fc3c7e2fa66a9cf5067852ebcf9b7a92",
        "content": "import React from 'react' const PostsPage = () => { return ( <section> <h1>Posts</h1> </section> ) } export default PostsPage",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "b640a0ce465fa2a4150c36b305c1c11b",
        "content": "connect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e14087a41eb4ebe25bef9fc2948ba273",
        "content": "mapStateToProps",
        "type": "code",
        "language": "text",
        "relevance": 0.5105263157894737
      },
      {
        "id": "b640a0ce465fa2a4150c36b305c1c11b",
        "content": "connect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a14fa2166ed698f3d04061f57e5ab9b9",
        "content": "loading",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "18958e30bdca0cfac8256824e570a89b",
        "content": "posts",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9308ef711245f4213a779903b194f396",
        "content": "hasErrors",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2f82bc0db49a2f28022ba43b3f9383b5",
        "content": "postsReducer",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "235572cec8f26b2c9fc4d94e7d0066b8",
        "content": "import React from 'react' import { connect } from 'react-redux' // Redux state is now in the props of the component const PostsPage = ({ loading, posts, hasErrors }) => { return ( <section> <h1>Posts</h1> </section> ) } // Map Redux state to React component propsconst mapStateToProps = (state) => ({ loading: state.posts.loading, posts: state.posts.posts, hasErrors: state.posts.hasErrors,})// Connect Redux to Reactexport default connect(mapStateToProps)(PostsPage)",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "235572cec8f26b2c9fc4d94e7d0066b8",
        "content": "import React from 'react' import { connect } from 'react-redux' // Redux state is now in the props of the component const PostsPage = ({ loading, posts, hasErrors }) => { return ( <section> <h1>Posts</h1> </section> ) } // Map Redux state to React component propsconst mapStateToProps = (state) => ({ loading: state.posts.loading, posts: state.posts.posts, hasErrors: state.posts.hasErrors,})// Connect Redux to Reactexport default connect(mapStateToProps)(PostsPage)",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "4d788ed0fdc7627374f53ce217a8a6c9",
        "content": "state => state.posts",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "d3ce3c8865b6e6cc8758cbd269d9cac7",
        "content": "fetchPosts",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9dddf2a4f7d94594ec2ea98407a410e1",
        "content": "dispatch",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d3ce3c8865b6e6cc8758cbd269d9cac7",
        "content": "fetchPosts",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9dddf2a4f7d94594ec2ea98407a410e1",
        "content": "dispatch",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c91a09b0f07ea482cd9ddb9f377d14e8",
        "content": "import React, { useEffect } from 'react'import { connect } from 'react-redux' // Bring in the asynchronous fetchPosts actionimport { fetchPosts } from '../actions/postsActions' const PostsPage = ({ dispatch, loading, posts, hasErrors }) => { useEffect(() => { dispatch(fetchPosts()) }, [dispatch]) return ( <section> <h1>Posts</h1> </section> ) } const mapStateToProps = (state) => ({ loading: state.posts.loading, posts: state.posts.posts, hasErrors: state.posts.hasErrors, }) export default connect(mapStateToProps)(PostsPage)",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "c91a09b0f07ea482cd9ddb9f377d14e8",
        "content": "import React, { useEffect } from 'react'import { connect } from 'react-redux' // Bring in the asynchronous fetchPosts actionimport { fetchPosts } from '../actions/postsActions' const PostsPage = ({ dispatch, loading, posts, hasErrors }) => { useEffect(() => { dispatch(fetchPosts()) }, [dispatch]) return ( <section> <h1>Posts</h1> </section> ) } const mapStateToProps = (state) => ({ loading: state.posts.loading, posts: state.posts.posts, hasErrors: state.posts.hasErrors, }) export default connect(mapStateToProps)(PostsPage)",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "475b81895f521ff9e1a79b743649b1ec",
        "content": "import React, { useEffect } from 'react' import { connect } from 'react-redux' import { fetchPosts } from '../actions/postsActions' import { Post } from '../components/Post' const PostsPage = ({ dispatch, loading, posts, hasErrors }) => { useEffect(() => { dispatch(fetchPosts()) }, [dispatch]) // Show loading, error, or success state const renderPosts = () => { if (loading) return <p>Loading posts...</p> if (hasErrors) return <p>Unable to display posts.</p> return posts.map((post) => <Post key={post.id} post={post} />) } return ( <section> <h1>Posts</h1> {renderPosts()} </section> ) } const mapStateToProps = (state) => ({ loading: state.posts.loading, posts: state.posts.posts, hasErrors: state.posts.hasErrors, }) export default connect(mapStateToProps)(PostsPage)",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "475b81895f521ff9e1a79b743649b1ec",
        "content": "import React, { useEffect } from 'react' import { connect } from 'react-redux' import { fetchPosts } from '../actions/postsActions' import { Post } from '../components/Post' const PostsPage = ({ dispatch, loading, posts, hasErrors }) => { useEffect(() => { dispatch(fetchPosts()) }, [dispatch]) // Show loading, error, or success state const renderPosts = () => { if (loading) return <p>Loading posts...</p> if (hasErrors) return <p>Unable to display posts.</p> return posts.map((post) => <Post key={post.id} post={post} />) } return ( <section> <h1>Posts</h1> {renderPosts()} </section> ) } const mapStateToProps = (state) => ({ loading: state.posts.loading, posts: state.posts.posts, hasErrors: state.posts.hasErrors, }) export default connect(mapStateToProps)(PostsPage)",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "fb615ed5c2724c80545e39376b9259cb",
        "content": "npm i reduxjs/toolkit",
        "type": "code",
        "language": "shell",
        "relevance": 0.30000000000000004
      },
      {
        "id": "fb615ed5c2724c80545e39376b9259cb",
        "content": "npm i reduxjs/toolkit",
        "type": "code",
        "language": "shell",
        "relevance": 0.30000000000000004
      },
      {
        "id": "48780f62be1149b547914a1ee68fa966",
        "content": "redux-thunk",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "8378cd91c18f0b160ca357f35fe043d4",
        "content": "redux-devtools-extension",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "be38c94741fa4715c450ceae8b9a5ae7",
        "content": "{ ...state }",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cd32db6e7a6e4d36d389a1b0a61cb9b3",
        "content": "configureStore",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cc258ed4fa61a08b3610f663fb7e2455",
        "content": "createStore",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4d6d419a95f1fc42a34363c88d6d5325",
        "content": "import React from 'react' import { render } from 'react-dom' import { configureStore } from ' reduxjs/toolkit'import { Provider } from 'react-redux' import App from './App' import rootReducer from './slices' import './index.css' const store = configureStore({ reducer: rootReducer }) render( <Provider store={store}> <App /> </Provider>, document.getElementById('root') )",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8052631578947369
      },
      {
        "id": "4d6d419a95f1fc42a34363c88d6d5325",
        "content": "import React from 'react' import { render } from 'react-dom' import { configureStore } from ' reduxjs/toolkit'import { Provider } from 'react-redux' import App from './App' import rootReducer from './slices' import './index.css' const store = configureStore({ reducer: rootReducer }) render( <Provider store={store}> <App /> </Provider>, document.getElementById('root') )",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8052631578947369
      },
      {
        "id": "f2cf7c1ba242c12be10c42df81bb60ba",
        "content": "slices",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "70f9d1ad651bdbd12fbdc8b026c70b98",
        "content": "initialState",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "50d596ce0102f9e7d63065799650f814",
        "content": "import { createSlice } from ' reduxjs/toolkit' export const initialState = { loading: false, hasErrors: false, posts: [], }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "50d596ce0102f9e7d63065799650f814",
        "content": "import { createSlice } from ' reduxjs/toolkit' export const initialState = { loading: false, hasErrors: false, posts: [], }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "30261789eed3addbd2d54402dcf6fa01",
        "content": "getPosts",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "de920264f7b42f677fe4c113e10c12cb",
        "content": "getPostsSuccess",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d51e64d3152adb8753a1f3f05512d4cb",
        "content": "getPostsFailure",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4c53f4e4a0511c9b961feb6d87e0a352",
        "content": "// A slice for posts with our three reducers const postsSlice = createSlice({ name: 'posts', initialState, reducers: { getPosts: (state) => { state.loading = true }, getPostsSuccess: (state, { payload }) => { state.posts = payload state.loading = false state.hasErrors = false }, getPostsFailure: (state) => { state.loading = false state.hasErrors = true }, }, })",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "4c53f4e4a0511c9b961feb6d87e0a352",
        "content": "// A slice for posts with our three reducers const postsSlice = createSlice({ name: 'posts', initialState, reducers: { getPosts: (state) => { state.loading = true }, getPostsSuccess: (state, { payload }) => { state.posts = payload state.loading = false state.hasErrors = false }, getPostsFailure: (state) => { state.loading = false state.hasErrors = true }, }, })",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "5b3c32009797feb79096d52e56a56b82",
        "content": "selector",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "b640a0ce465fa2a4150c36b305c1c11b",
        "content": "connect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7ed042522ae313887628d3e77dc4ed68",
        "content": "// Three actions generated from the slice export const { getPosts, getPostsSuccess, getPostsFailure } = postsSlice.actions // A selector export const postsSelector = (state) => state.posts // The reducer export default postsSlice.reducer // Asynchronous thunk action export function fetchPosts() { return async (dispatch) => { dispatch(getPosts()) try { const response = await fetch('https://jsonplaceholder.typicode.com/posts') const data = await response.json() dispatch(getPostsSuccess(data)) } catch (error) { dispatch(getPostsFailure()) } } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8105263157894738
      },
      {
        "id": "7ed042522ae313887628d3e77dc4ed68",
        "content": "// Three actions generated from the slice export const { getPosts, getPostsSuccess, getPostsFailure } = postsSlice.actions // A selector export const postsSelector = (state) => state.posts // The reducer export default postsSlice.reducer // Asynchronous thunk action export function fetchPosts() { return async (dispatch) => { dispatch(getPosts()) try { const response = await fetch('https://jsonplaceholder.typicode.com/posts') const data = await response.json() dispatch(getPostsSuccess(data)) } catch (error) { dispatch(getPostsFailure()) } } }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8105263157894738
      },
      {
        "id": "e14087a41eb4ebe25bef9fc2948ba273",
        "content": "mapStateToProps",
        "type": "code",
        "language": "text",
        "relevance": 0.5105263157894737
      },
      {
        "id": "fcb3434e4e9bfb46457aa0b3479e32fd",
        "content": "connect()",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "68541b0987aec216d23962b37583144b",
        "content": "useDispatch",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "8bc5a9c74d7fcf59277c2a43fe568cc9",
        "content": "useSelector",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "1ffa815c34d64d742ab00d7346213902",
        "content": "react-redux",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "4301942948578c48f580301e9f68c997",
        "content": "PostsPage.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e8800f4d9b96e176408b35824adb6ef0",
        "content": "import React, { useEffect } from 'react' import { useDispatch, useSelector } from 'react-redux' import { fetchPosts, postsSelector } from '../slices/posts' import { Post } from '../components/Post' const PostsPage = () => { const dispatch = useDispatch() const { posts, loading, hasErrors } = useSelector(postsSelector) useEffect(() => { dispatch(fetchPosts()) }, [dispatch]) const renderPosts = () => { if (loading) return <p>Loading posts...</p> if (hasErrors) return <p>Unable to display posts.</p> return posts.map((post) => <Post key={post.id} post={post} excerpt />) } return ( <section> <h1>Posts</h1> {renderPosts()} </section> ) } export default PostsPage",
        "type": "code",
        "language": "jsx",
        "relevance": 1.1157894736842104
      },
      {
        "id": "e8800f4d9b96e176408b35824adb6ef0",
        "content": "import React, { useEffect } from 'react' import { useDispatch, useSelector } from 'react-redux' import { fetchPosts, postsSelector } from '../slices/posts' import { Post } from '../components/Post' const PostsPage = () => { const dispatch = useDispatch() const { posts, loading, hasErrors } = useSelector(postsSelector) useEffect(() => { dispatch(fetchPosts()) }, [dispatch]) const renderPosts = () => { if (loading) return <p>Loading posts...</p> if (hasErrors) return <p>Unable to display posts.</p> return posts.map((post) => <Post key={post.id} post={post} excerpt />) } return ( <section> <h1>Posts</h1> {renderPosts()} </section> ) } export default PostsPage",
        "type": "code",
        "language": "jsx",
        "relevance": 1.1157894736842104
      }
    ]
  },
  {
    "metadata": {
      "description": "Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article…",
      "url": "https://www.taniarascia.com/keyboard-shortcut-hook-react/",
      "title": "Creating a Keyboard Shortcut Hook in React (Deep Dive) | Tania Rascia's Personal Website",
      "source_type": "web",
      "crawl_time": 1730107205.8254669,
      "keywords": [
        "sql",
        "web",
        "article",
        "extract",
        "development",
        "information",
        "react"
      ]
    },
    "relevance_score": 0.9145555555555556,
    "chunks": [
      {
        "content": "Creating a Keyboard Shortcut Hook in React (Deep Dive)Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "main",
        "score": 1.061,
        "word_count": 972,
        "chunk_id": "0705d975bd90e4cda9142423568d0cfa",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 19, 2024Category:TechnicalTagsjavascriptreacthookscachingtutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "main",
        "score": 1.061,
        "word_count": 733,
        "chunk_id": "9e9af7fc5b217c8729ad2eda33ded533",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "Creating a Keyboard Shortcut Hook in React (Deep Dive)Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.061,
        "word_count": 972,
        "chunk_id": "0705d975bd90e4cda9142423568d0cfa",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 19, 2024Category:TechnicalTagsjavascriptreacthookscachingtutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.061,
        "word_count": 733,
        "chunk_id": "9e9af7fc5b217c8729ad2eda33ded533",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "Creating a Keyboard Shortcut Hook in React (Deep Dive)Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.061,
        "word_count": 972,
        "chunk_id": "0705d975bd90e4cda9142423568d0cfa",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 19, 2024Category:TechnicalTagsjavascriptreacthookscachingtutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.061,
        "word_count": 733,
        "chunk_id": "9e9af7fc5b217c8729ad2eda33ded533",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "Creating a Keyboard Shortcut Hook in React (Deep Dive)Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.061,
        "word_count": 972,
        "chunk_id": "0705d975bd90e4cda9142423568d0cfa",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 19, 2024Category:TechnicalTagsjavascriptreacthookscachingtutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.061,
        "word_count": 733,
        "chunk_id": "9e9af7fc5b217c8729ad2eda33ded533",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "Creating a Keyboard Shortcut Hook in React (Deep Dive)Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.061,
        "word_count": 972,
        "chunk_id": "0705d975bd90e4cda9142423568d0cfa",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 19, 2024Category:TechnicalTagsjavascriptreacthookscachingtutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.061,
        "word_count": 733,
        "chunk_id": "9e9af7fc5b217c8729ad2eda33ded533",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "section",
        "score": 1.065,
        "word_count": 964,
        "chunk_id": "a5f4d426c39bf5465e1d3f9a4cf3091b",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.",
        "chunk_type": "technical_content",
        "tag": "section",
        "score": 1.065,
        "word_count": 680,
        "chunk_id": "6de87e9dc9b66e4c0b0e5f7d950bad78",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.065,
        "word_count": 964,
        "chunk_id": "a5f4d426c39bf5465e1d3f9a4cf3091b",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "id": "/keyboard-shortcut-hook-react/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.065,
        "word_count": 680,
        "chunk_id": "6de87e9dc9b66e4c0b0e5f7d950bad78",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "id": "/keyboard-shortcut-hook-react/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 19, 2024Category:TechnicalTagsjavascriptreacthookscachingtutorialNewsletterSubscribe to the Newsletter",
        "chunk_type": "technical_content",
        "tag": "aside",
        "score": 0.43600000000000005,
        "word_count": 54,
        "chunk_id": "0e4fa4fd0255579b9e96b315cceaa2a9",
        "metadata": {
          "source_tag": "aside",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "post-sidebar"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript"
          ]
        }
      },
      {
        "content": "import{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])}",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.905,
        "word_count": 78,
        "chunk_id": "ebd5d91fda9a81085d76425e33f6380c",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "js"
          },
          "technical_indicators": [
            "react",
            "javascript",
            "data"
          ]
        }
      },
      {
        "content": "import{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])}",
        "chunk_type": "technical_content",
        "tag": "pre",
        "score": 0.905,
        "word_count": 78,
        "chunk_id": "ebd5d91fda9a81085d76425e33f6380c",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "data"
          ]
        }
      },
      {
        "content": "import{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])}",
        "chunk_type": "technical_content",
        "tag": "code",
        "score": 0.905,
        "word_count": 78,
        "chunk_id": "ebd5d91fda9a81085d76425e33f6380c",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "data"
          ]
        }
      },
      {
        "content": "import{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])}",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.319,
        "word_count": 96,
        "chunk_id": "9fc296682936c5b5423fccb2230495b6",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "js"
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "import{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])}",
        "chunk_type": "technical_content",
        "tag": "pre",
        "score": 1.319,
        "word_count": 96,
        "chunk_id": "9fc296682936c5b5423fccb2230495b6",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "style": "counter-reset: linenumber 0",
            "class": [
              "language-js",
              "line-numbers"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "import{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])}",
        "chunk_type": "technical_content",
        "tag": "code",
        "score": 1.319,
        "word_count": 96,
        "chunk_id": "9fc296682936c5b5423fccb2230495b6",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "import{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...}",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.599,
        "word_count": 25,
        "chunk_id": "d2792864accec3abc015628114e83b5f",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "js"
          },
          "technical_indicators": [
            "javascript",
            "data"
          ]
        }
      },
      {
        "content": "import{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...}",
        "chunk_type": "technical_content",
        "tag": "pre",
        "score": 0.599,
        "word_count": 25,
        "chunk_id": "d2792864accec3abc015628114e83b5f",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "javascript",
            "data"
          ]
        }
      },
      {
        "content": "import{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...}",
        "chunk_type": "technical_content",
        "tag": "code",
        "score": 0.599,
        "word_count": 25,
        "chunk_id": "d2792864accec3abc015628114e83b5f",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "javascript",
            "data"
          ]
        }
      },
      {
        "content": "exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...}",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.30600000000000005,
        "word_count": 11,
        "chunk_id": "450994c7d656efe33ad0e45947012b7e",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "js"
          },
          "technical_indicators": [
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...}",
        "chunk_type": "technical_content",
        "tag": "pre",
        "score": 0.30600000000000005,
        "word_count": 11,
        "chunk_id": "450994c7d656efe33ad0e45947012b7e",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...}",
        "chunk_type": "technical_content",
        "tag": "code",
        "score": 0.30600000000000005,
        "word_count": 11,
        "chunk_id": "450994c7d656efe33ad0e45947012b7e",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "javascript",
            "sql"
          ]
        }
      }
    ],
    "chunk_count": 27,
    "content_types": [
      "code_markup",
      "technical_content"
    ],
    "technical_concepts": [
      "javascript",
      "data",
      "react",
      "sql"
    ],
    "crawl_metadata": {},
    "technical_content": [
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f0f0802505b28ff454f40670ef0cd5c9",
        "content": "useLayoutEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a43c1b0aa53a0c908810c06ab1ff3967",
        "content": "input",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6394d816bfb4220289a6f4b29cfb1834",
        "content": "textarea",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c8c2fb4e60f621aa8f72ba72405f9581",
        "content": "contenteditable",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "07f8f832fb06410d18ba1e1d8df4a751",
        "content": "useShortcut('Command+Shift+X', () => console.log(' Hola, mundo!'))",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "07f8f832fb06410d18ba1e1d8df4a751",
        "content": "useShortcut('Command+Shift+X', () => console.log(' Hola, mundo!'))",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "096672df389fb56cdc6e320583c65488",
        "content": "count, setCount",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7dfac8369abd7b5bb0af524aa2369f03",
        "content": "import { useState } from 'react' export default function App() { const [count, setCount] = useState(0) return ( <div> <button type=\"button\" onClick={() => setCount((prev) => prev + 1)}> { Count: {count} } </button> <button type=\"button\" onClick={() => setCount(0)}> Clear </button> <input type=\"text\" placeholder=\"Type a shortcut key\" /> </div> ) }",
        "type": "code",
        "language": "js",
        "relevance": 1.1105263157894738
      },
      {
        "id": "7dfac8369abd7b5bb0af524aa2369f03",
        "content": "import { useState } from 'react' export default function App() { const [count, setCount] = useState(0) return ( <div> <button type=\"button\" onClick={() => setCount((prev) => prev + 1)}> { Count: {count} } </button> <button type=\"button\" onClick={() => setCount(0)}> Clear </button> <input type=\"text\" placeholder=\"Type a shortcut key\" /> </div> ) }",
        "type": "code",
        "language": "js",
        "relevance": 1.1105263157894738
      },
      {
        "id": "a43c1b0aa53a0c908810c06ab1ff3967",
        "content": "input",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5a382f607841ee504c8d5d946c2fac94",
        "content": "useShortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5a382f607841ee504c8d5d946c2fac94",
        "content": "useShortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "58a8164e81e6261ac277ad2b4911c7fc",
        "content": "import { useState } from 'react' import { useShortcut } from './useShortcut' export default function App() { const [count, setCount] = useState(0) useShortcut('a', () => { setCount((prev) => prev + 1) }) return <div>{/* ... */}</div> }",
        "type": "code",
        "language": "js",
        "relevance": 0.9105263157894736
      },
      {
        "id": "58a8164e81e6261ac277ad2b4911c7fc",
        "content": "import { useState } from 'react' import { useShortcut } from './useShortcut' export default function App() { const [count, setCount] = useState(0) useShortcut('a', () => { setCount((prev) => prev + 1) }) return <div>{/* ... */}</div> }",
        "type": "code",
        "language": "js",
        "relevance": 0.9105263157894736
      },
      {
        "id": "5a382f607841ee504c8d5d946c2fac94",
        "content": "useShortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c0954f37465ac52acf4a22c5e1c5bf87",
        "content": "shortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "924a8ceeac17f54d3be3f8cdf1c04eb2",
        "content": "callback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cc87d1a0cdab463949001e224ba39371",
        "content": "handleKeyDown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c0954f37465ac52acf4a22c5e1c5bf87",
        "content": "shortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6ca5a13e7adad4ae151fe6500021eb96",
        "content": "event.key",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2959b6433abb3a4138a42ddda695c171",
        "content": "keydown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6d81f8b7989760ca2833a4aec03f1713",
        "content": "import { useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const handleKeyDown = (event) => { // Single key shortcuts (e.g. pressing a) if (shortcut === event.key) { return callback(event) } } useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }) }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "6d81f8b7989760ca2833a4aec03f1713",
        "content": "import { useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const handleKeyDown = (event) => { // Single key shortcuts (e.g. pressing a) if (shortcut === event.key) { return callback(event) } } useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }) }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cc87d1a0cdab463949001e224ba39371",
        "content": "handleKeyDown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "86000955b44e4f8640a21bd77aff6aa6",
        "content": "useMemo",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5789917c46ed70321e72360ff87926da",
        "content": "import { useCallback, useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const handleKeyDown = useCallback((event) => { // Single key shortcuts (e.g. pressing a) if (shortcut === event.key) { return callback(event) } }, []) useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }, [handleKeyDown])}",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "5789917c46ed70321e72360ff87926da",
        "content": "import { useCallback, useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const handleKeyDown = useCallback((event) => { // Single key shortcuts (e.g. pressing a) if (shortcut === event.key) { return callback(event) } }, []) useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }, [handleKeyDown])}",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "cc87d1a0cdab463949001e224ba39371",
        "content": "handleKeyDown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2959b6433abb3a4138a42ddda695c171",
        "content": "keydown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "80c2b4168fdae9029cfa9f29093bcfe3",
        "content": "setCount",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03ce4e517700d276d9173a7981a46a5a",
        "content": "setCount(prev => prev + 1)",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "158ea57c8f335461fb60566922b17a99",
        "content": "setCount(count + 1)",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e2942a04780e223b215eb8b663cf5353",
        "content": "count",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "075363380323b4799196ff5108cc951d",
        "content": "setState",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "e2942a04780e223b215eb8b663cf5353",
        "content": "count",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "00e8228ac71b3ae4fac2d47c93d98573",
        "content": "useShortcut('w', () => { setCount(count + count) })",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "00e8228ac71b3ae4fac2d47c93d98573",
        "content": "useShortcut('w', () => { setCount(count + count) })",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e2942a04780e223b215eb8b663cf5353",
        "content": "count",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "df853da39d97ebdf11e1f7e4c64db18a",
        "content": "count + count",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "eccbc87e4b5ce2fe28308fd9f2a7baf3",
        "content": "3",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1679091c5a880faf6fb5e6087eb1b2dc",
        "content": "6",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cfcd208495d565ef66e7dff9f98764da",
        "content": "0",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e2942a04780e223b215eb8b663cf5353",
        "content": "count",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "019aedfd528fc058f508edab1bb3b0ae",
        "content": "const handleW = useCallback(() => setCount(count + count), [count]) useShortcut('w', handleW)",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "019aedfd528fc058f508edab1bb3b0ae",
        "content": "const handleW = useCallback(() => setCount(count + count), [count]) useShortcut('w', handleW)",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "924a8ceeac17f54d3be3f8cdf1c04eb2",
        "content": "callback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cc87d1a0cdab463949001e224ba39371",
        "content": "handleKeyDown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "57b57638081f8f7cd81e57984a887634",
        "content": "useShotcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f0f0802505b28ff454f40670ef0cd5c9",
        "content": "useLayoutEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f0f0802505b28ff454f40670ef0cd5c9",
        "content": "useLayoutEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e86732df9d58dd6085e369915a018e63",
        "content": "import { useRef, useLayoutEffect, useCallback, useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const callbackRef = useRef(callback) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback((event) => { if (shortcut === event.key) { return callbackRef.current(event) } }, []) useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }, [handleKeyDown]) }",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "e86732df9d58dd6085e369915a018e63",
        "content": "import { useRef, useLayoutEffect, useCallback, useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const callbackRef = useRef(callback) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback((event) => { if (shortcut === event.key) { return callbackRef.current(event) } }, []) useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }, [handleKeyDown]) }",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "e2942a04780e223b215eb8b663cf5353",
        "content": "count",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5a382f607841ee504c8d5d946c2fac94",
        "content": "useShortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "77961215613b33241db00e28fcf69ad7",
        "content": "if (shortcut === event.key)",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4119639092e62c55ea8be348e4d9260d",
        "content": "event",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "25baf3402df19c373ea5f458e64cad8d",
        "content": "event.ctrlKey",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "3a132bf6b1b1359e934e7948db2e8c27",
        "content": "event.altKey",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "8f8ddef66e36eeebaa79b2d8c3fe9fb8",
        "content": "event.metaKey",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "0bf017792a71d415204285d4a11f4be0",
        "content": "event.shiftKey",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "0bf017792a71d415204285d4a11f4be0",
        "content": "event.shiftKey",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b326b5062b2f0e69046810717534cb09",
        "content": "true",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "47f6478eb87886529d1a239bb34ae33b",
        "content": "useShortcut('Control+C', () => { setCount(count + count) }) useShortcut('Command+Shift+X', () => { setCount(count + count) })",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "47f6478eb87886529d1a239bb34ae33b",
        "content": "useShortcut('Control+C', () => { setCount(count + count) }) useShortcut('Command+Shift+X', () => { setCount(count + count) })",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "26b17225b626fb9238849fd60eabdf60",
        "content": "+",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d0c1d488426c0f5d4d7ca38a69a98ffa",
        "content": "import { useRef, useLayoutEffect, useCallback, useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const callbackRef = useRef(callback) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback((event) => { const modifierMap = { Control: event.ctrlKey, Alt: event.altKey, Command: event.metaKey, Shift: event.shiftKey, } if (shortcut.includes('+')) { const keyArray = shortcut.split('+') // If the first key is a modifier, handle combinations if (Object.keys(modifierMap).includes(keyArray[0])) { const finalKey = keyArray.pop() // Run handler if the modifier(s) + key have both been pressed if (keyArray.every((k) => modifierMap[k]) finalKey === event.key) { return callbackRef.current(event) } } } if (shortcut === event.key) { return callbackRef.current(event) } }, []) // ... }",
        "type": "code",
        "language": "js",
        "relevance": 0.9052631578947368
      },
      {
        "id": "d0c1d488426c0f5d4d7ca38a69a98ffa",
        "content": "import { useRef, useLayoutEffect, useCallback, useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const callbackRef = useRef(callback) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback((event) => { const modifierMap = { Control: event.ctrlKey, Alt: event.altKey, Command: event.metaKey, Shift: event.shiftKey, } if (shortcut.includes('+')) { const keyArray = shortcut.split('+') // If the first key is a modifier, handle combinations if (Object.keys(modifierMap).includes(keyArray[0])) { const finalKey = keyArray.pop() // Run handler if the modifier(s) + key have both been pressed if (keyArray.every((k) => modifierMap[k]) finalKey === event.key) { return callbackRef.current(event) } } } if (shortcut === event.key) { return callbackRef.current(event) } }, []) // ... }",
        "type": "code",
        "language": "js",
        "relevance": 0.9052631578947368
      },
      {
        "id": "93da65a9fd0004d9477aeac024e08e15",
        "content": "options",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5a382f607841ee504c8d5d946c2fac94",
        "content": "useShortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7ac5a96aa06eab8a0e0fc327b7534f23",
        "content": "disableTextInputs: true",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "60a817081688675aef6249793b89c87d",
        "content": "HTMLTextAreaElement",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "44c146087f94f53b411690f3e6831db2",
        "content": "HTMLInputElement",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "599dcce2998a6b40b1e38e8c6006cb0a",
        "content": "type",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1cb251ec0d568de6a929b520c4aed8d1",
        "content": "text",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c8c2fb4e60f621aa8f72ba72405f9581",
        "content": "contenteditable",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "08d2df373d04ea3a56b181886b1fb4d3",
        "content": "export const useShortcut = ( shortcut, callback, options = { disableTextInputs: true }) => { const callbackRef = useRef(callback) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback((event) => { const isTextInput = event.target instanceof HTMLTextAreaElement (event.target instanceof HTMLInputElement (!event.target.type event.target.type === 'text')) event.target.isContentEditable // Don't enable shortcuts in inputs unless explicitly declared if (options.disableTextInputs isTextInput) { return event.stopPropagation() } // ... }, []) // ... }",
        "type": "code",
        "language": "js",
        "relevance": 0.9052631578947368
      },
      {
        "id": "08d2df373d04ea3a56b181886b1fb4d3",
        "content": "export const useShortcut = ( shortcut, callback, options = { disableTextInputs: true }) => { const callbackRef = useRef(callback) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback((event) => { const isTextInput = event.target instanceof HTMLTextAreaElement (event.target instanceof HTMLInputElement (!event.target.type event.target.type === 'text')) event.target.isContentEditable // Don't enable shortcuts in inputs unless explicitly declared if (options.disableTextInputs isTextInput) { return event.stopPropagation() } // ... }, []) // ... }",
        "type": "code",
        "language": "js",
        "relevance": 0.9052631578947368
      },
      {
        "id": "351ac178246fc29e75bc20cf02e349c6",
        "content": "tagName",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f9b4a8362b0f49ad2e70a6fe73807c71",
        "content": "\"INPUT\"",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1dfa33e3512e2bdd8ae3a54dd2c851fa",
        "content": "const handleKonamiCode = () => { /* ... */ } useShortcut( ArrowUp+ArrowUp+ ArrowDown+ArrowDown+ ArrowLeft+ArrowRight+ ArrowLeft+ArrowRight+ b+a , handleKonamiCode )",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1dfa33e3512e2bdd8ae3a54dd2c851fa",
        "content": "const handleKonamiCode = () => { /* ... */ } useShortcut( ArrowUp+ArrowUp+ ArrowDown+ArrowDown+ ArrowLeft+ArrowRight+ ArrowLeft+ArrowRight+ b+a , handleKonamiCode )",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "35c4003175f41503270e3c3eed6e0f63",
        "content": "keyCombo",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "26b17225b626fb9238849fd60eabdf60",
        "content": "+",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "35c4003175f41503270e3c3eed6e0f63",
        "content": "keyCombo",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d26317c9ef01f31c0df0fa5cc91b1696",
        "content": "import { useCallback, useRef, useLayoutEffect, useState, useEffect, } from 'react' export const useShortcut = ( shortcut, callback, options = { disableTextInputs: true } ) => { const callbackRef = useRef(callback) const [keyCombo, setKeyCombo] = useState([]) // ... const handleKeyDown = useCallback( (event) => { // ... // Handle combined modifier key shortcuts (e.g. pressing Control + D) if (shortcut.includes('+')) { const keyArray = shortcut.split('+') // If the first key is a modifier, handle combinations if (Object.keys(modifierMap).includes(keyArray[0])) { const finalKey = keyArray.pop() // Run handler if the modifier(s) + key have both been pressed if (keyArray.every((k) => modifierMap[k]) finalKey === event.key) { return callbackRef.current(event) } } else { // If the shortcut doesn't begin with a modifier, it's a sequence if (keyArray[keyCombo.length] === event.key) { // Handle final key in the sequence if ( keyArray[keyArray.length - 1] === event.key keyCombo.length === keyArray.length - 1 ) { // Run handler if the sequence is complete, then reset it callbackRef.current(event) return setKeyCombo([]) } // Add to the sequence return setKeyCombo((prevCombo) => [...prevCombo, event.key]) } if (keyCombo.length > 0) { // Reset key combo if it doesn't match the sequence return setKeyCombo([]) } } } // ... }, [keyCombo.length] ) // ... }, [handleKeyDown]) }",
        "type": "code",
        "language": "js",
        "relevance": 1.0105263157894737
      },
      {
        "id": "d26317c9ef01f31c0df0fa5cc91b1696",
        "content": "import { useCallback, useRef, useLayoutEffect, useState, useEffect, } from 'react' export const useShortcut = ( shortcut, callback, options = { disableTextInputs: true } ) => { const callbackRef = useRef(callback) const [keyCombo, setKeyCombo] = useState([]) // ... const handleKeyDown = useCallback( (event) => { // ... // Handle combined modifier key shortcuts (e.g. pressing Control + D) if (shortcut.includes('+')) { const keyArray = shortcut.split('+') // If the first key is a modifier, handle combinations if (Object.keys(modifierMap).includes(keyArray[0])) { const finalKey = keyArray.pop() // Run handler if the modifier(s) + key have both been pressed if (keyArray.every((k) => modifierMap[k]) finalKey === event.key) { return callbackRef.current(event) } } else { // If the shortcut doesn't begin with a modifier, it's a sequence if (keyArray[keyCombo.length] === event.key) { // Handle final key in the sequence if ( keyArray[keyArray.length - 1] === event.key keyCombo.length === keyArray.length - 1 ) { // Run handler if the sequence is complete, then reset it callbackRef.current(event) return setKeyCombo([]) } // Add to the sequence return setKeyCombo((prevCombo) => [...prevCombo, event.key]) } if (keyCombo.length > 0) { // Reset key combo if it doesn't match the sequence return setKeyCombo([]) } } } // ... }, [keyCombo.length] ) // ... }, [handleKeyDown]) }",
        "type": "code",
        "language": "js",
        "relevance": 1.0105263157894737
      },
      {
        "id": "35c4003175f41503270e3c3eed6e0f63",
        "content": "keyCombo",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "36dddab315a457fbe808b5f82e31014a",
        "content": "handleKeyPress",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5a382f607841ee504c8d5d946c2fac94",
        "content": "useShortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "95e1608661cf66ab1b2e28b9d3679fcb",
        "content": "event.repeat",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "014ef6476dd8a57e2057e639d42d6072",
        "content": "import { useCallback, useRef, useLayoutEffect, useState, useEffect } from 'react' export const useShortcut = (shortcut, callback, options = { disableTextInputs: true }) => { const callbackRef = useRef(callback) const [keyCombo, setKeyCombo] = useState([]) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback( (event) => { const isTextInput = event.target instanceof HTMLTextAreaElement (event.target instanceof HTMLInputElement (!event.target.type event.target.type === 'text')) event.target.isContentEditable const modifierMap = { Control: event.ctrlKey, Alt: event.altKey, Command: event.metaKey, Shift: event.shiftKey, } // Cancel shortcut if key is being held down if (event.repeat) { return null } // Don't enable shortcuts in inputs unless explicitly declared if (options.disableTextInputs isTextInput) { return event.stopPropagation() } // Handle combined modifier key shortcuts (e.g. pressing Control + D) if (shortcut.includes('+')) { const keyArray = shortcut.split('+') // If the first key is a modifier, handle combinations if (Object.keys(modifierMap).includes(keyArray[0])) { const finalKey = keyArray.pop() // Run handler if the modifier(s) + key have both been pressed if (keyArray.every((k) => modifierMap[k]) finalKey === event.key) { return callbackRef.current(event) } } else { // If the shortcut doesn't begin with a modifier, it's a sequence if (keyArray[keyCombo.length] === event.key) { // Handle final key in the sequence if ( keyArray[keyArray.length - 1] === event.key keyCombo.length === keyArray.length - 1 ) { // Run handler if the sequence is complete, then reset it callbackRef.current(event) return setKeyCombo([]) } // Add to the sequence return setKeyCombo((prevCombo) => [...prevCombo, event.key]) } if (keyCombo.length > 0) { // Reset key combo if it doesn't match the sequence return setKeyCombo([]) } } } // Single key shortcuts (e.g. pressing D) if (shortcut === event.key) { return callbackRef.current(event) } }, [keyCombo.length] ) useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }, [handleKeyDown]) }",
        "type": "code",
        "language": "js",
        "relevance": 1.1157894736842104
      },
      {
        "id": "014ef6476dd8a57e2057e639d42d6072",
        "content": "import { useCallback, useRef, useLayoutEffect, useState, useEffect } from 'react' export const useShortcut = (shortcut, callback, options = { disableTextInputs: true }) => { const callbackRef = useRef(callback) const [keyCombo, setKeyCombo] = useState([]) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback( (event) => { const isTextInput = event.target instanceof HTMLTextAreaElement (event.target instanceof HTMLInputElement (!event.target.type event.target.type === 'text')) event.target.isContentEditable const modifierMap = { Control: event.ctrlKey, Alt: event.altKey, Command: event.metaKey, Shift: event.shiftKey, } // Cancel shortcut if key is being held down if (event.repeat) { return null } // Don't enable shortcuts in inputs unless explicitly declared if (options.disableTextInputs isTextInput) { return event.stopPropagation() } // Handle combined modifier key shortcuts (e.g. pressing Control + D) if (shortcut.includes('+')) { const keyArray = shortcut.split('+') // If the first key is a modifier, handle combinations if (Object.keys(modifierMap).includes(keyArray[0])) { const finalKey = keyArray.pop() // Run handler if the modifier(s) + key have both been pressed if (keyArray.every((k) => modifierMap[k]) finalKey === event.key) { return callbackRef.current(event) } } else { // If the shortcut doesn't begin with a modifier, it's a sequence if (keyArray[keyCombo.length] === event.key) { // Handle final key in the sequence if ( keyArray[keyArray.length - 1] === event.key keyCombo.length === keyArray.length - 1 ) { // Run handler if the sequence is complete, then reset it callbackRef.current(event) return setKeyCombo([]) } // Add to the sequence return setKeyCombo((prevCombo) => [...prevCombo, event.key]) } if (keyCombo.length > 0) { // Reset key combo if it doesn't match the sequence return setKeyCombo([]) } } } // Single key shortcuts (e.g. pressing D) if (shortcut === event.key) { return callbackRef.current(event) } }, [keyCombo.length] ) useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }, [handleKeyDown]) }",
        "type": "code",
        "language": "js",
        "relevance": 1.1157894736842104
      },
      {
        "id": "6ca5a13e7adad4ae151fe6500021eb96",
        "content": "event.key",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      }
    ]
  },
  {
    "metadata": {
      "description": "Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article…",
      "url": "https://www.taniarascia.com/keyboard-shortcut-hook-react/#accessing-current-state",
      "title": "Creating a Keyboard Shortcut Hook in React (Deep Dive) | Tania Rascia's Personal Website",
      "source_type": "web",
      "crawl_time": 1730107218.352863,
      "keywords": [
        "sql",
        "web",
        "article",
        "extract",
        "development",
        "information",
        "react"
      ]
    },
    "relevance_score": 0.9145555555555556,
    "chunks": [
      {
        "content": "Creating a Keyboard Shortcut Hook in React (Deep Dive)Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "main",
        "score": 1.061,
        "word_count": 972,
        "chunk_id": "0705d975bd90e4cda9142423568d0cfa",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 19, 2024Category:TechnicalTagsjavascriptreacthookscachingtutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "main",
        "score": 1.061,
        "word_count": 733,
        "chunk_id": "9e9af7fc5b217c8729ad2eda33ded533",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "Creating a Keyboard Shortcut Hook in React (Deep Dive)Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.061,
        "word_count": 972,
        "chunk_id": "0705d975bd90e4cda9142423568d0cfa",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 19, 2024Category:TechnicalTagsjavascriptreacthookscachingtutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.061,
        "word_count": 733,
        "chunk_id": "9e9af7fc5b217c8729ad2eda33ded533",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "Creating a Keyboard Shortcut Hook in React (Deep Dive)Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.061,
        "word_count": 972,
        "chunk_id": "0705d975bd90e4cda9142423568d0cfa",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 19, 2024Category:TechnicalTagsjavascriptreacthookscachingtutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.061,
        "word_count": 733,
        "chunk_id": "9e9af7fc5b217c8729ad2eda33ded533",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "Creating a Keyboard Shortcut Hook in React (Deep Dive)Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.061,
        "word_count": 972,
        "chunk_id": "0705d975bd90e4cda9142423568d0cfa",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 19, 2024Category:TechnicalTagsjavascriptreacthookscachingtutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.061,
        "word_count": 733,
        "chunk_id": "9e9af7fc5b217c8729ad2eda33ded533",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "Creating a Keyboard Shortcut Hook in React (Deep Dive)Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.061,
        "word_count": 972,
        "chunk_id": "0705d975bd90e4cda9142423568d0cfa",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 19, 2024Category:TechnicalTagsjavascriptreacthookscachingtutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.061,
        "word_count": 733,
        "chunk_id": "9e9af7fc5b217c8729ad2eda33ded533",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "section",
        "score": 1.065,
        "word_count": 964,
        "chunk_id": "a5f4d426c39bf5465e1d3f9a4cf3091b",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.",
        "chunk_type": "technical_content",
        "tag": "section",
        "score": 1.065,
        "word_count": 680,
        "chunk_id": "6de87e9dc9b66e4c0b0e5f7d950bad78",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.065,
        "word_count": 964,
        "chunk_id": "a5f4d426c39bf5465e1d3f9a4cf3091b",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "id": "/keyboard-shortcut-hook-react/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.065,
        "word_count": 680,
        "chunk_id": "6de87e9dc9b66e4c0b0e5f7d950bad78",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "id": "/keyboard-shortcut-hook-react/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 19, 2024Category:TechnicalTagsjavascriptreacthookscachingtutorialNewsletterSubscribe to the Newsletter",
        "chunk_type": "technical_content",
        "tag": "aside",
        "score": 0.43600000000000005,
        "word_count": 54,
        "chunk_id": "0e4fa4fd0255579b9e96b315cceaa2a9",
        "metadata": {
          "source_tag": "aside",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "post-sidebar"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript"
          ]
        }
      },
      {
        "content": "import{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])}",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.905,
        "word_count": 78,
        "chunk_id": "ebd5d91fda9a81085d76425e33f6380c",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "js"
          },
          "technical_indicators": [
            "react",
            "javascript",
            "data"
          ]
        }
      },
      {
        "content": "import{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])}",
        "chunk_type": "technical_content",
        "tag": "pre",
        "score": 0.905,
        "word_count": 78,
        "chunk_id": "ebd5d91fda9a81085d76425e33f6380c",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "data"
          ]
        }
      },
      {
        "content": "import{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])}",
        "chunk_type": "technical_content",
        "tag": "code",
        "score": 0.905,
        "word_count": 78,
        "chunk_id": "ebd5d91fda9a81085d76425e33f6380c",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "data"
          ]
        }
      },
      {
        "content": "import{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])}",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.319,
        "word_count": 96,
        "chunk_id": "9fc296682936c5b5423fccb2230495b6",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "js"
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "import{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])}",
        "chunk_type": "technical_content",
        "tag": "pre",
        "score": 1.319,
        "word_count": 96,
        "chunk_id": "9fc296682936c5b5423fccb2230495b6",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "style": "counter-reset: linenumber 0",
            "class": [
              "language-js",
              "line-numbers"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "import{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])}",
        "chunk_type": "technical_content",
        "tag": "code",
        "score": 1.319,
        "word_count": 96,
        "chunk_id": "9fc296682936c5b5423fccb2230495b6",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "import{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...}",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.599,
        "word_count": 25,
        "chunk_id": "d2792864accec3abc015628114e83b5f",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "js"
          },
          "technical_indicators": [
            "javascript",
            "data"
          ]
        }
      },
      {
        "content": "import{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...}",
        "chunk_type": "technical_content",
        "tag": "pre",
        "score": 0.599,
        "word_count": 25,
        "chunk_id": "d2792864accec3abc015628114e83b5f",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "javascript",
            "data"
          ]
        }
      },
      {
        "content": "import{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...}",
        "chunk_type": "technical_content",
        "tag": "code",
        "score": 0.599,
        "word_count": 25,
        "chunk_id": "d2792864accec3abc015628114e83b5f",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "javascript",
            "data"
          ]
        }
      },
      {
        "content": "exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...}",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.30600000000000005,
        "word_count": 11,
        "chunk_id": "450994c7d656efe33ad0e45947012b7e",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "js"
          },
          "technical_indicators": [
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...}",
        "chunk_type": "technical_content",
        "tag": "pre",
        "score": 0.30600000000000005,
        "word_count": 11,
        "chunk_id": "450994c7d656efe33ad0e45947012b7e",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...}",
        "chunk_type": "technical_content",
        "tag": "code",
        "score": 0.30600000000000005,
        "word_count": 11,
        "chunk_id": "450994c7d656efe33ad0e45947012b7e",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "javascript",
            "sql"
          ]
        }
      }
    ],
    "chunk_count": 27,
    "content_types": [
      "code_markup",
      "technical_content"
    ],
    "technical_concepts": [
      "javascript",
      "data",
      "react",
      "sql"
    ],
    "crawl_metadata": {},
    "technical_content": [
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f0f0802505b28ff454f40670ef0cd5c9",
        "content": "useLayoutEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a43c1b0aa53a0c908810c06ab1ff3967",
        "content": "input",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6394d816bfb4220289a6f4b29cfb1834",
        "content": "textarea",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c8c2fb4e60f621aa8f72ba72405f9581",
        "content": "contenteditable",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "07f8f832fb06410d18ba1e1d8df4a751",
        "content": "useShortcut('Command+Shift+X', () => console.log(' Hola, mundo!'))",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "07f8f832fb06410d18ba1e1d8df4a751",
        "content": "useShortcut('Command+Shift+X', () => console.log(' Hola, mundo!'))",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "096672df389fb56cdc6e320583c65488",
        "content": "count, setCount",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7dfac8369abd7b5bb0af524aa2369f03",
        "content": "import { useState } from 'react' export default function App() { const [count, setCount] = useState(0) return ( <div> <button type=\"button\" onClick={() => setCount((prev) => prev + 1)}> { Count: {count} } </button> <button type=\"button\" onClick={() => setCount(0)}> Clear </button> <input type=\"text\" placeholder=\"Type a shortcut key\" /> </div> ) }",
        "type": "code",
        "language": "js",
        "relevance": 1.1105263157894738
      },
      {
        "id": "7dfac8369abd7b5bb0af524aa2369f03",
        "content": "import { useState } from 'react' export default function App() { const [count, setCount] = useState(0) return ( <div> <button type=\"button\" onClick={() => setCount((prev) => prev + 1)}> { Count: {count} } </button> <button type=\"button\" onClick={() => setCount(0)}> Clear </button> <input type=\"text\" placeholder=\"Type a shortcut key\" /> </div> ) }",
        "type": "code",
        "language": "js",
        "relevance": 1.1105263157894738
      },
      {
        "id": "a43c1b0aa53a0c908810c06ab1ff3967",
        "content": "input",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5a382f607841ee504c8d5d946c2fac94",
        "content": "useShortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5a382f607841ee504c8d5d946c2fac94",
        "content": "useShortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "58a8164e81e6261ac277ad2b4911c7fc",
        "content": "import { useState } from 'react' import { useShortcut } from './useShortcut' export default function App() { const [count, setCount] = useState(0) useShortcut('a', () => { setCount((prev) => prev + 1) }) return <div>{/* ... */}</div> }",
        "type": "code",
        "language": "js",
        "relevance": 0.9105263157894736
      },
      {
        "id": "58a8164e81e6261ac277ad2b4911c7fc",
        "content": "import { useState } from 'react' import { useShortcut } from './useShortcut' export default function App() { const [count, setCount] = useState(0) useShortcut('a', () => { setCount((prev) => prev + 1) }) return <div>{/* ... */}</div> }",
        "type": "code",
        "language": "js",
        "relevance": 0.9105263157894736
      },
      {
        "id": "5a382f607841ee504c8d5d946c2fac94",
        "content": "useShortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c0954f37465ac52acf4a22c5e1c5bf87",
        "content": "shortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "924a8ceeac17f54d3be3f8cdf1c04eb2",
        "content": "callback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cc87d1a0cdab463949001e224ba39371",
        "content": "handleKeyDown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c0954f37465ac52acf4a22c5e1c5bf87",
        "content": "shortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6ca5a13e7adad4ae151fe6500021eb96",
        "content": "event.key",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2959b6433abb3a4138a42ddda695c171",
        "content": "keydown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6d81f8b7989760ca2833a4aec03f1713",
        "content": "import { useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const handleKeyDown = (event) => { // Single key shortcuts (e.g. pressing a) if (shortcut === event.key) { return callback(event) } } useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }) }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "6d81f8b7989760ca2833a4aec03f1713",
        "content": "import { useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const handleKeyDown = (event) => { // Single key shortcuts (e.g. pressing a) if (shortcut === event.key) { return callback(event) } } useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }) }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cc87d1a0cdab463949001e224ba39371",
        "content": "handleKeyDown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "86000955b44e4f8640a21bd77aff6aa6",
        "content": "useMemo",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5789917c46ed70321e72360ff87926da",
        "content": "import { useCallback, useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const handleKeyDown = useCallback((event) => { // Single key shortcuts (e.g. pressing a) if (shortcut === event.key) { return callback(event) } }, []) useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }, [handleKeyDown])}",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "5789917c46ed70321e72360ff87926da",
        "content": "import { useCallback, useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const handleKeyDown = useCallback((event) => { // Single key shortcuts (e.g. pressing a) if (shortcut === event.key) { return callback(event) } }, []) useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }, [handleKeyDown])}",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "cc87d1a0cdab463949001e224ba39371",
        "content": "handleKeyDown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2959b6433abb3a4138a42ddda695c171",
        "content": "keydown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "80c2b4168fdae9029cfa9f29093bcfe3",
        "content": "setCount",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03ce4e517700d276d9173a7981a46a5a",
        "content": "setCount(prev => prev + 1)",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "158ea57c8f335461fb60566922b17a99",
        "content": "setCount(count + 1)",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e2942a04780e223b215eb8b663cf5353",
        "content": "count",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "075363380323b4799196ff5108cc951d",
        "content": "setState",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "e2942a04780e223b215eb8b663cf5353",
        "content": "count",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "00e8228ac71b3ae4fac2d47c93d98573",
        "content": "useShortcut('w', () => { setCount(count + count) })",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "00e8228ac71b3ae4fac2d47c93d98573",
        "content": "useShortcut('w', () => { setCount(count + count) })",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e2942a04780e223b215eb8b663cf5353",
        "content": "count",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "df853da39d97ebdf11e1f7e4c64db18a",
        "content": "count + count",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "eccbc87e4b5ce2fe28308fd9f2a7baf3",
        "content": "3",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1679091c5a880faf6fb5e6087eb1b2dc",
        "content": "6",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cfcd208495d565ef66e7dff9f98764da",
        "content": "0",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e2942a04780e223b215eb8b663cf5353",
        "content": "count",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "019aedfd528fc058f508edab1bb3b0ae",
        "content": "const handleW = useCallback(() => setCount(count + count), [count]) useShortcut('w', handleW)",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "019aedfd528fc058f508edab1bb3b0ae",
        "content": "const handleW = useCallback(() => setCount(count + count), [count]) useShortcut('w', handleW)",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "924a8ceeac17f54d3be3f8cdf1c04eb2",
        "content": "callback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cc87d1a0cdab463949001e224ba39371",
        "content": "handleKeyDown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "57b57638081f8f7cd81e57984a887634",
        "content": "useShotcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f0f0802505b28ff454f40670ef0cd5c9",
        "content": "useLayoutEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f0f0802505b28ff454f40670ef0cd5c9",
        "content": "useLayoutEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e86732df9d58dd6085e369915a018e63",
        "content": "import { useRef, useLayoutEffect, useCallback, useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const callbackRef = useRef(callback) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback((event) => { if (shortcut === event.key) { return callbackRef.current(event) } }, []) useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }, [handleKeyDown]) }",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "e86732df9d58dd6085e369915a018e63",
        "content": "import { useRef, useLayoutEffect, useCallback, useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const callbackRef = useRef(callback) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback((event) => { if (shortcut === event.key) { return callbackRef.current(event) } }, []) useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }, [handleKeyDown]) }",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "e2942a04780e223b215eb8b663cf5353",
        "content": "count",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5a382f607841ee504c8d5d946c2fac94",
        "content": "useShortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "77961215613b33241db00e28fcf69ad7",
        "content": "if (shortcut === event.key)",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4119639092e62c55ea8be348e4d9260d",
        "content": "event",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "25baf3402df19c373ea5f458e64cad8d",
        "content": "event.ctrlKey",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "3a132bf6b1b1359e934e7948db2e8c27",
        "content": "event.altKey",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "8f8ddef66e36eeebaa79b2d8c3fe9fb8",
        "content": "event.metaKey",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "0bf017792a71d415204285d4a11f4be0",
        "content": "event.shiftKey",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "0bf017792a71d415204285d4a11f4be0",
        "content": "event.shiftKey",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b326b5062b2f0e69046810717534cb09",
        "content": "true",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "47f6478eb87886529d1a239bb34ae33b",
        "content": "useShortcut('Control+C', () => { setCount(count + count) }) useShortcut('Command+Shift+X', () => { setCount(count + count) })",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "47f6478eb87886529d1a239bb34ae33b",
        "content": "useShortcut('Control+C', () => { setCount(count + count) }) useShortcut('Command+Shift+X', () => { setCount(count + count) })",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "26b17225b626fb9238849fd60eabdf60",
        "content": "+",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d0c1d488426c0f5d4d7ca38a69a98ffa",
        "content": "import { useRef, useLayoutEffect, useCallback, useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const callbackRef = useRef(callback) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback((event) => { const modifierMap = { Control: event.ctrlKey, Alt: event.altKey, Command: event.metaKey, Shift: event.shiftKey, } if (shortcut.includes('+')) { const keyArray = shortcut.split('+') // If the first key is a modifier, handle combinations if (Object.keys(modifierMap).includes(keyArray[0])) { const finalKey = keyArray.pop() // Run handler if the modifier(s) + key have both been pressed if (keyArray.every((k) => modifierMap[k]) finalKey === event.key) { return callbackRef.current(event) } } } if (shortcut === event.key) { return callbackRef.current(event) } }, []) // ... }",
        "type": "code",
        "language": "js",
        "relevance": 0.9052631578947368
      },
      {
        "id": "d0c1d488426c0f5d4d7ca38a69a98ffa",
        "content": "import { useRef, useLayoutEffect, useCallback, useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const callbackRef = useRef(callback) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback((event) => { const modifierMap = { Control: event.ctrlKey, Alt: event.altKey, Command: event.metaKey, Shift: event.shiftKey, } if (shortcut.includes('+')) { const keyArray = shortcut.split('+') // If the first key is a modifier, handle combinations if (Object.keys(modifierMap).includes(keyArray[0])) { const finalKey = keyArray.pop() // Run handler if the modifier(s) + key have both been pressed if (keyArray.every((k) => modifierMap[k]) finalKey === event.key) { return callbackRef.current(event) } } } if (shortcut === event.key) { return callbackRef.current(event) } }, []) // ... }",
        "type": "code",
        "language": "js",
        "relevance": 0.9052631578947368
      },
      {
        "id": "93da65a9fd0004d9477aeac024e08e15",
        "content": "options",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5a382f607841ee504c8d5d946c2fac94",
        "content": "useShortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7ac5a96aa06eab8a0e0fc327b7534f23",
        "content": "disableTextInputs: true",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "60a817081688675aef6249793b89c87d",
        "content": "HTMLTextAreaElement",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "44c146087f94f53b411690f3e6831db2",
        "content": "HTMLInputElement",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "599dcce2998a6b40b1e38e8c6006cb0a",
        "content": "type",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1cb251ec0d568de6a929b520c4aed8d1",
        "content": "text",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c8c2fb4e60f621aa8f72ba72405f9581",
        "content": "contenteditable",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "08d2df373d04ea3a56b181886b1fb4d3",
        "content": "export const useShortcut = ( shortcut, callback, options = { disableTextInputs: true }) => { const callbackRef = useRef(callback) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback((event) => { const isTextInput = event.target instanceof HTMLTextAreaElement (event.target instanceof HTMLInputElement (!event.target.type event.target.type === 'text')) event.target.isContentEditable // Don't enable shortcuts in inputs unless explicitly declared if (options.disableTextInputs isTextInput) { return event.stopPropagation() } // ... }, []) // ... }",
        "type": "code",
        "language": "js",
        "relevance": 0.9052631578947368
      },
      {
        "id": "08d2df373d04ea3a56b181886b1fb4d3",
        "content": "export const useShortcut = ( shortcut, callback, options = { disableTextInputs: true }) => { const callbackRef = useRef(callback) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback((event) => { const isTextInput = event.target instanceof HTMLTextAreaElement (event.target instanceof HTMLInputElement (!event.target.type event.target.type === 'text')) event.target.isContentEditable // Don't enable shortcuts in inputs unless explicitly declared if (options.disableTextInputs isTextInput) { return event.stopPropagation() } // ... }, []) // ... }",
        "type": "code",
        "language": "js",
        "relevance": 0.9052631578947368
      },
      {
        "id": "351ac178246fc29e75bc20cf02e349c6",
        "content": "tagName",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f9b4a8362b0f49ad2e70a6fe73807c71",
        "content": "\"INPUT\"",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1dfa33e3512e2bdd8ae3a54dd2c851fa",
        "content": "const handleKonamiCode = () => { /* ... */ } useShortcut( ArrowUp+ArrowUp+ ArrowDown+ArrowDown+ ArrowLeft+ArrowRight+ ArrowLeft+ArrowRight+ b+a , handleKonamiCode )",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1dfa33e3512e2bdd8ae3a54dd2c851fa",
        "content": "const handleKonamiCode = () => { /* ... */ } useShortcut( ArrowUp+ArrowUp+ ArrowDown+ArrowDown+ ArrowLeft+ArrowRight+ ArrowLeft+ArrowRight+ b+a , handleKonamiCode )",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "35c4003175f41503270e3c3eed6e0f63",
        "content": "keyCombo",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "26b17225b626fb9238849fd60eabdf60",
        "content": "+",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "35c4003175f41503270e3c3eed6e0f63",
        "content": "keyCombo",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d26317c9ef01f31c0df0fa5cc91b1696",
        "content": "import { useCallback, useRef, useLayoutEffect, useState, useEffect, } from 'react' export const useShortcut = ( shortcut, callback, options = { disableTextInputs: true } ) => { const callbackRef = useRef(callback) const [keyCombo, setKeyCombo] = useState([]) // ... const handleKeyDown = useCallback( (event) => { // ... // Handle combined modifier key shortcuts (e.g. pressing Control + D) if (shortcut.includes('+')) { const keyArray = shortcut.split('+') // If the first key is a modifier, handle combinations if (Object.keys(modifierMap).includes(keyArray[0])) { const finalKey = keyArray.pop() // Run handler if the modifier(s) + key have both been pressed if (keyArray.every((k) => modifierMap[k]) finalKey === event.key) { return callbackRef.current(event) } } else { // If the shortcut doesn't begin with a modifier, it's a sequence if (keyArray[keyCombo.length] === event.key) { // Handle final key in the sequence if ( keyArray[keyArray.length - 1] === event.key keyCombo.length === keyArray.length - 1 ) { // Run handler if the sequence is complete, then reset it callbackRef.current(event) return setKeyCombo([]) } // Add to the sequence return setKeyCombo((prevCombo) => [...prevCombo, event.key]) } if (keyCombo.length > 0) { // Reset key combo if it doesn't match the sequence return setKeyCombo([]) } } } // ... }, [keyCombo.length] ) // ... }, [handleKeyDown]) }",
        "type": "code",
        "language": "js",
        "relevance": 1.0105263157894737
      },
      {
        "id": "d26317c9ef01f31c0df0fa5cc91b1696",
        "content": "import { useCallback, useRef, useLayoutEffect, useState, useEffect, } from 'react' export const useShortcut = ( shortcut, callback, options = { disableTextInputs: true } ) => { const callbackRef = useRef(callback) const [keyCombo, setKeyCombo] = useState([]) // ... const handleKeyDown = useCallback( (event) => { // ... // Handle combined modifier key shortcuts (e.g. pressing Control + D) if (shortcut.includes('+')) { const keyArray = shortcut.split('+') // If the first key is a modifier, handle combinations if (Object.keys(modifierMap).includes(keyArray[0])) { const finalKey = keyArray.pop() // Run handler if the modifier(s) + key have both been pressed if (keyArray.every((k) => modifierMap[k]) finalKey === event.key) { return callbackRef.current(event) } } else { // If the shortcut doesn't begin with a modifier, it's a sequence if (keyArray[keyCombo.length] === event.key) { // Handle final key in the sequence if ( keyArray[keyArray.length - 1] === event.key keyCombo.length === keyArray.length - 1 ) { // Run handler if the sequence is complete, then reset it callbackRef.current(event) return setKeyCombo([]) } // Add to the sequence return setKeyCombo((prevCombo) => [...prevCombo, event.key]) } if (keyCombo.length > 0) { // Reset key combo if it doesn't match the sequence return setKeyCombo([]) } } } // ... }, [keyCombo.length] ) // ... }, [handleKeyDown]) }",
        "type": "code",
        "language": "js",
        "relevance": 1.0105263157894737
      },
      {
        "id": "35c4003175f41503270e3c3eed6e0f63",
        "content": "keyCombo",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "36dddab315a457fbe808b5f82e31014a",
        "content": "handleKeyPress",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5a382f607841ee504c8d5d946c2fac94",
        "content": "useShortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "95e1608661cf66ab1b2e28b9d3679fcb",
        "content": "event.repeat",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "014ef6476dd8a57e2057e639d42d6072",
        "content": "import { useCallback, useRef, useLayoutEffect, useState, useEffect } from 'react' export const useShortcut = (shortcut, callback, options = { disableTextInputs: true }) => { const callbackRef = useRef(callback) const [keyCombo, setKeyCombo] = useState([]) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback( (event) => { const isTextInput = event.target instanceof HTMLTextAreaElement (event.target instanceof HTMLInputElement (!event.target.type event.target.type === 'text')) event.target.isContentEditable const modifierMap = { Control: event.ctrlKey, Alt: event.altKey, Command: event.metaKey, Shift: event.shiftKey, } // Cancel shortcut if key is being held down if (event.repeat) { return null } // Don't enable shortcuts in inputs unless explicitly declared if (options.disableTextInputs isTextInput) { return event.stopPropagation() } // Handle combined modifier key shortcuts (e.g. pressing Control + D) if (shortcut.includes('+')) { const keyArray = shortcut.split('+') // If the first key is a modifier, handle combinations if (Object.keys(modifierMap).includes(keyArray[0])) { const finalKey = keyArray.pop() // Run handler if the modifier(s) + key have both been pressed if (keyArray.every((k) => modifierMap[k]) finalKey === event.key) { return callbackRef.current(event) } } else { // If the shortcut doesn't begin with a modifier, it's a sequence if (keyArray[keyCombo.length] === event.key) { // Handle final key in the sequence if ( keyArray[keyArray.length - 1] === event.key keyCombo.length === keyArray.length - 1 ) { // Run handler if the sequence is complete, then reset it callbackRef.current(event) return setKeyCombo([]) } // Add to the sequence return setKeyCombo((prevCombo) => [...prevCombo, event.key]) } if (keyCombo.length > 0) { // Reset key combo if it doesn't match the sequence return setKeyCombo([]) } } } // Single key shortcuts (e.g. pressing D) if (shortcut === event.key) { return callbackRef.current(event) } }, [keyCombo.length] ) useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }, [handleKeyDown]) }",
        "type": "code",
        "language": "js",
        "relevance": 1.1157894736842104
      },
      {
        "id": "014ef6476dd8a57e2057e639d42d6072",
        "content": "import { useCallback, useRef, useLayoutEffect, useState, useEffect } from 'react' export const useShortcut = (shortcut, callback, options = { disableTextInputs: true }) => { const callbackRef = useRef(callback) const [keyCombo, setKeyCombo] = useState([]) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback( (event) => { const isTextInput = event.target instanceof HTMLTextAreaElement (event.target instanceof HTMLInputElement (!event.target.type event.target.type === 'text')) event.target.isContentEditable const modifierMap = { Control: event.ctrlKey, Alt: event.altKey, Command: event.metaKey, Shift: event.shiftKey, } // Cancel shortcut if key is being held down if (event.repeat) { return null } // Don't enable shortcuts in inputs unless explicitly declared if (options.disableTextInputs isTextInput) { return event.stopPropagation() } // Handle combined modifier key shortcuts (e.g. pressing Control + D) if (shortcut.includes('+')) { const keyArray = shortcut.split('+') // If the first key is a modifier, handle combinations if (Object.keys(modifierMap).includes(keyArray[0])) { const finalKey = keyArray.pop() // Run handler if the modifier(s) + key have both been pressed if (keyArray.every((k) => modifierMap[k]) finalKey === event.key) { return callbackRef.current(event) } } else { // If the shortcut doesn't begin with a modifier, it's a sequence if (keyArray[keyCombo.length] === event.key) { // Handle final key in the sequence if ( keyArray[keyArray.length - 1] === event.key keyCombo.length === keyArray.length - 1 ) { // Run handler if the sequence is complete, then reset it callbackRef.current(event) return setKeyCombo([]) } // Add to the sequence return setKeyCombo((prevCombo) => [...prevCombo, event.key]) } if (keyCombo.length > 0) { // Reset key combo if it doesn't match the sequence return setKeyCombo([]) } } } // Single key shortcuts (e.g. pressing D) if (shortcut === event.key) { return callbackRef.current(event) } }, [keyCombo.length] ) useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }, [handleKeyDown]) }",
        "type": "code",
        "language": "js",
        "relevance": 1.1157894736842104
      },
      {
        "id": "6ca5a13e7adad4ae151fe6500021eb96",
        "content": "event.key",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      }
    ]
  },
  {
    "metadata": {
      "description": "Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article…",
      "url": "https://www.taniarascia.com/keyboard-shortcut-hook-react/#holding-onto-stale-state",
      "title": "Creating a Keyboard Shortcut Hook in React (Deep Dive) | Tania Rascia's Personal Website",
      "source_type": "web",
      "crawl_time": 1730107230.5742779,
      "keywords": [
        "sql",
        "web",
        "article",
        "extract",
        "development",
        "information",
        "react"
      ]
    },
    "relevance_score": 0.9145555555555556,
    "chunks": [
      {
        "content": "Creating a Keyboard Shortcut Hook in React (Deep Dive)Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "main",
        "score": 1.061,
        "word_count": 972,
        "chunk_id": "0705d975bd90e4cda9142423568d0cfa",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 19, 2024Category:TechnicalTagsjavascriptreacthookscachingtutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "main",
        "score": 1.061,
        "word_count": 733,
        "chunk_id": "9e9af7fc5b217c8729ad2eda33ded533",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "Creating a Keyboard Shortcut Hook in React (Deep Dive)Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.061,
        "word_count": 972,
        "chunk_id": "0705d975bd90e4cda9142423568d0cfa",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 19, 2024Category:TechnicalTagsjavascriptreacthookscachingtutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.061,
        "word_count": 733,
        "chunk_id": "9e9af7fc5b217c8729ad2eda33ded533",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "Creating a Keyboard Shortcut Hook in React (Deep Dive)Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.061,
        "word_count": 972,
        "chunk_id": "0705d975bd90e4cda9142423568d0cfa",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 19, 2024Category:TechnicalTagsjavascriptreacthookscachingtutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.061,
        "word_count": 733,
        "chunk_id": "9e9af7fc5b217c8729ad2eda33ded533",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "Creating a Keyboard Shortcut Hook in React (Deep Dive)Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.061,
        "word_count": 972,
        "chunk_id": "0705d975bd90e4cda9142423568d0cfa",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 19, 2024Category:TechnicalTagsjavascriptreacthookscachingtutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.061,
        "word_count": 733,
        "chunk_id": "9e9af7fc5b217c8729ad2eda33ded533",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "Creating a Keyboard Shortcut Hook in React (Deep Dive)Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.061,
        "word_count": 972,
        "chunk_id": "0705d975bd90e4cda9142423568d0cfa",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 19, 2024Category:TechnicalTagsjavascriptreacthookscachingtutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.061,
        "word_count": 733,
        "chunk_id": "9e9af7fc5b217c8729ad2eda33ded533",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "section",
        "score": 1.065,
        "word_count": 964,
        "chunk_id": "a5f4d426c39bf5465e1d3f9a4cf3091b",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.",
        "chunk_type": "technical_content",
        "tag": "section",
        "score": 1.065,
        "word_count": 680,
        "chunk_id": "6de87e9dc9b66e4c0b0e5f7d950bad78",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.065,
        "word_count": 964,
        "chunk_id": "a5f4d426c39bf5465e1d3f9a4cf3091b",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "id": "/keyboard-shortcut-hook-react/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.065,
        "word_count": 680,
        "chunk_id": "6de87e9dc9b66e4c0b0e5f7d950bad78",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "id": "/keyboard-shortcut-hook-react/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 19, 2024Category:TechnicalTagsjavascriptreacthookscachingtutorialNewsletterSubscribe to the Newsletter",
        "chunk_type": "technical_content",
        "tag": "aside",
        "score": 0.43600000000000005,
        "word_count": 54,
        "chunk_id": "0e4fa4fd0255579b9e96b315cceaa2a9",
        "metadata": {
          "source_tag": "aside",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "post-sidebar"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript"
          ]
        }
      },
      {
        "content": "import{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])}",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.905,
        "word_count": 78,
        "chunk_id": "ebd5d91fda9a81085d76425e33f6380c",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "js"
          },
          "technical_indicators": [
            "react",
            "javascript",
            "data"
          ]
        }
      },
      {
        "content": "import{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])}",
        "chunk_type": "technical_content",
        "tag": "pre",
        "score": 0.905,
        "word_count": 78,
        "chunk_id": "ebd5d91fda9a81085d76425e33f6380c",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "data"
          ]
        }
      },
      {
        "content": "import{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])}",
        "chunk_type": "technical_content",
        "tag": "code",
        "score": 0.905,
        "word_count": 78,
        "chunk_id": "ebd5d91fda9a81085d76425e33f6380c",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "data"
          ]
        }
      },
      {
        "content": "import{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])}",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.319,
        "word_count": 96,
        "chunk_id": "9fc296682936c5b5423fccb2230495b6",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "js"
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "import{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])}",
        "chunk_type": "technical_content",
        "tag": "pre",
        "score": 1.319,
        "word_count": 96,
        "chunk_id": "9fc296682936c5b5423fccb2230495b6",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "style": "counter-reset: linenumber 0",
            "class": [
              "language-js",
              "line-numbers"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "import{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])}",
        "chunk_type": "technical_content",
        "tag": "code",
        "score": 1.319,
        "word_count": 96,
        "chunk_id": "9fc296682936c5b5423fccb2230495b6",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "import{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...}",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.599,
        "word_count": 25,
        "chunk_id": "d2792864accec3abc015628114e83b5f",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "js"
          },
          "technical_indicators": [
            "javascript",
            "data"
          ]
        }
      },
      {
        "content": "import{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...}",
        "chunk_type": "technical_content",
        "tag": "pre",
        "score": 0.599,
        "word_count": 25,
        "chunk_id": "d2792864accec3abc015628114e83b5f",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "javascript",
            "data"
          ]
        }
      },
      {
        "content": "import{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...}",
        "chunk_type": "technical_content",
        "tag": "code",
        "score": 0.599,
        "word_count": 25,
        "chunk_id": "d2792864accec3abc015628114e83b5f",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "javascript",
            "data"
          ]
        }
      },
      {
        "content": "exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...}",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.30600000000000005,
        "word_count": 11,
        "chunk_id": "450994c7d656efe33ad0e45947012b7e",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "js"
          },
          "technical_indicators": [
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...}",
        "chunk_type": "technical_content",
        "tag": "pre",
        "score": 0.30600000000000005,
        "word_count": 11,
        "chunk_id": "450994c7d656efe33ad0e45947012b7e",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...}",
        "chunk_type": "technical_content",
        "tag": "code",
        "score": 0.30600000000000005,
        "word_count": 11,
        "chunk_id": "450994c7d656efe33ad0e45947012b7e",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "javascript",
            "sql"
          ]
        }
      }
    ],
    "chunk_count": 27,
    "content_types": [
      "code_markup",
      "technical_content"
    ],
    "technical_concepts": [
      "javascript",
      "data",
      "react",
      "sql"
    ],
    "crawl_metadata": {},
    "technical_content": [
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f0f0802505b28ff454f40670ef0cd5c9",
        "content": "useLayoutEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a43c1b0aa53a0c908810c06ab1ff3967",
        "content": "input",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6394d816bfb4220289a6f4b29cfb1834",
        "content": "textarea",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c8c2fb4e60f621aa8f72ba72405f9581",
        "content": "contenteditable",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "07f8f832fb06410d18ba1e1d8df4a751",
        "content": "useShortcut('Command+Shift+X', () => console.log(' Hola, mundo!'))",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "07f8f832fb06410d18ba1e1d8df4a751",
        "content": "useShortcut('Command+Shift+X', () => console.log(' Hola, mundo!'))",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "096672df389fb56cdc6e320583c65488",
        "content": "count, setCount",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7dfac8369abd7b5bb0af524aa2369f03",
        "content": "import { useState } from 'react' export default function App() { const [count, setCount] = useState(0) return ( <div> <button type=\"button\" onClick={() => setCount((prev) => prev + 1)}> { Count: {count} } </button> <button type=\"button\" onClick={() => setCount(0)}> Clear </button> <input type=\"text\" placeholder=\"Type a shortcut key\" /> </div> ) }",
        "type": "code",
        "language": "js",
        "relevance": 1.1105263157894738
      },
      {
        "id": "7dfac8369abd7b5bb0af524aa2369f03",
        "content": "import { useState } from 'react' export default function App() { const [count, setCount] = useState(0) return ( <div> <button type=\"button\" onClick={() => setCount((prev) => prev + 1)}> { Count: {count} } </button> <button type=\"button\" onClick={() => setCount(0)}> Clear </button> <input type=\"text\" placeholder=\"Type a shortcut key\" /> </div> ) }",
        "type": "code",
        "language": "js",
        "relevance": 1.1105263157894738
      },
      {
        "id": "a43c1b0aa53a0c908810c06ab1ff3967",
        "content": "input",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5a382f607841ee504c8d5d946c2fac94",
        "content": "useShortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5a382f607841ee504c8d5d946c2fac94",
        "content": "useShortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "58a8164e81e6261ac277ad2b4911c7fc",
        "content": "import { useState } from 'react' import { useShortcut } from './useShortcut' export default function App() { const [count, setCount] = useState(0) useShortcut('a', () => { setCount((prev) => prev + 1) }) return <div>{/* ... */}</div> }",
        "type": "code",
        "language": "js",
        "relevance": 0.9105263157894736
      },
      {
        "id": "58a8164e81e6261ac277ad2b4911c7fc",
        "content": "import { useState } from 'react' import { useShortcut } from './useShortcut' export default function App() { const [count, setCount] = useState(0) useShortcut('a', () => { setCount((prev) => prev + 1) }) return <div>{/* ... */}</div> }",
        "type": "code",
        "language": "js",
        "relevance": 0.9105263157894736
      },
      {
        "id": "5a382f607841ee504c8d5d946c2fac94",
        "content": "useShortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c0954f37465ac52acf4a22c5e1c5bf87",
        "content": "shortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "924a8ceeac17f54d3be3f8cdf1c04eb2",
        "content": "callback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cc87d1a0cdab463949001e224ba39371",
        "content": "handleKeyDown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c0954f37465ac52acf4a22c5e1c5bf87",
        "content": "shortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6ca5a13e7adad4ae151fe6500021eb96",
        "content": "event.key",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2959b6433abb3a4138a42ddda695c171",
        "content": "keydown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6d81f8b7989760ca2833a4aec03f1713",
        "content": "import { useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const handleKeyDown = (event) => { // Single key shortcuts (e.g. pressing a) if (shortcut === event.key) { return callback(event) } } useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }) }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "6d81f8b7989760ca2833a4aec03f1713",
        "content": "import { useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const handleKeyDown = (event) => { // Single key shortcuts (e.g. pressing a) if (shortcut === event.key) { return callback(event) } } useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }) }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cc87d1a0cdab463949001e224ba39371",
        "content": "handleKeyDown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "86000955b44e4f8640a21bd77aff6aa6",
        "content": "useMemo",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5789917c46ed70321e72360ff87926da",
        "content": "import { useCallback, useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const handleKeyDown = useCallback((event) => { // Single key shortcuts (e.g. pressing a) if (shortcut === event.key) { return callback(event) } }, []) useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }, [handleKeyDown])}",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "5789917c46ed70321e72360ff87926da",
        "content": "import { useCallback, useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const handleKeyDown = useCallback((event) => { // Single key shortcuts (e.g. pressing a) if (shortcut === event.key) { return callback(event) } }, []) useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }, [handleKeyDown])}",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "cc87d1a0cdab463949001e224ba39371",
        "content": "handleKeyDown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2959b6433abb3a4138a42ddda695c171",
        "content": "keydown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "80c2b4168fdae9029cfa9f29093bcfe3",
        "content": "setCount",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03ce4e517700d276d9173a7981a46a5a",
        "content": "setCount(prev => prev + 1)",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "158ea57c8f335461fb60566922b17a99",
        "content": "setCount(count + 1)",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e2942a04780e223b215eb8b663cf5353",
        "content": "count",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "075363380323b4799196ff5108cc951d",
        "content": "setState",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "e2942a04780e223b215eb8b663cf5353",
        "content": "count",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "00e8228ac71b3ae4fac2d47c93d98573",
        "content": "useShortcut('w', () => { setCount(count + count) })",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "00e8228ac71b3ae4fac2d47c93d98573",
        "content": "useShortcut('w', () => { setCount(count + count) })",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e2942a04780e223b215eb8b663cf5353",
        "content": "count",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "df853da39d97ebdf11e1f7e4c64db18a",
        "content": "count + count",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "eccbc87e4b5ce2fe28308fd9f2a7baf3",
        "content": "3",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1679091c5a880faf6fb5e6087eb1b2dc",
        "content": "6",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cfcd208495d565ef66e7dff9f98764da",
        "content": "0",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e2942a04780e223b215eb8b663cf5353",
        "content": "count",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "019aedfd528fc058f508edab1bb3b0ae",
        "content": "const handleW = useCallback(() => setCount(count + count), [count]) useShortcut('w', handleW)",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "019aedfd528fc058f508edab1bb3b0ae",
        "content": "const handleW = useCallback(() => setCount(count + count), [count]) useShortcut('w', handleW)",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "924a8ceeac17f54d3be3f8cdf1c04eb2",
        "content": "callback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cc87d1a0cdab463949001e224ba39371",
        "content": "handleKeyDown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "57b57638081f8f7cd81e57984a887634",
        "content": "useShotcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f0f0802505b28ff454f40670ef0cd5c9",
        "content": "useLayoutEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f0f0802505b28ff454f40670ef0cd5c9",
        "content": "useLayoutEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e86732df9d58dd6085e369915a018e63",
        "content": "import { useRef, useLayoutEffect, useCallback, useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const callbackRef = useRef(callback) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback((event) => { if (shortcut === event.key) { return callbackRef.current(event) } }, []) useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }, [handleKeyDown]) }",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "e86732df9d58dd6085e369915a018e63",
        "content": "import { useRef, useLayoutEffect, useCallback, useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const callbackRef = useRef(callback) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback((event) => { if (shortcut === event.key) { return callbackRef.current(event) } }, []) useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }, [handleKeyDown]) }",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "e2942a04780e223b215eb8b663cf5353",
        "content": "count",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5a382f607841ee504c8d5d946c2fac94",
        "content": "useShortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "77961215613b33241db00e28fcf69ad7",
        "content": "if (shortcut === event.key)",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4119639092e62c55ea8be348e4d9260d",
        "content": "event",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "25baf3402df19c373ea5f458e64cad8d",
        "content": "event.ctrlKey",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "3a132bf6b1b1359e934e7948db2e8c27",
        "content": "event.altKey",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "8f8ddef66e36eeebaa79b2d8c3fe9fb8",
        "content": "event.metaKey",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "0bf017792a71d415204285d4a11f4be0",
        "content": "event.shiftKey",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "0bf017792a71d415204285d4a11f4be0",
        "content": "event.shiftKey",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b326b5062b2f0e69046810717534cb09",
        "content": "true",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "47f6478eb87886529d1a239bb34ae33b",
        "content": "useShortcut('Control+C', () => { setCount(count + count) }) useShortcut('Command+Shift+X', () => { setCount(count + count) })",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "47f6478eb87886529d1a239bb34ae33b",
        "content": "useShortcut('Control+C', () => { setCount(count + count) }) useShortcut('Command+Shift+X', () => { setCount(count + count) })",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "26b17225b626fb9238849fd60eabdf60",
        "content": "+",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d0c1d488426c0f5d4d7ca38a69a98ffa",
        "content": "import { useRef, useLayoutEffect, useCallback, useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const callbackRef = useRef(callback) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback((event) => { const modifierMap = { Control: event.ctrlKey, Alt: event.altKey, Command: event.metaKey, Shift: event.shiftKey, } if (shortcut.includes('+')) { const keyArray = shortcut.split('+') // If the first key is a modifier, handle combinations if (Object.keys(modifierMap).includes(keyArray[0])) { const finalKey = keyArray.pop() // Run handler if the modifier(s) + key have both been pressed if (keyArray.every((k) => modifierMap[k]) finalKey === event.key) { return callbackRef.current(event) } } } if (shortcut === event.key) { return callbackRef.current(event) } }, []) // ... }",
        "type": "code",
        "language": "js",
        "relevance": 0.9052631578947368
      },
      {
        "id": "d0c1d488426c0f5d4d7ca38a69a98ffa",
        "content": "import { useRef, useLayoutEffect, useCallback, useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const callbackRef = useRef(callback) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback((event) => { const modifierMap = { Control: event.ctrlKey, Alt: event.altKey, Command: event.metaKey, Shift: event.shiftKey, } if (shortcut.includes('+')) { const keyArray = shortcut.split('+') // If the first key is a modifier, handle combinations if (Object.keys(modifierMap).includes(keyArray[0])) { const finalKey = keyArray.pop() // Run handler if the modifier(s) + key have both been pressed if (keyArray.every((k) => modifierMap[k]) finalKey === event.key) { return callbackRef.current(event) } } } if (shortcut === event.key) { return callbackRef.current(event) } }, []) // ... }",
        "type": "code",
        "language": "js",
        "relevance": 0.9052631578947368
      },
      {
        "id": "93da65a9fd0004d9477aeac024e08e15",
        "content": "options",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5a382f607841ee504c8d5d946c2fac94",
        "content": "useShortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7ac5a96aa06eab8a0e0fc327b7534f23",
        "content": "disableTextInputs: true",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "60a817081688675aef6249793b89c87d",
        "content": "HTMLTextAreaElement",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "44c146087f94f53b411690f3e6831db2",
        "content": "HTMLInputElement",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "599dcce2998a6b40b1e38e8c6006cb0a",
        "content": "type",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1cb251ec0d568de6a929b520c4aed8d1",
        "content": "text",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c8c2fb4e60f621aa8f72ba72405f9581",
        "content": "contenteditable",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "08d2df373d04ea3a56b181886b1fb4d3",
        "content": "export const useShortcut = ( shortcut, callback, options = { disableTextInputs: true }) => { const callbackRef = useRef(callback) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback((event) => { const isTextInput = event.target instanceof HTMLTextAreaElement (event.target instanceof HTMLInputElement (!event.target.type event.target.type === 'text')) event.target.isContentEditable // Don't enable shortcuts in inputs unless explicitly declared if (options.disableTextInputs isTextInput) { return event.stopPropagation() } // ... }, []) // ... }",
        "type": "code",
        "language": "js",
        "relevance": 0.9052631578947368
      },
      {
        "id": "08d2df373d04ea3a56b181886b1fb4d3",
        "content": "export const useShortcut = ( shortcut, callback, options = { disableTextInputs: true }) => { const callbackRef = useRef(callback) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback((event) => { const isTextInput = event.target instanceof HTMLTextAreaElement (event.target instanceof HTMLInputElement (!event.target.type event.target.type === 'text')) event.target.isContentEditable // Don't enable shortcuts in inputs unless explicitly declared if (options.disableTextInputs isTextInput) { return event.stopPropagation() } // ... }, []) // ... }",
        "type": "code",
        "language": "js",
        "relevance": 0.9052631578947368
      },
      {
        "id": "351ac178246fc29e75bc20cf02e349c6",
        "content": "tagName",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f9b4a8362b0f49ad2e70a6fe73807c71",
        "content": "\"INPUT\"",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1dfa33e3512e2bdd8ae3a54dd2c851fa",
        "content": "const handleKonamiCode = () => { /* ... */ } useShortcut( ArrowUp+ArrowUp+ ArrowDown+ArrowDown+ ArrowLeft+ArrowRight+ ArrowLeft+ArrowRight+ b+a , handleKonamiCode )",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1dfa33e3512e2bdd8ae3a54dd2c851fa",
        "content": "const handleKonamiCode = () => { /* ... */ } useShortcut( ArrowUp+ArrowUp+ ArrowDown+ArrowDown+ ArrowLeft+ArrowRight+ ArrowLeft+ArrowRight+ b+a , handleKonamiCode )",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "35c4003175f41503270e3c3eed6e0f63",
        "content": "keyCombo",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "26b17225b626fb9238849fd60eabdf60",
        "content": "+",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "35c4003175f41503270e3c3eed6e0f63",
        "content": "keyCombo",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d26317c9ef01f31c0df0fa5cc91b1696",
        "content": "import { useCallback, useRef, useLayoutEffect, useState, useEffect, } from 'react' export const useShortcut = ( shortcut, callback, options = { disableTextInputs: true } ) => { const callbackRef = useRef(callback) const [keyCombo, setKeyCombo] = useState([]) // ... const handleKeyDown = useCallback( (event) => { // ... // Handle combined modifier key shortcuts (e.g. pressing Control + D) if (shortcut.includes('+')) { const keyArray = shortcut.split('+') // If the first key is a modifier, handle combinations if (Object.keys(modifierMap).includes(keyArray[0])) { const finalKey = keyArray.pop() // Run handler if the modifier(s) + key have both been pressed if (keyArray.every((k) => modifierMap[k]) finalKey === event.key) { return callbackRef.current(event) } } else { // If the shortcut doesn't begin with a modifier, it's a sequence if (keyArray[keyCombo.length] === event.key) { // Handle final key in the sequence if ( keyArray[keyArray.length - 1] === event.key keyCombo.length === keyArray.length - 1 ) { // Run handler if the sequence is complete, then reset it callbackRef.current(event) return setKeyCombo([]) } // Add to the sequence return setKeyCombo((prevCombo) => [...prevCombo, event.key]) } if (keyCombo.length > 0) { // Reset key combo if it doesn't match the sequence return setKeyCombo([]) } } } // ... }, [keyCombo.length] ) // ... }, [handleKeyDown]) }",
        "type": "code",
        "language": "js",
        "relevance": 1.0105263157894737
      },
      {
        "id": "d26317c9ef01f31c0df0fa5cc91b1696",
        "content": "import { useCallback, useRef, useLayoutEffect, useState, useEffect, } from 'react' export const useShortcut = ( shortcut, callback, options = { disableTextInputs: true } ) => { const callbackRef = useRef(callback) const [keyCombo, setKeyCombo] = useState([]) // ... const handleKeyDown = useCallback( (event) => { // ... // Handle combined modifier key shortcuts (e.g. pressing Control + D) if (shortcut.includes('+')) { const keyArray = shortcut.split('+') // If the first key is a modifier, handle combinations if (Object.keys(modifierMap).includes(keyArray[0])) { const finalKey = keyArray.pop() // Run handler if the modifier(s) + key have both been pressed if (keyArray.every((k) => modifierMap[k]) finalKey === event.key) { return callbackRef.current(event) } } else { // If the shortcut doesn't begin with a modifier, it's a sequence if (keyArray[keyCombo.length] === event.key) { // Handle final key in the sequence if ( keyArray[keyArray.length - 1] === event.key keyCombo.length === keyArray.length - 1 ) { // Run handler if the sequence is complete, then reset it callbackRef.current(event) return setKeyCombo([]) } // Add to the sequence return setKeyCombo((prevCombo) => [...prevCombo, event.key]) } if (keyCombo.length > 0) { // Reset key combo if it doesn't match the sequence return setKeyCombo([]) } } } // ... }, [keyCombo.length] ) // ... }, [handleKeyDown]) }",
        "type": "code",
        "language": "js",
        "relevance": 1.0105263157894737
      },
      {
        "id": "35c4003175f41503270e3c3eed6e0f63",
        "content": "keyCombo",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "36dddab315a457fbe808b5f82e31014a",
        "content": "handleKeyPress",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5a382f607841ee504c8d5d946c2fac94",
        "content": "useShortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "95e1608661cf66ab1b2e28b9d3679fcb",
        "content": "event.repeat",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "014ef6476dd8a57e2057e639d42d6072",
        "content": "import { useCallback, useRef, useLayoutEffect, useState, useEffect } from 'react' export const useShortcut = (shortcut, callback, options = { disableTextInputs: true }) => { const callbackRef = useRef(callback) const [keyCombo, setKeyCombo] = useState([]) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback( (event) => { const isTextInput = event.target instanceof HTMLTextAreaElement (event.target instanceof HTMLInputElement (!event.target.type event.target.type === 'text')) event.target.isContentEditable const modifierMap = { Control: event.ctrlKey, Alt: event.altKey, Command: event.metaKey, Shift: event.shiftKey, } // Cancel shortcut if key is being held down if (event.repeat) { return null } // Don't enable shortcuts in inputs unless explicitly declared if (options.disableTextInputs isTextInput) { return event.stopPropagation() } // Handle combined modifier key shortcuts (e.g. pressing Control + D) if (shortcut.includes('+')) { const keyArray = shortcut.split('+') // If the first key is a modifier, handle combinations if (Object.keys(modifierMap).includes(keyArray[0])) { const finalKey = keyArray.pop() // Run handler if the modifier(s) + key have both been pressed if (keyArray.every((k) => modifierMap[k]) finalKey === event.key) { return callbackRef.current(event) } } else { // If the shortcut doesn't begin with a modifier, it's a sequence if (keyArray[keyCombo.length] === event.key) { // Handle final key in the sequence if ( keyArray[keyArray.length - 1] === event.key keyCombo.length === keyArray.length - 1 ) { // Run handler if the sequence is complete, then reset it callbackRef.current(event) return setKeyCombo([]) } // Add to the sequence return setKeyCombo((prevCombo) => [...prevCombo, event.key]) } if (keyCombo.length > 0) { // Reset key combo if it doesn't match the sequence return setKeyCombo([]) } } } // Single key shortcuts (e.g. pressing D) if (shortcut === event.key) { return callbackRef.current(event) } }, [keyCombo.length] ) useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }, [handleKeyDown]) }",
        "type": "code",
        "language": "js",
        "relevance": 1.1157894736842104
      },
      {
        "id": "014ef6476dd8a57e2057e639d42d6072",
        "content": "import { useCallback, useRef, useLayoutEffect, useState, useEffect } from 'react' export const useShortcut = (shortcut, callback, options = { disableTextInputs: true }) => { const callbackRef = useRef(callback) const [keyCombo, setKeyCombo] = useState([]) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback( (event) => { const isTextInput = event.target instanceof HTMLTextAreaElement (event.target instanceof HTMLInputElement (!event.target.type event.target.type === 'text')) event.target.isContentEditable const modifierMap = { Control: event.ctrlKey, Alt: event.altKey, Command: event.metaKey, Shift: event.shiftKey, } // Cancel shortcut if key is being held down if (event.repeat) { return null } // Don't enable shortcuts in inputs unless explicitly declared if (options.disableTextInputs isTextInput) { return event.stopPropagation() } // Handle combined modifier key shortcuts (e.g. pressing Control + D) if (shortcut.includes('+')) { const keyArray = shortcut.split('+') // If the first key is a modifier, handle combinations if (Object.keys(modifierMap).includes(keyArray[0])) { const finalKey = keyArray.pop() // Run handler if the modifier(s) + key have both been pressed if (keyArray.every((k) => modifierMap[k]) finalKey === event.key) { return callbackRef.current(event) } } else { // If the shortcut doesn't begin with a modifier, it's a sequence if (keyArray[keyCombo.length] === event.key) { // Handle final key in the sequence if ( keyArray[keyArray.length - 1] === event.key keyCombo.length === keyArray.length - 1 ) { // Run handler if the sequence is complete, then reset it callbackRef.current(event) return setKeyCombo([]) } // Add to the sequence return setKeyCombo((prevCombo) => [...prevCombo, event.key]) } if (keyCombo.length > 0) { // Reset key combo if it doesn't match the sequence return setKeyCombo([]) } } } // Single key shortcuts (e.g. pressing D) if (shortcut === event.key) { return callbackRef.current(event) } }, [keyCombo.length] ) useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }, [handleKeyDown]) }",
        "type": "code",
        "language": "js",
        "relevance": 1.1157894736842104
      },
      {
        "id": "6ca5a13e7adad4ae151fe6500021eb96",
        "content": "event.key",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      }
    ]
  },
  {
    "metadata": {
      "description": "Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article…",
      "url": "https://www.taniarascia.com/keyboard-shortcut-hook-react/#useshortcut-hook",
      "title": "Creating a Keyboard Shortcut Hook in React (Deep Dive) | Tania Rascia's Personal Website",
      "source_type": "web",
      "crawl_time": 1730107243.0313542,
      "keywords": [
        "sql",
        "web",
        "article",
        "extract",
        "development",
        "information",
        "react"
      ]
    },
    "relevance_score": 0.9145555555555556,
    "chunks": [
      {
        "content": "Creating a Keyboard Shortcut Hook in React (Deep Dive)Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "main",
        "score": 1.061,
        "word_count": 972,
        "chunk_id": "0705d975bd90e4cda9142423568d0cfa",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 19, 2024Category:TechnicalTagsjavascriptreacthookscachingtutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "main",
        "score": 1.061,
        "word_count": 733,
        "chunk_id": "9e9af7fc5b217c8729ad2eda33ded533",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "Creating a Keyboard Shortcut Hook in React (Deep Dive)Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.061,
        "word_count": 972,
        "chunk_id": "0705d975bd90e4cda9142423568d0cfa",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 19, 2024Category:TechnicalTagsjavascriptreacthookscachingtutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.061,
        "word_count": 733,
        "chunk_id": "9e9af7fc5b217c8729ad2eda33ded533",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "Creating a Keyboard Shortcut Hook in React (Deep Dive)Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.061,
        "word_count": 972,
        "chunk_id": "0705d975bd90e4cda9142423568d0cfa",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 19, 2024Category:TechnicalTagsjavascriptreacthookscachingtutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.061,
        "word_count": 733,
        "chunk_id": "9e9af7fc5b217c8729ad2eda33ded533",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "Creating a Keyboard Shortcut Hook in React (Deep Dive)Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.061,
        "word_count": 972,
        "chunk_id": "0705d975bd90e4cda9142423568d0cfa",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 19, 2024Category:TechnicalTagsjavascriptreacthookscachingtutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.061,
        "word_count": 733,
        "chunk_id": "9e9af7fc5b217c8729ad2eda33ded533",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "Creating a Keyboard Shortcut Hook in React (Deep Dive)Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.061,
        "word_count": 972,
        "chunk_id": "0705d975bd90e4cda9142423568d0cfa",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 19, 2024Category:TechnicalTagsjavascriptreacthookscachingtutorialNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.061,
        "word_count": 733,
        "chunk_id": "9e9af7fc5b217c8729ad2eda33ded533",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "section",
        "score": 1.065,
        "word_count": 964,
        "chunk_id": "a5f4d426c39bf5465e1d3f9a4cf3091b",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.",
        "chunk_type": "technical_content",
        "tag": "section",
        "score": 1.065,
        "word_count": 680,
        "chunk_id": "6de87e9dc9b66e4c0b0e5f7d950bad78",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "Recently I needed to add some keyboard shortcuts to an app I was working on. I wrote up some example code and decided to write this article about it. It goes into various types of shortcuts, caching, some potential bugs and pitfalls you might encounter, and more. 👇tl;drI made a custom React hook to handle keyboard shortcuts.DemoCodeSandboxIt handles:A single keypress:XA combination keypress with modifiers:⌥+X(Option + X)A combination keypress with multiple modifiers:⌘+⇧+X(Command + Shift + X)A sequence of characters:↑↑↓↓←→←→BAIt also makes sure:The shortcut will cache the event handler function if nothing changed (withuseCallback)The shortcut always uses the latest function value, not holding on to stale state (withuseLayoutEffect)Shortcuts won't run while you're typing in a textinput,textarea, orcontenteditableelement (unless you want them to)You'll be able to run the hook in a component like this:useShortcut('Command+Shift+X',()=>console.log('¡Hola, mundo!'))I'll make a little example to show everything working in a minimalist fashion, or you can just go to the sandbox or demo and play around with it.Try any of those key combinations, including but not limited to theKonami Code!Note: The Konami Code is an old cheat code for video games that has also been included as a secret in a lot of websites.Setting UpI don't usually like using a contrived example likecount, setCountand just increasing state, but in this case we just care about making sure the shortcut is working and accessing state properly, so I decided to make it simple. Here's a simple React app with a button that increments and displays the count, and an input.App.jsimport{useState} rom'react'exportdefaultfunctionApp(){const[count,setCount]=useState(0)return(<div><button type=\"button\"onClick={()=>setCount((prev)=>prev+1)}>{`Count:${count}`}</button><button type=\"button\"onClick={()=>setCount(0)}>Clear</button><input type=\"text\"placeholder=\"Type a shortcut key\"/></div>)} he front end buttons aren't overly necessary, they just help with debugging. Theinputwill come in handy later.useShortcutHookWe're going to want to be able to implement theuseShortcuthook like this:App.jsimport{useState} rom'react'import{useShortcut} rom'./useShortcut'exportdefaultfunctionApp(){const[count,setCount]=useState(0)useShortcut('a',()=>{setCount((prev)=>prev+1)})return<div>{/* ... */}</div>} o let's make the simplest version of the hook. You'll make auseShortcutfunction that takes two parameters:shortcut- the string representing a key, key combination, or key sequence (currently just a key)callback- the function that should be called when the correct key is pressedIt consists of ahandleKeyDownfunction that checks if the correct key is being pressed by comparingshortcuttoevent.key, and runs the passed in function if so. AuseEffectadds the event listener on thekeydownevent, and removes it if dismounted. There's no dependency array in theuseEffect, so it will always fire.useShortcut.jsimport{useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=(event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}} seEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}})} ow if you pressA, the count will increment.Performance OptimizationThis will work every time, because theuseEffecthas no dependency array, and fires on every render. This is pretty inefficient, though. If I go to the Performance Monitor in Chrome DevTools (Command+Shfit+Pin DevTools, and search for \"Performance Monitor\") I can see 20 or more event listeners being added with every time the shortcut is run.In an attempt to reduce how often this is firing, I can useuseCallbackon thehandleKeyDownfunction and pass it into theuseEffectarray.Note: Going forward, Reactshouldn't require so much finaglingwithuseCallbackanduseMemo, but since you won't always have the option to use the latest and greatest, it's good to know how to work with this.useShortcut.jsimport{useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{consthandleKeyDown=useCallback((event)=>{// Single key shortcuts (e.g. pressing a)if(shortcut===event.key){returncallback(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} 've wrappedhandleKeyDowninuseCallbackin an attempt to memoize the function, and passed that memoized function into the dependency array of theuseEffect. I can see in the Performance Monitor that this only adds one event listener perkeydownevent now instead of 30.Holding Onto Stale StateThis seems good at first - the shortcut is still working, and the Performance Monitor is looking better. However, this works because thesetCountfunction is using a callback as the value (setCount(prev => prev + 1)), instead of updating the value directly (setCount(count + 1)) ensuring the previouscountvalue is always up to date.In the real world, we can't always guarantee that every bit of state we're working with is asetStatecallback. If I make a shortcut that accesses the direct state value ofcountand attempts to modify it, like so:useShortcut('w',()=>{setCount(count+count)})TheWshortcut willnotbe guaranteed to be accessing the latestcountstate. You can see what happens in the below example if you pressAa few times to increase the count, then pressWto addcount + countIf you increase the count to something like3, you'd expect running theWshortcut to return6. However, what you'll end up with is0.That's because the initial state ofcountgets passed into the function, and there's nothing in theuseCallbackdependency array, so it never updates with the new value.Accessing Current StateOne way to solve this is to ensure that the function passed in is always wrapped in auseCallback.consthandleW=useCallback(()=>setCount(count+count),[count])useShortcut('w',handleW)Then addcallbackto the dependency array ofhandleKeyDowninuseShotcut. However, I'm not a fan of that approach because it requires that the user to always remember to memoize their function and pass in any state that might update. It should be easier to less prone to potential bugs to use a hook.I discoveredthis interesting patternto create a ref to hold the callback, and useuseLayoutEffectto to update the ref.I've useduseLayoutEffectin the past for scrolling purposes, (for example, to make sure a reload of a page always starts at the top) but this is the first time I've seen it use in this way with refs.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{if(shortcut===event.key){returncallbackRef.current(event)}},[])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} sing that code, I can see that it uses the correct and most up to datecountstate without forcing the consumer of theuseShortcuthook to pass the callback in withuseEffect. I can also see in the Performance Monitor that it's not adding tons of event listeners the way the original code was. I'd be interested to hear more opinions on this pattern, because it does seem to add a lot of boilerplate, but it does seem to make the hook more optimized and easier to use.Now that everything is working properly for a single keypress, we can move on to adding a combination shortcuts.Combination Keyboard Shortcuts with ModifiersSo far, usingif (shortcut === event.key), we can make sure the key being pressed matches the shortcut and run it accordingly. But keyboard shortcuts are usually combinations, using the modifiers at the bottom left and right of the keyboard.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 1.065,
        "word_count": 964,
        "chunk_id": "a5f4d426c39bf5465e1d3f9a4cf3091b",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "id": "/keyboard-shortcut-hook-react/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There are four, and they each have aneventproperty associated with them being pressed:^Control-event.ctrlKey⌥Optionor Alt -event.altKey⌘CommandorWindows-event.metaKey⇧Shift-event.shiftKeyIf you're pressing Shift,event.shiftKeywill returntrue.We want to enable the use of one or multiple modifiers with a key, like so:useShortcut('Control+C',()=>{setCount(count+count)})useShortcut('Command+Shift+X',()=>{setCount(count+count)})I decided to solve this by making an Object there the string of the modifier is mapped to the modifier event. If your shortcut has a+, and any of those modifiers are pressed along with the key, run the shortcut.useShortcut.jsimport{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...} ow pressing one or more modifiers along with the key will run the shortcut.Note: There are some issues with theAltkey, which I discuss in the conclusion.Shortcuts and Text InputsSomething that will come up while creating shortcuts in the real world is deciding when and where you want them to be available. If you have a shortcut that saves the current page you're working on, maybe by pressingS, you don't want that shortcut to run while the user is typing into a text box.I've added anoptionsproperty to theuseShortcuthook, with a default setting ofdisableTextInputs: true. If the shortcut you're creating is explicitly for use while typing, you can disable it.I've disabled it forHTMLTextAreaElement,HTMLInputElementwheretype=text, andcontenteditableelements.useShortcut.jsexportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...} here are other ways to handle this, like checking iftagNameis\"INPUT\", but I prefer ensuring it's a text-type input, because you might have a shortcut that works with other types of inputs, so I think this is a good solution.Key SequencesThe last thing I want to handle is a sequence of characters, such asA+B+Call pressed in succession.For my example, I used the Konami Code, which is \"up up down down left right left right b a\" pressed in succession.consthandleKonamiCode=()=>{/* ... */} seShortcut(`ArrowUp+ArrowUp+ rrowDown+ArrowDown+ rrowLeft+ArrowRight+ rrowLeft+ArrowRight+\nb+a`,handleKonamiCode)In order to set this up, I'm going to create some state to hold onto any matching combination of keys, calledkeyCombo. After splitting the shortcut string by+and putting it into an array, you can just keep adding each matching key to thekeyComboarray. If it's the last one in the sequence, run the callback. If it doesn't match the sequence, clear the queue.useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])} also added thekeyCombolength to the dependency array ofhandleKeyPresssince the function depends on it. Pressing a combination of keys will run the shortcut now.ConclusionHere is our completeduseShortcuthook: (I also added a line to ignore ifevent.repeatis true, meaning a key is just being held down)useShortcut.jsimport{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])} nce again, you canplay around with the demoorthe sandbox. There is still more that can be done here - for example, handling an Alt key can be tricky becuause pressingAlt+Cwill actually produce \"ç\" (not \"C\") as both the output andevent.keyvalue. Some overlapping shortcuts on the same page might have issues.Overall, this should give you a good idea of how to work with a custom hook, avoid bugs (like holding onto stale state), improve caching (withuseCallback) and set up various types of keyboard events.Thanks for reading! I'd be happy to hear any additional thoughts about shortcuts and hooks you might have.",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.065,
        "word_count": 680,
        "chunk_id": "6de87e9dc9b66e4c0b0e5f7d950bad78",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "id": "/keyboard-shortcut-hook-react/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 19, 2024Category:TechnicalTagsjavascriptreacthookscachingtutorialNewsletterSubscribe to the Newsletter",
        "chunk_type": "technical_content",
        "tag": "aside",
        "score": 0.43600000000000005,
        "word_count": 54,
        "chunk_id": "0e4fa4fd0255579b9e96b315cceaa2a9",
        "metadata": {
          "source_tag": "aside",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "post-sidebar"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript"
          ]
        }
      },
      {
        "content": "import{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])}",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.905,
        "word_count": 78,
        "chunk_id": "ebd5d91fda9a81085d76425e33f6380c",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "js"
          },
          "technical_indicators": [
            "react",
            "javascript",
            "data"
          ]
        }
      },
      {
        "content": "import{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])}",
        "chunk_type": "technical_content",
        "tag": "pre",
        "score": 0.905,
        "word_count": 78,
        "chunk_id": "ebd5d91fda9a81085d76425e33f6380c",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "data"
          ]
        }
      },
      {
        "content": "import{useCallback,useRef,useLayoutEffect,useState,useEffect,} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])// ...consthandleKeyDown=useCallback((event)=>{// ...// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// ...},[keyCombo.length])// ...},[handleKeyDown])}",
        "chunk_type": "technical_content",
        "tag": "code",
        "score": 0.905,
        "word_count": 78,
        "chunk_id": "ebd5d91fda9a81085d76425e33f6380c",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "data"
          ]
        }
      },
      {
        "content": "import{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])}",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.319,
        "word_count": 96,
        "chunk_id": "9fc296682936c5b5423fccb2230495b6",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "js"
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "import{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])}",
        "chunk_type": "technical_content",
        "tag": "pre",
        "score": 1.319,
        "word_count": 96,
        "chunk_id": "9fc296682936c5b5423fccb2230495b6",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "style": "counter-reset: linenumber 0",
            "class": [
              "language-js",
              "line-numbers"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "import{useCallback,useRef,useLayoutEffect,useState,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)const[keyCombo,setKeyCombo]=useState([])useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditableconstmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,}// Cancel shortcut if key is being held downif(event.repeat){returnnull}// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// Handle combined modifier key shortcuts (e.g. pressing Control + D)if(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}} lse{// If the shortcut doesn't begin with a modifier, it's a sequenceif(keyArray[keyCombo.length]===event.key){// Handle final key in the sequenceif(keyArray[keyArray.length-1]===event.key&&keyCombo.length===keyArray.length-1){// Run handler if the sequence is complete, then reset itcallbackRef.current(event)returnsetKeyCombo([])}// Add to the sequencereturnsetKeyCombo((prevCombo)=>[...prevCombo,event.key])} f(keyCombo.length>0){// Reset key combo if it doesn't match the sequencereturnsetKeyCombo([])}}}// Single key shortcuts (e.g. pressing D)if(shortcut===event.key){returncallbackRef.current(event)}},[keyCombo.length])useEffect(()=>{window.addEventListener('keydown',handleKeyDown)return()=>{window.removeEventListener('keydown',handleKeyDown)}},[handleKeyDown])}",
        "chunk_type": "technical_content",
        "tag": "code",
        "score": 1.319,
        "word_count": 96,
        "chunk_id": "9fc296682936c5b5423fccb2230495b6",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "import{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...}",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.599,
        "word_count": 25,
        "chunk_id": "d2792864accec3abc015628114e83b5f",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "js"
          },
          "technical_indicators": [
            "javascript",
            "data"
          ]
        }
      },
      {
        "content": "import{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...}",
        "chunk_type": "technical_content",
        "tag": "pre",
        "score": 0.599,
        "word_count": 25,
        "chunk_id": "d2792864accec3abc015628114e83b5f",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "javascript",
            "data"
          ]
        }
      },
      {
        "content": "import{useRef,useLayoutEffect,useCallback,useEffect} rom'react'exportconstuseShortcut=(shortcut,callback)=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constmodifierMap={Control:event.ctrlKey,Alt:event.altKey,Command:event.metaKey,Shift:event.shiftKey,} f(shortcut.includes('+')){constkeyArray=shortcut.split('+')// If the first key is a modifier, handle combinationsif(Object.keys(modifierMap).includes(keyArray[0])){constfinalKey=keyArray.pop()// Run handler if the modifier(s) + key have both been pressedif(keyArray.every((k)=>modifierMap[k])&&finalKey===event.key){returncallbackRef.current(event)}}} f(shortcut===event.key){returncallbackRef.current(event)}},[])// ...}",
        "chunk_type": "technical_content",
        "tag": "code",
        "score": 0.599,
        "word_count": 25,
        "chunk_id": "d2792864accec3abc015628114e83b5f",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "javascript",
            "data"
          ]
        }
      },
      {
        "content": "exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...}",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.30600000000000005,
        "word_count": 11,
        "chunk_id": "450994c7d656efe33ad0e45947012b7e",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "js"
          },
          "technical_indicators": [
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...}",
        "chunk_type": "technical_content",
        "tag": "pre",
        "score": 0.30600000000000005,
        "word_count": 11,
        "chunk_id": "450994c7d656efe33ad0e45947012b7e",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "exportconstuseShortcut=(shortcut,callback,options={disableTextInputs:true})=>{constcallbackRef=useRef(callback)useLayoutEffect(()=>{callbackRef.current=callback})consthandleKeyDown=useCallback((event)=>{constisTextInput=event.targetinstanceofHTMLTextAreaElement||(event.targetinstanceofHTMLInputElement&&(!event.target.type||event.target.type==='text'))||event.target.isContentEditable// Don't enable shortcuts in inputs unless explicitly declaredif(options.disableTextInputs&&isTextInput){returnevent.stopPropagation()}// ...},[])// ...}",
        "chunk_type": "technical_content",
        "tag": "code",
        "score": 0.30600000000000005,
        "word_count": 11,
        "chunk_id": "450994c7d656efe33ad0e45947012b7e",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "javascript",
            "sql"
          ]
        }
      }
    ],
    "chunk_count": 27,
    "content_types": [
      "code_markup",
      "technical_content"
    ],
    "technical_concepts": [
      "javascript",
      "data",
      "react",
      "sql"
    ],
    "crawl_metadata": {},
    "technical_content": [
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f0f0802505b28ff454f40670ef0cd5c9",
        "content": "useLayoutEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a43c1b0aa53a0c908810c06ab1ff3967",
        "content": "input",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6394d816bfb4220289a6f4b29cfb1834",
        "content": "textarea",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c8c2fb4e60f621aa8f72ba72405f9581",
        "content": "contenteditable",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "07f8f832fb06410d18ba1e1d8df4a751",
        "content": "useShortcut('Command+Shift+X', () => console.log(' Hola, mundo!'))",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "07f8f832fb06410d18ba1e1d8df4a751",
        "content": "useShortcut('Command+Shift+X', () => console.log(' Hola, mundo!'))",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "096672df389fb56cdc6e320583c65488",
        "content": "count, setCount",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7dfac8369abd7b5bb0af524aa2369f03",
        "content": "import { useState } from 'react' export default function App() { const [count, setCount] = useState(0) return ( <div> <button type=\"button\" onClick={() => setCount((prev) => prev + 1)}> { Count: {count} } </button> <button type=\"button\" onClick={() => setCount(0)}> Clear </button> <input type=\"text\" placeholder=\"Type a shortcut key\" /> </div> ) }",
        "type": "code",
        "language": "js",
        "relevance": 1.1105263157894738
      },
      {
        "id": "7dfac8369abd7b5bb0af524aa2369f03",
        "content": "import { useState } from 'react' export default function App() { const [count, setCount] = useState(0) return ( <div> <button type=\"button\" onClick={() => setCount((prev) => prev + 1)}> { Count: {count} } </button> <button type=\"button\" onClick={() => setCount(0)}> Clear </button> <input type=\"text\" placeholder=\"Type a shortcut key\" /> </div> ) }",
        "type": "code",
        "language": "js",
        "relevance": 1.1105263157894738
      },
      {
        "id": "a43c1b0aa53a0c908810c06ab1ff3967",
        "content": "input",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5a382f607841ee504c8d5d946c2fac94",
        "content": "useShortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5a382f607841ee504c8d5d946c2fac94",
        "content": "useShortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "58a8164e81e6261ac277ad2b4911c7fc",
        "content": "import { useState } from 'react' import { useShortcut } from './useShortcut' export default function App() { const [count, setCount] = useState(0) useShortcut('a', () => { setCount((prev) => prev + 1) }) return <div>{/* ... */}</div> }",
        "type": "code",
        "language": "js",
        "relevance": 0.9105263157894736
      },
      {
        "id": "58a8164e81e6261ac277ad2b4911c7fc",
        "content": "import { useState } from 'react' import { useShortcut } from './useShortcut' export default function App() { const [count, setCount] = useState(0) useShortcut('a', () => { setCount((prev) => prev + 1) }) return <div>{/* ... */}</div> }",
        "type": "code",
        "language": "js",
        "relevance": 0.9105263157894736
      },
      {
        "id": "5a382f607841ee504c8d5d946c2fac94",
        "content": "useShortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c0954f37465ac52acf4a22c5e1c5bf87",
        "content": "shortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "924a8ceeac17f54d3be3f8cdf1c04eb2",
        "content": "callback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cc87d1a0cdab463949001e224ba39371",
        "content": "handleKeyDown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c0954f37465ac52acf4a22c5e1c5bf87",
        "content": "shortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6ca5a13e7adad4ae151fe6500021eb96",
        "content": "event.key",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2959b6433abb3a4138a42ddda695c171",
        "content": "keydown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6d81f8b7989760ca2833a4aec03f1713",
        "content": "import { useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const handleKeyDown = (event) => { // Single key shortcuts (e.g. pressing a) if (shortcut === event.key) { return callback(event) } } useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }) }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "6d81f8b7989760ca2833a4aec03f1713",
        "content": "import { useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const handleKeyDown = (event) => { // Single key shortcuts (e.g. pressing a) if (shortcut === event.key) { return callback(event) } } useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }) }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cc87d1a0cdab463949001e224ba39371",
        "content": "handleKeyDown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "86000955b44e4f8640a21bd77aff6aa6",
        "content": "useMemo",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5789917c46ed70321e72360ff87926da",
        "content": "import { useCallback, useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const handleKeyDown = useCallback((event) => { // Single key shortcuts (e.g. pressing a) if (shortcut === event.key) { return callback(event) } }, []) useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }, [handleKeyDown])}",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "5789917c46ed70321e72360ff87926da",
        "content": "import { useCallback, useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const handleKeyDown = useCallback((event) => { // Single key shortcuts (e.g. pressing a) if (shortcut === event.key) { return callback(event) } }, []) useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }, [handleKeyDown])}",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "cc87d1a0cdab463949001e224ba39371",
        "content": "handleKeyDown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2959b6433abb3a4138a42ddda695c171",
        "content": "keydown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "80c2b4168fdae9029cfa9f29093bcfe3",
        "content": "setCount",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03ce4e517700d276d9173a7981a46a5a",
        "content": "setCount(prev => prev + 1)",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "158ea57c8f335461fb60566922b17a99",
        "content": "setCount(count + 1)",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e2942a04780e223b215eb8b663cf5353",
        "content": "count",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "075363380323b4799196ff5108cc951d",
        "content": "setState",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "e2942a04780e223b215eb8b663cf5353",
        "content": "count",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "00e8228ac71b3ae4fac2d47c93d98573",
        "content": "useShortcut('w', () => { setCount(count + count) })",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "00e8228ac71b3ae4fac2d47c93d98573",
        "content": "useShortcut('w', () => { setCount(count + count) })",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e2942a04780e223b215eb8b663cf5353",
        "content": "count",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "df853da39d97ebdf11e1f7e4c64db18a",
        "content": "count + count",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "eccbc87e4b5ce2fe28308fd9f2a7baf3",
        "content": "3",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1679091c5a880faf6fb5e6087eb1b2dc",
        "content": "6",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cfcd208495d565ef66e7dff9f98764da",
        "content": "0",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e2942a04780e223b215eb8b663cf5353",
        "content": "count",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "019aedfd528fc058f508edab1bb3b0ae",
        "content": "const handleW = useCallback(() => setCount(count + count), [count]) useShortcut('w', handleW)",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "019aedfd528fc058f508edab1bb3b0ae",
        "content": "const handleW = useCallback(() => setCount(count + count), [count]) useShortcut('w', handleW)",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "924a8ceeac17f54d3be3f8cdf1c04eb2",
        "content": "callback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cc87d1a0cdab463949001e224ba39371",
        "content": "handleKeyDown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "57b57638081f8f7cd81e57984a887634",
        "content": "useShotcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f0f0802505b28ff454f40670ef0cd5c9",
        "content": "useLayoutEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f0f0802505b28ff454f40670ef0cd5c9",
        "content": "useLayoutEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e86732df9d58dd6085e369915a018e63",
        "content": "import { useRef, useLayoutEffect, useCallback, useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const callbackRef = useRef(callback) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback((event) => { if (shortcut === event.key) { return callbackRef.current(event) } }, []) useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }, [handleKeyDown]) }",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "e86732df9d58dd6085e369915a018e63",
        "content": "import { useRef, useLayoutEffect, useCallback, useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const callbackRef = useRef(callback) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback((event) => { if (shortcut === event.key) { return callbackRef.current(event) } }, []) useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }, [handleKeyDown]) }",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "e2942a04780e223b215eb8b663cf5353",
        "content": "count",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5a382f607841ee504c8d5d946c2fac94",
        "content": "useShortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "77961215613b33241db00e28fcf69ad7",
        "content": "if (shortcut === event.key)",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4119639092e62c55ea8be348e4d9260d",
        "content": "event",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "25baf3402df19c373ea5f458e64cad8d",
        "content": "event.ctrlKey",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "3a132bf6b1b1359e934e7948db2e8c27",
        "content": "event.altKey",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "8f8ddef66e36eeebaa79b2d8c3fe9fb8",
        "content": "event.metaKey",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "0bf017792a71d415204285d4a11f4be0",
        "content": "event.shiftKey",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "0bf017792a71d415204285d4a11f4be0",
        "content": "event.shiftKey",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b326b5062b2f0e69046810717534cb09",
        "content": "true",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "47f6478eb87886529d1a239bb34ae33b",
        "content": "useShortcut('Control+C', () => { setCount(count + count) }) useShortcut('Command+Shift+X', () => { setCount(count + count) })",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "47f6478eb87886529d1a239bb34ae33b",
        "content": "useShortcut('Control+C', () => { setCount(count + count) }) useShortcut('Command+Shift+X', () => { setCount(count + count) })",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "26b17225b626fb9238849fd60eabdf60",
        "content": "+",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d0c1d488426c0f5d4d7ca38a69a98ffa",
        "content": "import { useRef, useLayoutEffect, useCallback, useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const callbackRef = useRef(callback) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback((event) => { const modifierMap = { Control: event.ctrlKey, Alt: event.altKey, Command: event.metaKey, Shift: event.shiftKey, } if (shortcut.includes('+')) { const keyArray = shortcut.split('+') // If the first key is a modifier, handle combinations if (Object.keys(modifierMap).includes(keyArray[0])) { const finalKey = keyArray.pop() // Run handler if the modifier(s) + key have both been pressed if (keyArray.every((k) => modifierMap[k]) finalKey === event.key) { return callbackRef.current(event) } } } if (shortcut === event.key) { return callbackRef.current(event) } }, []) // ... }",
        "type": "code",
        "language": "js",
        "relevance": 0.9052631578947368
      },
      {
        "id": "d0c1d488426c0f5d4d7ca38a69a98ffa",
        "content": "import { useRef, useLayoutEffect, useCallback, useEffect } from 'react' export const useShortcut = (shortcut, callback) => { const callbackRef = useRef(callback) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback((event) => { const modifierMap = { Control: event.ctrlKey, Alt: event.altKey, Command: event.metaKey, Shift: event.shiftKey, } if (shortcut.includes('+')) { const keyArray = shortcut.split('+') // If the first key is a modifier, handle combinations if (Object.keys(modifierMap).includes(keyArray[0])) { const finalKey = keyArray.pop() // Run handler if the modifier(s) + key have both been pressed if (keyArray.every((k) => modifierMap[k]) finalKey === event.key) { return callbackRef.current(event) } } } if (shortcut === event.key) { return callbackRef.current(event) } }, []) // ... }",
        "type": "code",
        "language": "js",
        "relevance": 0.9052631578947368
      },
      {
        "id": "93da65a9fd0004d9477aeac024e08e15",
        "content": "options",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5a382f607841ee504c8d5d946c2fac94",
        "content": "useShortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7ac5a96aa06eab8a0e0fc327b7534f23",
        "content": "disableTextInputs: true",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "60a817081688675aef6249793b89c87d",
        "content": "HTMLTextAreaElement",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "44c146087f94f53b411690f3e6831db2",
        "content": "HTMLInputElement",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "599dcce2998a6b40b1e38e8c6006cb0a",
        "content": "type",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1cb251ec0d568de6a929b520c4aed8d1",
        "content": "text",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c8c2fb4e60f621aa8f72ba72405f9581",
        "content": "contenteditable",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "08d2df373d04ea3a56b181886b1fb4d3",
        "content": "export const useShortcut = ( shortcut, callback, options = { disableTextInputs: true }) => { const callbackRef = useRef(callback) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback((event) => { const isTextInput = event.target instanceof HTMLTextAreaElement (event.target instanceof HTMLInputElement (!event.target.type event.target.type === 'text')) event.target.isContentEditable // Don't enable shortcuts in inputs unless explicitly declared if (options.disableTextInputs isTextInput) { return event.stopPropagation() } // ... }, []) // ... }",
        "type": "code",
        "language": "js",
        "relevance": 0.9052631578947368
      },
      {
        "id": "08d2df373d04ea3a56b181886b1fb4d3",
        "content": "export const useShortcut = ( shortcut, callback, options = { disableTextInputs: true }) => { const callbackRef = useRef(callback) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback((event) => { const isTextInput = event.target instanceof HTMLTextAreaElement (event.target instanceof HTMLInputElement (!event.target.type event.target.type === 'text')) event.target.isContentEditable // Don't enable shortcuts in inputs unless explicitly declared if (options.disableTextInputs isTextInput) { return event.stopPropagation() } // ... }, []) // ... }",
        "type": "code",
        "language": "js",
        "relevance": 0.9052631578947368
      },
      {
        "id": "351ac178246fc29e75bc20cf02e349c6",
        "content": "tagName",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f9b4a8362b0f49ad2e70a6fe73807c71",
        "content": "\"INPUT\"",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1dfa33e3512e2bdd8ae3a54dd2c851fa",
        "content": "const handleKonamiCode = () => { /* ... */ } useShortcut( ArrowUp+ArrowUp+ ArrowDown+ArrowDown+ ArrowLeft+ArrowRight+ ArrowLeft+ArrowRight+ b+a , handleKonamiCode )",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1dfa33e3512e2bdd8ae3a54dd2c851fa",
        "content": "const handleKonamiCode = () => { /* ... */ } useShortcut( ArrowUp+ArrowUp+ ArrowDown+ArrowDown+ ArrowLeft+ArrowRight+ ArrowLeft+ArrowRight+ b+a , handleKonamiCode )",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "35c4003175f41503270e3c3eed6e0f63",
        "content": "keyCombo",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "26b17225b626fb9238849fd60eabdf60",
        "content": "+",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "35c4003175f41503270e3c3eed6e0f63",
        "content": "keyCombo",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d26317c9ef01f31c0df0fa5cc91b1696",
        "content": "import { useCallback, useRef, useLayoutEffect, useState, useEffect, } from 'react' export const useShortcut = ( shortcut, callback, options = { disableTextInputs: true } ) => { const callbackRef = useRef(callback) const [keyCombo, setKeyCombo] = useState([]) // ... const handleKeyDown = useCallback( (event) => { // ... // Handle combined modifier key shortcuts (e.g. pressing Control + D) if (shortcut.includes('+')) { const keyArray = shortcut.split('+') // If the first key is a modifier, handle combinations if (Object.keys(modifierMap).includes(keyArray[0])) { const finalKey = keyArray.pop() // Run handler if the modifier(s) + key have both been pressed if (keyArray.every((k) => modifierMap[k]) finalKey === event.key) { return callbackRef.current(event) } } else { // If the shortcut doesn't begin with a modifier, it's a sequence if (keyArray[keyCombo.length] === event.key) { // Handle final key in the sequence if ( keyArray[keyArray.length - 1] === event.key keyCombo.length === keyArray.length - 1 ) { // Run handler if the sequence is complete, then reset it callbackRef.current(event) return setKeyCombo([]) } // Add to the sequence return setKeyCombo((prevCombo) => [...prevCombo, event.key]) } if (keyCombo.length > 0) { // Reset key combo if it doesn't match the sequence return setKeyCombo([]) } } } // ... }, [keyCombo.length] ) // ... }, [handleKeyDown]) }",
        "type": "code",
        "language": "js",
        "relevance": 1.0105263157894737
      },
      {
        "id": "d26317c9ef01f31c0df0fa5cc91b1696",
        "content": "import { useCallback, useRef, useLayoutEffect, useState, useEffect, } from 'react' export const useShortcut = ( shortcut, callback, options = { disableTextInputs: true } ) => { const callbackRef = useRef(callback) const [keyCombo, setKeyCombo] = useState([]) // ... const handleKeyDown = useCallback( (event) => { // ... // Handle combined modifier key shortcuts (e.g. pressing Control + D) if (shortcut.includes('+')) { const keyArray = shortcut.split('+') // If the first key is a modifier, handle combinations if (Object.keys(modifierMap).includes(keyArray[0])) { const finalKey = keyArray.pop() // Run handler if the modifier(s) + key have both been pressed if (keyArray.every((k) => modifierMap[k]) finalKey === event.key) { return callbackRef.current(event) } } else { // If the shortcut doesn't begin with a modifier, it's a sequence if (keyArray[keyCombo.length] === event.key) { // Handle final key in the sequence if ( keyArray[keyArray.length - 1] === event.key keyCombo.length === keyArray.length - 1 ) { // Run handler if the sequence is complete, then reset it callbackRef.current(event) return setKeyCombo([]) } // Add to the sequence return setKeyCombo((prevCombo) => [...prevCombo, event.key]) } if (keyCombo.length > 0) { // Reset key combo if it doesn't match the sequence return setKeyCombo([]) } } } // ... }, [keyCombo.length] ) // ... }, [handleKeyDown]) }",
        "type": "code",
        "language": "js",
        "relevance": 1.0105263157894737
      },
      {
        "id": "35c4003175f41503270e3c3eed6e0f63",
        "content": "keyCombo",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "36dddab315a457fbe808b5f82e31014a",
        "content": "handleKeyPress",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5a382f607841ee504c8d5d946c2fac94",
        "content": "useShortcut",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "95e1608661cf66ab1b2e28b9d3679fcb",
        "content": "event.repeat",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "014ef6476dd8a57e2057e639d42d6072",
        "content": "import { useCallback, useRef, useLayoutEffect, useState, useEffect } from 'react' export const useShortcut = (shortcut, callback, options = { disableTextInputs: true }) => { const callbackRef = useRef(callback) const [keyCombo, setKeyCombo] = useState([]) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback( (event) => { const isTextInput = event.target instanceof HTMLTextAreaElement (event.target instanceof HTMLInputElement (!event.target.type event.target.type === 'text')) event.target.isContentEditable const modifierMap = { Control: event.ctrlKey, Alt: event.altKey, Command: event.metaKey, Shift: event.shiftKey, } // Cancel shortcut if key is being held down if (event.repeat) { return null } // Don't enable shortcuts in inputs unless explicitly declared if (options.disableTextInputs isTextInput) { return event.stopPropagation() } // Handle combined modifier key shortcuts (e.g. pressing Control + D) if (shortcut.includes('+')) { const keyArray = shortcut.split('+') // If the first key is a modifier, handle combinations if (Object.keys(modifierMap).includes(keyArray[0])) { const finalKey = keyArray.pop() // Run handler if the modifier(s) + key have both been pressed if (keyArray.every((k) => modifierMap[k]) finalKey === event.key) { return callbackRef.current(event) } } else { // If the shortcut doesn't begin with a modifier, it's a sequence if (keyArray[keyCombo.length] === event.key) { // Handle final key in the sequence if ( keyArray[keyArray.length - 1] === event.key keyCombo.length === keyArray.length - 1 ) { // Run handler if the sequence is complete, then reset it callbackRef.current(event) return setKeyCombo([]) } // Add to the sequence return setKeyCombo((prevCombo) => [...prevCombo, event.key]) } if (keyCombo.length > 0) { // Reset key combo if it doesn't match the sequence return setKeyCombo([]) } } } // Single key shortcuts (e.g. pressing D) if (shortcut === event.key) { return callbackRef.current(event) } }, [keyCombo.length] ) useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }, [handleKeyDown]) }",
        "type": "code",
        "language": "js",
        "relevance": 1.1157894736842104
      },
      {
        "id": "014ef6476dd8a57e2057e639d42d6072",
        "content": "import { useCallback, useRef, useLayoutEffect, useState, useEffect } from 'react' export const useShortcut = (shortcut, callback, options = { disableTextInputs: true }) => { const callbackRef = useRef(callback) const [keyCombo, setKeyCombo] = useState([]) useLayoutEffect(() => { callbackRef.current = callback }) const handleKeyDown = useCallback( (event) => { const isTextInput = event.target instanceof HTMLTextAreaElement (event.target instanceof HTMLInputElement (!event.target.type event.target.type === 'text')) event.target.isContentEditable const modifierMap = { Control: event.ctrlKey, Alt: event.altKey, Command: event.metaKey, Shift: event.shiftKey, } // Cancel shortcut if key is being held down if (event.repeat) { return null } // Don't enable shortcuts in inputs unless explicitly declared if (options.disableTextInputs isTextInput) { return event.stopPropagation() } // Handle combined modifier key shortcuts (e.g. pressing Control + D) if (shortcut.includes('+')) { const keyArray = shortcut.split('+') // If the first key is a modifier, handle combinations if (Object.keys(modifierMap).includes(keyArray[0])) { const finalKey = keyArray.pop() // Run handler if the modifier(s) + key have both been pressed if (keyArray.every((k) => modifierMap[k]) finalKey === event.key) { return callbackRef.current(event) } } else { // If the shortcut doesn't begin with a modifier, it's a sequence if (keyArray[keyCombo.length] === event.key) { // Handle final key in the sequence if ( keyArray[keyArray.length - 1] === event.key keyCombo.length === keyArray.length - 1 ) { // Run handler if the sequence is complete, then reset it callbackRef.current(event) return setKeyCombo([]) } // Add to the sequence return setKeyCombo((prevCombo) => [...prevCombo, event.key]) } if (keyCombo.length > 0) { // Reset key combo if it doesn't match the sequence return setKeyCombo([]) } } } // Single key shortcuts (e.g. pressing D) if (shortcut === event.key) { return callbackRef.current(event) } }, [keyCombo.length] ) useEffect(() => { window.addEventListener('keydown', handleKeyDown) return () => { window.removeEventListener('keydown', handleKeyDown) } }, [handleKeyDown]) }",
        "type": "code",
        "language": "js",
        "relevance": 1.1157894736842104
      },
      {
        "id": "6ca5a13e7adad4ae151fe6500021eb96",
        "content": "event.key",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6856eee4be07c4f868b870bc420e3299",
        "content": "useCallback",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      }
    ]
  },
  {
    "metadata": {
      "description": "Software engineer and open source creator. This is my digital garden.",
      "url": "https://www.taniarascia.com",
      "title": "Tania Rascia's Personal Website",
      "source_type": "web",
      "crawl_time": 1730107170.726292,
      "keywords": [
        "sql",
        "web",
        "article",
        "extract",
        "development",
        "information",
        "react"
      ]
    },
    "relevance_score": 0.7867777777777777,
    "chunks": [
      {
        "content": "Hey, I'm TaniaI'm a software developer who makes open-source projects and writes about code and life.On this site, you can check out all thetechnical articlesI've written, read some of mypersonal notes, or learn moreabout me.ArticlesAll ArticlesCreating a Keyboard Shortcut Hook in React (Deep Dive)October 2024New!Tables with Fixed Headers and Horizontal ScrollOctober 2024New!How to Use WebSockets in a Redux ApplicationFebruary 2023Understanding the GraphQL Type SystemJanuary 2023Testing API Calls With React Testing Library and JestDecember 2022NotesAll Notes2023 into 2024January 20242022 into 2023January 2023The Lore of Animorphs (an Ode)December 2022Tending to My Digital GardenDecember 2022Memories of JoshAugust 2022HighlightsNovember 17, 2021An Introduction to GraphQLJune 23, 2021How to Structure and Organize a React ApplicationOctober 15, 2020How to Set Up webpack 5 From ScratchSeptember 10, 2020The Event Loop, Callbacks, Promises, and Async/Await in JavaScriptMarch 09, 2020How to Use Redux and ReactFebruary 17, 2020How to Set up a Mac for DevelopmentDecember 02, 2019A Complete Guide to CSS Concepts and FundamentalsMay 16, 2019How to Use Vue, the JavaScript FrameworkFebruary 11, 2019Everything I Know as a Software Developer Without a Degree (2019)August 20, 2018How to Use React, the JavaScript FrameworkOctober 12, 2017Design for Developers: Specific Steps to Improve Your Website DesignJanuary 09, 2017How to Use the Command Line in Linux and macOSProjectsAll Projects2022Keyboard AccordionPlay the accordion with your keyboard!ArticleDemo2020TakeNoteA free, open source notes app for the web.ArticleDemo2019Chip8A retro game emulator for three platforms.ArticleDemo2021SokobanA web-based Sokoban implementation.ArticleDemo2015New MoonThe optimized dark theme for web development.Demo2019SnekA terminal-based Snake implementation.ArticleDemo",
        "chunk_type": "technical_content",
        "tag": "main",
        "score": 1.1760000000000002,
        "word_count": 237,
        "chunk_id": "ecbe39bff3a34097569fceda6a214d69",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web",
            "article",
            "development",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "Hey, I'm TaniaI'm a software developer who makes open-source projects and writes about code and life.On this site, you can check out all thetechnical articlesI've written, read some of mypersonal notes, or learn moreabout me.ArticlesAll ArticlesCreating a Keyboard Shortcut Hook in React (Deep Dive)October 2024New!Tables with Fixed Headers and Horizontal ScrollOctober 2024New!How to Use WebSockets in a Redux ApplicationFebruary 2023Understanding the GraphQL Type SystemJanuary 2023Testing API Calls With React Testing Library and JestDecember 2022NotesAll Notes2023 into 2024January 20242022 into 2023January 2023The Lore of Animorphs (an Ode)December 2022Tending to My Digital GardenDecember 2022Memories of JoshAugust 2022HighlightsNovember 17, 2021An Introduction to GraphQLJune 23, 2021How to Structure and Organize a React ApplicationOctober 15, 2020How to Set Up webpack 5 From ScratchSeptember 10, 2020The Event Loop, Callbacks, Promises, and Async/Await in JavaScriptMarch 09, 2020How to Use Redux and ReactFebruary 17, 2020How to Set up a Mac for DevelopmentDecember 02, 2019A Complete Guide to CSS Concepts and FundamentalsMay 16, 2019How to Use Vue, the JavaScript FrameworkFebruary 11, 2019Everything I Know as a Software Developer Without a Degree (2019)August 20, 2018How to Use React, the JavaScript FrameworkOctober 12, 2017Design for Developers: Specific Steps to Improve Your Website DesignJanuary 09, 2017How to Use the Command Line in Linux and macOSProjectsAll Projects2022Keyboard AccordionPlay the accordion with your keyboard!ArticleDemo2020TakeNoteA free, open source notes app for the web.ArticleDemo2019Chip8A retro game emulator for three platforms.ArticleDemo2021SokobanA web-based Sokoban implementation.ArticleDemo2015New MoonThe optimized dark theme for web development.Demo2019SnekA terminal-based Snake implementation.ArticleDemo",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.1760000000000002,
        "word_count": 237,
        "chunk_id": "ecbe39bff3a34097569fceda6a214d69",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "development",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "ArticlesAll ArticlesCreating a Keyboard Shortcut Hook in React (Deep Dive)October 2024New!Tables with Fixed Headers and Horizontal ScrollOctober 2024New!How to Use WebSockets in a Redux ApplicationFebruary 2023Understanding the GraphQL Type SystemJanuary 2023Testing API Calls With React Testing Library and JestDecember 2022NotesAll Notes2023 into 2024January 20242022 into 2023January 2023The Lore of Animorphs (an Ode)December 2022Tending to My Digital GardenDecember 2022Memories of JoshAugust 2022HighlightsNovember 17, 2021An Introduction to GraphQLJune 23, 2021How to Structure and Organize a React ApplicationOctober 15, 2020How to Set Up webpack 5 From ScratchSeptember 10, 2020The Event Loop, Callbacks, Promises, and Async/Await in JavaScriptMarch 09, 2020How to Use Redux and ReactFebruary 17, 2020How to Set up a Mac for DevelopmentDecember 02, 2019A Complete Guide to CSS Concepts and FundamentalsMay 16, 2019How to Use Vue, the JavaScript FrameworkFebruary 11, 2019Everything I Know as a Software Developer Without a Degree (2019)August 20, 2018How to Use React, the JavaScript FrameworkOctober 12, 2017Design for Developers: Specific Steps to Improve Your Website DesignJanuary 09, 2017How to Use the Command Line in Linux and macOSProjectsAll Projects2022Keyboard AccordionPlay the accordion with your keyboard!ArticleDemo2020TakeNoteA free, open source notes app for the web.ArticleDemo2019Chip8A retro game emulator for three platforms.ArticleDemo2021SokobanA web-based Sokoban implementation.ArticleDemo2015New MoonThe optimized dark theme for web development.Demo2019SnekA terminal-based Snake implementation.ArticleDemo",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 1.256,
        "word_count": 203,
        "chunk_id": "d83967ff037873a94af042901bf91801",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "development",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "ArticlesAll ArticlesCreating a Keyboard Shortcut Hook in React (Deep Dive)October 2024New!Tables with Fixed Headers and Horizontal ScrollOctober 2024New!How to Use WebSockets in a Redux ApplicationFebruary 2023Understanding the GraphQL Type SystemJanuary 2023Testing API Calls With React Testing Library and JestDecember 2022",
        "chunk_type": "technical_content",
        "tag": "section",
        "score": 0.515,
        "word_count": 40,
        "chunk_id": "5cc6a6aeb36f35bda2c982978fa378fe",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "segment"
            ]
          },
          "technical_indicators": [
            "react",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "HighlightsNovember 17, 2021An Introduction to GraphQLJune 23, 2021How to Structure and Organize a React ApplicationOctober 15, 2020How to Set Up webpack 5 From ScratchSeptember 10, 2020The Event Loop, Callbacks, Promises, and Async/Await in JavaScriptMarch 09, 2020How to Use Redux and ReactFebruary 17, 2020How to Set up a Mac for DevelopmentDecember 02, 2019A Complete Guide to CSS Concepts and FundamentalsMay 16, 2019How to Use Vue, the JavaScript FrameworkFebruary 11, 2019Everything I Know as a Software Developer Without a Degree (2019)August 20, 2018How to Use React, the JavaScript FrameworkOctober 12, 2017Design for Developers: Specific Steps to Improve Your Website DesignJanuary 09, 2017How to Use the Command Line in Linux and macOS",
        "chunk_type": "text",
        "tag": "section",
        "score": 0.7210000000000001,
        "word_count": 109,
        "chunk_id": "374c38a6cfa3a961947c36d4cb25e1a9",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "web",
            "development",
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "large"
            ]
          },
          "technical_indicators": [
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "November 17, 2021An Introduction to GraphQLJune 23, 2021How to Structure and Organize a React ApplicationOctober 15, 2020How to Set Up webpack 5 From ScratchSeptember 10, 2020The Event Loop, Callbacks, Promises, and Async/Await in JavaScriptMarch 09, 2020How to Use Redux and ReactFebruary 17, 2020How to Set up a Mac for DevelopmentDecember 02, 2019A Complete Guide to CSS Concepts and FundamentalsMay 16, 2019How to Use Vue, the JavaScript FrameworkFebruary 11, 2019Everything I Know as a Software Developer Without a Degree (2019)August 20, 2018How to Use React, the JavaScript FrameworkOctober 12, 2017Design for Developers: Specific Steps to Improve Your Website DesignJanuary 09, 2017How to Use the Command Line in Linux and macOS",
        "chunk_type": "text",
        "tag": "div",
        "score": 0.7170000000000001,
        "word_count": 109,
        "chunk_id": "eb798f456c4957f7496947c12e09769f",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "development",
            "react"
          ],
          "attributes": {
            "class": [
              "highlight-preview"
            ]
          },
          "technical_indicators": [
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "ProjectsAll Projects2022Keyboard AccordionPlay the accordion with your keyboard!ArticleDemo2020TakeNoteA free, open source notes app for the web.ArticleDemo2019Chip8A retro game emulator for three platforms.ArticleDemo2021SokobanA web-based Sokoban implementation.ArticleDemo2015New MoonThe optimized dark theme for web development.Demo2019SnekA terminal-based Snake implementation.ArticleDemo",
        "chunk_type": "text",
        "tag": "section",
        "score": 0.573,
        "word_count": 35,
        "chunk_id": "8b1b9fdfd304efc446b2c464618e9de8",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "web",
            "article",
            "development"
          ],
          "attributes": {
            "class": [
              "segment",
              "large"
            ]
          },
          "technical_indicators": []
        }
      },
      {
        "content": "2022Keyboard AccordionPlay the accordion with your keyboard!ArticleDemo2020TakeNoteA free, open source notes app for the web.ArticleDemo2019Chip8A retro game emulator for three platforms.ArticleDemo2021SokobanA web-based Sokoban implementation.ArticleDemo2015New MoonThe optimized dark theme for web development.Demo2019SnekA terminal-based Snake implementation.ArticleDemo",
        "chunk_type": "text",
        "tag": "div",
        "score": 0.565,
        "word_count": 34,
        "chunk_id": "7823bf78c7b8142ce0ef47614c802d5f",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "development"
          ],
          "attributes": {
            "class": [
              "post-preview"
            ]
          },
          "technical_indicators": []
        }
      },
      {
        "content": "Creating a Keyboard Shortcut Hook in React (Deep Dive)October 2024New!Tables with Fixed Headers and Horizontal ScrollOctober 2024New!How to Use WebSockets in a Redux ApplicationFebruary 2023Understanding the GraphQL Type SystemJanuary 2023Testing API Calls With React Testing Library and JestDecember 2022",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.382,
        "word_count": 39,
        "chunk_id": "959ae1c7e8a32f512cb9cd55b7995029",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "posts",
              "newspaper"
            ]
          },
          "technical_indicators": [
            "react",
            "sql",
            "api"
          ]
        }
      }
    ],
    "chunk_count": 9,
    "content_types": [
      "text",
      "technical_content"
    ],
    "technical_concepts": [
      "javascript",
      "react",
      "api",
      "sql"
    ],
    "crawl_metadata": {}
  },
  {
    "metadata": {
      "description": "At some point, you might work on a React/Redux application that requires the use of WebSockets, such as for chat or live updates on a…",
      "url": "https://www.taniarascia.com/websockets-in-redux/",
      "title": "How to Use WebSockets in a Redux Application | Tania Rascia's Personal Website",
      "source_type": "web",
      "crawl_time": 1730107312.3411908,
      "keywords": [
        "sql",
        "web",
        "article",
        "extract",
        "development",
        "information",
        "react"
      ]
    },
    "relevance_score": 0.7711428571428571,
    "chunks": [
      {
        "content": "How to Use WebSockets in a Redux ApplicationAt some point, you might work on a React/Redux application that requires the use of WebSockets, such as for chat or live updates on a dashboard. It might be confusing at first to know where to put the WebSocket state and events relative to React components and Redux state.Redux Middlewareis a good place to handle all your WebSocket needs, which I'll lay out here.You can also see a working implementation of this method used in this minimalopen-source chat applicationI made with React/Redux, TypeScript, and Socket.io. I opted to just use the browser's WebSocket API for this article, though.PrerequisitesUnderstanding ReactUnderstanding ReduxGoalsSet up a Socket client and Redux middleware for handling a WebSocket connectionUsing WebSocketsTheWebSocket APIis a Web API that makes it possible to open a connection between a client and server. If you wanted to make something like a chat application without a WebSocket, you would have to utilize polling, or continuously making API requests at an interval.The client portion of the connection is set up withnew WebSocket(url), and it handlesopen,close, andmessageevents.// Initialize WebSocket connectionconstsocket=newWebSocket('wss://my-websocket-url')// Listen for open connectionsocket.addEventListener('open',(event)=>{console.log('You say hello...')})// Listen for messagessocket.addEventListener('message',(event)=>{console.log('Incoming message: ',event.data)})// Listen for close connectionsocket.addEventListener('close',(event)=>{console.log('...and I say goodbye!')})// Send a messagesocket.send('A message')// Close websocket connectionsocket.close()Socket ClassI often like to make a little class API to make it slightly cleaner and easier to work with code, and not have to make any global variables. Though I'm not sure exactly why I feel that this is so much better than havingconst socket = new WebSocket(url)defined somewhere. But here's a class that connects, disconnects, sends messages, and handles events.@/utils/Socket.jsclassSocket{constructor(){this.socket=null} onnect(url){if(!this.socket){this.socket=newWebSocket(url)}} isconnect(){if(this.socket){this.socket.close()this.socket=null}} end(message){if(this.socket){this.socket.send(JSON.stringify(message))}} n(eventName,callback){if(this.socket){this.socket.addEventListener(eventName,callback)}}} xport{Socket} ow this can be used in basically the same way, and it makes it simple to work with multiple WebSockets, which I have needed to do on some projects. The example here is quite simple, but you might have more than justopen,messageandcloseevents, and you might add other things into the class like checking for a heartbeat, applying retries, etc.import{Socket} rom'@/utils/Socket'constsocket=newSocket()socket.connect('wss://my-websocket-url')socket.on('open',(event)=>{console.log('You say hello...')})socket.on('message',(event)=>{console.log('Incoming message: ',event.data)})socket.on('close',(event)=>{console.log('...and I say goodbye!')})socket.send('A message')socket.disconnect()Creating Redux MiddlewareHere is an example of Redux middleware:constmiddleware=(params)=>(next)=>(action)=>{const{dispatch,getState}=paramsif(action.type==='action you want to intercept'){// Do something} eturnnext(action)} ou have access to the entire current state withgetState, and you have access to dispatching an action withdispatch. Middleware is similar to aRedux thunkaction.So for the Socket middleware, you'll want to intercept the open and close events for the WebSocket that have been dispatched from elsewhere. It might be on login to the application, as with an entire chat application, or it might be on mount of a specific page, as with a live dashboard.Usingsocket/connectandsocket/disconnectactions, you can pass through an initialized instance of theSocketclass created earlier. Onsocket/connect, you'll open the WebSocket connection and handle all events. Onsocket/disconnect, you'll close the connection.@/middleware/socket.jsexportconstsocketMiddleware=(socket)=>(params)=>(next)=>(action)=>{const{dispatch,getState}=paramsconst{type}=actionswitch(type){case'socket/connect':socket.connect('wss://example.com')socket.on('open',()=>{})socket.on('message',(data)=>{})socket.on('close',()=>{})breakcase'socket/disconnect':socket.disconnect()breakdefault:break} eturnnext(action)} ow the connection should be initialized when you callsocket/connect, and throughout the life of the application the WebSocket will be listening via the event handlers, until you end the connection.Finally, you'll add the middleware to the store configuration, shown here using theRedux Toolkitmethod which is currently the officially preferred method.@/store/index.jsimport{configureStore,getDefaultMiddleware} rom'@reduxjs/toolkit'import{rootReducer} rom'@/store/rootReducer'import{Socket} rom'@/utils/Socket'exportconststore=configureStore({reducer:rootReducer,middleware:[socketMiddleware(newSocket()),...getDefaultMiddleware()],})Now wherever you decide to call the connect and disconnect functions within the React component will have the desired effect.importReact,{useEffect} rom'react'import{useDispatch} rom'react-redux'exportconstLiveDashboardPage=()=>{constdispatch=useDispatch()useEffect(()=>{dispatch({type:'socket/connect'})return()=>{dispatch({type:'socket/disconnect'})}},[])} onclusionThis is a very minimalist setup for getting a WebSocket connection into a Redux application, but it covers the main gist of it. Use Middleware to intercept connect and disconnect events, and listen to all the events upon initialization and handle them accordingly.One thing to note with this particular approach is that every tab will open a new WebSocket connection. I've done some poking around but I haven't come to a definitive conclusion on whether or not 1 tab = 1 connection is the best approach, or whether using theSharedWorker APIandBroadcastChannel APIis a better approach. I plan to follow up this article with one about sharing a connection across multiple tabs using these APIs.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:February 15, 2023Category:TechnicalTagsreduxapijavascriptNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_class",
        "tag": "main",
        "score": 1.137,
        "word_count": 698,
        "chunk_id": "2be8d84da6c4405de257805ba9397cf9",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "How to Use WebSockets in a Redux ApplicationAt some point, you might work on a React/Redux application that requires the use of WebSockets, such as for chat or live updates on a dashboard. It might be confusing at first to know where to put the WebSocket state and events relative to React components and Redux state.Redux Middlewareis a good place to handle all your WebSocket needs, which I'll lay out here.You can also see a working implementation of this method used in this minimalopen-source chat applicationI made with React/Redux, TypeScript, and Socket.io. I opted to just use the browser's WebSocket API for this article, though.PrerequisitesUnderstanding ReactUnderstanding ReduxGoalsSet up a Socket client and Redux middleware for handling a WebSocket connectionUsing WebSocketsTheWebSocket APIis a Web API that makes it possible to open a connection between a client and server. If you wanted to make something like a chat application without a WebSocket, you would have to utilize polling, or continuously making API requests at an interval.The client portion of the connection is set up withnew WebSocket(url), and it handlesopen,close, andmessageevents.// Initialize WebSocket connectionconstsocket=newWebSocket('wss://my-websocket-url')// Listen for open connectionsocket.addEventListener('open',(event)=>{console.log('You say hello...')})// Listen for messagessocket.addEventListener('message',(event)=>{console.log('Incoming message: ',event.data)})// Listen for close connectionsocket.addEventListener('close',(event)=>{console.log('...and I say goodbye!')})// Send a messagesocket.send('A message')// Close websocket connectionsocket.close()Socket ClassI often like to make a little class API to make it slightly cleaner and easier to work with code, and not have to make any global variables. Though I'm not sure exactly why I feel that this is so much better than havingconst socket = new WebSocket(url)defined somewhere. But here's a class that connects, disconnects, sends messages, and handles events.@/utils/Socket.jsclassSocket{constructor(){this.socket=null} onnect(url){if(!this.socket){this.socket=newWebSocket(url)}} isconnect(){if(this.socket){this.socket.close()this.socket=null}} end(message){if(this.socket){this.socket.send(JSON.stringify(message))}} n(eventName,callback){if(this.socket){this.socket.addEventListener(eventName,callback)}}} xport{Socket} ow this can be used in basically the same way, and it makes it simple to work with multiple WebSockets, which I have needed to do on some projects. The example here is quite simple, but you might have more than justopen,messageandcloseevents, and you might add other things into the class like checking for a heartbeat, applying retries, etc.import{Socket} rom'@/utils/Socket'constsocket=newSocket()socket.connect('wss://my-websocket-url')socket.on('open',(event)=>{console.log('You say hello...')})socket.on('message',(event)=>{console.log('Incoming message: ',event.data)})socket.on('close',(event)=>{console.log('...and I say goodbye!')})socket.send('A message')socket.disconnect()Creating Redux MiddlewareHere is an example of Redux middleware:constmiddleware=(params)=>(next)=>(action)=>{const{dispatch,getState}=paramsif(action.type==='action you want to intercept'){// Do something} eturnnext(action)} ou have access to the entire current state withgetState, and you have access to dispatching an action withdispatch. Middleware is similar to aRedux thunkaction.So for the Socket middleware, you'll want to intercept the open and close events for the WebSocket that have been dispatched from elsewhere. It might be on login to the application, as with an entire chat application, or it might be on mount of a specific page, as with a live dashboard.Usingsocket/connectandsocket/disconnectactions, you can pass through an initialized instance of theSocketclass created earlier. Onsocket/connect, you'll open the WebSocket connection and handle all events. Onsocket/disconnect, you'll close the connection.@/middleware/socket.jsexportconstsocketMiddleware=(socket)=>(params)=>(next)=>(action)=>{const{dispatch,getState}=paramsconst{type}=actionswitch(type){case'socket/connect':socket.connect('wss://example.com')socket.on('open',()=>{})socket.on('message',(data)=>{})socket.on('close',()=>{})breakcase'socket/disconnect':socket.disconnect()breakdefault:break} eturnnext(action)} ow the connection should be initialized when you callsocket/connect, and throughout the life of the application the WebSocket will be listening via the event handlers, until you end the connection.Finally, you'll add the middleware to the store configuration, shown here using theRedux Toolkitmethod which is currently the officially preferred method.@/store/index.jsimport{configureStore,getDefaultMiddleware} rom'@reduxjs/toolkit'import{rootReducer} rom'@/store/rootReducer'import{Socket} rom'@/utils/Socket'exportconststore=configureStore({reducer:rootReducer,middleware:[socketMiddleware(newSocket()),...getDefaultMiddleware()],})Now wherever you decide to call the connect and disconnect functions within the React component will have the desired effect.importReact,{useEffect} rom'react'import{useDispatch} rom'react-redux'exportconstLiveDashboardPage=()=>{constdispatch=useDispatch()useEffect(()=>{dispatch({type:'socket/connect'})return()=>{dispatch({type:'socket/disconnect'})}},[])} onclusionThis is a very minimalist setup for getting a WebSocket connection into a Redux application, but it covers the main gist of it. Use Middleware to intercept connect and disconnect events, and listen to all the events upon initialization and handle them accordingly.One thing to note with this particular approach is that every tab will open a new WebSocket connection. I've done some poking around but I haven't come to a definitive conclusion on whether or not 1 tab = 1 connection is the best approach, or whether using theSharedWorker APIandBroadcastChannel APIis a better approach. I plan to follow up this article with one about sharing a connection across multiple tabs using these APIs.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:February 15, 2023Category:TechnicalTagsreduxapijavascriptNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.137,
        "word_count": 698,
        "chunk_id": "2be8d84da6c4405de257805ba9397cf9",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "How to Use WebSockets in a Redux ApplicationAt some point, you might work on a React/Redux application that requires the use of WebSockets, such as for chat or live updates on a dashboard. It might be confusing at first to know where to put the WebSocket state and events relative to React components and Redux state.Redux Middlewareis a good place to handle all your WebSocket needs, which I'll lay out here.You can also see a working implementation of this method used in this minimalopen-source chat applicationI made with React/Redux, TypeScript, and Socket.io. I opted to just use the browser's WebSocket API for this article, though.PrerequisitesUnderstanding ReactUnderstanding ReduxGoalsSet up a Socket client and Redux middleware for handling a WebSocket connectionUsing WebSocketsTheWebSocket APIis a Web API that makes it possible to open a connection between a client and server. If you wanted to make something like a chat application without a WebSocket, you would have to utilize polling, or continuously making API requests at an interval.The client portion of the connection is set up withnew WebSocket(url), and it handlesopen,close, andmessageevents.// Initialize WebSocket connectionconstsocket=newWebSocket('wss://my-websocket-url')// Listen for open connectionsocket.addEventListener('open',(event)=>{console.log('You say hello...')})// Listen for messagessocket.addEventListener('message',(event)=>{console.log('Incoming message: ',event.data)})// Listen for close connectionsocket.addEventListener('close',(event)=>{console.log('...and I say goodbye!')})// Send a messagesocket.send('A message')// Close websocket connectionsocket.close()Socket ClassI often like to make a little class API to make it slightly cleaner and easier to work with code, and not have to make any global variables. Though I'm not sure exactly why I feel that this is so much better than havingconst socket = new WebSocket(url)defined somewhere. But here's a class that connects, disconnects, sends messages, and handles events.@/utils/Socket.jsclassSocket{constructor(){this.socket=null} onnect(url){if(!this.socket){this.socket=newWebSocket(url)}} isconnect(){if(this.socket){this.socket.close()this.socket=null}} end(message){if(this.socket){this.socket.send(JSON.stringify(message))}} n(eventName,callback){if(this.socket){this.socket.addEventListener(eventName,callback)}}} xport{Socket} ow this can be used in basically the same way, and it makes it simple to work with multiple WebSockets, which I have needed to do on some projects. The example here is quite simple, but you might have more than justopen,messageandcloseevents, and you might add other things into the class like checking for a heartbeat, applying retries, etc.import{Socket} rom'@/utils/Socket'constsocket=newSocket()socket.connect('wss://my-websocket-url')socket.on('open',(event)=>{console.log('You say hello...')})socket.on('message',(event)=>{console.log('Incoming message: ',event.data)})socket.on('close',(event)=>{console.log('...and I say goodbye!')})socket.send('A message')socket.disconnect()Creating Redux MiddlewareHere is an example of Redux middleware:constmiddleware=(params)=>(next)=>(action)=>{const{dispatch,getState}=paramsif(action.type==='action you want to intercept'){// Do something} eturnnext(action)} ou have access to the entire current state withgetState, and you have access to dispatching an action withdispatch. Middleware is similar to aRedux thunkaction.So for the Socket middleware, you'll want to intercept the open and close events for the WebSocket that have been dispatched from elsewhere. It might be on login to the application, as with an entire chat application, or it might be on mount of a specific page, as with a live dashboard.Usingsocket/connectandsocket/disconnectactions, you can pass through an initialized instance of theSocketclass created earlier. Onsocket/connect, you'll open the WebSocket connection and handle all events. Onsocket/disconnect, you'll close the connection.@/middleware/socket.jsexportconstsocketMiddleware=(socket)=>(params)=>(next)=>(action)=>{const{dispatch,getState}=paramsconst{type}=actionswitch(type){case'socket/connect':socket.connect('wss://example.com')socket.on('open',()=>{})socket.on('message',(data)=>{})socket.on('close',()=>{})breakcase'socket/disconnect':socket.disconnect()breakdefault:break} eturnnext(action)} ow the connection should be initialized when you callsocket/connect, and throughout the life of the application the WebSocket will be listening via the event handlers, until you end the connection.Finally, you'll add the middleware to the store configuration, shown here using theRedux Toolkitmethod which is currently the officially preferred method.@/store/index.jsimport{configureStore,getDefaultMiddleware} rom'@reduxjs/toolkit'import{rootReducer} rom'@/store/rootReducer'import{Socket} rom'@/utils/Socket'exportconststore=configureStore({reducer:rootReducer,middleware:[socketMiddleware(newSocket()),...getDefaultMiddleware()],})Now wherever you decide to call the connect and disconnect functions within the React component will have the desired effect.importReact,{useEffect} rom'react'import{useDispatch} rom'react-redux'exportconstLiveDashboardPage=()=>{constdispatch=useDispatch()useEffect(()=>{dispatch({type:'socket/connect'})return()=>{dispatch({type:'socket/disconnect'})}},[])} onclusionThis is a very minimalist setup for getting a WebSocket connection into a Redux application, but it covers the main gist of it. Use Middleware to intercept connect and disconnect events, and listen to all the events upon initialization and handle them accordingly.One thing to note with this particular approach is that every tab will open a new WebSocket connection. I've done some poking around but I haven't come to a definitive conclusion on whether or not 1 tab = 1 connection is the best approach, or whether using theSharedWorker APIandBroadcastChannel APIis a better approach. I plan to follow up this article with one about sharing a connection across multiple tabs using these APIs.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:February 15, 2023Category:TechnicalTagsreduxapijavascriptNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.137,
        "word_count": 698,
        "chunk_id": "2be8d84da6c4405de257805ba9397cf9",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "How to Use WebSockets in a Redux ApplicationAt some point, you might work on a React/Redux application that requires the use of WebSockets, such as for chat or live updates on a dashboard. It might be confusing at first to know where to put the WebSocket state and events relative to React components and Redux state.Redux Middlewareis a good place to handle all your WebSocket needs, which I'll lay out here.You can also see a working implementation of this method used in this minimalopen-source chat applicationI made with React/Redux, TypeScript, and Socket.io. I opted to just use the browser's WebSocket API for this article, though.PrerequisitesUnderstanding ReactUnderstanding ReduxGoalsSet up a Socket client and Redux middleware for handling a WebSocket connectionUsing WebSocketsTheWebSocket APIis a Web API that makes it possible to open a connection between a client and server. If you wanted to make something like a chat application without a WebSocket, you would have to utilize polling, or continuously making API requests at an interval.The client portion of the connection is set up withnew WebSocket(url), and it handlesopen,close, andmessageevents.// Initialize WebSocket connectionconstsocket=newWebSocket('wss://my-websocket-url')// Listen for open connectionsocket.addEventListener('open',(event)=>{console.log('You say hello...')})// Listen for messagessocket.addEventListener('message',(event)=>{console.log('Incoming message: ',event.data)})// Listen for close connectionsocket.addEventListener('close',(event)=>{console.log('...and I say goodbye!')})// Send a messagesocket.send('A message')// Close websocket connectionsocket.close()Socket ClassI often like to make a little class API to make it slightly cleaner and easier to work with code, and not have to make any global variables. Though I'm not sure exactly why I feel that this is so much better than havingconst socket = new WebSocket(url)defined somewhere. But here's a class that connects, disconnects, sends messages, and handles events.@/utils/Socket.jsclassSocket{constructor(){this.socket=null} onnect(url){if(!this.socket){this.socket=newWebSocket(url)}} isconnect(){if(this.socket){this.socket.close()this.socket=null}} end(message){if(this.socket){this.socket.send(JSON.stringify(message))}} n(eventName,callback){if(this.socket){this.socket.addEventListener(eventName,callback)}}} xport{Socket} ow this can be used in basically the same way, and it makes it simple to work with multiple WebSockets, which I have needed to do on some projects. The example here is quite simple, but you might have more than justopen,messageandcloseevents, and you might add other things into the class like checking for a heartbeat, applying retries, etc.import{Socket} rom'@/utils/Socket'constsocket=newSocket()socket.connect('wss://my-websocket-url')socket.on('open',(event)=>{console.log('You say hello...')})socket.on('message',(event)=>{console.log('Incoming message: ',event.data)})socket.on('close',(event)=>{console.log('...and I say goodbye!')})socket.send('A message')socket.disconnect()Creating Redux MiddlewareHere is an example of Redux middleware:constmiddleware=(params)=>(next)=>(action)=>{const{dispatch,getState}=paramsif(action.type==='action you want to intercept'){// Do something} eturnnext(action)} ou have access to the entire current state withgetState, and you have access to dispatching an action withdispatch. Middleware is similar to aRedux thunkaction.So for the Socket middleware, you'll want to intercept the open and close events for the WebSocket that have been dispatched from elsewhere. It might be on login to the application, as with an entire chat application, or it might be on mount of a specific page, as with a live dashboard.Usingsocket/connectandsocket/disconnectactions, you can pass through an initialized instance of theSocketclass created earlier. Onsocket/connect, you'll open the WebSocket connection and handle all events. Onsocket/disconnect, you'll close the connection.@/middleware/socket.jsexportconstsocketMiddleware=(socket)=>(params)=>(next)=>(action)=>{const{dispatch,getState}=paramsconst{type}=actionswitch(type){case'socket/connect':socket.connect('wss://example.com')socket.on('open',()=>{})socket.on('message',(data)=>{})socket.on('close',()=>{})breakcase'socket/disconnect':socket.disconnect()breakdefault:break} eturnnext(action)} ow the connection should be initialized when you callsocket/connect, and throughout the life of the application the WebSocket will be listening via the event handlers, until you end the connection.Finally, you'll add the middleware to the store configuration, shown here using theRedux Toolkitmethod which is currently the officially preferred method.@/store/index.jsimport{configureStore,getDefaultMiddleware} rom'@reduxjs/toolkit'import{rootReducer} rom'@/store/rootReducer'import{Socket} rom'@/utils/Socket'exportconststore=configureStore({reducer:rootReducer,middleware:[socketMiddleware(newSocket()),...getDefaultMiddleware()],})Now wherever you decide to call the connect and disconnect functions within the React component will have the desired effect.importReact,{useEffect} rom'react'import{useDispatch} rom'react-redux'exportconstLiveDashboardPage=()=>{constdispatch=useDispatch()useEffect(()=>{dispatch({type:'socket/connect'})return()=>{dispatch({type:'socket/disconnect'})}},[])} onclusionThis is a very minimalist setup for getting a WebSocket connection into a Redux application, but it covers the main gist of it. Use Middleware to intercept connect and disconnect events, and listen to all the events upon initialization and handle them accordingly.One thing to note with this particular approach is that every tab will open a new WebSocket connection. I've done some poking around but I haven't come to a definitive conclusion on whether or not 1 tab = 1 connection is the best approach, or whether using theSharedWorker APIandBroadcastChannel APIis a better approach. I plan to follow up this article with one about sharing a connection across multiple tabs using these APIs.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:February 15, 2023Category:TechnicalTagsreduxapijavascriptNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.137,
        "word_count": 698,
        "chunk_id": "2be8d84da6c4405de257805ba9397cf9",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "How to Use WebSockets in a Redux ApplicationAt some point, you might work on a React/Redux application that requires the use of WebSockets, such as for chat or live updates on a dashboard. It might be confusing at first to know where to put the WebSocket state and events relative to React components and Redux state.Redux Middlewareis a good place to handle all your WebSocket needs, which I'll lay out here.You can also see a working implementation of this method used in this minimalopen-source chat applicationI made with React/Redux, TypeScript, and Socket.io. I opted to just use the browser's WebSocket API for this article, though.PrerequisitesUnderstanding ReactUnderstanding ReduxGoalsSet up a Socket client and Redux middleware for handling a WebSocket connectionUsing WebSocketsTheWebSocket APIis a Web API that makes it possible to open a connection between a client and server. If you wanted to make something like a chat application without a WebSocket, you would have to utilize polling, or continuously making API requests at an interval.The client portion of the connection is set up withnew WebSocket(url), and it handlesopen,close, andmessageevents.// Initialize WebSocket connectionconstsocket=newWebSocket('wss://my-websocket-url')// Listen for open connectionsocket.addEventListener('open',(event)=>{console.log('You say hello...')})// Listen for messagessocket.addEventListener('message',(event)=>{console.log('Incoming message: ',event.data)})// Listen for close connectionsocket.addEventListener('close',(event)=>{console.log('...and I say goodbye!')})// Send a messagesocket.send('A message')// Close websocket connectionsocket.close()Socket ClassI often like to make a little class API to make it slightly cleaner and easier to work with code, and not have to make any global variables. Though I'm not sure exactly why I feel that this is so much better than havingconst socket = new WebSocket(url)defined somewhere. But here's a class that connects, disconnects, sends messages, and handles events.@/utils/Socket.jsclassSocket{constructor(){this.socket=null} onnect(url){if(!this.socket){this.socket=newWebSocket(url)}} isconnect(){if(this.socket){this.socket.close()this.socket=null}} end(message){if(this.socket){this.socket.send(JSON.stringify(message))}} n(eventName,callback){if(this.socket){this.socket.addEventListener(eventName,callback)}}} xport{Socket} ow this can be used in basically the same way, and it makes it simple to work with multiple WebSockets, which I have needed to do on some projects. The example here is quite simple, but you might have more than justopen,messageandcloseevents, and you might add other things into the class like checking for a heartbeat, applying retries, etc.import{Socket} rom'@/utils/Socket'constsocket=newSocket()socket.connect('wss://my-websocket-url')socket.on('open',(event)=>{console.log('You say hello...')})socket.on('message',(event)=>{console.log('Incoming message: ',event.data)})socket.on('close',(event)=>{console.log('...and I say goodbye!')})socket.send('A message')socket.disconnect()Creating Redux MiddlewareHere is an example of Redux middleware:constmiddleware=(params)=>(next)=>(action)=>{const{dispatch,getState}=paramsif(action.type==='action you want to intercept'){// Do something} eturnnext(action)} ou have access to the entire current state withgetState, and you have access to dispatching an action withdispatch. Middleware is similar to aRedux thunkaction.So for the Socket middleware, you'll want to intercept the open and close events for the WebSocket that have been dispatched from elsewhere. It might be on login to the application, as with an entire chat application, or it might be on mount of a specific page, as with a live dashboard.Usingsocket/connectandsocket/disconnectactions, you can pass through an initialized instance of theSocketclass created earlier. Onsocket/connect, you'll open the WebSocket connection and handle all events. Onsocket/disconnect, you'll close the connection.@/middleware/socket.jsexportconstsocketMiddleware=(socket)=>(params)=>(next)=>(action)=>{const{dispatch,getState}=paramsconst{type}=actionswitch(type){case'socket/connect':socket.connect('wss://example.com')socket.on('open',()=>{})socket.on('message',(data)=>{})socket.on('close',()=>{})breakcase'socket/disconnect':socket.disconnect()breakdefault:break} eturnnext(action)} ow the connection should be initialized when you callsocket/connect, and throughout the life of the application the WebSocket will be listening via the event handlers, until you end the connection.Finally, you'll add the middleware to the store configuration, shown here using theRedux Toolkitmethod which is currently the officially preferred method.@/store/index.jsimport{configureStore,getDefaultMiddleware} rom'@reduxjs/toolkit'import{rootReducer} rom'@/store/rootReducer'import{Socket} rom'@/utils/Socket'exportconststore=configureStore({reducer:rootReducer,middleware:[socketMiddleware(newSocket()),...getDefaultMiddleware()],})Now wherever you decide to call the connect and disconnect functions within the React component will have the desired effect.importReact,{useEffect} rom'react'import{useDispatch} rom'react-redux'exportconstLiveDashboardPage=()=>{constdispatch=useDispatch()useEffect(()=>{dispatch({type:'socket/connect'})return()=>{dispatch({type:'socket/disconnect'})}},[])} onclusionThis is a very minimalist setup for getting a WebSocket connection into a Redux application, but it covers the main gist of it. Use Middleware to intercept connect and disconnect events, and listen to all the events upon initialization and handle them accordingly.One thing to note with this particular approach is that every tab will open a new WebSocket connection. I've done some poking around but I haven't come to a definitive conclusion on whether or not 1 tab = 1 connection is the best approach, or whether using theSharedWorker APIandBroadcastChannel APIis a better approach. I plan to follow up this article with one about sharing a connection across multiple tabs using these APIs.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:February 15, 2023Category:TechnicalTagsreduxapijavascriptNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.137,
        "word_count": 698,
        "chunk_id": "2be8d84da6c4405de257805ba9397cf9",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "At some point, you might work on a React/Redux application that requires the use of WebSockets, such as for chat or live updates on a dashboard. It might be confusing at first to know where to put the WebSocket state and events relative to React components and Redux state.Redux Middlewareis a good place to handle all your WebSocket needs, which I'll lay out here.You can also see a working implementation of this method used in this minimalopen-source chat applicationI made with React/Redux, TypeScript, and Socket.io. I opted to just use the browser's WebSocket API for this article, though.PrerequisitesUnderstanding ReactUnderstanding ReduxGoalsSet up a Socket client and Redux middleware for handling a WebSocket connectionUsing WebSocketsTheWebSocket APIis a Web API that makes it possible to open a connection between a client and server. If you wanted to make something like a chat application without a WebSocket, you would have to utilize polling, or continuously making API requests at an interval.The client portion of the connection is set up withnew WebSocket(url), and it handlesopen,close, andmessageevents.// Initialize WebSocket connectionconstsocket=newWebSocket('wss://my-websocket-url')// Listen for open connectionsocket.addEventListener('open',(event)=>{console.log('You say hello...')})// Listen for messagessocket.addEventListener('message',(event)=>{console.log('Incoming message: ',event.data)})// Listen for close connectionsocket.addEventListener('close',(event)=>{console.log('...and I say goodbye!')})// Send a messagesocket.send('A message')// Close websocket connectionsocket.close()Socket ClassI often like to make a little class API to make it slightly cleaner and easier to work with code, and not have to make any global variables. Though I'm not sure exactly why I feel that this is so much better than havingconst socket = new WebSocket(url)defined somewhere. But here's a class that connects, disconnects, sends messages, and handles events.@/utils/Socket.jsclassSocket{constructor(){this.socket=null} onnect(url){if(!this.socket){this.socket=newWebSocket(url)}} isconnect(){if(this.socket){this.socket.close()this.socket=null}} end(message){if(this.socket){this.socket.send(JSON.stringify(message))}} n(eventName,callback){if(this.socket){this.socket.addEventListener(eventName,callback)}}} xport{Socket} ow this can be used in basically the same way, and it makes it simple to work with multiple WebSockets, which I have needed to do on some projects. The example here is quite simple, but you might have more than justopen,messageandcloseevents, and you might add other things into the class like checking for a heartbeat, applying retries, etc.import{Socket} rom'@/utils/Socket'constsocket=newSocket()socket.connect('wss://my-websocket-url')socket.on('open',(event)=>{console.log('You say hello...')})socket.on('message',(event)=>{console.log('Incoming message: ',event.data)})socket.on('close',(event)=>{console.log('...and I say goodbye!')})socket.send('A message')socket.disconnect()Creating Redux MiddlewareHere is an example of Redux middleware:constmiddleware=(params)=>(next)=>(action)=>{const{dispatch,getState}=paramsif(action.type==='action you want to intercept'){// Do something} eturnnext(action)} ou have access to the entire current state withgetState, and you have access to dispatching an action withdispatch. Middleware is similar to aRedux thunkaction.So for the Socket middleware, you'll want to intercept the open and close events for the WebSocket that have been dispatched from elsewhere. It might be on login to the application, as with an entire chat application, or it might be on mount of a specific page, as with a live dashboard.Usingsocket/connectandsocket/disconnectactions, you can pass through an initialized instance of theSocketclass created earlier. Onsocket/connect, you'll open the WebSocket connection and handle all events. Onsocket/disconnect, you'll close the connection.@/middleware/socket.jsexportconstsocketMiddleware=(socket)=>(params)=>(next)=>(action)=>{const{dispatch,getState}=paramsconst{type}=actionswitch(type){case'socket/connect':socket.connect('wss://example.com')socket.on('open',()=>{})socket.on('message',(data)=>{})socket.on('close',()=>{})breakcase'socket/disconnect':socket.disconnect()breakdefault:break} eturnnext(action)} ow the connection should be initialized when you callsocket/connect, and throughout the life of the application the WebSocket will be listening via the event handlers, until you end the connection.Finally, you'll add the middleware to the store configuration, shown here using theRedux Toolkitmethod which is currently the officially preferred method.@/store/index.jsimport{configureStore,getDefaultMiddleware} rom'@reduxjs/toolkit'import{rootReducer} rom'@/store/rootReducer'import{Socket} rom'@/utils/Socket'exportconststore=configureStore({reducer:rootReducer,middleware:[socketMiddleware(newSocket()),...getDefaultMiddleware()],})Now wherever you decide to call the connect and disconnect functions within the React component will have the desired effect.importReact,{useEffect} rom'react'import{useDispatch} rom'react-redux'exportconstLiveDashboardPage=()=>{constdispatch=useDispatch()useEffect(()=>{dispatch({type:'socket/connect'})return()=>{dispatch({type:'socket/disconnect'})}},[])} onclusionThis is a very minimalist setup for getting a WebSocket connection into a Redux application, but it covers the main gist of it. Use Middleware to intercept connect and disconnect events, and listen to all the events upon initialization and handle them accordingly.One thing to note with this particular approach is that every tab will open a new WebSocket connection. I've done some poking around but I haven't come to a definitive conclusion on whether or not 1 tab = 1 connection is the best approach, or whether using theSharedWorker APIandBroadcastChannel APIis a better approach. I plan to follow up this article with one about sharing a connection across multiple tabs using these APIs.",
        "chunk_type": "code_class",
        "tag": "section",
        "score": 1.157,
        "word_count": 638,
        "chunk_id": "a47fa0006cf1a662b69b0b18eeeb6d66",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "At some point, you might work on a React/Redux application that requires the use of WebSockets, such as for chat or live updates on a dashboard. It might be confusing at first to know where to put the WebSocket state and events relative to React components and Redux state.Redux Middlewareis a good place to handle all your WebSocket needs, which I'll lay out here.You can also see a working implementation of this method used in this minimalopen-source chat applicationI made with React/Redux, TypeScript, and Socket.io. I opted to just use the browser's WebSocket API for this article, though.PrerequisitesUnderstanding ReactUnderstanding ReduxGoalsSet up a Socket client and Redux middleware for handling a WebSocket connectionUsing WebSocketsTheWebSocket APIis a Web API that makes it possible to open a connection between a client and server. If you wanted to make something like a chat application without a WebSocket, you would have to utilize polling, or continuously making API requests at an interval.The client portion of the connection is set up withnew WebSocket(url), and it handlesopen,close, andmessageevents.// Initialize WebSocket connectionconstsocket=newWebSocket('wss://my-websocket-url')// Listen for open connectionsocket.addEventListener('open',(event)=>{console.log('You say hello...')})// Listen for messagessocket.addEventListener('message',(event)=>{console.log('Incoming message: ',event.data)})// Listen for close connectionsocket.addEventListener('close',(event)=>{console.log('...and I say goodbye!')})// Send a messagesocket.send('A message')// Close websocket connectionsocket.close()Socket ClassI often like to make a little class API to make it slightly cleaner and easier to work with code, and not have to make any global variables. Though I'm not sure exactly why I feel that this is so much better than havingconst socket = new WebSocket(url)defined somewhere. But here's a class that connects, disconnects, sends messages, and handles events.@/utils/Socket.jsclassSocket{constructor(){this.socket=null} onnect(url){if(!this.socket){this.socket=newWebSocket(url)}} isconnect(){if(this.socket){this.socket.close()this.socket=null}} end(message){if(this.socket){this.socket.send(JSON.stringify(message))}} n(eventName,callback){if(this.socket){this.socket.addEventListener(eventName,callback)}}} xport{Socket} ow this can be used in basically the same way, and it makes it simple to work with multiple WebSockets, which I have needed to do on some projects. The example here is quite simple, but you might have more than justopen,messageandcloseevents, and you might add other things into the class like checking for a heartbeat, applying retries, etc.import{Socket} rom'@/utils/Socket'constsocket=newSocket()socket.connect('wss://my-websocket-url')socket.on('open',(event)=>{console.log('You say hello...')})socket.on('message',(event)=>{console.log('Incoming message: ',event.data)})socket.on('close',(event)=>{console.log('...and I say goodbye!')})socket.send('A message')socket.disconnect()Creating Redux MiddlewareHere is an example of Redux middleware:constmiddleware=(params)=>(next)=>(action)=>{const{dispatch,getState}=paramsif(action.type==='action you want to intercept'){// Do something} eturnnext(action)} ou have access to the entire current state withgetState, and you have access to dispatching an action withdispatch. Middleware is similar to aRedux thunkaction.So for the Socket middleware, you'll want to intercept the open and close events for the WebSocket that have been dispatched from elsewhere. It might be on login to the application, as with an entire chat application, or it might be on mount of a specific page, as with a live dashboard.Usingsocket/connectandsocket/disconnectactions, you can pass through an initialized instance of theSocketclass created earlier. Onsocket/connect, you'll open the WebSocket connection and handle all events. Onsocket/disconnect, you'll close the connection.@/middleware/socket.jsexportconstsocketMiddleware=(socket)=>(params)=>(next)=>(action)=>{const{dispatch,getState}=paramsconst{type}=actionswitch(type){case'socket/connect':socket.connect('wss://example.com')socket.on('open',()=>{})socket.on('message',(data)=>{})socket.on('close',()=>{})breakcase'socket/disconnect':socket.disconnect()breakdefault:break} eturnnext(action)} ow the connection should be initialized when you callsocket/connect, and throughout the life of the application the WebSocket will be listening via the event handlers, until you end the connection.Finally, you'll add the middleware to the store configuration, shown here using theRedux Toolkitmethod which is currently the officially preferred method.@/store/index.jsimport{configureStore,getDefaultMiddleware} rom'@reduxjs/toolkit'import{rootReducer} rom'@/store/rootReducer'import{Socket} rom'@/utils/Socket'exportconststore=configureStore({reducer:rootReducer,middleware:[socketMiddleware(newSocket()),...getDefaultMiddleware()],})Now wherever you decide to call the connect and disconnect functions within the React component will have the desired effect.importReact,{useEffect} rom'react'import{useDispatch} rom'react-redux'exportconstLiveDashboardPage=()=>{constdispatch=useDispatch()useEffect(()=>{dispatch({type:'socket/connect'})return()=>{dispatch({type:'socket/disconnect'})}},[])} onclusionThis is a very minimalist setup for getting a WebSocket connection into a Redux application, but it covers the main gist of it. Use Middleware to intercept connect and disconnect events, and listen to all the events upon initialization and handle them accordingly.One thing to note with this particular approach is that every tab will open a new WebSocket connection. I've done some poking around but I haven't come to a definitive conclusion on whether or not 1 tab = 1 connection is the best approach, or whether using theSharedWorker APIandBroadcastChannel APIis a better approach. I plan to follow up this article with one about sharing a connection across multiple tabs using these APIs.",
        "chunk_type": "code_class",
        "tag": "div",
        "score": 1.157,
        "word_count": 638,
        "chunk_id": "a47fa0006cf1a662b69b0b18eeeb6d66",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "id": "/websockets-in-redux/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api",
            "data"
          ]
        }
      },
      {
        "content": "You can also see a working implementation of this method used in this minimalopen-source chat applicationI made with React/Redux, TypeScript, and Socket.io. I opted to just use the browser's WebSocket API for this article, though.",
        "chunk_type": "technical_content",
        "tag": "p",
        "score": 0.483,
        "word_count": 35,
        "chunk_id": "b62257d0704e9985caf9b0f951f5c695",
        "metadata": {
          "source_tag": "p",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "api"
          ]
        }
      },
      {
        "content": "At some point, you might work on a React/Redux application that requires the use of WebSockets, such as for chat or live updates on a dashboard. It might be confusing at first to know where to put the WebSocket state and events relative to React components and Redux state.",
        "chunk_type": "technical_content",
        "tag": "p",
        "score": 0.372,
        "word_count": 49,
        "chunk_id": "5f4de1292d6cd297d500061f0e2d6b15",
        "metadata": {
          "source_tag": "p",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "sql"
          ]
        }
      },
      {
        "content": "One thing to note with this particular approach is that every tab will open a new WebSocket connection. I've done some poking around but I haven't come to a definitive conclusion on whether or not 1 tab = 1 connection is the best approach, or whether using theSharedWorker APIandBroadcastChannel APIis a better approach. I plan to follow up this article with one about sharing a connection across multiple tabs using these APIs.",
        "chunk_type": "technical_content",
        "tag": "p",
        "score": 0.43000000000000005,
        "word_count": 72,
        "chunk_id": "97befc2a2f7e7953485530831bc3898c",
        "metadata": {
          "source_tag": "p",
          "keywords_found": [
            "web",
            "article"
          ],
          "attributes": {},
          "technical_indicators": [
            "api"
          ]
        }
      },
      {
        "content": "// Initialize WebSocket connectionconstsocket=newWebSocket('wss://my-websocket-url')// Listen for open connectionsocket.addEventListener('open',(event)=>{console.log('You say hello...')})// Listen for messagessocket.addEventListener('message',(event)=>{console.log('Incoming message: ',event.data)})// Listen for close connectionsocket.addEventListener('close',(event)=>{console.log('...and I say goodbye!')})// Send a messagesocket.send('A message')// Close websocket connectionsocket.close()",
        "chunk_type": "text",
        "tag": "div",
        "score": 0.40099999999999997,
        "word_count": 29,
        "chunk_id": "1b50f40eb8de290a47a144fae4bba6a2",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web"
          ],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "js"
          },
          "technical_indicators": [
            "javascript"
          ]
        }
      },
      {
        "content": "// Initialize WebSocket connectionconstsocket=newWebSocket('wss://my-websocket-url')// Listen for open connectionsocket.addEventListener('open',(event)=>{console.log('You say hello...')})// Listen for messagessocket.addEventListener('message',(event)=>{console.log('Incoming message: ',event.data)})// Listen for close connectionsocket.addEventListener('close',(event)=>{console.log('...and I say goodbye!')})// Send a messagesocket.send('A message')// Close websocket connectionsocket.close()",
        "chunk_type": "text",
        "tag": "pre",
        "score": 0.40099999999999997,
        "word_count": 29,
        "chunk_id": "1b50f40eb8de290a47a144fae4bba6a2",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [
            "web"
          ],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "javascript"
          ]
        }
      },
      {
        "content": "// Initialize WebSocket connectionconstsocket=newWebSocket('wss://my-websocket-url')// Listen for open connectionsocket.addEventListener('open',(event)=>{console.log('You say hello...')})// Listen for messagessocket.addEventListener('message',(event)=>{console.log('Incoming message: ',event.data)})// Listen for close connectionsocket.addEventListener('close',(event)=>{console.log('...and I say goodbye!')})// Send a messagesocket.send('A message')// Close websocket connectionsocket.close()",
        "chunk_type": "text",
        "tag": "code",
        "score": 0.40099999999999997,
        "word_count": 29,
        "chunk_id": "1b50f40eb8de290a47a144fae4bba6a2",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [
            "web"
          ],
          "attributes": {
            "class": [
              "language-js"
            ]
          },
          "technical_indicators": [
            "javascript"
          ]
        }
      },
      {
        "content": "About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:February 15, 2023Category:TechnicalTagsreduxapijavascriptNewsletterSubscribe to the Newsletter",
        "chunk_type": "technical_content",
        "tag": "aside",
        "score": 0.30900000000000005,
        "word_count": 54,
        "chunk_id": "08e69a950d5144052f4a0f58dc45b73c",
        "metadata": {
          "source_tag": "aside",
          "keywords_found": [
            "web"
          ],
          "attributes": {
            "class": [
              "post-sidebar"
            ]
          },
          "technical_indicators": [
            "javascript",
            "api"
          ]
        }
      }
    ],
    "chunk_count": 14,
    "content_types": [
      "code_class",
      "text",
      "technical_content"
    ],
    "technical_concepts": [
      "javascript",
      "sql",
      "data",
      "api",
      "react"
    ],
    "crawl_metadata": {},
    "technical_content": [
      {
        "id": "02b33f8dfa3c169af05c8b197dce78b0",
        "content": "new WebSocket(url)",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "7cef8a734855777c2a9d0caf42666e69",
        "content": "open",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "716f6b30598ba30945d84485e61c1027",
        "content": "close",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "78e731027d8fd50ed642340b7c9a63b3",
        "content": "message",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4d9ffed76fc1013a12f58f367b49e70e",
        "content": "// Initialize WebSocket connection const socket = new WebSocket('wss://my-websocket-url') // Listen for open connection socket.addEventListener('open', (event) => { console.log('You say hello...') }) // Listen for messages socket.addEventListener('message', (event) => { console.log('Incoming message: ', event.data) }) // Listen for close connection socket.addEventListener('close', (event) => { console.log('...and I say goodbye!') }) // Send a message socket.send('A message') // Close websocket connection socket.close()",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "4d9ffed76fc1013a12f58f367b49e70e",
        "content": "// Initialize WebSocket connection const socket = new WebSocket('wss://my-websocket-url') // Listen for open connection socket.addEventListener('open', (event) => { console.log('You say hello...') }) // Listen for messages socket.addEventListener('message', (event) => { console.log('Incoming message: ', event.data) }) // Listen for close connection socket.addEventListener('close', (event) => { console.log('...and I say goodbye!') }) // Send a message socket.send('A message') // Close websocket connection socket.close()",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "d30a1ffa125af72c3cd5b34e1948d386",
        "content": "const socket = new WebSocket(url)",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "2c9951e4ba4fe3caa79b33cfcd88f28f",
        "content": "class Socket { constructor() { this.socket = null } connect(url) { if (!this.socket) { this.socket = new WebSocket(url) } } disconnect() { if (this.socket) { this.socket.close() this.socket = null } } send(message) { if (this.socket) { this.socket.send(JSON.stringify(message)) } } on(eventName, callback) { if (this.socket) { this.socket.addEventListener(eventName, callback) } } } export { Socket }",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "2c9951e4ba4fe3caa79b33cfcd88f28f",
        "content": "class Socket { constructor() { this.socket = null } connect(url) { if (!this.socket) { this.socket = new WebSocket(url) } } disconnect() { if (this.socket) { this.socket.close() this.socket = null } } send(message) { if (this.socket) { this.socket.send(JSON.stringify(message)) } } on(eventName, callback) { if (this.socket) { this.socket.addEventListener(eventName, callback) } } } export { Socket }",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "7cef8a734855777c2a9d0caf42666e69",
        "content": "open",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "78e731027d8fd50ed642340b7c9a63b3",
        "content": "message",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "716f6b30598ba30945d84485e61c1027",
        "content": "close",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "92fe05caef2e7e537c052be81dc1cca5",
        "content": "import { Socket } from ' /utils/Socket' const socket = new Socket()socket.connect('wss://my-websocket-url') socket.on('open', (event) => { console.log('You say hello...') }) socket.on('message', (event) => { console.log('Incoming message: ', event.data) }) socket.on('close', (event) => { console.log('...and I say goodbye!') }) socket.send('A message') socket.disconnect()",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "92fe05caef2e7e537c052be81dc1cca5",
        "content": "import { Socket } from ' /utils/Socket' const socket = new Socket()socket.connect('wss://my-websocket-url') socket.on('open', (event) => { console.log('You say hello...') }) socket.on('message', (event) => { console.log('Incoming message: ', event.data) }) socket.on('close', (event) => { console.log('...and I say goodbye!') }) socket.send('A message') socket.disconnect()",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "5438088c1daeaf2a58e523d9ac49eafc",
        "content": "const middleware = (params) => (next) => (action) => { const { dispatch, getState } = params if (action.type === 'action you want to intercept') { // Do something } return next(action) }",
        "type": "code",
        "language": "js",
        "relevance": 0.4052631578947369
      },
      {
        "id": "5438088c1daeaf2a58e523d9ac49eafc",
        "content": "const middleware = (params) => (next) => (action) => { const { dispatch, getState } = params if (action.type === 'action you want to intercept') { // Do something } return next(action) }",
        "type": "code",
        "language": "js",
        "relevance": 0.4052631578947369
      },
      {
        "id": "2129e874626fd86fe1c10033c626dcf6",
        "content": "getState",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "9dddf2a4f7d94594ec2ea98407a410e1",
        "content": "dispatch",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "445839998890c17a8378518751502a99",
        "content": "socket/connect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5f78569a85c8db55291bf3865bc1b74b",
        "content": "socket/disconnect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "69f69b59aae6f4ee1a47bbc1086ecdb4",
        "content": "Socket",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "445839998890c17a8378518751502a99",
        "content": "socket/connect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5f78569a85c8db55291bf3865bc1b74b",
        "content": "socket/disconnect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "fa521c261592ea7d90d648aff8900e0c",
        "content": "export const socketMiddleware = (socket) => (params) => (next) => (action) => { const { dispatch, getState } = params const { type } = action switch (type) { case 'socket/connect': socket.connect('wss://example.com') socket.on('open', () => {}) socket.on('message', (data) => {}) socket.on('close', () => {}) break case 'socket/disconnect': socket.disconnect() break default: break } return next(action) }",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "fa521c261592ea7d90d648aff8900e0c",
        "content": "export const socketMiddleware = (socket) => (params) => (next) => (action) => { const { dispatch, getState } = params const { type } = action switch (type) { case 'socket/connect': socket.connect('wss://example.com') socket.on('open', () => {}) socket.on('message', (data) => {}) socket.on('close', () => {}) break case 'socket/disconnect': socket.disconnect() break default: break } return next(action) }",
        "type": "code",
        "language": "js",
        "relevance": 0.7052631578947368
      },
      {
        "id": "445839998890c17a8378518751502a99",
        "content": "socket/connect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c6aa526b79ff708d1f3404912fbe11e8",
        "content": "import { configureStore, getDefaultMiddleware } from ' reduxjs/toolkit' import { rootReducer } from ' /store/rootReducer' import { Socket } from ' /utils/Socket' export const store = configureStore({ reducer: rootReducer, middleware: [socketMiddleware(new Socket()), ...getDefaultMiddleware()],})",
        "type": "code",
        "language": "js",
        "relevance": 0.7
      },
      {
        "id": "c6aa526b79ff708d1f3404912fbe11e8",
        "content": "import { configureStore, getDefaultMiddleware } from ' reduxjs/toolkit' import { rootReducer } from ' /store/rootReducer' import { Socket } from ' /utils/Socket' export const store = configureStore({ reducer: rootReducer, middleware: [socketMiddleware(new Socket()), ...getDefaultMiddleware()],})",
        "type": "code",
        "language": "js",
        "relevance": 0.7
      },
      {
        "id": "6aa92fc98413aa2d8a8abfd09c39fc3d",
        "content": "import React, { useEffect } from 'react' import { useDispatch } from 'react-redux' export const LiveDashboardPage = () => { const dispatch = useDispatch() useEffect(() => { dispatch({ type: 'socket/connect' }) return () => { dispatch({ type: 'socket/disconnect' }) } }, []) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8052631578947369
      },
      {
        "id": "6aa92fc98413aa2d8a8abfd09c39fc3d",
        "content": "import React, { useEffect } from 'react' import { useDispatch } from 'react-redux' export const LiveDashboardPage = () => { const dispatch = useDispatch() useEffect(() => { dispatch({ type: 'socket/connect' }) return () => { dispatch({ type: 'socket/disconnect' }) } }, []) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8052631578947369
      }
    ]
  },
  {
    "metadata": {
      "description": "There is no consensus on the right way to organize a React application. React gives you a lot of freedom, but with that freedom comes the…",
      "url": "https://www.taniarascia.com/react-architecture-directory-structure/",
      "title": "How to Structure and Organize a React Application | Tania Rascia's Personal Website",
      "source_type": "web",
      "crawl_time": 1730107255.6947641,
      "keywords": [
        "sql",
        "web",
        "article",
        "extract",
        "development",
        "information",
        "react"
      ]
    },
    "relevance_score": 0.7672000000000002,
    "chunks": [
      {
        "content": "How to Structure and Organize a React ApplicationThere is no consensus on the right way to organize a React application. React gives you a lot of freedom, but with that freedom comes the responsibility of deciding on your own architecture. Often the case is that whoever sets up the application in the beginning throws almost everything in acomponentsfolder, or maybecomponentsandcontainersif they used Redux, but I propose there's a better way. I like to be deliberate about how I organize my applications so they're easy to use, understand, and extend.I'm going to show you what I consider to be an intuitive and scalable system for large-scale production React applications. The main concept I think is important is to make the architecture focused onfeatureas opposed totype, organizing only shared components on a global level and modularized all the other related entities together in the localized view.Tech assumptionsSince this article will be opinionated, I'll make some assumptions about what technology the project will be using:Application-React(Hooks)Global state management-Redux,Redux ToolkitRouting-React RouterStyles-Styled ComponentsTesting-Jest,React Testing LibraryI don't have a very strong opinion about the styling, whether Styled Components or CSS modules or a custom Sass setup is ideal, but I think Styled Components is probably one of the best options for keeping your styles modular.I'm also going to assume the tests are alongside the code, as opposed to in a top-leveltestsfolder. I can go either way with this one, but in order for an example to work, and in the real world, decisions need to be made.Everything here can still apply if you're using vanilla Redux instead of Redux Toolkit. I would recommendsetting up your Redux as feature sliceseither way.I'm also ambivalent aboutStorybook, but I'll include what it would look like with those files if you choose to use it in your project.For the sake of the example, I'll use a \"Library App\" example, that has a page for listing books, a page for listing authors, and has an authentication system.Directory StructureThe top level directory structure will be as follows:assets- global static assets such as images, svgs, company logo, etc.components- global shared/reusable components, such as layout (wrappers, navigation), form components, buttonsservices- JavaScript modulesstore- Global Redux storeutils- Utilities, helpers, constants, and the likeviews- Can also be called \"pages\", the majority of the app would be contained hereI like keeping familiar conventions wherever possible, sosrccontains everything,index.jsis the entry point, andApp.jssets up the auth and routing..\n└── /src\n    ├── /assets\n    ├── /components\n    ├── /services\n    ├── /store\n    ├── /utils\n    ├── /views\n    ├── index.js\n    └── App.jsI can see some additional folders you might have, such astypesif it's a TypeScript project,middlewareif necessary, maybecontextforContext, etc.AliasesI would set up the system to use aliases, so anything within thecomponentsfolder could be imported as@components,assetsas@assets, etc. If you have a custom Webpack, this is done through theresolveconfiguration.module.exports={resolve:{extensions:['js','ts'],alias:{'@':path.resolve(__dirname,'src'),'@assets':path.resolve(__dirname,'src/assets'),'@components':path.resolve(__dirname,'src/components'),// ...etc},},} t just makes it a lot easier to import from anywhere within the project and move files around without changing imports, and you never end up with something like../../../../../components/.ComponentsWithin thecomponentsfolder, I would group by type -forms,tables,buttons,layout, etc. The specifics will vary by your specific app.In this example, I'm assuming you're either creating your own form system, or creating your own bindings to an existing form system (for example, combining Formik and Material UI). In this case, you'd create a folder for each component (TextField,Select,Radio,Dropdown, etc.), and inside would be a file for the component itself, the styles, the tests, and the Storybook if it's being used.Component.js- The actual React componentComponent.styles.js- The Styled Components file for the componentComponent.test.js- The testsComponent.stories.js- The Storybook fileTo me, this makes a lot more sense than having one folder that contains the files for ALL components, one folder that contains all the tests, and one folder that contains all the Storybook files, etc. Everything related is grouped together and easy to find..\n└── /src\n    └── /components\n        ├── /forms\n        │   ├── /TextField\n        │   │   ├── TextField.js\n        │   │   ├── TextField.styles.js\n        │   │   ├── TextField.test.js\n        │   │   └── TextField.stories.js\n        │   ├── /Select\n        │   │   ├── Select.js\n        │   │   ├── Select.styles.js\n        │   │   ├── Select.test.js\n        │   │   └── Select.stories.js\n        │   └── index.js\n        ├── /routing\n        │   └── /PrivateRoute\n        │       ├── /PrivateRoute.js\n        │       └── /PrivateRoute.test.js\n        └── /layout\n            └── /navigation\n                └── /NavBar\n                    ├── NavBar.js\n                    ├── NavBar.styles.js\n                    ├── NavBar.test.js\n                    └── NavBar.stories.jsYou'll notice there's anindex.jsfile in thecomponents/formsdirectory. It is often rightfully suggested to avoid usingindex.jsfiles as they're not explicit, but in this case it makes sense - it will end up being an index of all the forms and look something like this:src/components/forms/index.jsimport{TextField} rom'./TextField/TextField'import{Select} rom'./Select/Select'import{Radio} rom'./Radio/Radio'export{TextField,Select,Radio} hen when you need to use one or more of the components, you can easily import them all at once.import{TextField,Select,Radio} rom'@components/forms'I would recommend this approach more than making anindex.jsinside ofeveryfolder withinforms, so now you just have oneindex.jsthat actually indexes the entire directory, as opposed to tenindex.jsfiles just to make imports easier for each individual file.ServicesTheservicesdirectory is less essential thancomponents, but if you're making a plain JavaScript module that the rest of the application is using, it can be handy. A common contrived example is a LocalStorage module, which might look like this:.\n└── /src\n    └── /services\n        ├── /LocalStorage\n        │   ├── LocalStorage.service.js\n        │   └── LocalStorage.test.js\n        └── index.jsAn example of the service:src/services/LocalStorage/LocalStorage.service.jsexportconstLocalStorage={get(key){},set(key,value){},remove(key){},clear(){},} mport{LocalStorage} rom'@services'LocalStorage.get('foo')StoreThe global data store will be contained in thestoredirectory - in this case, Redux. Each feature will have a folder, which will contain theRedux Toolkitslice, as well as actions and tests. This setup can also be used with regular Redux, you would just create a.reducers.jsfile and.actions.jsfile instead of aslice.",
        "chunk_type": "technical_content",
        "tag": "main",
        "score": 0.9450000000000001,
        "word_count": 902,
        "chunk_id": "868da1e1c72b4aff6a5a3a6a17a17652",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "If you're using sagas, it could be.saga.jsinstead of.actions.jsfor Redux Thunk actions..\n└── /src\n    ├── /store\n    │   ├── /authentication\n    │   │   ├── /authentication.slice.js\n    │   │   ├── /authentication.actions.js\n    │   │   └── /authentication.test.js\n    │   ├── /authors\n    │   │   ├── /authors.slice.js\n    │   │   ├── /authors.actions.js\n    │   │   └── /authors.test.js\n    │   └── /books\n    │       ├── /books.slice.js\n    │       ├── /books.actions.js\n    │       └── /books.test.js\n    ├── rootReducer.js\n    └── index.jsYou can also add something like auisection of the store to handle modals, toasts, sidebar toggling, and other global UI state, which I find better than havingconst [isOpen, setIsOpen] = useState(false)all over the place.In therootReduceryou would import all your slices and combine them withcombineReducers, and inindex.jsyou would configure the store.UtilsWhether or not your project needs autilsfolder is up to you, but I think there are usually some global utility functions, like validation and conversion, that could easily be used across multiple sections of the app. If you keep it organized - not just having onehelpers.jsfile that contains thousands of functions - it could be a helpful addition to the organization of your project..\n└── src\n    └── /utils\n        ├── /constants\n        │   └── countries.constants.js\n        └── /helpers\n            ├── validation.helpers.js\n            ├── currency.helpers.js\n            └── array.helpers.jsAgain, theutilsfolder can contain anything you want that you think makes sense to keep on a global level. If you don't prefer the \"multi-tier\" filenames, you could just call itvalidation.js, but the way I see it, being explicit does not take anything away from the project, and makes it easier to navigate filenames when searching in your IDE.ViewsHere's where the main part of your app will live: in theviewsdirectory. Any page in your app is a \"view\". In this small example, the views line up pretty well with the Redux store, but it won't necessarily be the case that the store and views are exactly the same, which is why they're separate. Also,booksmight pull fromauthors, and so on.Anything within a view is an item that will likely only be used within that specific view - aBookFormthat will only be used at the/booksroute, and anAuthorBlurbthat will only be used on the/authorsroute. It might include specific forms, modals, buttons, any component that won't be global.The advantage of keeping everything domain-focused instead of putting all your pages together incomponents/pagesis that it makes it really easy to look at the structure of the application and know how many top level views there are, and know where everything that's only used by that view is. If there are nested routes, you can always add a nestedviewsfolder within the main route..\n└── /src\n    └── /views\n        ├── /Authors\n        │   ├── /AuthorsPage\n        │   │   ├── AuthorsPage.js\n        │   │   └── AuthorsPage.test.js\n        │   └── /AuthorBlurb\n        │       ├── /AuthorBlurb.js\n        │       └── /AuthorBlurb.test.js\n        ├── /Books\n        │   ├── /BooksPage\n        │   │   ├── BooksPage.js\n        │   │   └── BooksPage.test.js\n        │   └── /BookForm\n        │       ├── /BookForm.js\n        │       └── /BookForm.test.js\n        └── /Login\n            ├── LoginPage\n            │   ├── LoginPage.styles.js\n            │   ├── LoginPage.js\n            │   └── LoginPage.test.js\n            └── LoginForm\n                ├── LoginForm.js\n                └── LoginForm.test.jsKeeping everything within folders might seem annoying if you've never set up your project that way - you can always keep it more flat, or moveteststo its own directory that mimics the rest of the app.ConclusionThis is my proposal for a sytem for React organization that scales well for a large production app, and handles testing and styling as well as keeping everything together in a feature focused way. It's more nested than the traditional structure of everything being incomponentsandcontainers, but that system is a bit more dated due to Redux being much easier to implement with Hooks, and \"smart\" containers and \"dumb\" components no longer being necessary.It's easy to look at this system and understand everything that is needed for your app and where to go to work on a specific section, or a component that affects the app globally. This system may not make sense for every type of app, but it has worked for me. I'd love to hear any comments about ways this system can be improved, or other systems that have merit.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:June 23, 2021Category:TechnicalTagsjavascriptreactNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "main",
        "score": 0.9450000000000001,
        "word_count": 710,
        "chunk_id": "dcae5e9436a953c56de3a1793a5291d4",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "How to Structure and Organize a React ApplicationThere is no consensus on the right way to organize a React application. React gives you a lot of freedom, but with that freedom comes the responsibility of deciding on your own architecture. Often the case is that whoever sets up the application in the beginning throws almost everything in acomponentsfolder, or maybecomponentsandcontainersif they used Redux, but I propose there's a better way. I like to be deliberate about how I organize my applications so they're easy to use, understand, and extend.I'm going to show you what I consider to be an intuitive and scalable system for large-scale production React applications. The main concept I think is important is to make the architecture focused onfeatureas opposed totype, organizing only shared components on a global level and modularized all the other related entities together in the localized view.Tech assumptionsSince this article will be opinionated, I'll make some assumptions about what technology the project will be using:Application-React(Hooks)Global state management-Redux,Redux ToolkitRouting-React RouterStyles-Styled ComponentsTesting-Jest,React Testing LibraryI don't have a very strong opinion about the styling, whether Styled Components or CSS modules or a custom Sass setup is ideal, but I think Styled Components is probably one of the best options for keeping your styles modular.I'm also going to assume the tests are alongside the code, as opposed to in a top-leveltestsfolder. I can go either way with this one, but in order for an example to work, and in the real world, decisions need to be made.Everything here can still apply if you're using vanilla Redux instead of Redux Toolkit. I would recommendsetting up your Redux as feature sliceseither way.I'm also ambivalent aboutStorybook, but I'll include what it would look like with those files if you choose to use it in your project.For the sake of the example, I'll use a \"Library App\" example, that has a page for listing books, a page for listing authors, and has an authentication system.Directory StructureThe top level directory structure will be as follows:assets- global static assets such as images, svgs, company logo, etc.components- global shared/reusable components, such as layout (wrappers, navigation), form components, buttonsservices- JavaScript modulesstore- Global Redux storeutils- Utilities, helpers, constants, and the likeviews- Can also be called \"pages\", the majority of the app would be contained hereI like keeping familiar conventions wherever possible, sosrccontains everything,index.jsis the entry point, andApp.jssets up the auth and routing..\n└── /src\n    ├── /assets\n    ├── /components\n    ├── /services\n    ├── /store\n    ├── /utils\n    ├── /views\n    ├── index.js\n    └── App.jsI can see some additional folders you might have, such astypesif it's a TypeScript project,middlewareif necessary, maybecontextforContext, etc.AliasesI would set up the system to use aliases, so anything within thecomponentsfolder could be imported as@components,assetsas@assets, etc. If you have a custom Webpack, this is done through theresolveconfiguration.module.exports={resolve:{extensions:['js','ts'],alias:{'@':path.resolve(__dirname,'src'),'@assets':path.resolve(__dirname,'src/assets'),'@components':path.resolve(__dirname,'src/components'),// ...etc},},} t just makes it a lot easier to import from anywhere within the project and move files around without changing imports, and you never end up with something like../../../../../components/.ComponentsWithin thecomponentsfolder, I would group by type -forms,tables,buttons,layout, etc. The specifics will vary by your specific app.In this example, I'm assuming you're either creating your own form system, or creating your own bindings to an existing form system (for example, combining Formik and Material UI). In this case, you'd create a folder for each component (TextField,Select,Radio,Dropdown, etc.), and inside would be a file for the component itself, the styles, the tests, and the Storybook if it's being used.Component.js- The actual React componentComponent.styles.js- The Styled Components file for the componentComponent.test.js- The testsComponent.stories.js- The Storybook fileTo me, this makes a lot more sense than having one folder that contains the files for ALL components, one folder that contains all the tests, and one folder that contains all the Storybook files, etc. Everything related is grouped together and easy to find..\n└── /src\n    └── /components\n        ├── /forms\n        │   ├── /TextField\n        │   │   ├── TextField.js\n        │   │   ├── TextField.styles.js\n        │   │   ├── TextField.test.js\n        │   │   └── TextField.stories.js\n        │   ├── /Select\n        │   │   ├── Select.js\n        │   │   ├── Select.styles.js\n        │   │   ├── Select.test.js\n        │   │   └── Select.stories.js\n        │   └── index.js\n        ├── /routing\n        │   └── /PrivateRoute\n        │       ├── /PrivateRoute.js\n        │       └── /PrivateRoute.test.js\n        └── /layout\n            └── /navigation\n                └── /NavBar\n                    ├── NavBar.js\n                    ├── NavBar.styles.js\n                    ├── NavBar.test.js\n                    └── NavBar.stories.jsYou'll notice there's anindex.jsfile in thecomponents/formsdirectory. It is often rightfully suggested to avoid usingindex.jsfiles as they're not explicit, but in this case it makes sense - it will end up being an index of all the forms and look something like this:src/components/forms/index.jsimport{TextField} rom'./TextField/TextField'import{Select} rom'./Select/Select'import{Radio} rom'./Radio/Radio'export{TextField,Select,Radio} hen when you need to use one or more of the components, you can easily import them all at once.import{TextField,Select,Radio} rom'@components/forms'I would recommend this approach more than making anindex.jsinside ofeveryfolder withinforms, so now you just have oneindex.jsthat actually indexes the entire directory, as opposed to tenindex.jsfiles just to make imports easier for each individual file.ServicesTheservicesdirectory is less essential thancomponents, but if you're making a plain JavaScript module that the rest of the application is using, it can be handy. A common contrived example is a LocalStorage module, which might look like this:.\n└── /src\n    └── /services\n        ├── /LocalStorage\n        │   ├── LocalStorage.service.js\n        │   └── LocalStorage.test.js\n        └── index.jsAn example of the service:src/services/LocalStorage/LocalStorage.service.jsexportconstLocalStorage={get(key){},set(key,value){},remove(key){},clear(){},} mport{LocalStorage} rom'@services'LocalStorage.get('foo')StoreThe global data store will be contained in thestoredirectory - in this case, Redux. Each feature will have a folder, which will contain theRedux Toolkitslice, as well as actions and tests. This setup can also be used with regular Redux, you would just create a.reducers.jsfile and.actions.jsfile instead of aslice.",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.9450000000000001,
        "word_count": 902,
        "chunk_id": "868da1e1c72b4aff6a5a3a6a17a17652",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "If you're using sagas, it could be.saga.jsinstead of.actions.jsfor Redux Thunk actions..\n└── /src\n    ├── /store\n    │   ├── /authentication\n    │   │   ├── /authentication.slice.js\n    │   │   ├── /authentication.actions.js\n    │   │   └── /authentication.test.js\n    │   ├── /authors\n    │   │   ├── /authors.slice.js\n    │   │   ├── /authors.actions.js\n    │   │   └── /authors.test.js\n    │   └── /books\n    │       ├── /books.slice.js\n    │       ├── /books.actions.js\n    │       └── /books.test.js\n    ├── rootReducer.js\n    └── index.jsYou can also add something like auisection of the store to handle modals, toasts, sidebar toggling, and other global UI state, which I find better than havingconst [isOpen, setIsOpen] = useState(false)all over the place.In therootReduceryou would import all your slices and combine them withcombineReducers, and inindex.jsyou would configure the store.UtilsWhether or not your project needs autilsfolder is up to you, but I think there are usually some global utility functions, like validation and conversion, that could easily be used across multiple sections of the app. If you keep it organized - not just having onehelpers.jsfile that contains thousands of functions - it could be a helpful addition to the organization of your project..\n└── src\n    └── /utils\n        ├── /constants\n        │   └── countries.constants.js\n        └── /helpers\n            ├── validation.helpers.js\n            ├── currency.helpers.js\n            └── array.helpers.jsAgain, theutilsfolder can contain anything you want that you think makes sense to keep on a global level. If you don't prefer the \"multi-tier\" filenames, you could just call itvalidation.js, but the way I see it, being explicit does not take anything away from the project, and makes it easier to navigate filenames when searching in your IDE.ViewsHere's where the main part of your app will live: in theviewsdirectory. Any page in your app is a \"view\". In this small example, the views line up pretty well with the Redux store, but it won't necessarily be the case that the store and views are exactly the same, which is why they're separate. Also,booksmight pull fromauthors, and so on.Anything within a view is an item that will likely only be used within that specific view - aBookFormthat will only be used at the/booksroute, and anAuthorBlurbthat will only be used on the/authorsroute. It might include specific forms, modals, buttons, any component that won't be global.The advantage of keeping everything domain-focused instead of putting all your pages together incomponents/pagesis that it makes it really easy to look at the structure of the application and know how many top level views there are, and know where everything that's only used by that view is. If there are nested routes, you can always add a nestedviewsfolder within the main route..\n└── /src\n    └── /views\n        ├── /Authors\n        │   ├── /AuthorsPage\n        │   │   ├── AuthorsPage.js\n        │   │   └── AuthorsPage.test.js\n        │   └── /AuthorBlurb\n        │       ├── /AuthorBlurb.js\n        │       └── /AuthorBlurb.test.js\n        ├── /Books\n        │   ├── /BooksPage\n        │   │   ├── BooksPage.js\n        │   │   └── BooksPage.test.js\n        │   └── /BookForm\n        │       ├── /BookForm.js\n        │       └── /BookForm.test.js\n        └── /Login\n            ├── LoginPage\n            │   ├── LoginPage.styles.js\n            │   ├── LoginPage.js\n            │   └── LoginPage.test.js\n            └── LoginForm\n                ├── LoginForm.js\n                └── LoginForm.test.jsKeeping everything within folders might seem annoying if you've never set up your project that way - you can always keep it more flat, or moveteststo its own directory that mimics the rest of the app.ConclusionThis is my proposal for a sytem for React organization that scales well for a large production app, and handles testing and styling as well as keeping everything together in a feature focused way. It's more nested than the traditional structure of everything being incomponentsandcontainers, but that system is a bit more dated due to Redux being much easier to implement with Hooks, and \"smart\" containers and \"dumb\" components no longer being necessary.It's easy to look at this system and understand everything that is needed for your app and where to go to work on a specific section, or a component that affects the app globally. This system may not make sense for every type of app, but it has worked for me. I'd love to hear any comments about ways this system can be improved, or other systems that have merit.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:June 23, 2021Category:TechnicalTagsjavascriptreactNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.9450000000000001,
        "word_count": 710,
        "chunk_id": "dcae5e9436a953c56de3a1793a5291d4",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "How to Structure and Organize a React ApplicationThere is no consensus on the right way to organize a React application. React gives you a lot of freedom, but with that freedom comes the responsibility of deciding on your own architecture. Often the case is that whoever sets up the application in the beginning throws almost everything in acomponentsfolder, or maybecomponentsandcontainersif they used Redux, but I propose there's a better way. I like to be deliberate about how I organize my applications so they're easy to use, understand, and extend.I'm going to show you what I consider to be an intuitive and scalable system for large-scale production React applications. The main concept I think is important is to make the architecture focused onfeatureas opposed totype, organizing only shared components on a global level and modularized all the other related entities together in the localized view.Tech assumptionsSince this article will be opinionated, I'll make some assumptions about what technology the project will be using:Application-React(Hooks)Global state management-Redux,Redux ToolkitRouting-React RouterStyles-Styled ComponentsTesting-Jest,React Testing LibraryI don't have a very strong opinion about the styling, whether Styled Components or CSS modules or a custom Sass setup is ideal, but I think Styled Components is probably one of the best options for keeping your styles modular.I'm also going to assume the tests are alongside the code, as opposed to in a top-leveltestsfolder. I can go either way with this one, but in order for an example to work, and in the real world, decisions need to be made.Everything here can still apply if you're using vanilla Redux instead of Redux Toolkit. I would recommendsetting up your Redux as feature sliceseither way.I'm also ambivalent aboutStorybook, but I'll include what it would look like with those files if you choose to use it in your project.For the sake of the example, I'll use a \"Library App\" example, that has a page for listing books, a page for listing authors, and has an authentication system.Directory StructureThe top level directory structure will be as follows:assets- global static assets such as images, svgs, company logo, etc.components- global shared/reusable components, such as layout (wrappers, navigation), form components, buttonsservices- JavaScript modulesstore- Global Redux storeutils- Utilities, helpers, constants, and the likeviews- Can also be called \"pages\", the majority of the app would be contained hereI like keeping familiar conventions wherever possible, sosrccontains everything,index.jsis the entry point, andApp.jssets up the auth and routing..\n└── /src\n    ├── /assets\n    ├── /components\n    ├── /services\n    ├── /store\n    ├── /utils\n    ├── /views\n    ├── index.js\n    └── App.jsI can see some additional folders you might have, such astypesif it's a TypeScript project,middlewareif necessary, maybecontextforContext, etc.AliasesI would set up the system to use aliases, so anything within thecomponentsfolder could be imported as@components,assetsas@assets, etc. If you have a custom Webpack, this is done through theresolveconfiguration.module.exports={resolve:{extensions:['js','ts'],alias:{'@':path.resolve(__dirname,'src'),'@assets':path.resolve(__dirname,'src/assets'),'@components':path.resolve(__dirname,'src/components'),// ...etc},},} t just makes it a lot easier to import from anywhere within the project and move files around without changing imports, and you never end up with something like../../../../../components/.ComponentsWithin thecomponentsfolder, I would group by type -forms,tables,buttons,layout, etc. The specifics will vary by your specific app.In this example, I'm assuming you're either creating your own form system, or creating your own bindings to an existing form system (for example, combining Formik and Material UI). In this case, you'd create a folder for each component (TextField,Select,Radio,Dropdown, etc.), and inside would be a file for the component itself, the styles, the tests, and the Storybook if it's being used.Component.js- The actual React componentComponent.styles.js- The Styled Components file for the componentComponent.test.js- The testsComponent.stories.js- The Storybook fileTo me, this makes a lot more sense than having one folder that contains the files for ALL components, one folder that contains all the tests, and one folder that contains all the Storybook files, etc. Everything related is grouped together and easy to find..\n└── /src\n    └── /components\n        ├── /forms\n        │   ├── /TextField\n        │   │   ├── TextField.js\n        │   │   ├── TextField.styles.js\n        │   │   ├── TextField.test.js\n        │   │   └── TextField.stories.js\n        │   ├── /Select\n        │   │   ├── Select.js\n        │   │   ├── Select.styles.js\n        │   │   ├── Select.test.js\n        │   │   └── Select.stories.js\n        │   └── index.js\n        ├── /routing\n        │   └── /PrivateRoute\n        │       ├── /PrivateRoute.js\n        │       └── /PrivateRoute.test.js\n        └── /layout\n            └── /navigation\n                └── /NavBar\n                    ├── NavBar.js\n                    ├── NavBar.styles.js\n                    ├── NavBar.test.js\n                    └── NavBar.stories.jsYou'll notice there's anindex.jsfile in thecomponents/formsdirectory. It is often rightfully suggested to avoid usingindex.jsfiles as they're not explicit, but in this case it makes sense - it will end up being an index of all the forms and look something like this:src/components/forms/index.jsimport{TextField} rom'./TextField/TextField'import{Select} rom'./Select/Select'import{Radio} rom'./Radio/Radio'export{TextField,Select,Radio} hen when you need to use one or more of the components, you can easily import them all at once.import{TextField,Select,Radio} rom'@components/forms'I would recommend this approach more than making anindex.jsinside ofeveryfolder withinforms, so now you just have oneindex.jsthat actually indexes the entire directory, as opposed to tenindex.jsfiles just to make imports easier for each individual file.ServicesTheservicesdirectory is less essential thancomponents, but if you're making a plain JavaScript module that the rest of the application is using, it can be handy. A common contrived example is a LocalStorage module, which might look like this:.\n└── /src\n    └── /services\n        ├── /LocalStorage\n        │   ├── LocalStorage.service.js\n        │   └── LocalStorage.test.js\n        └── index.jsAn example of the service:src/services/LocalStorage/LocalStorage.service.jsexportconstLocalStorage={get(key){},set(key,value){},remove(key){},clear(){},} mport{LocalStorage} rom'@services'LocalStorage.get('foo')StoreThe global data store will be contained in thestoredirectory - in this case, Redux. Each feature will have a folder, which will contain theRedux Toolkitslice, as well as actions and tests. This setup can also be used with regular Redux, you would just create a.reducers.jsfile and.actions.jsfile instead of aslice.",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.9450000000000001,
        "word_count": 902,
        "chunk_id": "868da1e1c72b4aff6a5a3a6a17a17652",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "If you're using sagas, it could be.saga.jsinstead of.actions.jsfor Redux Thunk actions..\n└── /src\n    ├── /store\n    │   ├── /authentication\n    │   │   ├── /authentication.slice.js\n    │   │   ├── /authentication.actions.js\n    │   │   └── /authentication.test.js\n    │   ├── /authors\n    │   │   ├── /authors.slice.js\n    │   │   ├── /authors.actions.js\n    │   │   └── /authors.test.js\n    │   └── /books\n    │       ├── /books.slice.js\n    │       ├── /books.actions.js\n    │       └── /books.test.js\n    ├── rootReducer.js\n    └── index.jsYou can also add something like auisection of the store to handle modals, toasts, sidebar toggling, and other global UI state, which I find better than havingconst [isOpen, setIsOpen] = useState(false)all over the place.In therootReduceryou would import all your slices and combine them withcombineReducers, and inindex.jsyou would configure the store.UtilsWhether or not your project needs autilsfolder is up to you, but I think there are usually some global utility functions, like validation and conversion, that could easily be used across multiple sections of the app. If you keep it organized - not just having onehelpers.jsfile that contains thousands of functions - it could be a helpful addition to the organization of your project..\n└── src\n    └── /utils\n        ├── /constants\n        │   └── countries.constants.js\n        └── /helpers\n            ├── validation.helpers.js\n            ├── currency.helpers.js\n            └── array.helpers.jsAgain, theutilsfolder can contain anything you want that you think makes sense to keep on a global level. If you don't prefer the \"multi-tier\" filenames, you could just call itvalidation.js, but the way I see it, being explicit does not take anything away from the project, and makes it easier to navigate filenames when searching in your IDE.ViewsHere's where the main part of your app will live: in theviewsdirectory. Any page in your app is a \"view\". In this small example, the views line up pretty well with the Redux store, but it won't necessarily be the case that the store and views are exactly the same, which is why they're separate. Also,booksmight pull fromauthors, and so on.Anything within a view is an item that will likely only be used within that specific view - aBookFormthat will only be used at the/booksroute, and anAuthorBlurbthat will only be used on the/authorsroute. It might include specific forms, modals, buttons, any component that won't be global.The advantage of keeping everything domain-focused instead of putting all your pages together incomponents/pagesis that it makes it really easy to look at the structure of the application and know how many top level views there are, and know where everything that's only used by that view is. If there are nested routes, you can always add a nestedviewsfolder within the main route..\n└── /src\n    └── /views\n        ├── /Authors\n        │   ├── /AuthorsPage\n        │   │   ├── AuthorsPage.js\n        │   │   └── AuthorsPage.test.js\n        │   └── /AuthorBlurb\n        │       ├── /AuthorBlurb.js\n        │       └── /AuthorBlurb.test.js\n        ├── /Books\n        │   ├── /BooksPage\n        │   │   ├── BooksPage.js\n        │   │   └── BooksPage.test.js\n        │   └── /BookForm\n        │       ├── /BookForm.js\n        │       └── /BookForm.test.js\n        └── /Login\n            ├── LoginPage\n            │   ├── LoginPage.styles.js\n            │   ├── LoginPage.js\n            │   └── LoginPage.test.js\n            └── LoginForm\n                ├── LoginForm.js\n                └── LoginForm.test.jsKeeping everything within folders might seem annoying if you've never set up your project that way - you can always keep it more flat, or moveteststo its own directory that mimics the rest of the app.ConclusionThis is my proposal for a sytem for React organization that scales well for a large production app, and handles testing and styling as well as keeping everything together in a feature focused way. It's more nested than the traditional structure of everything being incomponentsandcontainers, but that system is a bit more dated due to Redux being much easier to implement with Hooks, and \"smart\" containers and \"dumb\" components no longer being necessary.It's easy to look at this system and understand everything that is needed for your app and where to go to work on a specific section, or a component that affects the app globally. This system may not make sense for every type of app, but it has worked for me. I'd love to hear any comments about ways this system can be improved, or other systems that have merit.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:June 23, 2021Category:TechnicalTagsjavascriptreactNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.9450000000000001,
        "word_count": 710,
        "chunk_id": "dcae5e9436a953c56de3a1793a5291d4",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "How to Structure and Organize a React ApplicationThere is no consensus on the right way to organize a React application. React gives you a lot of freedom, but with that freedom comes the responsibility of deciding on your own architecture. Often the case is that whoever sets up the application in the beginning throws almost everything in acomponentsfolder, or maybecomponentsandcontainersif they used Redux, but I propose there's a better way. I like to be deliberate about how I organize my applications so they're easy to use, understand, and extend.I'm going to show you what I consider to be an intuitive and scalable system for large-scale production React applications. The main concept I think is important is to make the architecture focused onfeatureas opposed totype, organizing only shared components on a global level and modularized all the other related entities together in the localized view.Tech assumptionsSince this article will be opinionated, I'll make some assumptions about what technology the project will be using:Application-React(Hooks)Global state management-Redux,Redux ToolkitRouting-React RouterStyles-Styled ComponentsTesting-Jest,React Testing LibraryI don't have a very strong opinion about the styling, whether Styled Components or CSS modules or a custom Sass setup is ideal, but I think Styled Components is probably one of the best options for keeping your styles modular.I'm also going to assume the tests are alongside the code, as opposed to in a top-leveltestsfolder. I can go either way with this one, but in order for an example to work, and in the real world, decisions need to be made.Everything here can still apply if you're using vanilla Redux instead of Redux Toolkit. I would recommendsetting up your Redux as feature sliceseither way.I'm also ambivalent aboutStorybook, but I'll include what it would look like with those files if you choose to use it in your project.For the sake of the example, I'll use a \"Library App\" example, that has a page for listing books, a page for listing authors, and has an authentication system.Directory StructureThe top level directory structure will be as follows:assets- global static assets such as images, svgs, company logo, etc.components- global shared/reusable components, such as layout (wrappers, navigation), form components, buttonsservices- JavaScript modulesstore- Global Redux storeutils- Utilities, helpers, constants, and the likeviews- Can also be called \"pages\", the majority of the app would be contained hereI like keeping familiar conventions wherever possible, sosrccontains everything,index.jsis the entry point, andApp.jssets up the auth and routing..\n└── /src\n    ├── /assets\n    ├── /components\n    ├── /services\n    ├── /store\n    ├── /utils\n    ├── /views\n    ├── index.js\n    └── App.jsI can see some additional folders you might have, such astypesif it's a TypeScript project,middlewareif necessary, maybecontextforContext, etc.AliasesI would set up the system to use aliases, so anything within thecomponentsfolder could be imported as@components,assetsas@assets, etc. If you have a custom Webpack, this is done through theresolveconfiguration.module.exports={resolve:{extensions:['js','ts'],alias:{'@':path.resolve(__dirname,'src'),'@assets':path.resolve(__dirname,'src/assets'),'@components':path.resolve(__dirname,'src/components'),// ...etc},},} t just makes it a lot easier to import from anywhere within the project and move files around without changing imports, and you never end up with something like../../../../../components/.ComponentsWithin thecomponentsfolder, I would group by type -forms,tables,buttons,layout, etc. The specifics will vary by your specific app.In this example, I'm assuming you're either creating your own form system, or creating your own bindings to an existing form system (for example, combining Formik and Material UI). In this case, you'd create a folder for each component (TextField,Select,Radio,Dropdown, etc.), and inside would be a file for the component itself, the styles, the tests, and the Storybook if it's being used.Component.js- The actual React componentComponent.styles.js- The Styled Components file for the componentComponent.test.js- The testsComponent.stories.js- The Storybook fileTo me, this makes a lot more sense than having one folder that contains the files for ALL components, one folder that contains all the tests, and one folder that contains all the Storybook files, etc. Everything related is grouped together and easy to find..\n└── /src\n    └── /components\n        ├── /forms\n        │   ├── /TextField\n        │   │   ├── TextField.js\n        │   │   ├── TextField.styles.js\n        │   │   ├── TextField.test.js\n        │   │   └── TextField.stories.js\n        │   ├── /Select\n        │   │   ├── Select.js\n        │   │   ├── Select.styles.js\n        │   │   ├── Select.test.js\n        │   │   └── Select.stories.js\n        │   └── index.js\n        ├── /routing\n        │   └── /PrivateRoute\n        │       ├── /PrivateRoute.js\n        │       └── /PrivateRoute.test.js\n        └── /layout\n            └── /navigation\n                └── /NavBar\n                    ├── NavBar.js\n                    ├── NavBar.styles.js\n                    ├── NavBar.test.js\n                    └── NavBar.stories.jsYou'll notice there's anindex.jsfile in thecomponents/formsdirectory. It is often rightfully suggested to avoid usingindex.jsfiles as they're not explicit, but in this case it makes sense - it will end up being an index of all the forms and look something like this:src/components/forms/index.jsimport{TextField} rom'./TextField/TextField'import{Select} rom'./Select/Select'import{Radio} rom'./Radio/Radio'export{TextField,Select,Radio} hen when you need to use one or more of the components, you can easily import them all at once.import{TextField,Select,Radio} rom'@components/forms'I would recommend this approach more than making anindex.jsinside ofeveryfolder withinforms, so now you just have oneindex.jsthat actually indexes the entire directory, as opposed to tenindex.jsfiles just to make imports easier for each individual file.ServicesTheservicesdirectory is less essential thancomponents, but if you're making a plain JavaScript module that the rest of the application is using, it can be handy. A common contrived example is a LocalStorage module, which might look like this:.\n└── /src\n    └── /services\n        ├── /LocalStorage\n        │   ├── LocalStorage.service.js\n        │   └── LocalStorage.test.js\n        └── index.jsAn example of the service:src/services/LocalStorage/LocalStorage.service.jsexportconstLocalStorage={get(key){},set(key,value){},remove(key){},clear(){},} mport{LocalStorage} rom'@services'LocalStorage.get('foo')StoreThe global data store will be contained in thestoredirectory - in this case, Redux. Each feature will have a folder, which will contain theRedux Toolkitslice, as well as actions and tests. This setup can also be used with regular Redux, you would just create a.reducers.jsfile and.actions.jsfile instead of aslice.",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.9450000000000001,
        "word_count": 902,
        "chunk_id": "868da1e1c72b4aff6a5a3a6a17a17652",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "If you're using sagas, it could be.saga.jsinstead of.actions.jsfor Redux Thunk actions..\n└── /src\n    ├── /store\n    │   ├── /authentication\n    │   │   ├── /authentication.slice.js\n    │   │   ├── /authentication.actions.js\n    │   │   └── /authentication.test.js\n    │   ├── /authors\n    │   │   ├── /authors.slice.js\n    │   │   ├── /authors.actions.js\n    │   │   └── /authors.test.js\n    │   └── /books\n    │       ├── /books.slice.js\n    │       ├── /books.actions.js\n    │       └── /books.test.js\n    ├── rootReducer.js\n    └── index.jsYou can also add something like auisection of the store to handle modals, toasts, sidebar toggling, and other global UI state, which I find better than havingconst [isOpen, setIsOpen] = useState(false)all over the place.In therootReduceryou would import all your slices and combine them withcombineReducers, and inindex.jsyou would configure the store.UtilsWhether or not your project needs autilsfolder is up to you, but I think there are usually some global utility functions, like validation and conversion, that could easily be used across multiple sections of the app. If you keep it organized - not just having onehelpers.jsfile that contains thousands of functions - it could be a helpful addition to the organization of your project..\n└── src\n    └── /utils\n        ├── /constants\n        │   └── countries.constants.js\n        └── /helpers\n            ├── validation.helpers.js\n            ├── currency.helpers.js\n            └── array.helpers.jsAgain, theutilsfolder can contain anything you want that you think makes sense to keep on a global level. If you don't prefer the \"multi-tier\" filenames, you could just call itvalidation.js, but the way I see it, being explicit does not take anything away from the project, and makes it easier to navigate filenames when searching in your IDE.ViewsHere's where the main part of your app will live: in theviewsdirectory. Any page in your app is a \"view\". In this small example, the views line up pretty well with the Redux store, but it won't necessarily be the case that the store and views are exactly the same, which is why they're separate. Also,booksmight pull fromauthors, and so on.Anything within a view is an item that will likely only be used within that specific view - aBookFormthat will only be used at the/booksroute, and anAuthorBlurbthat will only be used on the/authorsroute. It might include specific forms, modals, buttons, any component that won't be global.The advantage of keeping everything domain-focused instead of putting all your pages together incomponents/pagesis that it makes it really easy to look at the structure of the application and know how many top level views there are, and know where everything that's only used by that view is. If there are nested routes, you can always add a nestedviewsfolder within the main route..\n└── /src\n    └── /views\n        ├── /Authors\n        │   ├── /AuthorsPage\n        │   │   ├── AuthorsPage.js\n        │   │   └── AuthorsPage.test.js\n        │   └── /AuthorBlurb\n        │       ├── /AuthorBlurb.js\n        │       └── /AuthorBlurb.test.js\n        ├── /Books\n        │   ├── /BooksPage\n        │   │   ├── BooksPage.js\n        │   │   └── BooksPage.test.js\n        │   └── /BookForm\n        │       ├── /BookForm.js\n        │       └── /BookForm.test.js\n        └── /Login\n            ├── LoginPage\n            │   ├── LoginPage.styles.js\n            │   ├── LoginPage.js\n            │   └── LoginPage.test.js\n            └── LoginForm\n                ├── LoginForm.js\n                └── LoginForm.test.jsKeeping everything within folders might seem annoying if you've never set up your project that way - you can always keep it more flat, or moveteststo its own directory that mimics the rest of the app.ConclusionThis is my proposal for a sytem for React organization that scales well for a large production app, and handles testing and styling as well as keeping everything together in a feature focused way. It's more nested than the traditional structure of everything being incomponentsandcontainers, but that system is a bit more dated due to Redux being much easier to implement with Hooks, and \"smart\" containers and \"dumb\" components no longer being necessary.It's easy to look at this system and understand everything that is needed for your app and where to go to work on a specific section, or a component that affects the app globally. This system may not make sense for every type of app, but it has worked for me. I'd love to hear any comments about ways this system can be improved, or other systems that have merit.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:June 23, 2021Category:TechnicalTagsjavascriptreactNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.9450000000000001,
        "word_count": 710,
        "chunk_id": "dcae5e9436a953c56de3a1793a5291d4",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "How to Structure and Organize a React ApplicationThere is no consensus on the right way to organize a React application. React gives you a lot of freedom, but with that freedom comes the responsibility of deciding on your own architecture. Often the case is that whoever sets up the application in the beginning throws almost everything in acomponentsfolder, or maybecomponentsandcontainersif they used Redux, but I propose there's a better way. I like to be deliberate about how I organize my applications so they're easy to use, understand, and extend.I'm going to show you what I consider to be an intuitive and scalable system for large-scale production React applications. The main concept I think is important is to make the architecture focused onfeatureas opposed totype, organizing only shared components on a global level and modularized all the other related entities together in the localized view.Tech assumptionsSince this article will be opinionated, I'll make some assumptions about what technology the project will be using:Application-React(Hooks)Global state management-Redux,Redux ToolkitRouting-React RouterStyles-Styled ComponentsTesting-Jest,React Testing LibraryI don't have a very strong opinion about the styling, whether Styled Components or CSS modules or a custom Sass setup is ideal, but I think Styled Components is probably one of the best options for keeping your styles modular.I'm also going to assume the tests are alongside the code, as opposed to in a top-leveltestsfolder. I can go either way with this one, but in order for an example to work, and in the real world, decisions need to be made.Everything here can still apply if you're using vanilla Redux instead of Redux Toolkit. I would recommendsetting up your Redux as feature sliceseither way.I'm also ambivalent aboutStorybook, but I'll include what it would look like with those files if you choose to use it in your project.For the sake of the example, I'll use a \"Library App\" example, that has a page for listing books, a page for listing authors, and has an authentication system.Directory StructureThe top level directory structure will be as follows:assets- global static assets such as images, svgs, company logo, etc.components- global shared/reusable components, such as layout (wrappers, navigation), form components, buttonsservices- JavaScript modulesstore- Global Redux storeutils- Utilities, helpers, constants, and the likeviews- Can also be called \"pages\", the majority of the app would be contained hereI like keeping familiar conventions wherever possible, sosrccontains everything,index.jsis the entry point, andApp.jssets up the auth and routing..\n└── /src\n    ├── /assets\n    ├── /components\n    ├── /services\n    ├── /store\n    ├── /utils\n    ├── /views\n    ├── index.js\n    └── App.jsI can see some additional folders you might have, such astypesif it's a TypeScript project,middlewareif necessary, maybecontextforContext, etc.AliasesI would set up the system to use aliases, so anything within thecomponentsfolder could be imported as@components,assetsas@assets, etc. If you have a custom Webpack, this is done through theresolveconfiguration.module.exports={resolve:{extensions:['js','ts'],alias:{'@':path.resolve(__dirname,'src'),'@assets':path.resolve(__dirname,'src/assets'),'@components':path.resolve(__dirname,'src/components'),// ...etc},},} t just makes it a lot easier to import from anywhere within the project and move files around without changing imports, and you never end up with something like../../../../../components/.ComponentsWithin thecomponentsfolder, I would group by type -forms,tables,buttons,layout, etc. The specifics will vary by your specific app.In this example, I'm assuming you're either creating your own form system, or creating your own bindings to an existing form system (for example, combining Formik and Material UI). In this case, you'd create a folder for each component (TextField,Select,Radio,Dropdown, etc.), and inside would be a file for the component itself, the styles, the tests, and the Storybook if it's being used.Component.js- The actual React componentComponent.styles.js- The Styled Components file for the componentComponent.test.js- The testsComponent.stories.js- The Storybook fileTo me, this makes a lot more sense than having one folder that contains the files for ALL components, one folder that contains all the tests, and one folder that contains all the Storybook files, etc. Everything related is grouped together and easy to find..\n└── /src\n    └── /components\n        ├── /forms\n        │   ├── /TextField\n        │   │   ├── TextField.js\n        │   │   ├── TextField.styles.js\n        │   │   ├── TextField.test.js\n        │   │   └── TextField.stories.js\n        │   ├── /Select\n        │   │   ├── Select.js\n        │   │   ├── Select.styles.js\n        │   │   ├── Select.test.js\n        │   │   └── Select.stories.js\n        │   └── index.js\n        ├── /routing\n        │   └── /PrivateRoute\n        │       ├── /PrivateRoute.js\n        │       └── /PrivateRoute.test.js\n        └── /layout\n            └── /navigation\n                └── /NavBar\n                    ├── NavBar.js\n                    ├── NavBar.styles.js\n                    ├── NavBar.test.js\n                    └── NavBar.stories.jsYou'll notice there's anindex.jsfile in thecomponents/formsdirectory. It is often rightfully suggested to avoid usingindex.jsfiles as they're not explicit, but in this case it makes sense - it will end up being an index of all the forms and look something like this:src/components/forms/index.jsimport{TextField} rom'./TextField/TextField'import{Select} rom'./Select/Select'import{Radio} rom'./Radio/Radio'export{TextField,Select,Radio} hen when you need to use one or more of the components, you can easily import them all at once.import{TextField,Select,Radio} rom'@components/forms'I would recommend this approach more than making anindex.jsinside ofeveryfolder withinforms, so now you just have oneindex.jsthat actually indexes the entire directory, as opposed to tenindex.jsfiles just to make imports easier for each individual file.ServicesTheservicesdirectory is less essential thancomponents, but if you're making a plain JavaScript module that the rest of the application is using, it can be handy. A common contrived example is a LocalStorage module, which might look like this:.\n└── /src\n    └── /services\n        ├── /LocalStorage\n        │   ├── LocalStorage.service.js\n        │   └── LocalStorage.test.js\n        └── index.jsAn example of the service:src/services/LocalStorage/LocalStorage.service.jsexportconstLocalStorage={get(key){},set(key,value){},remove(key){},clear(){},} mport{LocalStorage} rom'@services'LocalStorage.get('foo')StoreThe global data store will be contained in thestoredirectory - in this case, Redux. Each feature will have a folder, which will contain theRedux Toolkitslice, as well as actions and tests. This setup can also be used with regular Redux, you would just create a.reducers.jsfile and.actions.jsfile instead of aslice.",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.9450000000000001,
        "word_count": 902,
        "chunk_id": "868da1e1c72b4aff6a5a3a6a17a17652",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "If you're using sagas, it could be.saga.jsinstead of.actions.jsfor Redux Thunk actions..\n└── /src\n    ├── /store\n    │   ├── /authentication\n    │   │   ├── /authentication.slice.js\n    │   │   ├── /authentication.actions.js\n    │   │   └── /authentication.test.js\n    │   ├── /authors\n    │   │   ├── /authors.slice.js\n    │   │   ├── /authors.actions.js\n    │   │   └── /authors.test.js\n    │   └── /books\n    │       ├── /books.slice.js\n    │       ├── /books.actions.js\n    │       └── /books.test.js\n    ├── rootReducer.js\n    └── index.jsYou can also add something like auisection of the store to handle modals, toasts, sidebar toggling, and other global UI state, which I find better than havingconst [isOpen, setIsOpen] = useState(false)all over the place.In therootReduceryou would import all your slices and combine them withcombineReducers, and inindex.jsyou would configure the store.UtilsWhether or not your project needs autilsfolder is up to you, but I think there are usually some global utility functions, like validation and conversion, that could easily be used across multiple sections of the app. If you keep it organized - not just having onehelpers.jsfile that contains thousands of functions - it could be a helpful addition to the organization of your project..\n└── src\n    └── /utils\n        ├── /constants\n        │   └── countries.constants.js\n        └── /helpers\n            ├── validation.helpers.js\n            ├── currency.helpers.js\n            └── array.helpers.jsAgain, theutilsfolder can contain anything you want that you think makes sense to keep on a global level. If you don't prefer the \"multi-tier\" filenames, you could just call itvalidation.js, but the way I see it, being explicit does not take anything away from the project, and makes it easier to navigate filenames when searching in your IDE.ViewsHere's where the main part of your app will live: in theviewsdirectory. Any page in your app is a \"view\". In this small example, the views line up pretty well with the Redux store, but it won't necessarily be the case that the store and views are exactly the same, which is why they're separate. Also,booksmight pull fromauthors, and so on.Anything within a view is an item that will likely only be used within that specific view - aBookFormthat will only be used at the/booksroute, and anAuthorBlurbthat will only be used on the/authorsroute. It might include specific forms, modals, buttons, any component that won't be global.The advantage of keeping everything domain-focused instead of putting all your pages together incomponents/pagesis that it makes it really easy to look at the structure of the application and know how many top level views there are, and know where everything that's only used by that view is. If there are nested routes, you can always add a nestedviewsfolder within the main route..\n└── /src\n    └── /views\n        ├── /Authors\n        │   ├── /AuthorsPage\n        │   │   ├── AuthorsPage.js\n        │   │   └── AuthorsPage.test.js\n        │   └── /AuthorBlurb\n        │       ├── /AuthorBlurb.js\n        │       └── /AuthorBlurb.test.js\n        ├── /Books\n        │   ├── /BooksPage\n        │   │   ├── BooksPage.js\n        │   │   └── BooksPage.test.js\n        │   └── /BookForm\n        │       ├── /BookForm.js\n        │       └── /BookForm.test.js\n        └── /Login\n            ├── LoginPage\n            │   ├── LoginPage.styles.js\n            │   ├── LoginPage.js\n            │   └── LoginPage.test.js\n            └── LoginForm\n                ├── LoginForm.js\n                └── LoginForm.test.jsKeeping everything within folders might seem annoying if you've never set up your project that way - you can always keep it more flat, or moveteststo its own directory that mimics the rest of the app.ConclusionThis is my proposal for a sytem for React organization that scales well for a large production app, and handles testing and styling as well as keeping everything together in a feature focused way. It's more nested than the traditional structure of everything being incomponentsandcontainers, but that system is a bit more dated due to Redux being much easier to implement with Hooks, and \"smart\" containers and \"dumb\" components no longer being necessary.It's easy to look at this system and understand everything that is needed for your app and where to go to work on a specific section, or a component that affects the app globally. This system may not make sense for every type of app, but it has worked for me. I'd love to hear any comments about ways this system can be improved, or other systems that have merit.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:June 23, 2021Category:TechnicalTagsjavascriptreactNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.9450000000000001,
        "word_count": 710,
        "chunk_id": "dcae5e9436a953c56de3a1793a5291d4",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There is no consensus on the right way to organize a React application. React gives you a lot of freedom, but with that freedom comes the responsibility of deciding on your own architecture. Often the case is that whoever sets up the application in the beginning throws almost everything in acomponentsfolder, or maybecomponentsandcontainersif they used Redux, but I propose there's a better way. I like to be deliberate about how I organize my applications so they're easy to use, understand, and extend.I'm going to show you what I consider to be an intuitive and scalable system for large-scale production React applications. The main concept I think is important is to make the architecture focused onfeatureas opposed totype, organizing only shared components on a global level and modularized all the other related entities together in the localized view.Tech assumptionsSince this article will be opinionated, I'll make some assumptions about what technology the project will be using:Application-React(Hooks)Global state management-Redux,Redux ToolkitRouting-React RouterStyles-Styled ComponentsTesting-Jest,React Testing LibraryI don't have a very strong opinion about the styling, whether Styled Components or CSS modules or a custom Sass setup is ideal, but I think Styled Components is probably one of the best options for keeping your styles modular.I'm also going to assume the tests are alongside the code, as opposed to in a top-leveltestsfolder. I can go either way with this one, but in order for an example to work, and in the real world, decisions need to be made.Everything here can still apply if you're using vanilla Redux instead of Redux Toolkit. I would recommendsetting up your Redux as feature sliceseither way.I'm also ambivalent aboutStorybook, but I'll include what it would look like with those files if you choose to use it in your project.For the sake of the example, I'll use a \"Library App\" example, that has a page for listing books, a page for listing authors, and has an authentication system.Directory StructureThe top level directory structure will be as follows:assets- global static assets such as images, svgs, company logo, etc.components- global shared/reusable components, such as layout (wrappers, navigation), form components, buttonsservices- JavaScript modulesstore- Global Redux storeutils- Utilities, helpers, constants, and the likeviews- Can also be called \"pages\", the majority of the app would be contained hereI like keeping familiar conventions wherever possible, sosrccontains everything,index.jsis the entry point, andApp.jssets up the auth and routing..\n└── /src\n    ├── /assets\n    ├── /components\n    ├── /services\n    ├── /store\n    ├── /utils\n    ├── /views\n    ├── index.js\n    └── App.jsI can see some additional folders you might have, such astypesif it's a TypeScript project,middlewareif necessary, maybecontextforContext, etc.AliasesI would set up the system to use aliases, so anything within thecomponentsfolder could be imported as@components,assetsas@assets, etc. If you have a custom Webpack, this is done through theresolveconfiguration.module.exports={resolve:{extensions:['js','ts'],alias:{'@':path.resolve(__dirname,'src'),'@assets':path.resolve(__dirname,'src/assets'),'@components':path.resolve(__dirname,'src/components'),// ...etc},},} t just makes it a lot easier to import from anywhere within the project and move files around without changing imports, and you never end up with something like../../../../../components/.ComponentsWithin thecomponentsfolder, I would group by type -forms,tables,buttons,layout, etc. The specifics will vary by your specific app.In this example, I'm assuming you're either creating your own form system, or creating your own bindings to an existing form system (for example, combining Formik and Material UI). In this case, you'd create a folder for each component (TextField,Select,Radio,Dropdown, etc.), and inside would be a file for the component itself, the styles, the tests, and the Storybook if it's being used.Component.js- The actual React componentComponent.styles.js- The Styled Components file for the componentComponent.test.js- The testsComponent.stories.js- The Storybook fileTo me, this makes a lot more sense than having one folder that contains the files for ALL components, one folder that contains all the tests, and one folder that contains all the Storybook files, etc. Everything related is grouped together and easy to find..\n└── /src\n    └── /components\n        ├── /forms\n        │   ├── /TextField\n        │   │   ├── TextField.js\n        │   │   ├── TextField.styles.js\n        │   │   ├── TextField.test.js\n        │   │   └── TextField.stories.js\n        │   ├── /Select\n        │   │   ├── Select.js\n        │   │   ├── Select.styles.js\n        │   │   ├── Select.test.js\n        │   │   └── Select.stories.js\n        │   └── index.js\n        ├── /routing\n        │   └── /PrivateRoute\n        │       ├── /PrivateRoute.js\n        │       └── /PrivateRoute.test.js\n        └── /layout\n            └── /navigation\n                └── /NavBar\n                    ├── NavBar.js\n                    ├── NavBar.styles.js\n                    ├── NavBar.test.js\n                    └── NavBar.stories.jsYou'll notice there's anindex.jsfile in thecomponents/formsdirectory. It is often rightfully suggested to avoid usingindex.jsfiles as they're not explicit, but in this case it makes sense - it will end up being an index of all the forms and look something like this:src/components/forms/index.jsimport{TextField} rom'./TextField/TextField'import{Select} rom'./Select/Select'import{Radio} rom'./Radio/Radio'export{TextField,Select,Radio} hen when you need to use one or more of the components, you can easily import them all at once.import{TextField,Select,Radio} rom'@components/forms'I would recommend this approach more than making anindex.jsinside ofeveryfolder withinforms, so now you just have oneindex.jsthat actually indexes the entire directory, as opposed to tenindex.jsfiles just to make imports easier for each individual file.ServicesTheservicesdirectory is less essential thancomponents, but if you're making a plain JavaScript module that the rest of the application is using, it can be handy. A common contrived example is a LocalStorage module, which might look like this:.\n└── /src\n    └── /services\n        ├── /LocalStorage\n        │   ├── LocalStorage.service.js\n        │   └── LocalStorage.test.js\n        └── index.jsAn example of the service:src/services/LocalStorage/LocalStorage.service.jsexportconstLocalStorage={get(key){},set(key,value){},remove(key){},clear(){},} mport{LocalStorage} rom'@services'LocalStorage.get('foo')StoreThe global data store will be contained in thestoredirectory - in this case, Redux. Each feature will have a folder, which will contain theRedux Toolkitslice, as well as actions and tests. This setup can also be used with regular Redux, you would just create a.reducers.jsfile and.actions.jsfile instead of aslice.",
        "chunk_type": "technical_content",
        "tag": "section",
        "score": 0.9450000000000001,
        "word_count": 895,
        "chunk_id": "dc01d48e25930e1dd43bed11c795bc28",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "If you're using sagas, it could be.saga.jsinstead of.actions.jsfor Redux Thunk actions..\n└── /src\n    ├── /store\n    │   ├── /authentication\n    │   │   ├── /authentication.slice.js\n    │   │   ├── /authentication.actions.js\n    │   │   └── /authentication.test.js\n    │   ├── /authors\n    │   │   ├── /authors.slice.js\n    │   │   ├── /authors.actions.js\n    │   │   └── /authors.test.js\n    │   └── /books\n    │       ├── /books.slice.js\n    │       ├── /books.actions.js\n    │       └── /books.test.js\n    ├── rootReducer.js\n    └── index.jsYou can also add something like auisection of the store to handle modals, toasts, sidebar toggling, and other global UI state, which I find better than havingconst [isOpen, setIsOpen] = useState(false)all over the place.In therootReduceryou would import all your slices and combine them withcombineReducers, and inindex.jsyou would configure the store.UtilsWhether or not your project needs autilsfolder is up to you, but I think there are usually some global utility functions, like validation and conversion, that could easily be used across multiple sections of the app. If you keep it organized - not just having onehelpers.jsfile that contains thousands of functions - it could be a helpful addition to the organization of your project..\n└── src\n    └── /utils\n        ├── /constants\n        │   └── countries.constants.js\n        └── /helpers\n            ├── validation.helpers.js\n            ├── currency.helpers.js\n            └── array.helpers.jsAgain, theutilsfolder can contain anything you want that you think makes sense to keep on a global level. If you don't prefer the \"multi-tier\" filenames, you could just call itvalidation.js, but the way I see it, being explicit does not take anything away from the project, and makes it easier to navigate filenames when searching in your IDE.ViewsHere's where the main part of your app will live: in theviewsdirectory. Any page in your app is a \"view\". In this small example, the views line up pretty well with the Redux store, but it won't necessarily be the case that the store and views are exactly the same, which is why they're separate. Also,booksmight pull fromauthors, and so on.Anything within a view is an item that will likely only be used within that specific view - aBookFormthat will only be used at the/booksroute, and anAuthorBlurbthat will only be used on the/authorsroute. It might include specific forms, modals, buttons, any component that won't be global.The advantage of keeping everything domain-focused instead of putting all your pages together incomponents/pagesis that it makes it really easy to look at the structure of the application and know how many top level views there are, and know where everything that's only used by that view is. If there are nested routes, you can always add a nestedviewsfolder within the main route..\n└── /src\n    └── /views\n        ├── /Authors\n        │   ├── /AuthorsPage\n        │   │   ├── AuthorsPage.js\n        │   │   └── AuthorsPage.test.js\n        │   └── /AuthorBlurb\n        │       ├── /AuthorBlurb.js\n        │       └── /AuthorBlurb.test.js\n        ├── /Books\n        │   ├── /BooksPage\n        │   │   ├── BooksPage.js\n        │   │   └── BooksPage.test.js\n        │   └── /BookForm\n        │       ├── /BookForm.js\n        │       └── /BookForm.test.js\n        └── /Login\n            ├── LoginPage\n            │   ├── LoginPage.styles.js\n            │   ├── LoginPage.js\n            │   └── LoginPage.test.js\n            └── LoginForm\n                ├── LoginForm.js\n                └── LoginForm.test.jsKeeping everything within folders might seem annoying if you've never set up your project that way - you can always keep it more flat, or moveteststo its own directory that mimics the rest of the app.ConclusionThis is my proposal for a sytem for React organization that scales well for a large production app, and handles testing and styling as well as keeping everything together in a feature focused way. It's more nested than the traditional structure of everything being incomponentsandcontainers, but that system is a bit more dated due to Redux being much easier to implement with Hooks, and \"smart\" containers and \"dumb\" components no longer being necessary.It's easy to look at this system and understand everything that is needed for your app and where to go to work on a specific section, or a component that affects the app globally. This system may not make sense for every type of app, but it has worked for me. I'd love to hear any comments about ways this system can be improved, or other systems that have merit.",
        "chunk_type": "technical_content",
        "tag": "section",
        "score": 0.9450000000000001,
        "word_count": 657,
        "chunk_id": "9dff314324abd20f55e9c4db237db02f",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There is no consensus on the right way to organize a React application. React gives you a lot of freedom, but with that freedom comes the responsibility of deciding on your own architecture. Often the case is that whoever sets up the application in the beginning throws almost everything in acomponentsfolder, or maybecomponentsandcontainersif they used Redux, but I propose there's a better way. I like to be deliberate about how I organize my applications so they're easy to use, understand, and extend.I'm going to show you what I consider to be an intuitive and scalable system for large-scale production React applications. The main concept I think is important is to make the architecture focused onfeatureas opposed totype, organizing only shared components on a global level and modularized all the other related entities together in the localized view.Tech assumptionsSince this article will be opinionated, I'll make some assumptions about what technology the project will be using:Application-React(Hooks)Global state management-Redux,Redux ToolkitRouting-React RouterStyles-Styled ComponentsTesting-Jest,React Testing LibraryI don't have a very strong opinion about the styling, whether Styled Components or CSS modules or a custom Sass setup is ideal, but I think Styled Components is probably one of the best options for keeping your styles modular.I'm also going to assume the tests are alongside the code, as opposed to in a top-leveltestsfolder. I can go either way with this one, but in order for an example to work, and in the real world, decisions need to be made.Everything here can still apply if you're using vanilla Redux instead of Redux Toolkit. I would recommendsetting up your Redux as feature sliceseither way.I'm also ambivalent aboutStorybook, but I'll include what it would look like with those files if you choose to use it in your project.For the sake of the example, I'll use a \"Library App\" example, that has a page for listing books, a page for listing authors, and has an authentication system.Directory StructureThe top level directory structure will be as follows:assets- global static assets such as images, svgs, company logo, etc.components- global shared/reusable components, such as layout (wrappers, navigation), form components, buttonsservices- JavaScript modulesstore- Global Redux storeutils- Utilities, helpers, constants, and the likeviews- Can also be called \"pages\", the majority of the app would be contained hereI like keeping familiar conventions wherever possible, sosrccontains everything,index.jsis the entry point, andApp.jssets up the auth and routing..\n└── /src\n    ├── /assets\n    ├── /components\n    ├── /services\n    ├── /store\n    ├── /utils\n    ├── /views\n    ├── index.js\n    └── App.jsI can see some additional folders you might have, such astypesif it's a TypeScript project,middlewareif necessary, maybecontextforContext, etc.AliasesI would set up the system to use aliases, so anything within thecomponentsfolder could be imported as@components,assetsas@assets, etc. If you have a custom Webpack, this is done through theresolveconfiguration.module.exports={resolve:{extensions:['js','ts'],alias:{'@':path.resolve(__dirname,'src'),'@assets':path.resolve(__dirname,'src/assets'),'@components':path.resolve(__dirname,'src/components'),// ...etc},},} t just makes it a lot easier to import from anywhere within the project and move files around without changing imports, and you never end up with something like../../../../../components/.ComponentsWithin thecomponentsfolder, I would group by type -forms,tables,buttons,layout, etc. The specifics will vary by your specific app.In this example, I'm assuming you're either creating your own form system, or creating your own bindings to an existing form system (for example, combining Formik and Material UI). In this case, you'd create a folder for each component (TextField,Select,Radio,Dropdown, etc.), and inside would be a file for the component itself, the styles, the tests, and the Storybook if it's being used.Component.js- The actual React componentComponent.styles.js- The Styled Components file for the componentComponent.test.js- The testsComponent.stories.js- The Storybook fileTo me, this makes a lot more sense than having one folder that contains the files for ALL components, one folder that contains all the tests, and one folder that contains all the Storybook files, etc. Everything related is grouped together and easy to find..\n└── /src\n    └── /components\n        ├── /forms\n        │   ├── /TextField\n        │   │   ├── TextField.js\n        │   │   ├── TextField.styles.js\n        │   │   ├── TextField.test.js\n        │   │   └── TextField.stories.js\n        │   ├── /Select\n        │   │   ├── Select.js\n        │   │   ├── Select.styles.js\n        │   │   ├── Select.test.js\n        │   │   └── Select.stories.js\n        │   └── index.js\n        ├── /routing\n        │   └── /PrivateRoute\n        │       ├── /PrivateRoute.js\n        │       └── /PrivateRoute.test.js\n        └── /layout\n            └── /navigation\n                └── /NavBar\n                    ├── NavBar.js\n                    ├── NavBar.styles.js\n                    ├── NavBar.test.js\n                    └── NavBar.stories.jsYou'll notice there's anindex.jsfile in thecomponents/formsdirectory. It is often rightfully suggested to avoid usingindex.jsfiles as they're not explicit, but in this case it makes sense - it will end up being an index of all the forms and look something like this:src/components/forms/index.jsimport{TextField} rom'./TextField/TextField'import{Select} rom'./Select/Select'import{Radio} rom'./Radio/Radio'export{TextField,Select,Radio} hen when you need to use one or more of the components, you can easily import them all at once.import{TextField,Select,Radio} rom'@components/forms'I would recommend this approach more than making anindex.jsinside ofeveryfolder withinforms, so now you just have oneindex.jsthat actually indexes the entire directory, as opposed to tenindex.jsfiles just to make imports easier for each individual file.ServicesTheservicesdirectory is less essential thancomponents, but if you're making a plain JavaScript module that the rest of the application is using, it can be handy. A common contrived example is a LocalStorage module, which might look like this:.\n└── /src\n    └── /services\n        ├── /LocalStorage\n        │   ├── LocalStorage.service.js\n        │   └── LocalStorage.test.js\n        └── index.jsAn example of the service:src/services/LocalStorage/LocalStorage.service.jsexportconstLocalStorage={get(key){},set(key,value){},remove(key){},clear(){},} mport{LocalStorage} rom'@services'LocalStorage.get('foo')StoreThe global data store will be contained in thestoredirectory - in this case, Redux. Each feature will have a folder, which will contain theRedux Toolkitslice, as well as actions and tests. This setup can also be used with regular Redux, you would just create a.reducers.jsfile and.actions.jsfile instead of aslice.",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.9450000000000001,
        "word_count": 895,
        "chunk_id": "dc01d48e25930e1dd43bed11c795bc28",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "id": "/react-architecture-directory-structure/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "If you're using sagas, it could be.saga.jsinstead of.actions.jsfor Redux Thunk actions..\n└── /src\n    ├── /store\n    │   ├── /authentication\n    │   │   ├── /authentication.slice.js\n    │   │   ├── /authentication.actions.js\n    │   │   └── /authentication.test.js\n    │   ├── /authors\n    │   │   ├── /authors.slice.js\n    │   │   ├── /authors.actions.js\n    │   │   └── /authors.test.js\n    │   └── /books\n    │       ├── /books.slice.js\n    │       ├── /books.actions.js\n    │       └── /books.test.js\n    ├── rootReducer.js\n    └── index.jsYou can also add something like auisection of the store to handle modals, toasts, sidebar toggling, and other global UI state, which I find better than havingconst [isOpen, setIsOpen] = useState(false)all over the place.In therootReduceryou would import all your slices and combine them withcombineReducers, and inindex.jsyou would configure the store.UtilsWhether or not your project needs autilsfolder is up to you, but I think there are usually some global utility functions, like validation and conversion, that could easily be used across multiple sections of the app. If you keep it organized - not just having onehelpers.jsfile that contains thousands of functions - it could be a helpful addition to the organization of your project..\n└── src\n    └── /utils\n        ├── /constants\n        │   └── countries.constants.js\n        └── /helpers\n            ├── validation.helpers.js\n            ├── currency.helpers.js\n            └── array.helpers.jsAgain, theutilsfolder can contain anything you want that you think makes sense to keep on a global level. If you don't prefer the \"multi-tier\" filenames, you could just call itvalidation.js, but the way I see it, being explicit does not take anything away from the project, and makes it easier to navigate filenames when searching in your IDE.ViewsHere's where the main part of your app will live: in theviewsdirectory. Any page in your app is a \"view\". In this small example, the views line up pretty well with the Redux store, but it won't necessarily be the case that the store and views are exactly the same, which is why they're separate. Also,booksmight pull fromauthors, and so on.Anything within a view is an item that will likely only be used within that specific view - aBookFormthat will only be used at the/booksroute, and anAuthorBlurbthat will only be used on the/authorsroute. It might include specific forms, modals, buttons, any component that won't be global.The advantage of keeping everything domain-focused instead of putting all your pages together incomponents/pagesis that it makes it really easy to look at the structure of the application and know how many top level views there are, and know where everything that's only used by that view is. If there are nested routes, you can always add a nestedviewsfolder within the main route..\n└── /src\n    └── /views\n        ├── /Authors\n        │   ├── /AuthorsPage\n        │   │   ├── AuthorsPage.js\n        │   │   └── AuthorsPage.test.js\n        │   └── /AuthorBlurb\n        │       ├── /AuthorBlurb.js\n        │       └── /AuthorBlurb.test.js\n        ├── /Books\n        │   ├── /BooksPage\n        │   │   ├── BooksPage.js\n        │   │   └── BooksPage.test.js\n        │   └── /BookForm\n        │       ├── /BookForm.js\n        │       └── /BookForm.test.js\n        └── /Login\n            ├── LoginPage\n            │   ├── LoginPage.styles.js\n            │   ├── LoginPage.js\n            │   └── LoginPage.test.js\n            └── LoginForm\n                ├── LoginForm.js\n                └── LoginForm.test.jsKeeping everything within folders might seem annoying if you've never set up your project that way - you can always keep it more flat, or moveteststo its own directory that mimics the rest of the app.ConclusionThis is my proposal for a sytem for React organization that scales well for a large production app, and handles testing and styling as well as keeping everything together in a feature focused way. It's more nested than the traditional structure of everything being incomponentsandcontainers, but that system is a bit more dated due to Redux being much easier to implement with Hooks, and \"smart\" containers and \"dumb\" components no longer being necessary.It's easy to look at this system and understand everything that is needed for your app and where to go to work on a specific section, or a component that affects the app globally. This system may not make sense for every type of app, but it has worked for me. I'd love to hear any comments about ways this system can be improved, or other systems that have merit.",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.9450000000000001,
        "word_count": 657,
        "chunk_id": "9dff314324abd20f55e9c4db237db02f",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "id": "/react-architecture-directory-structure/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:June 23, 2021Category:TechnicalTagsjavascriptreactNewsletterSubscribe to the Newsletter",
        "chunk_type": "text",
        "tag": "aside",
        "score": 0.42600000000000005,
        "word_count": 54,
        "chunk_id": "1000d105e10fbe48a0dd5be39330f2d5",
        "metadata": {
          "source_tag": "aside",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "post-sidebar"
            ]
          },
          "technical_indicators": [
            "javascript"
          ]
        }
      },
      {
        "content": "There is no consensus on the right way to organize a React application. React gives you a lot of freedom, but with that freedom comes the responsibility of deciding on your own architecture. Often the case is that whoever sets up the application in the beginning throws almost everything in acomponentsfolder, or maybecomponentsandcontainersif they used Redux, but I propose there's a better way. I like to be deliberate about how I organize my applications so they're easy to use, understand, and extend.",
        "chunk_type": "technical_content",
        "tag": "p",
        "score": 0.335,
        "word_count": 82,
        "chunk_id": "30d517213c62ce11b3ed1fffbd2f09d8",
        "metadata": {
          "source_tag": "p",
          "keywords_found": [
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react"
          ]
        }
      },
      {
        "content": "This is my proposal for a sytem for React organization that scales well for a large production app, and handles testing and styling as well as keeping everything together in a feature focused way. It's more nested than the traditional structure of everything being incomponentsandcontainers, but that system is a bit more dated due to Redux being much easier to implement with Hooks, and \"smart\" containers and \"dumb\" components no longer being necessary.",
        "chunk_type": "technical_content",
        "tag": "p",
        "score": 0.30900000000000005,
        "word_count": 73,
        "chunk_id": "d0bb356074d80a5c60884cb34e1f3cc8",
        "metadata": {
          "source_tag": "p",
          "keywords_found": [
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react"
          ]
        }
      },
      {
        "content": ".\n└── /src\n    └── /components\n        ├── /forms\n        │   ├── /TextField\n        │   │   ├── TextField.js\n        │   │   ├── TextField.styles.js\n        │   │   ├── TextField.test.js\n        │   │   └── TextField.stories.js\n        │   ├── /Select\n        │   │   ├── Select.js\n        │   │   ├── Select.styles.js\n        │   │   ├── Select.test.js\n        │   │   └── Select.stories.js\n        │   └── index.js\n        ├── /routing\n        │   └── /PrivateRoute\n        │       ├── /PrivateRoute.js\n        │       └── /PrivateRoute.test.js\n        └── /layout\n            └── /navigation\n                └── /NavBar\n                    ├── NavBar.js\n                    ├── NavBar.styles.js\n                    ├── NavBar.test.js\n                    └── NavBar.stories.js",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.34800000000000003,
        "word_count": 73,
        "chunk_id": "c0d1d6ffad4a0b97636290c67ca5c913",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "text"
          },
          "technical_indicators": [
            "react",
            "sql"
          ]
        }
      },
      {
        "content": ".\n└── /src\n    └── /components\n        ├── /forms\n        │   ├── /TextField\n        │   │   ├── TextField.js\n        │   │   ├── TextField.styles.js\n        │   │   ├── TextField.test.js\n        │   │   └── TextField.stories.js\n        │   ├── /Select\n        │   │   ├── Select.js\n        │   │   ├── Select.styles.js\n        │   │   ├── Select.test.js\n        │   │   └── Select.stories.js\n        │   └── index.js\n        ├── /routing\n        │   └── /PrivateRoute\n        │       ├── /PrivateRoute.js\n        │       └── /PrivateRoute.test.js\n        └── /layout\n            └── /navigation\n                └── /NavBar\n                    ├── NavBar.js\n                    ├── NavBar.styles.js\n                    ├── NavBar.test.js\n                    └── NavBar.stories.js",
        "chunk_type": "technical_content",
        "tag": "pre",
        "score": 0.34800000000000003,
        "word_count": 73,
        "chunk_id": "c0d1d6ffad4a0b97636290c67ca5c913",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [],
          "attributes": {
            "class": [
              "language-text"
            ]
          },
          "technical_indicators": [
            "react",
            "sql"
          ]
        }
      },
      {
        "content": ".\n└── /src\n    └── /components\n        ├── /forms\n        │   ├── /TextField\n        │   │   ├── TextField.js\n        │   │   ├── TextField.styles.js\n        │   │   ├── TextField.test.js\n        │   │   └── TextField.stories.js\n        │   ├── /Select\n        │   │   ├── Select.js\n        │   │   ├── Select.styles.js\n        │   │   ├── Select.test.js\n        │   │   └── Select.stories.js\n        │   └── index.js\n        ├── /routing\n        │   └── /PrivateRoute\n        │       ├── /PrivateRoute.js\n        │       └── /PrivateRoute.test.js\n        └── /layout\n            └── /navigation\n                └── /NavBar\n                    ├── NavBar.js\n                    ├── NavBar.styles.js\n                    ├── NavBar.test.js\n                    └── NavBar.stories.js",
        "chunk_type": "technical_content",
        "tag": "code",
        "score": 0.34800000000000003,
        "word_count": 73,
        "chunk_id": "c0d1d6ffad4a0b97636290c67ca5c913",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [],
          "attributes": {
            "class": [
              "language-text"
            ]
          },
          "technical_indicators": [
            "react",
            "sql"
          ]
        }
      }
    ],
    "chunk_count": 20,
    "content_types": [
      "text",
      "technical_content"
    ],
    "technical_concepts": [
      "javascript",
      "data",
      "react",
      "sql"
    ],
    "crawl_metadata": {},
    "technical_content": [
      {
        "id": "4725dcf446a342f1473a8228e42dfa48",
        "content": "components",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "4725dcf446a342f1473a8228e42dfa48",
        "content": "components",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "57bcbf1d2df6010d41816c012905835d",
        "content": "containers",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b61a6d542f9036550ba9c401c80f00ef",
        "content": "tests",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "25d902c24283ab8cfbac54dfa101ad31",
        "content": "src",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "958f6f56cd42c904603d226cd36a57b6",
        "content": "App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "47170b535c8d7d3d90b971fde19235a6",
        "content": ". /src /assets /components /services /store /utils /views index.js App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "47170b535c8d7d3d90b971fde19235a6",
        "content": ". /src /assets /components /services /store /utils /views index.js App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "d14a8022b085f9ef19d479cbdd581127",
        "content": "types",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b200f0642a4dc4d9d66162920860c3f0",
        "content": "middleware",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5c18ef72771564b7f43c497dc507aeab",
        "content": "context",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4725dcf446a342f1473a8228e42dfa48",
        "content": "components",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "4725dcf446a342f1473a8228e42dfa48",
        "content": "components",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "32bb636196f91ed59d7a49190e26b42c",
        "content": "assets",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "32bb636196f91ed59d7a49190e26b42c",
        "content": "assets",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1434d28b6e423e0afb72fc13508c2a84",
        "content": "module.exports = { resolve: { extensions: ['js', 'ts'], alias: { ' ': path.resolve(__dirname, 'src'), ' assets': path.resolve(__dirname, 'src/assets'), ' components': path.resolve(__dirname, 'src/components'), // ...etc }, }, }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "1434d28b6e423e0afb72fc13508c2a84",
        "content": "module.exports = { resolve: { extensions: ['js', 'ts'], alias: { ' ': path.resolve(__dirname, 'src'), ' assets': path.resolve(__dirname, 'src/assets'), ' components': path.resolve(__dirname, 'src/components'), // ...etc }, }, }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "7aad648ac77cc166378353ba27675255",
        "content": "../../../../../components/",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "4725dcf446a342f1473a8228e42dfa48",
        "content": "components",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "ac68b62abfd6a9fe26e8ac4236c8ce0c",
        "content": "forms",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9ab2ec7ea4a2041306f7bdf150fcd453",
        "content": "tables",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "02634eff3c24742057ecacbee91c4bbd",
        "content": "buttons",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c61404957758dfda283709e89376ab3e",
        "content": "layout",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f0bfb289e820988a0d3e577bed6156a8",
        "content": "TextField",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e0626222614bdee31951d84c64e5e9ff",
        "content": "Select",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "1f32d2c1b49b9b0c9d99bd10da107e41",
        "content": "Radio",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7498c445a737312f3678aa1494e01a38",
        "content": "Dropdown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e419bf2968f5831d6fe6c40e5579145b",
        "content": ". /src /components /forms /TextField TextField.js TextField.styles.js TextField.test.js TextField.stories.js /Select Select.js Select.styles.js Select.test.js Select.stories.js index.js /routing /PrivateRoute /PrivateRoute.js /PrivateRoute.test.js /layout /navigation /NavBar NavBar.js NavBar.styles.js NavBar.test.js NavBar.stories.js",
        "type": "code",
        "language": "text",
        "relevance": 0.7105263157894737
      },
      {
        "id": "e419bf2968f5831d6fe6c40e5579145b",
        "content": ". /src /components /forms /TextField TextField.js TextField.styles.js TextField.test.js TextField.stories.js /Select Select.js Select.styles.js Select.test.js Select.stories.js index.js /routing /PrivateRoute /PrivateRoute.js /PrivateRoute.test.js /layout /navigation /NavBar NavBar.js NavBar.styles.js NavBar.test.js NavBar.stories.js",
        "type": "code",
        "language": "text",
        "relevance": 0.7105263157894737
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "94459ba4fe0afaa641824f1980519df4",
        "content": "components/forms",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "8cde8a71d72e2832aba0d1c2dc9cb1a9",
        "content": "import { TextField } from './TextField/TextField' import { Select } from './Select/Select' import { Radio } from './Radio/Radio' export { TextField, Select, Radio }",
        "type": "code",
        "language": "js",
        "relevance": 0.4052631578947369
      },
      {
        "id": "8cde8a71d72e2832aba0d1c2dc9cb1a9",
        "content": "import { TextField } from './TextField/TextField' import { Select } from './Select/Select' import { Radio } from './Radio/Radio' export { TextField, Select, Radio }",
        "type": "code",
        "language": "js",
        "relevance": 0.4052631578947369
      },
      {
        "id": "7b4c25191269c10aa1cc135597254122",
        "content": "import { TextField, Select, Radio } from ' components/forms'",
        "type": "code",
        "language": "js",
        "relevance": 0.5105263157894737
      },
      {
        "id": "7b4c25191269c10aa1cc135597254122",
        "content": "import { TextField, Select, Radio } from ' components/forms'",
        "type": "code",
        "language": "js",
        "relevance": 0.5105263157894737
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "ac68b62abfd6a9fe26e8ac4236c8ce0c",
        "content": "forms",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "10cd395cf71c18328c863c08e78f3fd0",
        "content": "services",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4725dcf446a342f1473a8228e42dfa48",
        "content": "components",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "6e24fcd5c6b278e94a46e7468ea97cc0",
        "content": ". /src /services /LocalStorage LocalStorage.service.js LocalStorage.test.js index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6e24fcd5c6b278e94a46e7468ea97cc0",
        "content": ". /src /services /LocalStorage LocalStorage.service.js LocalStorage.test.js index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9a36cc7db6e091af0154eff0db2f8f67",
        "content": "export const LocalStorage = { get(key) {}, set(key, value) {}, remove(key) {}, clear() {}, }",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "9a36cc7db6e091af0154eff0db2f8f67",
        "content": "export const LocalStorage = { get(key) {}, set(key, value) {}, remove(key) {}, clear() {}, }",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "6b28381bb04ac64e3680a189f9a68c0c",
        "content": "import { LocalStorage } from ' services' LocalStorage.get('foo')",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6b28381bb04ac64e3680a189f9a68c0c",
        "content": "import { LocalStorage } from ' services' LocalStorage.get('foo')",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "8cd892b7b97ef9489ae4479d3f4ef0fc",
        "content": "store",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9cca54e1345a80a2447d8e56f1fddf3e",
        "content": ".reducers.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "549426947ddd23caba101a9a5f06e816",
        "content": ".actions.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6d52012dca4fc77aa554f25430aef501",
        "content": "slice",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1fca03237a5c3f384e1653b192d5a3f3",
        "content": ".saga.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "549426947ddd23caba101a9a5f06e816",
        "content": ".actions.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "45c98fbf2adc96d622592fdd8faf57a1",
        "content": ". /src /store /authentication /authentication.slice.js /authentication.actions.js /authentication.test.js /authors /authors.slice.js /authors.actions.js /authors.test.js /books /books.slice.js /books.actions.js /books.test.js rootReducer.js index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "45c98fbf2adc96d622592fdd8faf57a1",
        "content": ". /src /store /authentication /authentication.slice.js /authentication.actions.js /authentication.test.js /authors /authors.slice.js /authors.actions.js /authors.test.js /books /books.slice.js /books.actions.js /books.test.js rootReducer.js index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7d5c009e4eb8bbc78647caeca308e61b",
        "content": "ui",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "da29d57b18ba9673c61de6d76442dfa5",
        "content": "const [isOpen, setIsOpen] = useState(false)",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "c0be6c4e3861c6ba620e547e8819de0a",
        "content": "rootReducer",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4b7dbab04392cd22a1fec72b0a1831ce",
        "content": "combineReducers",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2b3583e6e17721c54496bd04e57a0c15",
        "content": "utils",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9539354d35e1c6c1fa65496aaba008cc",
        "content": "helpers.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "25dcfa147b11089b521eb0d6fffc316b",
        "content": ". src /utils /constants countries.constants.js /helpers validation.helpers.js currency.helpers.js array.helpers.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "25dcfa147b11089b521eb0d6fffc316b",
        "content": ". src /utils /constants countries.constants.js /helpers validation.helpers.js currency.helpers.js array.helpers.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2b3583e6e17721c54496bd04e57a0c15",
        "content": "utils",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7cff2fbef3d599eb49f2813d9a65a86a",
        "content": "validation.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "59a14a5786fe7a105d780bb1e1e2b21b",
        "content": "views",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7d8949bcbf85067fceda9f84a6affb6b",
        "content": "books",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5d9449e8d8508c7ee2cf746c86e5dde3",
        "content": "authors",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "910c626184c19461aebd7de5f2e078af",
        "content": "BookForm",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a0721c16c96f044d5d405fef10a701de",
        "content": "/books",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d0ee792df4dd099b4ea2a8f0054ecf78",
        "content": "AuthorBlurb",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "0cd2ab40365b290f953028a915b0281d",
        "content": "/authors",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "771b1d7e6d2be441e2bf5648d3dafde6",
        "content": "components/pages",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "59a14a5786fe7a105d780bb1e1e2b21b",
        "content": "views",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6ed460066bf33f67b1fcd32579959d4b",
        "content": ". /src /views /Authors /AuthorsPage AuthorsPage.js AuthorsPage.test.js /AuthorBlurb /AuthorBlurb.js /AuthorBlurb.test.js /Books /BooksPage BooksPage.js BooksPage.test.js /BookForm /BookForm.js /BookForm.test.js /Login LoginPage LoginPage.styles.js LoginPage.js LoginPage.test.js LoginForm LoginForm.js LoginForm.test.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6ed460066bf33f67b1fcd32579959d4b",
        "content": ". /src /views /Authors /AuthorsPage AuthorsPage.js AuthorsPage.test.js /AuthorBlurb /AuthorBlurb.js /AuthorBlurb.test.js /Books /BooksPage BooksPage.js BooksPage.test.js /BookForm /BookForm.js /BookForm.test.js /Login LoginPage LoginPage.styles.js LoginPage.js LoginPage.test.js LoginForm LoginForm.js LoginForm.test.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b61a6d542f9036550ba9c401c80f00ef",
        "content": "tests",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4725dcf446a342f1473a8228e42dfa48",
        "content": "components",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "57bcbf1d2df6010d41816c012905835d",
        "content": "containers",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      }
    ]
  },
  {
    "metadata": {
      "description": "There is no consensus on the right way to organize a React application. React gives you a lot of freedom, but with that freedom comes the…",
      "url": "https://www.taniarascia.com/react-architecture-directory-structure/#components",
      "title": "How to Structure and Organize a React Application | Tania Rascia's Personal Website",
      "source_type": "web",
      "crawl_time": 1730107263.774955,
      "keywords": [
        "sql",
        "web",
        "article",
        "extract",
        "development",
        "information",
        "react"
      ]
    },
    "relevance_score": 0.7672000000000002,
    "chunks": [
      {
        "content": "How to Structure and Organize a React ApplicationThere is no consensus on the right way to organize a React application. React gives you a lot of freedom, but with that freedom comes the responsibility of deciding on your own architecture. Often the case is that whoever sets up the application in the beginning throws almost everything in acomponentsfolder, or maybecomponentsandcontainersif they used Redux, but I propose there's a better way. I like to be deliberate about how I organize my applications so they're easy to use, understand, and extend.I'm going to show you what I consider to be an intuitive and scalable system for large-scale production React applications. The main concept I think is important is to make the architecture focused onfeatureas opposed totype, organizing only shared components on a global level and modularized all the other related entities together in the localized view.Tech assumptionsSince this article will be opinionated, I'll make some assumptions about what technology the project will be using:Application-React(Hooks)Global state management-Redux,Redux ToolkitRouting-React RouterStyles-Styled ComponentsTesting-Jest,React Testing LibraryI don't have a very strong opinion about the styling, whether Styled Components or CSS modules or a custom Sass setup is ideal, but I think Styled Components is probably one of the best options for keeping your styles modular.I'm also going to assume the tests are alongside the code, as opposed to in a top-leveltestsfolder. I can go either way with this one, but in order for an example to work, and in the real world, decisions need to be made.Everything here can still apply if you're using vanilla Redux instead of Redux Toolkit. I would recommendsetting up your Redux as feature sliceseither way.I'm also ambivalent aboutStorybook, but I'll include what it would look like with those files if you choose to use it in your project.For the sake of the example, I'll use a \"Library App\" example, that has a page for listing books, a page for listing authors, and has an authentication system.Directory StructureThe top level directory structure will be as follows:assets- global static assets such as images, svgs, company logo, etc.components- global shared/reusable components, such as layout (wrappers, navigation), form components, buttonsservices- JavaScript modulesstore- Global Redux storeutils- Utilities, helpers, constants, and the likeviews- Can also be called \"pages\", the majority of the app would be contained hereI like keeping familiar conventions wherever possible, sosrccontains everything,index.jsis the entry point, andApp.jssets up the auth and routing..\n└── /src\n    ├── /assets\n    ├── /components\n    ├── /services\n    ├── /store\n    ├── /utils\n    ├── /views\n    ├── index.js\n    └── App.jsI can see some additional folders you might have, such astypesif it's a TypeScript project,middlewareif necessary, maybecontextforContext, etc.AliasesI would set up the system to use aliases, so anything within thecomponentsfolder could be imported as@components,assetsas@assets, etc. If you have a custom Webpack, this is done through theresolveconfiguration.module.exports={resolve:{extensions:['js','ts'],alias:{'@':path.resolve(__dirname,'src'),'@assets':path.resolve(__dirname,'src/assets'),'@components':path.resolve(__dirname,'src/components'),// ...etc},},} t just makes it a lot easier to import from anywhere within the project and move files around without changing imports, and you never end up with something like../../../../../components/.ComponentsWithin thecomponentsfolder, I would group by type -forms,tables,buttons,layout, etc. The specifics will vary by your specific app.In this example, I'm assuming you're either creating your own form system, or creating your own bindings to an existing form system (for example, combining Formik and Material UI). In this case, you'd create a folder for each component (TextField,Select,Radio,Dropdown, etc.), and inside would be a file for the component itself, the styles, the tests, and the Storybook if it's being used.Component.js- The actual React componentComponent.styles.js- The Styled Components file for the componentComponent.test.js- The testsComponent.stories.js- The Storybook fileTo me, this makes a lot more sense than having one folder that contains the files for ALL components, one folder that contains all the tests, and one folder that contains all the Storybook files, etc. Everything related is grouped together and easy to find..\n└── /src\n    └── /components\n        ├── /forms\n        │   ├── /TextField\n        │   │   ├── TextField.js\n        │   │   ├── TextField.styles.js\n        │   │   ├── TextField.test.js\n        │   │   └── TextField.stories.js\n        │   ├── /Select\n        │   │   ├── Select.js\n        │   │   ├── Select.styles.js\n        │   │   ├── Select.test.js\n        │   │   └── Select.stories.js\n        │   └── index.js\n        ├── /routing\n        │   └── /PrivateRoute\n        │       ├── /PrivateRoute.js\n        │       └── /PrivateRoute.test.js\n        └── /layout\n            └── /navigation\n                └── /NavBar\n                    ├── NavBar.js\n                    ├── NavBar.styles.js\n                    ├── NavBar.test.js\n                    └── NavBar.stories.jsYou'll notice there's anindex.jsfile in thecomponents/formsdirectory. It is often rightfully suggested to avoid usingindex.jsfiles as they're not explicit, but in this case it makes sense - it will end up being an index of all the forms and look something like this:src/components/forms/index.jsimport{TextField} rom'./TextField/TextField'import{Select} rom'./Select/Select'import{Radio} rom'./Radio/Radio'export{TextField,Select,Radio} hen when you need to use one or more of the components, you can easily import them all at once.import{TextField,Select,Radio} rom'@components/forms'I would recommend this approach more than making anindex.jsinside ofeveryfolder withinforms, so now you just have oneindex.jsthat actually indexes the entire directory, as opposed to tenindex.jsfiles just to make imports easier for each individual file.ServicesTheservicesdirectory is less essential thancomponents, but if you're making a plain JavaScript module that the rest of the application is using, it can be handy. A common contrived example is a LocalStorage module, which might look like this:.\n└── /src\n    └── /services\n        ├── /LocalStorage\n        │   ├── LocalStorage.service.js\n        │   └── LocalStorage.test.js\n        └── index.jsAn example of the service:src/services/LocalStorage/LocalStorage.service.jsexportconstLocalStorage={get(key){},set(key,value){},remove(key){},clear(){},} mport{LocalStorage} rom'@services'LocalStorage.get('foo')StoreThe global data store will be contained in thestoredirectory - in this case, Redux. Each feature will have a folder, which will contain theRedux Toolkitslice, as well as actions and tests. This setup can also be used with regular Redux, you would just create a.reducers.jsfile and.actions.jsfile instead of aslice.",
        "chunk_type": "technical_content",
        "tag": "main",
        "score": 0.9450000000000001,
        "word_count": 902,
        "chunk_id": "868da1e1c72b4aff6a5a3a6a17a17652",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "If you're using sagas, it could be.saga.jsinstead of.actions.jsfor Redux Thunk actions..\n└── /src\n    ├── /store\n    │   ├── /authentication\n    │   │   ├── /authentication.slice.js\n    │   │   ├── /authentication.actions.js\n    │   │   └── /authentication.test.js\n    │   ├── /authors\n    │   │   ├── /authors.slice.js\n    │   │   ├── /authors.actions.js\n    │   │   └── /authors.test.js\n    │   └── /books\n    │       ├── /books.slice.js\n    │       ├── /books.actions.js\n    │       └── /books.test.js\n    ├── rootReducer.js\n    └── index.jsYou can also add something like auisection of the store to handle modals, toasts, sidebar toggling, and other global UI state, which I find better than havingconst [isOpen, setIsOpen] = useState(false)all over the place.In therootReduceryou would import all your slices and combine them withcombineReducers, and inindex.jsyou would configure the store.UtilsWhether or not your project needs autilsfolder is up to you, but I think there are usually some global utility functions, like validation and conversion, that could easily be used across multiple sections of the app. If you keep it organized - not just having onehelpers.jsfile that contains thousands of functions - it could be a helpful addition to the organization of your project..\n└── src\n    └── /utils\n        ├── /constants\n        │   └── countries.constants.js\n        └── /helpers\n            ├── validation.helpers.js\n            ├── currency.helpers.js\n            └── array.helpers.jsAgain, theutilsfolder can contain anything you want that you think makes sense to keep on a global level. If you don't prefer the \"multi-tier\" filenames, you could just call itvalidation.js, but the way I see it, being explicit does not take anything away from the project, and makes it easier to navigate filenames when searching in your IDE.ViewsHere's where the main part of your app will live: in theviewsdirectory. Any page in your app is a \"view\". In this small example, the views line up pretty well with the Redux store, but it won't necessarily be the case that the store and views are exactly the same, which is why they're separate. Also,booksmight pull fromauthors, and so on.Anything within a view is an item that will likely only be used within that specific view - aBookFormthat will only be used at the/booksroute, and anAuthorBlurbthat will only be used on the/authorsroute. It might include specific forms, modals, buttons, any component that won't be global.The advantage of keeping everything domain-focused instead of putting all your pages together incomponents/pagesis that it makes it really easy to look at the structure of the application and know how many top level views there are, and know where everything that's only used by that view is. If there are nested routes, you can always add a nestedviewsfolder within the main route..\n└── /src\n    └── /views\n        ├── /Authors\n        │   ├── /AuthorsPage\n        │   │   ├── AuthorsPage.js\n        │   │   └── AuthorsPage.test.js\n        │   └── /AuthorBlurb\n        │       ├── /AuthorBlurb.js\n        │       └── /AuthorBlurb.test.js\n        ├── /Books\n        │   ├── /BooksPage\n        │   │   ├── BooksPage.js\n        │   │   └── BooksPage.test.js\n        │   └── /BookForm\n        │       ├── /BookForm.js\n        │       └── /BookForm.test.js\n        └── /Login\n            ├── LoginPage\n            │   ├── LoginPage.styles.js\n            │   ├── LoginPage.js\n            │   └── LoginPage.test.js\n            └── LoginForm\n                ├── LoginForm.js\n                └── LoginForm.test.jsKeeping everything within folders might seem annoying if you've never set up your project that way - you can always keep it more flat, or moveteststo its own directory that mimics the rest of the app.ConclusionThis is my proposal for a sytem for React organization that scales well for a large production app, and handles testing and styling as well as keeping everything together in a feature focused way. It's more nested than the traditional structure of everything being incomponentsandcontainers, but that system is a bit more dated due to Redux being much easier to implement with Hooks, and \"smart\" containers and \"dumb\" components no longer being necessary.It's easy to look at this system and understand everything that is needed for your app and where to go to work on a specific section, or a component that affects the app globally. This system may not make sense for every type of app, but it has worked for me. I'd love to hear any comments about ways this system can be improved, or other systems that have merit.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:June 23, 2021Category:TechnicalTagsjavascriptreactNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "main",
        "score": 0.9450000000000001,
        "word_count": 710,
        "chunk_id": "dcae5e9436a953c56de3a1793a5291d4",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "How to Structure and Organize a React ApplicationThere is no consensus on the right way to organize a React application. React gives you a lot of freedom, but with that freedom comes the responsibility of deciding on your own architecture. Often the case is that whoever sets up the application in the beginning throws almost everything in acomponentsfolder, or maybecomponentsandcontainersif they used Redux, but I propose there's a better way. I like to be deliberate about how I organize my applications so they're easy to use, understand, and extend.I'm going to show you what I consider to be an intuitive and scalable system for large-scale production React applications. The main concept I think is important is to make the architecture focused onfeatureas opposed totype, organizing only shared components on a global level and modularized all the other related entities together in the localized view.Tech assumptionsSince this article will be opinionated, I'll make some assumptions about what technology the project will be using:Application-React(Hooks)Global state management-Redux,Redux ToolkitRouting-React RouterStyles-Styled ComponentsTesting-Jest,React Testing LibraryI don't have a very strong opinion about the styling, whether Styled Components or CSS modules or a custom Sass setup is ideal, but I think Styled Components is probably one of the best options for keeping your styles modular.I'm also going to assume the tests are alongside the code, as opposed to in a top-leveltestsfolder. I can go either way with this one, but in order for an example to work, and in the real world, decisions need to be made.Everything here can still apply if you're using vanilla Redux instead of Redux Toolkit. I would recommendsetting up your Redux as feature sliceseither way.I'm also ambivalent aboutStorybook, but I'll include what it would look like with those files if you choose to use it in your project.For the sake of the example, I'll use a \"Library App\" example, that has a page for listing books, a page for listing authors, and has an authentication system.Directory StructureThe top level directory structure will be as follows:assets- global static assets such as images, svgs, company logo, etc.components- global shared/reusable components, such as layout (wrappers, navigation), form components, buttonsservices- JavaScript modulesstore- Global Redux storeutils- Utilities, helpers, constants, and the likeviews- Can also be called \"pages\", the majority of the app would be contained hereI like keeping familiar conventions wherever possible, sosrccontains everything,index.jsis the entry point, andApp.jssets up the auth and routing..\n└── /src\n    ├── /assets\n    ├── /components\n    ├── /services\n    ├── /store\n    ├── /utils\n    ├── /views\n    ├── index.js\n    └── App.jsI can see some additional folders you might have, such astypesif it's a TypeScript project,middlewareif necessary, maybecontextforContext, etc.AliasesI would set up the system to use aliases, so anything within thecomponentsfolder could be imported as@components,assetsas@assets, etc. If you have a custom Webpack, this is done through theresolveconfiguration.module.exports={resolve:{extensions:['js','ts'],alias:{'@':path.resolve(__dirname,'src'),'@assets':path.resolve(__dirname,'src/assets'),'@components':path.resolve(__dirname,'src/components'),// ...etc},},} t just makes it a lot easier to import from anywhere within the project and move files around without changing imports, and you never end up with something like../../../../../components/.ComponentsWithin thecomponentsfolder, I would group by type -forms,tables,buttons,layout, etc. The specifics will vary by your specific app.In this example, I'm assuming you're either creating your own form system, or creating your own bindings to an existing form system (for example, combining Formik and Material UI). In this case, you'd create a folder for each component (TextField,Select,Radio,Dropdown, etc.), and inside would be a file for the component itself, the styles, the tests, and the Storybook if it's being used.Component.js- The actual React componentComponent.styles.js- The Styled Components file for the componentComponent.test.js- The testsComponent.stories.js- The Storybook fileTo me, this makes a lot more sense than having one folder that contains the files for ALL components, one folder that contains all the tests, and one folder that contains all the Storybook files, etc. Everything related is grouped together and easy to find..\n└── /src\n    └── /components\n        ├── /forms\n        │   ├── /TextField\n        │   │   ├── TextField.js\n        │   │   ├── TextField.styles.js\n        │   │   ├── TextField.test.js\n        │   │   └── TextField.stories.js\n        │   ├── /Select\n        │   │   ├── Select.js\n        │   │   ├── Select.styles.js\n        │   │   ├── Select.test.js\n        │   │   └── Select.stories.js\n        │   └── index.js\n        ├── /routing\n        │   └── /PrivateRoute\n        │       ├── /PrivateRoute.js\n        │       └── /PrivateRoute.test.js\n        └── /layout\n            └── /navigation\n                └── /NavBar\n                    ├── NavBar.js\n                    ├── NavBar.styles.js\n                    ├── NavBar.test.js\n                    └── NavBar.stories.jsYou'll notice there's anindex.jsfile in thecomponents/formsdirectory. It is often rightfully suggested to avoid usingindex.jsfiles as they're not explicit, but in this case it makes sense - it will end up being an index of all the forms and look something like this:src/components/forms/index.jsimport{TextField} rom'./TextField/TextField'import{Select} rom'./Select/Select'import{Radio} rom'./Radio/Radio'export{TextField,Select,Radio} hen when you need to use one or more of the components, you can easily import them all at once.import{TextField,Select,Radio} rom'@components/forms'I would recommend this approach more than making anindex.jsinside ofeveryfolder withinforms, so now you just have oneindex.jsthat actually indexes the entire directory, as opposed to tenindex.jsfiles just to make imports easier for each individual file.ServicesTheservicesdirectory is less essential thancomponents, but if you're making a plain JavaScript module that the rest of the application is using, it can be handy. A common contrived example is a LocalStorage module, which might look like this:.\n└── /src\n    └── /services\n        ├── /LocalStorage\n        │   ├── LocalStorage.service.js\n        │   └── LocalStorage.test.js\n        └── index.jsAn example of the service:src/services/LocalStorage/LocalStorage.service.jsexportconstLocalStorage={get(key){},set(key,value){},remove(key){},clear(){},} mport{LocalStorage} rom'@services'LocalStorage.get('foo')StoreThe global data store will be contained in thestoredirectory - in this case, Redux. Each feature will have a folder, which will contain theRedux Toolkitslice, as well as actions and tests. This setup can also be used with regular Redux, you would just create a.reducers.jsfile and.actions.jsfile instead of aslice.",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.9450000000000001,
        "word_count": 902,
        "chunk_id": "868da1e1c72b4aff6a5a3a6a17a17652",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "If you're using sagas, it could be.saga.jsinstead of.actions.jsfor Redux Thunk actions..\n└── /src\n    ├── /store\n    │   ├── /authentication\n    │   │   ├── /authentication.slice.js\n    │   │   ├── /authentication.actions.js\n    │   │   └── /authentication.test.js\n    │   ├── /authors\n    │   │   ├── /authors.slice.js\n    │   │   ├── /authors.actions.js\n    │   │   └── /authors.test.js\n    │   └── /books\n    │       ├── /books.slice.js\n    │       ├── /books.actions.js\n    │       └── /books.test.js\n    ├── rootReducer.js\n    └── index.jsYou can also add something like auisection of the store to handle modals, toasts, sidebar toggling, and other global UI state, which I find better than havingconst [isOpen, setIsOpen] = useState(false)all over the place.In therootReduceryou would import all your slices and combine them withcombineReducers, and inindex.jsyou would configure the store.UtilsWhether or not your project needs autilsfolder is up to you, but I think there are usually some global utility functions, like validation and conversion, that could easily be used across multiple sections of the app. If you keep it organized - not just having onehelpers.jsfile that contains thousands of functions - it could be a helpful addition to the organization of your project..\n└── src\n    └── /utils\n        ├── /constants\n        │   └── countries.constants.js\n        └── /helpers\n            ├── validation.helpers.js\n            ├── currency.helpers.js\n            └── array.helpers.jsAgain, theutilsfolder can contain anything you want that you think makes sense to keep on a global level. If you don't prefer the \"multi-tier\" filenames, you could just call itvalidation.js, but the way I see it, being explicit does not take anything away from the project, and makes it easier to navigate filenames when searching in your IDE.ViewsHere's where the main part of your app will live: in theviewsdirectory. Any page in your app is a \"view\". In this small example, the views line up pretty well with the Redux store, but it won't necessarily be the case that the store and views are exactly the same, which is why they're separate. Also,booksmight pull fromauthors, and so on.Anything within a view is an item that will likely only be used within that specific view - aBookFormthat will only be used at the/booksroute, and anAuthorBlurbthat will only be used on the/authorsroute. It might include specific forms, modals, buttons, any component that won't be global.The advantage of keeping everything domain-focused instead of putting all your pages together incomponents/pagesis that it makes it really easy to look at the structure of the application and know how many top level views there are, and know where everything that's only used by that view is. If there are nested routes, you can always add a nestedviewsfolder within the main route..\n└── /src\n    └── /views\n        ├── /Authors\n        │   ├── /AuthorsPage\n        │   │   ├── AuthorsPage.js\n        │   │   └── AuthorsPage.test.js\n        │   └── /AuthorBlurb\n        │       ├── /AuthorBlurb.js\n        │       └── /AuthorBlurb.test.js\n        ├── /Books\n        │   ├── /BooksPage\n        │   │   ├── BooksPage.js\n        │   │   └── BooksPage.test.js\n        │   └── /BookForm\n        │       ├── /BookForm.js\n        │       └── /BookForm.test.js\n        └── /Login\n            ├── LoginPage\n            │   ├── LoginPage.styles.js\n            │   ├── LoginPage.js\n            │   └── LoginPage.test.js\n            └── LoginForm\n                ├── LoginForm.js\n                └── LoginForm.test.jsKeeping everything within folders might seem annoying if you've never set up your project that way - you can always keep it more flat, or moveteststo its own directory that mimics the rest of the app.ConclusionThis is my proposal for a sytem for React organization that scales well for a large production app, and handles testing and styling as well as keeping everything together in a feature focused way. It's more nested than the traditional structure of everything being incomponentsandcontainers, but that system is a bit more dated due to Redux being much easier to implement with Hooks, and \"smart\" containers and \"dumb\" components no longer being necessary.It's easy to look at this system and understand everything that is needed for your app and where to go to work on a specific section, or a component that affects the app globally. This system may not make sense for every type of app, but it has worked for me. I'd love to hear any comments about ways this system can be improved, or other systems that have merit.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:June 23, 2021Category:TechnicalTagsjavascriptreactNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.9450000000000001,
        "word_count": 710,
        "chunk_id": "dcae5e9436a953c56de3a1793a5291d4",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "How to Structure and Organize a React ApplicationThere is no consensus on the right way to organize a React application. React gives you a lot of freedom, but with that freedom comes the responsibility of deciding on your own architecture. Often the case is that whoever sets up the application in the beginning throws almost everything in acomponentsfolder, or maybecomponentsandcontainersif they used Redux, but I propose there's a better way. I like to be deliberate about how I organize my applications so they're easy to use, understand, and extend.I'm going to show you what I consider to be an intuitive and scalable system for large-scale production React applications. The main concept I think is important is to make the architecture focused onfeatureas opposed totype, organizing only shared components on a global level and modularized all the other related entities together in the localized view.Tech assumptionsSince this article will be opinionated, I'll make some assumptions about what technology the project will be using:Application-React(Hooks)Global state management-Redux,Redux ToolkitRouting-React RouterStyles-Styled ComponentsTesting-Jest,React Testing LibraryI don't have a very strong opinion about the styling, whether Styled Components or CSS modules or a custom Sass setup is ideal, but I think Styled Components is probably one of the best options for keeping your styles modular.I'm also going to assume the tests are alongside the code, as opposed to in a top-leveltestsfolder. I can go either way with this one, but in order for an example to work, and in the real world, decisions need to be made.Everything here can still apply if you're using vanilla Redux instead of Redux Toolkit. I would recommendsetting up your Redux as feature sliceseither way.I'm also ambivalent aboutStorybook, but I'll include what it would look like with those files if you choose to use it in your project.For the sake of the example, I'll use a \"Library App\" example, that has a page for listing books, a page for listing authors, and has an authentication system.Directory StructureThe top level directory structure will be as follows:assets- global static assets such as images, svgs, company logo, etc.components- global shared/reusable components, such as layout (wrappers, navigation), form components, buttonsservices- JavaScript modulesstore- Global Redux storeutils- Utilities, helpers, constants, and the likeviews- Can also be called \"pages\", the majority of the app would be contained hereI like keeping familiar conventions wherever possible, sosrccontains everything,index.jsis the entry point, andApp.jssets up the auth and routing..\n└── /src\n    ├── /assets\n    ├── /components\n    ├── /services\n    ├── /store\n    ├── /utils\n    ├── /views\n    ├── index.js\n    └── App.jsI can see some additional folders you might have, such astypesif it's a TypeScript project,middlewareif necessary, maybecontextforContext, etc.AliasesI would set up the system to use aliases, so anything within thecomponentsfolder could be imported as@components,assetsas@assets, etc. If you have a custom Webpack, this is done through theresolveconfiguration.module.exports={resolve:{extensions:['js','ts'],alias:{'@':path.resolve(__dirname,'src'),'@assets':path.resolve(__dirname,'src/assets'),'@components':path.resolve(__dirname,'src/components'),// ...etc},},} t just makes it a lot easier to import from anywhere within the project and move files around without changing imports, and you never end up with something like../../../../../components/.ComponentsWithin thecomponentsfolder, I would group by type -forms,tables,buttons,layout, etc. The specifics will vary by your specific app.In this example, I'm assuming you're either creating your own form system, or creating your own bindings to an existing form system (for example, combining Formik and Material UI). In this case, you'd create a folder for each component (TextField,Select,Radio,Dropdown, etc.), and inside would be a file for the component itself, the styles, the tests, and the Storybook if it's being used.Component.js- The actual React componentComponent.styles.js- The Styled Components file for the componentComponent.test.js- The testsComponent.stories.js- The Storybook fileTo me, this makes a lot more sense than having one folder that contains the files for ALL components, one folder that contains all the tests, and one folder that contains all the Storybook files, etc. Everything related is grouped together and easy to find..\n└── /src\n    └── /components\n        ├── /forms\n        │   ├── /TextField\n        │   │   ├── TextField.js\n        │   │   ├── TextField.styles.js\n        │   │   ├── TextField.test.js\n        │   │   └── TextField.stories.js\n        │   ├── /Select\n        │   │   ├── Select.js\n        │   │   ├── Select.styles.js\n        │   │   ├── Select.test.js\n        │   │   └── Select.stories.js\n        │   └── index.js\n        ├── /routing\n        │   └── /PrivateRoute\n        │       ├── /PrivateRoute.js\n        │       └── /PrivateRoute.test.js\n        └── /layout\n            └── /navigation\n                └── /NavBar\n                    ├── NavBar.js\n                    ├── NavBar.styles.js\n                    ├── NavBar.test.js\n                    └── NavBar.stories.jsYou'll notice there's anindex.jsfile in thecomponents/formsdirectory. It is often rightfully suggested to avoid usingindex.jsfiles as they're not explicit, but in this case it makes sense - it will end up being an index of all the forms and look something like this:src/components/forms/index.jsimport{TextField} rom'./TextField/TextField'import{Select} rom'./Select/Select'import{Radio} rom'./Radio/Radio'export{TextField,Select,Radio} hen when you need to use one or more of the components, you can easily import them all at once.import{TextField,Select,Radio} rom'@components/forms'I would recommend this approach more than making anindex.jsinside ofeveryfolder withinforms, so now you just have oneindex.jsthat actually indexes the entire directory, as opposed to tenindex.jsfiles just to make imports easier for each individual file.ServicesTheservicesdirectory is less essential thancomponents, but if you're making a plain JavaScript module that the rest of the application is using, it can be handy. A common contrived example is a LocalStorage module, which might look like this:.\n└── /src\n    └── /services\n        ├── /LocalStorage\n        │   ├── LocalStorage.service.js\n        │   └── LocalStorage.test.js\n        └── index.jsAn example of the service:src/services/LocalStorage/LocalStorage.service.jsexportconstLocalStorage={get(key){},set(key,value){},remove(key){},clear(){},} mport{LocalStorage} rom'@services'LocalStorage.get('foo')StoreThe global data store will be contained in thestoredirectory - in this case, Redux. Each feature will have a folder, which will contain theRedux Toolkitslice, as well as actions and tests. This setup can also be used with regular Redux, you would just create a.reducers.jsfile and.actions.jsfile instead of aslice.",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.9450000000000001,
        "word_count": 902,
        "chunk_id": "868da1e1c72b4aff6a5a3a6a17a17652",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "If you're using sagas, it could be.saga.jsinstead of.actions.jsfor Redux Thunk actions..\n└── /src\n    ├── /store\n    │   ├── /authentication\n    │   │   ├── /authentication.slice.js\n    │   │   ├── /authentication.actions.js\n    │   │   └── /authentication.test.js\n    │   ├── /authors\n    │   │   ├── /authors.slice.js\n    │   │   ├── /authors.actions.js\n    │   │   └── /authors.test.js\n    │   └── /books\n    │       ├── /books.slice.js\n    │       ├── /books.actions.js\n    │       └── /books.test.js\n    ├── rootReducer.js\n    └── index.jsYou can also add something like auisection of the store to handle modals, toasts, sidebar toggling, and other global UI state, which I find better than havingconst [isOpen, setIsOpen] = useState(false)all over the place.In therootReduceryou would import all your slices and combine them withcombineReducers, and inindex.jsyou would configure the store.UtilsWhether or not your project needs autilsfolder is up to you, but I think there are usually some global utility functions, like validation and conversion, that could easily be used across multiple sections of the app. If you keep it organized - not just having onehelpers.jsfile that contains thousands of functions - it could be a helpful addition to the organization of your project..\n└── src\n    └── /utils\n        ├── /constants\n        │   └── countries.constants.js\n        └── /helpers\n            ├── validation.helpers.js\n            ├── currency.helpers.js\n            └── array.helpers.jsAgain, theutilsfolder can contain anything you want that you think makes sense to keep on a global level. If you don't prefer the \"multi-tier\" filenames, you could just call itvalidation.js, but the way I see it, being explicit does not take anything away from the project, and makes it easier to navigate filenames when searching in your IDE.ViewsHere's where the main part of your app will live: in theviewsdirectory. Any page in your app is a \"view\". In this small example, the views line up pretty well with the Redux store, but it won't necessarily be the case that the store and views are exactly the same, which is why they're separate. Also,booksmight pull fromauthors, and so on.Anything within a view is an item that will likely only be used within that specific view - aBookFormthat will only be used at the/booksroute, and anAuthorBlurbthat will only be used on the/authorsroute. It might include specific forms, modals, buttons, any component that won't be global.The advantage of keeping everything domain-focused instead of putting all your pages together incomponents/pagesis that it makes it really easy to look at the structure of the application and know how many top level views there are, and know where everything that's only used by that view is. If there are nested routes, you can always add a nestedviewsfolder within the main route..\n└── /src\n    └── /views\n        ├── /Authors\n        │   ├── /AuthorsPage\n        │   │   ├── AuthorsPage.js\n        │   │   └── AuthorsPage.test.js\n        │   └── /AuthorBlurb\n        │       ├── /AuthorBlurb.js\n        │       └── /AuthorBlurb.test.js\n        ├── /Books\n        │   ├── /BooksPage\n        │   │   ├── BooksPage.js\n        │   │   └── BooksPage.test.js\n        │   └── /BookForm\n        │       ├── /BookForm.js\n        │       └── /BookForm.test.js\n        └── /Login\n            ├── LoginPage\n            │   ├── LoginPage.styles.js\n            │   ├── LoginPage.js\n            │   └── LoginPage.test.js\n            └── LoginForm\n                ├── LoginForm.js\n                └── LoginForm.test.jsKeeping everything within folders might seem annoying if you've never set up your project that way - you can always keep it more flat, or moveteststo its own directory that mimics the rest of the app.ConclusionThis is my proposal for a sytem for React organization that scales well for a large production app, and handles testing and styling as well as keeping everything together in a feature focused way. It's more nested than the traditional structure of everything being incomponentsandcontainers, but that system is a bit more dated due to Redux being much easier to implement with Hooks, and \"smart\" containers and \"dumb\" components no longer being necessary.It's easy to look at this system and understand everything that is needed for your app and where to go to work on a specific section, or a component that affects the app globally. This system may not make sense for every type of app, but it has worked for me. I'd love to hear any comments about ways this system can be improved, or other systems that have merit.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:June 23, 2021Category:TechnicalTagsjavascriptreactNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.9450000000000001,
        "word_count": 710,
        "chunk_id": "dcae5e9436a953c56de3a1793a5291d4",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "How to Structure and Organize a React ApplicationThere is no consensus on the right way to organize a React application. React gives you a lot of freedom, but with that freedom comes the responsibility of deciding on your own architecture. Often the case is that whoever sets up the application in the beginning throws almost everything in acomponentsfolder, or maybecomponentsandcontainersif they used Redux, but I propose there's a better way. I like to be deliberate about how I organize my applications so they're easy to use, understand, and extend.I'm going to show you what I consider to be an intuitive and scalable system for large-scale production React applications. The main concept I think is important is to make the architecture focused onfeatureas opposed totype, organizing only shared components on a global level and modularized all the other related entities together in the localized view.Tech assumptionsSince this article will be opinionated, I'll make some assumptions about what technology the project will be using:Application-React(Hooks)Global state management-Redux,Redux ToolkitRouting-React RouterStyles-Styled ComponentsTesting-Jest,React Testing LibraryI don't have a very strong opinion about the styling, whether Styled Components or CSS modules or a custom Sass setup is ideal, but I think Styled Components is probably one of the best options for keeping your styles modular.I'm also going to assume the tests are alongside the code, as opposed to in a top-leveltestsfolder. I can go either way with this one, but in order for an example to work, and in the real world, decisions need to be made.Everything here can still apply if you're using vanilla Redux instead of Redux Toolkit. I would recommendsetting up your Redux as feature sliceseither way.I'm also ambivalent aboutStorybook, but I'll include what it would look like with those files if you choose to use it in your project.For the sake of the example, I'll use a \"Library App\" example, that has a page for listing books, a page for listing authors, and has an authentication system.Directory StructureThe top level directory structure will be as follows:assets- global static assets such as images, svgs, company logo, etc.components- global shared/reusable components, such as layout (wrappers, navigation), form components, buttonsservices- JavaScript modulesstore- Global Redux storeutils- Utilities, helpers, constants, and the likeviews- Can also be called \"pages\", the majority of the app would be contained hereI like keeping familiar conventions wherever possible, sosrccontains everything,index.jsis the entry point, andApp.jssets up the auth and routing..\n└── /src\n    ├── /assets\n    ├── /components\n    ├── /services\n    ├── /store\n    ├── /utils\n    ├── /views\n    ├── index.js\n    └── App.jsI can see some additional folders you might have, such astypesif it's a TypeScript project,middlewareif necessary, maybecontextforContext, etc.AliasesI would set up the system to use aliases, so anything within thecomponentsfolder could be imported as@components,assetsas@assets, etc. If you have a custom Webpack, this is done through theresolveconfiguration.module.exports={resolve:{extensions:['js','ts'],alias:{'@':path.resolve(__dirname,'src'),'@assets':path.resolve(__dirname,'src/assets'),'@components':path.resolve(__dirname,'src/components'),// ...etc},},} t just makes it a lot easier to import from anywhere within the project and move files around without changing imports, and you never end up with something like../../../../../components/.ComponentsWithin thecomponentsfolder, I would group by type -forms,tables,buttons,layout, etc. The specifics will vary by your specific app.In this example, I'm assuming you're either creating your own form system, or creating your own bindings to an existing form system (for example, combining Formik and Material UI). In this case, you'd create a folder for each component (TextField,Select,Radio,Dropdown, etc.), and inside would be a file for the component itself, the styles, the tests, and the Storybook if it's being used.Component.js- The actual React componentComponent.styles.js- The Styled Components file for the componentComponent.test.js- The testsComponent.stories.js- The Storybook fileTo me, this makes a lot more sense than having one folder that contains the files for ALL components, one folder that contains all the tests, and one folder that contains all the Storybook files, etc. Everything related is grouped together and easy to find..\n└── /src\n    └── /components\n        ├── /forms\n        │   ├── /TextField\n        │   │   ├── TextField.js\n        │   │   ├── TextField.styles.js\n        │   │   ├── TextField.test.js\n        │   │   └── TextField.stories.js\n        │   ├── /Select\n        │   │   ├── Select.js\n        │   │   ├── Select.styles.js\n        │   │   ├── Select.test.js\n        │   │   └── Select.stories.js\n        │   └── index.js\n        ├── /routing\n        │   └── /PrivateRoute\n        │       ├── /PrivateRoute.js\n        │       └── /PrivateRoute.test.js\n        └── /layout\n            └── /navigation\n                └── /NavBar\n                    ├── NavBar.js\n                    ├── NavBar.styles.js\n                    ├── NavBar.test.js\n                    └── NavBar.stories.jsYou'll notice there's anindex.jsfile in thecomponents/formsdirectory. It is often rightfully suggested to avoid usingindex.jsfiles as they're not explicit, but in this case it makes sense - it will end up being an index of all the forms and look something like this:src/components/forms/index.jsimport{TextField} rom'./TextField/TextField'import{Select} rom'./Select/Select'import{Radio} rom'./Radio/Radio'export{TextField,Select,Radio} hen when you need to use one or more of the components, you can easily import them all at once.import{TextField,Select,Radio} rom'@components/forms'I would recommend this approach more than making anindex.jsinside ofeveryfolder withinforms, so now you just have oneindex.jsthat actually indexes the entire directory, as opposed to tenindex.jsfiles just to make imports easier for each individual file.ServicesTheservicesdirectory is less essential thancomponents, but if you're making a plain JavaScript module that the rest of the application is using, it can be handy. A common contrived example is a LocalStorage module, which might look like this:.\n└── /src\n    └── /services\n        ├── /LocalStorage\n        │   ├── LocalStorage.service.js\n        │   └── LocalStorage.test.js\n        └── index.jsAn example of the service:src/services/LocalStorage/LocalStorage.service.jsexportconstLocalStorage={get(key){},set(key,value){},remove(key){},clear(){},} mport{LocalStorage} rom'@services'LocalStorage.get('foo')StoreThe global data store will be contained in thestoredirectory - in this case, Redux. Each feature will have a folder, which will contain theRedux Toolkitslice, as well as actions and tests. This setup can also be used with regular Redux, you would just create a.reducers.jsfile and.actions.jsfile instead of aslice.",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.9450000000000001,
        "word_count": 902,
        "chunk_id": "868da1e1c72b4aff6a5a3a6a17a17652",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "If you're using sagas, it could be.saga.jsinstead of.actions.jsfor Redux Thunk actions..\n└── /src\n    ├── /store\n    │   ├── /authentication\n    │   │   ├── /authentication.slice.js\n    │   │   ├── /authentication.actions.js\n    │   │   └── /authentication.test.js\n    │   ├── /authors\n    │   │   ├── /authors.slice.js\n    │   │   ├── /authors.actions.js\n    │   │   └── /authors.test.js\n    │   └── /books\n    │       ├── /books.slice.js\n    │       ├── /books.actions.js\n    │       └── /books.test.js\n    ├── rootReducer.js\n    └── index.jsYou can also add something like auisection of the store to handle modals, toasts, sidebar toggling, and other global UI state, which I find better than havingconst [isOpen, setIsOpen] = useState(false)all over the place.In therootReduceryou would import all your slices and combine them withcombineReducers, and inindex.jsyou would configure the store.UtilsWhether or not your project needs autilsfolder is up to you, but I think there are usually some global utility functions, like validation and conversion, that could easily be used across multiple sections of the app. If you keep it organized - not just having onehelpers.jsfile that contains thousands of functions - it could be a helpful addition to the organization of your project..\n└── src\n    └── /utils\n        ├── /constants\n        │   └── countries.constants.js\n        └── /helpers\n            ├── validation.helpers.js\n            ├── currency.helpers.js\n            └── array.helpers.jsAgain, theutilsfolder can contain anything you want that you think makes sense to keep on a global level. If you don't prefer the \"multi-tier\" filenames, you could just call itvalidation.js, but the way I see it, being explicit does not take anything away from the project, and makes it easier to navigate filenames when searching in your IDE.ViewsHere's where the main part of your app will live: in theviewsdirectory. Any page in your app is a \"view\". In this small example, the views line up pretty well with the Redux store, but it won't necessarily be the case that the store and views are exactly the same, which is why they're separate. Also,booksmight pull fromauthors, and so on.Anything within a view is an item that will likely only be used within that specific view - aBookFormthat will only be used at the/booksroute, and anAuthorBlurbthat will only be used on the/authorsroute. It might include specific forms, modals, buttons, any component that won't be global.The advantage of keeping everything domain-focused instead of putting all your pages together incomponents/pagesis that it makes it really easy to look at the structure of the application and know how many top level views there are, and know where everything that's only used by that view is. If there are nested routes, you can always add a nestedviewsfolder within the main route..\n└── /src\n    └── /views\n        ├── /Authors\n        │   ├── /AuthorsPage\n        │   │   ├── AuthorsPage.js\n        │   │   └── AuthorsPage.test.js\n        │   └── /AuthorBlurb\n        │       ├── /AuthorBlurb.js\n        │       └── /AuthorBlurb.test.js\n        ├── /Books\n        │   ├── /BooksPage\n        │   │   ├── BooksPage.js\n        │   │   └── BooksPage.test.js\n        │   └── /BookForm\n        │       ├── /BookForm.js\n        │       └── /BookForm.test.js\n        └── /Login\n            ├── LoginPage\n            │   ├── LoginPage.styles.js\n            │   ├── LoginPage.js\n            │   └── LoginPage.test.js\n            └── LoginForm\n                ├── LoginForm.js\n                └── LoginForm.test.jsKeeping everything within folders might seem annoying if you've never set up your project that way - you can always keep it more flat, or moveteststo its own directory that mimics the rest of the app.ConclusionThis is my proposal for a sytem for React organization that scales well for a large production app, and handles testing and styling as well as keeping everything together in a feature focused way. It's more nested than the traditional structure of everything being incomponentsandcontainers, but that system is a bit more dated due to Redux being much easier to implement with Hooks, and \"smart\" containers and \"dumb\" components no longer being necessary.It's easy to look at this system and understand everything that is needed for your app and where to go to work on a specific section, or a component that affects the app globally. This system may not make sense for every type of app, but it has worked for me. I'd love to hear any comments about ways this system can be improved, or other systems that have merit.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:June 23, 2021Category:TechnicalTagsjavascriptreactNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.9450000000000001,
        "word_count": 710,
        "chunk_id": "dcae5e9436a953c56de3a1793a5291d4",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "How to Structure and Organize a React ApplicationThere is no consensus on the right way to organize a React application. React gives you a lot of freedom, but with that freedom comes the responsibility of deciding on your own architecture. Often the case is that whoever sets up the application in the beginning throws almost everything in acomponentsfolder, or maybecomponentsandcontainersif they used Redux, but I propose there's a better way. I like to be deliberate about how I organize my applications so they're easy to use, understand, and extend.I'm going to show you what I consider to be an intuitive and scalable system for large-scale production React applications. The main concept I think is important is to make the architecture focused onfeatureas opposed totype, organizing only shared components on a global level and modularized all the other related entities together in the localized view.Tech assumptionsSince this article will be opinionated, I'll make some assumptions about what technology the project will be using:Application-React(Hooks)Global state management-Redux,Redux ToolkitRouting-React RouterStyles-Styled ComponentsTesting-Jest,React Testing LibraryI don't have a very strong opinion about the styling, whether Styled Components or CSS modules or a custom Sass setup is ideal, but I think Styled Components is probably one of the best options for keeping your styles modular.I'm also going to assume the tests are alongside the code, as opposed to in a top-leveltestsfolder. I can go either way with this one, but in order for an example to work, and in the real world, decisions need to be made.Everything here can still apply if you're using vanilla Redux instead of Redux Toolkit. I would recommendsetting up your Redux as feature sliceseither way.I'm also ambivalent aboutStorybook, but I'll include what it would look like with those files if you choose to use it in your project.For the sake of the example, I'll use a \"Library App\" example, that has a page for listing books, a page for listing authors, and has an authentication system.Directory StructureThe top level directory structure will be as follows:assets- global static assets such as images, svgs, company logo, etc.components- global shared/reusable components, such as layout (wrappers, navigation), form components, buttonsservices- JavaScript modulesstore- Global Redux storeutils- Utilities, helpers, constants, and the likeviews- Can also be called \"pages\", the majority of the app would be contained hereI like keeping familiar conventions wherever possible, sosrccontains everything,index.jsis the entry point, andApp.jssets up the auth and routing..\n└── /src\n    ├── /assets\n    ├── /components\n    ├── /services\n    ├── /store\n    ├── /utils\n    ├── /views\n    ├── index.js\n    └── App.jsI can see some additional folders you might have, such astypesif it's a TypeScript project,middlewareif necessary, maybecontextforContext, etc.AliasesI would set up the system to use aliases, so anything within thecomponentsfolder could be imported as@components,assetsas@assets, etc. If you have a custom Webpack, this is done through theresolveconfiguration.module.exports={resolve:{extensions:['js','ts'],alias:{'@':path.resolve(__dirname,'src'),'@assets':path.resolve(__dirname,'src/assets'),'@components':path.resolve(__dirname,'src/components'),// ...etc},},} t just makes it a lot easier to import from anywhere within the project and move files around without changing imports, and you never end up with something like../../../../../components/.ComponentsWithin thecomponentsfolder, I would group by type -forms,tables,buttons,layout, etc. The specifics will vary by your specific app.In this example, I'm assuming you're either creating your own form system, or creating your own bindings to an existing form system (for example, combining Formik and Material UI). In this case, you'd create a folder for each component (TextField,Select,Radio,Dropdown, etc.), and inside would be a file for the component itself, the styles, the tests, and the Storybook if it's being used.Component.js- The actual React componentComponent.styles.js- The Styled Components file for the componentComponent.test.js- The testsComponent.stories.js- The Storybook fileTo me, this makes a lot more sense than having one folder that contains the files for ALL components, one folder that contains all the tests, and one folder that contains all the Storybook files, etc. Everything related is grouped together and easy to find..\n└── /src\n    └── /components\n        ├── /forms\n        │   ├── /TextField\n        │   │   ├── TextField.js\n        │   │   ├── TextField.styles.js\n        │   │   ├── TextField.test.js\n        │   │   └── TextField.stories.js\n        │   ├── /Select\n        │   │   ├── Select.js\n        │   │   ├── Select.styles.js\n        │   │   ├── Select.test.js\n        │   │   └── Select.stories.js\n        │   └── index.js\n        ├── /routing\n        │   └── /PrivateRoute\n        │       ├── /PrivateRoute.js\n        │       └── /PrivateRoute.test.js\n        └── /layout\n            └── /navigation\n                └── /NavBar\n                    ├── NavBar.js\n                    ├── NavBar.styles.js\n                    ├── NavBar.test.js\n                    └── NavBar.stories.jsYou'll notice there's anindex.jsfile in thecomponents/formsdirectory. It is often rightfully suggested to avoid usingindex.jsfiles as they're not explicit, but in this case it makes sense - it will end up being an index of all the forms and look something like this:src/components/forms/index.jsimport{TextField} rom'./TextField/TextField'import{Select} rom'./Select/Select'import{Radio} rom'./Radio/Radio'export{TextField,Select,Radio} hen when you need to use one or more of the components, you can easily import them all at once.import{TextField,Select,Radio} rom'@components/forms'I would recommend this approach more than making anindex.jsinside ofeveryfolder withinforms, so now you just have oneindex.jsthat actually indexes the entire directory, as opposed to tenindex.jsfiles just to make imports easier for each individual file.ServicesTheservicesdirectory is less essential thancomponents, but if you're making a plain JavaScript module that the rest of the application is using, it can be handy. A common contrived example is a LocalStorage module, which might look like this:.\n└── /src\n    └── /services\n        ├── /LocalStorage\n        │   ├── LocalStorage.service.js\n        │   └── LocalStorage.test.js\n        └── index.jsAn example of the service:src/services/LocalStorage/LocalStorage.service.jsexportconstLocalStorage={get(key){},set(key,value){},remove(key){},clear(){},} mport{LocalStorage} rom'@services'LocalStorage.get('foo')StoreThe global data store will be contained in thestoredirectory - in this case, Redux. Each feature will have a folder, which will contain theRedux Toolkitslice, as well as actions and tests. This setup can also be used with regular Redux, you would just create a.reducers.jsfile and.actions.jsfile instead of aslice.",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.9450000000000001,
        "word_count": 902,
        "chunk_id": "868da1e1c72b4aff6a5a3a6a17a17652",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "If you're using sagas, it could be.saga.jsinstead of.actions.jsfor Redux Thunk actions..\n└── /src\n    ├── /store\n    │   ├── /authentication\n    │   │   ├── /authentication.slice.js\n    │   │   ├── /authentication.actions.js\n    │   │   └── /authentication.test.js\n    │   ├── /authors\n    │   │   ├── /authors.slice.js\n    │   │   ├── /authors.actions.js\n    │   │   └── /authors.test.js\n    │   └── /books\n    │       ├── /books.slice.js\n    │       ├── /books.actions.js\n    │       └── /books.test.js\n    ├── rootReducer.js\n    └── index.jsYou can also add something like auisection of the store to handle modals, toasts, sidebar toggling, and other global UI state, which I find better than havingconst [isOpen, setIsOpen] = useState(false)all over the place.In therootReduceryou would import all your slices and combine them withcombineReducers, and inindex.jsyou would configure the store.UtilsWhether or not your project needs autilsfolder is up to you, but I think there are usually some global utility functions, like validation and conversion, that could easily be used across multiple sections of the app. If you keep it organized - not just having onehelpers.jsfile that contains thousands of functions - it could be a helpful addition to the organization of your project..\n└── src\n    └── /utils\n        ├── /constants\n        │   └── countries.constants.js\n        └── /helpers\n            ├── validation.helpers.js\n            ├── currency.helpers.js\n            └── array.helpers.jsAgain, theutilsfolder can contain anything you want that you think makes sense to keep on a global level. If you don't prefer the \"multi-tier\" filenames, you could just call itvalidation.js, but the way I see it, being explicit does not take anything away from the project, and makes it easier to navigate filenames when searching in your IDE.ViewsHere's where the main part of your app will live: in theviewsdirectory. Any page in your app is a \"view\". In this small example, the views line up pretty well with the Redux store, but it won't necessarily be the case that the store and views are exactly the same, which is why they're separate. Also,booksmight pull fromauthors, and so on.Anything within a view is an item that will likely only be used within that specific view - aBookFormthat will only be used at the/booksroute, and anAuthorBlurbthat will only be used on the/authorsroute. It might include specific forms, modals, buttons, any component that won't be global.The advantage of keeping everything domain-focused instead of putting all your pages together incomponents/pagesis that it makes it really easy to look at the structure of the application and know how many top level views there are, and know where everything that's only used by that view is. If there are nested routes, you can always add a nestedviewsfolder within the main route..\n└── /src\n    └── /views\n        ├── /Authors\n        │   ├── /AuthorsPage\n        │   │   ├── AuthorsPage.js\n        │   │   └── AuthorsPage.test.js\n        │   └── /AuthorBlurb\n        │       ├── /AuthorBlurb.js\n        │       └── /AuthorBlurb.test.js\n        ├── /Books\n        │   ├── /BooksPage\n        │   │   ├── BooksPage.js\n        │   │   └── BooksPage.test.js\n        │   └── /BookForm\n        │       ├── /BookForm.js\n        │       └── /BookForm.test.js\n        └── /Login\n            ├── LoginPage\n            │   ├── LoginPage.styles.js\n            │   ├── LoginPage.js\n            │   └── LoginPage.test.js\n            └── LoginForm\n                ├── LoginForm.js\n                └── LoginForm.test.jsKeeping everything within folders might seem annoying if you've never set up your project that way - you can always keep it more flat, or moveteststo its own directory that mimics the rest of the app.ConclusionThis is my proposal for a sytem for React organization that scales well for a large production app, and handles testing and styling as well as keeping everything together in a feature focused way. It's more nested than the traditional structure of everything being incomponentsandcontainers, but that system is a bit more dated due to Redux being much easier to implement with Hooks, and \"smart\" containers and \"dumb\" components no longer being necessary.It's easy to look at this system and understand everything that is needed for your app and where to go to work on a specific section, or a component that affects the app globally. This system may not make sense for every type of app, but it has worked for me. I'd love to hear any comments about ways this system can be improved, or other systems that have merit.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:June 23, 2021Category:TechnicalTagsjavascriptreactNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.9450000000000001,
        "word_count": 710,
        "chunk_id": "dcae5e9436a953c56de3a1793a5291d4",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There is no consensus on the right way to organize a React application. React gives you a lot of freedom, but with that freedom comes the responsibility of deciding on your own architecture. Often the case is that whoever sets up the application in the beginning throws almost everything in acomponentsfolder, or maybecomponentsandcontainersif they used Redux, but I propose there's a better way. I like to be deliberate about how I organize my applications so they're easy to use, understand, and extend.I'm going to show you what I consider to be an intuitive and scalable system for large-scale production React applications. The main concept I think is important is to make the architecture focused onfeatureas opposed totype, organizing only shared components on a global level and modularized all the other related entities together in the localized view.Tech assumptionsSince this article will be opinionated, I'll make some assumptions about what technology the project will be using:Application-React(Hooks)Global state management-Redux,Redux ToolkitRouting-React RouterStyles-Styled ComponentsTesting-Jest,React Testing LibraryI don't have a very strong opinion about the styling, whether Styled Components or CSS modules or a custom Sass setup is ideal, but I think Styled Components is probably one of the best options for keeping your styles modular.I'm also going to assume the tests are alongside the code, as opposed to in a top-leveltestsfolder. I can go either way with this one, but in order for an example to work, and in the real world, decisions need to be made.Everything here can still apply if you're using vanilla Redux instead of Redux Toolkit. I would recommendsetting up your Redux as feature sliceseither way.I'm also ambivalent aboutStorybook, but I'll include what it would look like with those files if you choose to use it in your project.For the sake of the example, I'll use a \"Library App\" example, that has a page for listing books, a page for listing authors, and has an authentication system.Directory StructureThe top level directory structure will be as follows:assets- global static assets such as images, svgs, company logo, etc.components- global shared/reusable components, such as layout (wrappers, navigation), form components, buttonsservices- JavaScript modulesstore- Global Redux storeutils- Utilities, helpers, constants, and the likeviews- Can also be called \"pages\", the majority of the app would be contained hereI like keeping familiar conventions wherever possible, sosrccontains everything,index.jsis the entry point, andApp.jssets up the auth and routing..\n└── /src\n    ├── /assets\n    ├── /components\n    ├── /services\n    ├── /store\n    ├── /utils\n    ├── /views\n    ├── index.js\n    └── App.jsI can see some additional folders you might have, such astypesif it's a TypeScript project,middlewareif necessary, maybecontextforContext, etc.AliasesI would set up the system to use aliases, so anything within thecomponentsfolder could be imported as@components,assetsas@assets, etc. If you have a custom Webpack, this is done through theresolveconfiguration.module.exports={resolve:{extensions:['js','ts'],alias:{'@':path.resolve(__dirname,'src'),'@assets':path.resolve(__dirname,'src/assets'),'@components':path.resolve(__dirname,'src/components'),// ...etc},},} t just makes it a lot easier to import from anywhere within the project and move files around without changing imports, and you never end up with something like../../../../../components/.ComponentsWithin thecomponentsfolder, I would group by type -forms,tables,buttons,layout, etc. The specifics will vary by your specific app.In this example, I'm assuming you're either creating your own form system, or creating your own bindings to an existing form system (for example, combining Formik and Material UI). In this case, you'd create a folder for each component (TextField,Select,Radio,Dropdown, etc.), and inside would be a file for the component itself, the styles, the tests, and the Storybook if it's being used.Component.js- The actual React componentComponent.styles.js- The Styled Components file for the componentComponent.test.js- The testsComponent.stories.js- The Storybook fileTo me, this makes a lot more sense than having one folder that contains the files for ALL components, one folder that contains all the tests, and one folder that contains all the Storybook files, etc. Everything related is grouped together and easy to find..\n└── /src\n    └── /components\n        ├── /forms\n        │   ├── /TextField\n        │   │   ├── TextField.js\n        │   │   ├── TextField.styles.js\n        │   │   ├── TextField.test.js\n        │   │   └── TextField.stories.js\n        │   ├── /Select\n        │   │   ├── Select.js\n        │   │   ├── Select.styles.js\n        │   │   ├── Select.test.js\n        │   │   └── Select.stories.js\n        │   └── index.js\n        ├── /routing\n        │   └── /PrivateRoute\n        │       ├── /PrivateRoute.js\n        │       └── /PrivateRoute.test.js\n        └── /layout\n            └── /navigation\n                └── /NavBar\n                    ├── NavBar.js\n                    ├── NavBar.styles.js\n                    ├── NavBar.test.js\n                    └── NavBar.stories.jsYou'll notice there's anindex.jsfile in thecomponents/formsdirectory. It is often rightfully suggested to avoid usingindex.jsfiles as they're not explicit, but in this case it makes sense - it will end up being an index of all the forms and look something like this:src/components/forms/index.jsimport{TextField} rom'./TextField/TextField'import{Select} rom'./Select/Select'import{Radio} rom'./Radio/Radio'export{TextField,Select,Radio} hen when you need to use one or more of the components, you can easily import them all at once.import{TextField,Select,Radio} rom'@components/forms'I would recommend this approach more than making anindex.jsinside ofeveryfolder withinforms, so now you just have oneindex.jsthat actually indexes the entire directory, as opposed to tenindex.jsfiles just to make imports easier for each individual file.ServicesTheservicesdirectory is less essential thancomponents, but if you're making a plain JavaScript module that the rest of the application is using, it can be handy. A common contrived example is a LocalStorage module, which might look like this:.\n└── /src\n    └── /services\n        ├── /LocalStorage\n        │   ├── LocalStorage.service.js\n        │   └── LocalStorage.test.js\n        └── index.jsAn example of the service:src/services/LocalStorage/LocalStorage.service.jsexportconstLocalStorage={get(key){},set(key,value){},remove(key){},clear(){},} mport{LocalStorage} rom'@services'LocalStorage.get('foo')StoreThe global data store will be contained in thestoredirectory - in this case, Redux. Each feature will have a folder, which will contain theRedux Toolkitslice, as well as actions and tests. This setup can also be used with regular Redux, you would just create a.reducers.jsfile and.actions.jsfile instead of aslice.",
        "chunk_type": "technical_content",
        "tag": "section",
        "score": 0.9450000000000001,
        "word_count": 895,
        "chunk_id": "dc01d48e25930e1dd43bed11c795bc28",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "If you're using sagas, it could be.saga.jsinstead of.actions.jsfor Redux Thunk actions..\n└── /src\n    ├── /store\n    │   ├── /authentication\n    │   │   ├── /authentication.slice.js\n    │   │   ├── /authentication.actions.js\n    │   │   └── /authentication.test.js\n    │   ├── /authors\n    │   │   ├── /authors.slice.js\n    │   │   ├── /authors.actions.js\n    │   │   └── /authors.test.js\n    │   └── /books\n    │       ├── /books.slice.js\n    │       ├── /books.actions.js\n    │       └── /books.test.js\n    ├── rootReducer.js\n    └── index.jsYou can also add something like auisection of the store to handle modals, toasts, sidebar toggling, and other global UI state, which I find better than havingconst [isOpen, setIsOpen] = useState(false)all over the place.In therootReduceryou would import all your slices and combine them withcombineReducers, and inindex.jsyou would configure the store.UtilsWhether or not your project needs autilsfolder is up to you, but I think there are usually some global utility functions, like validation and conversion, that could easily be used across multiple sections of the app. If you keep it organized - not just having onehelpers.jsfile that contains thousands of functions - it could be a helpful addition to the organization of your project..\n└── src\n    └── /utils\n        ├── /constants\n        │   └── countries.constants.js\n        └── /helpers\n            ├── validation.helpers.js\n            ├── currency.helpers.js\n            └── array.helpers.jsAgain, theutilsfolder can contain anything you want that you think makes sense to keep on a global level. If you don't prefer the \"multi-tier\" filenames, you could just call itvalidation.js, but the way I see it, being explicit does not take anything away from the project, and makes it easier to navigate filenames when searching in your IDE.ViewsHere's where the main part of your app will live: in theviewsdirectory. Any page in your app is a \"view\". In this small example, the views line up pretty well with the Redux store, but it won't necessarily be the case that the store and views are exactly the same, which is why they're separate. Also,booksmight pull fromauthors, and so on.Anything within a view is an item that will likely only be used within that specific view - aBookFormthat will only be used at the/booksroute, and anAuthorBlurbthat will only be used on the/authorsroute. It might include specific forms, modals, buttons, any component that won't be global.The advantage of keeping everything domain-focused instead of putting all your pages together incomponents/pagesis that it makes it really easy to look at the structure of the application and know how many top level views there are, and know where everything that's only used by that view is. If there are nested routes, you can always add a nestedviewsfolder within the main route..\n└── /src\n    └── /views\n        ├── /Authors\n        │   ├── /AuthorsPage\n        │   │   ├── AuthorsPage.js\n        │   │   └── AuthorsPage.test.js\n        │   └── /AuthorBlurb\n        │       ├── /AuthorBlurb.js\n        │       └── /AuthorBlurb.test.js\n        ├── /Books\n        │   ├── /BooksPage\n        │   │   ├── BooksPage.js\n        │   │   └── BooksPage.test.js\n        │   └── /BookForm\n        │       ├── /BookForm.js\n        │       └── /BookForm.test.js\n        └── /Login\n            ├── LoginPage\n            │   ├── LoginPage.styles.js\n            │   ├── LoginPage.js\n            │   └── LoginPage.test.js\n            └── LoginForm\n                ├── LoginForm.js\n                └── LoginForm.test.jsKeeping everything within folders might seem annoying if you've never set up your project that way - you can always keep it more flat, or moveteststo its own directory that mimics the rest of the app.ConclusionThis is my proposal for a sytem for React organization that scales well for a large production app, and handles testing and styling as well as keeping everything together in a feature focused way. It's more nested than the traditional structure of everything being incomponentsandcontainers, but that system is a bit more dated due to Redux being much easier to implement with Hooks, and \"smart\" containers and \"dumb\" components no longer being necessary.It's easy to look at this system and understand everything that is needed for your app and where to go to work on a specific section, or a component that affects the app globally. This system may not make sense for every type of app, but it has worked for me. I'd love to hear any comments about ways this system can be improved, or other systems that have merit.",
        "chunk_type": "technical_content",
        "tag": "section",
        "score": 0.9450000000000001,
        "word_count": 657,
        "chunk_id": "9dff314324abd20f55e9c4db237db02f",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "There is no consensus on the right way to organize a React application. React gives you a lot of freedom, but with that freedom comes the responsibility of deciding on your own architecture. Often the case is that whoever sets up the application in the beginning throws almost everything in acomponentsfolder, or maybecomponentsandcontainersif they used Redux, but I propose there's a better way. I like to be deliberate about how I organize my applications so they're easy to use, understand, and extend.I'm going to show you what I consider to be an intuitive and scalable system for large-scale production React applications. The main concept I think is important is to make the architecture focused onfeatureas opposed totype, organizing only shared components on a global level and modularized all the other related entities together in the localized view.Tech assumptionsSince this article will be opinionated, I'll make some assumptions about what technology the project will be using:Application-React(Hooks)Global state management-Redux,Redux ToolkitRouting-React RouterStyles-Styled ComponentsTesting-Jest,React Testing LibraryI don't have a very strong opinion about the styling, whether Styled Components or CSS modules or a custom Sass setup is ideal, but I think Styled Components is probably one of the best options for keeping your styles modular.I'm also going to assume the tests are alongside the code, as opposed to in a top-leveltestsfolder. I can go either way with this one, but in order for an example to work, and in the real world, decisions need to be made.Everything here can still apply if you're using vanilla Redux instead of Redux Toolkit. I would recommendsetting up your Redux as feature sliceseither way.I'm also ambivalent aboutStorybook, but I'll include what it would look like with those files if you choose to use it in your project.For the sake of the example, I'll use a \"Library App\" example, that has a page for listing books, a page for listing authors, and has an authentication system.Directory StructureThe top level directory structure will be as follows:assets- global static assets such as images, svgs, company logo, etc.components- global shared/reusable components, such as layout (wrappers, navigation), form components, buttonsservices- JavaScript modulesstore- Global Redux storeutils- Utilities, helpers, constants, and the likeviews- Can also be called \"pages\", the majority of the app would be contained hereI like keeping familiar conventions wherever possible, sosrccontains everything,index.jsis the entry point, andApp.jssets up the auth and routing..\n└── /src\n    ├── /assets\n    ├── /components\n    ├── /services\n    ├── /store\n    ├── /utils\n    ├── /views\n    ├── index.js\n    └── App.jsI can see some additional folders you might have, such astypesif it's a TypeScript project,middlewareif necessary, maybecontextforContext, etc.AliasesI would set up the system to use aliases, so anything within thecomponentsfolder could be imported as@components,assetsas@assets, etc. If you have a custom Webpack, this is done through theresolveconfiguration.module.exports={resolve:{extensions:['js','ts'],alias:{'@':path.resolve(__dirname,'src'),'@assets':path.resolve(__dirname,'src/assets'),'@components':path.resolve(__dirname,'src/components'),// ...etc},},} t just makes it a lot easier to import from anywhere within the project and move files around without changing imports, and you never end up with something like../../../../../components/.ComponentsWithin thecomponentsfolder, I would group by type -forms,tables,buttons,layout, etc. The specifics will vary by your specific app.In this example, I'm assuming you're either creating your own form system, or creating your own bindings to an existing form system (for example, combining Formik and Material UI). In this case, you'd create a folder for each component (TextField,Select,Radio,Dropdown, etc.), and inside would be a file for the component itself, the styles, the tests, and the Storybook if it's being used.Component.js- The actual React componentComponent.styles.js- The Styled Components file for the componentComponent.test.js- The testsComponent.stories.js- The Storybook fileTo me, this makes a lot more sense than having one folder that contains the files for ALL components, one folder that contains all the tests, and one folder that contains all the Storybook files, etc. Everything related is grouped together and easy to find..\n└── /src\n    └── /components\n        ├── /forms\n        │   ├── /TextField\n        │   │   ├── TextField.js\n        │   │   ├── TextField.styles.js\n        │   │   ├── TextField.test.js\n        │   │   └── TextField.stories.js\n        │   ├── /Select\n        │   │   ├── Select.js\n        │   │   ├── Select.styles.js\n        │   │   ├── Select.test.js\n        │   │   └── Select.stories.js\n        │   └── index.js\n        ├── /routing\n        │   └── /PrivateRoute\n        │       ├── /PrivateRoute.js\n        │       └── /PrivateRoute.test.js\n        └── /layout\n            └── /navigation\n                └── /NavBar\n                    ├── NavBar.js\n                    ├── NavBar.styles.js\n                    ├── NavBar.test.js\n                    └── NavBar.stories.jsYou'll notice there's anindex.jsfile in thecomponents/formsdirectory. It is often rightfully suggested to avoid usingindex.jsfiles as they're not explicit, but in this case it makes sense - it will end up being an index of all the forms and look something like this:src/components/forms/index.jsimport{TextField} rom'./TextField/TextField'import{Select} rom'./Select/Select'import{Radio} rom'./Radio/Radio'export{TextField,Select,Radio} hen when you need to use one or more of the components, you can easily import them all at once.import{TextField,Select,Radio} rom'@components/forms'I would recommend this approach more than making anindex.jsinside ofeveryfolder withinforms, so now you just have oneindex.jsthat actually indexes the entire directory, as opposed to tenindex.jsfiles just to make imports easier for each individual file.ServicesTheservicesdirectory is less essential thancomponents, but if you're making a plain JavaScript module that the rest of the application is using, it can be handy. A common contrived example is a LocalStorage module, which might look like this:.\n└── /src\n    └── /services\n        ├── /LocalStorage\n        │   ├── LocalStorage.service.js\n        │   └── LocalStorage.test.js\n        └── index.jsAn example of the service:src/services/LocalStorage/LocalStorage.service.jsexportconstLocalStorage={get(key){},set(key,value){},remove(key){},clear(){},} mport{LocalStorage} rom'@services'LocalStorage.get('foo')StoreThe global data store will be contained in thestoredirectory - in this case, Redux. Each feature will have a folder, which will contain theRedux Toolkitslice, as well as actions and tests. This setup can also be used with regular Redux, you would just create a.reducers.jsfile and.actions.jsfile instead of aslice.",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.9450000000000001,
        "word_count": 895,
        "chunk_id": "dc01d48e25930e1dd43bed11c795bc28",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "id": "/react-architecture-directory-structure/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "If you're using sagas, it could be.saga.jsinstead of.actions.jsfor Redux Thunk actions..\n└── /src\n    ├── /store\n    │   ├── /authentication\n    │   │   ├── /authentication.slice.js\n    │   │   ├── /authentication.actions.js\n    │   │   └── /authentication.test.js\n    │   ├── /authors\n    │   │   ├── /authors.slice.js\n    │   │   ├── /authors.actions.js\n    │   │   └── /authors.test.js\n    │   └── /books\n    │       ├── /books.slice.js\n    │       ├── /books.actions.js\n    │       └── /books.test.js\n    ├── rootReducer.js\n    └── index.jsYou can also add something like auisection of the store to handle modals, toasts, sidebar toggling, and other global UI state, which I find better than havingconst [isOpen, setIsOpen] = useState(false)all over the place.In therootReduceryou would import all your slices and combine them withcombineReducers, and inindex.jsyou would configure the store.UtilsWhether or not your project needs autilsfolder is up to you, but I think there are usually some global utility functions, like validation and conversion, that could easily be used across multiple sections of the app. If you keep it organized - not just having onehelpers.jsfile that contains thousands of functions - it could be a helpful addition to the organization of your project..\n└── src\n    └── /utils\n        ├── /constants\n        │   └── countries.constants.js\n        └── /helpers\n            ├── validation.helpers.js\n            ├── currency.helpers.js\n            └── array.helpers.jsAgain, theutilsfolder can contain anything you want that you think makes sense to keep on a global level. If you don't prefer the \"multi-tier\" filenames, you could just call itvalidation.js, but the way I see it, being explicit does not take anything away from the project, and makes it easier to navigate filenames when searching in your IDE.ViewsHere's where the main part of your app will live: in theviewsdirectory. Any page in your app is a \"view\". In this small example, the views line up pretty well with the Redux store, but it won't necessarily be the case that the store and views are exactly the same, which is why they're separate. Also,booksmight pull fromauthors, and so on.Anything within a view is an item that will likely only be used within that specific view - aBookFormthat will only be used at the/booksroute, and anAuthorBlurbthat will only be used on the/authorsroute. It might include specific forms, modals, buttons, any component that won't be global.The advantage of keeping everything domain-focused instead of putting all your pages together incomponents/pagesis that it makes it really easy to look at the structure of the application and know how many top level views there are, and know where everything that's only used by that view is. If there are nested routes, you can always add a nestedviewsfolder within the main route..\n└── /src\n    └── /views\n        ├── /Authors\n        │   ├── /AuthorsPage\n        │   │   ├── AuthorsPage.js\n        │   │   └── AuthorsPage.test.js\n        │   └── /AuthorBlurb\n        │       ├── /AuthorBlurb.js\n        │       └── /AuthorBlurb.test.js\n        ├── /Books\n        │   ├── /BooksPage\n        │   │   ├── BooksPage.js\n        │   │   └── BooksPage.test.js\n        │   └── /BookForm\n        │       ├── /BookForm.js\n        │       └── /BookForm.test.js\n        └── /Login\n            ├── LoginPage\n            │   ├── LoginPage.styles.js\n            │   ├── LoginPage.js\n            │   └── LoginPage.test.js\n            └── LoginForm\n                ├── LoginForm.js\n                └── LoginForm.test.jsKeeping everything within folders might seem annoying if you've never set up your project that way - you can always keep it more flat, or moveteststo its own directory that mimics the rest of the app.ConclusionThis is my proposal for a sytem for React organization that scales well for a large production app, and handles testing and styling as well as keeping everything together in a feature focused way. It's more nested than the traditional structure of everything being incomponentsandcontainers, but that system is a bit more dated due to Redux being much easier to implement with Hooks, and \"smart\" containers and \"dumb\" components no longer being necessary.It's easy to look at this system and understand everything that is needed for your app and where to go to work on a specific section, or a component that affects the app globally. This system may not make sense for every type of app, but it has worked for me. I'd love to hear any comments about ways this system can be improved, or other systems that have merit.",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.9450000000000001,
        "word_count": 657,
        "chunk_id": "9dff314324abd20f55e9c4db237db02f",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "id": "/react-architecture-directory-structure/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "data"
          ]
        }
      },
      {
        "content": "About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:June 23, 2021Category:TechnicalTagsjavascriptreactNewsletterSubscribe to the Newsletter",
        "chunk_type": "text",
        "tag": "aside",
        "score": 0.42600000000000005,
        "word_count": 54,
        "chunk_id": "1000d105e10fbe48a0dd5be39330f2d5",
        "metadata": {
          "source_tag": "aside",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "post-sidebar"
            ]
          },
          "technical_indicators": [
            "javascript"
          ]
        }
      },
      {
        "content": "There is no consensus on the right way to organize a React application. React gives you a lot of freedom, but with that freedom comes the responsibility of deciding on your own architecture. Often the case is that whoever sets up the application in the beginning throws almost everything in acomponentsfolder, or maybecomponentsandcontainersif they used Redux, but I propose there's a better way. I like to be deliberate about how I organize my applications so they're easy to use, understand, and extend.",
        "chunk_type": "technical_content",
        "tag": "p",
        "score": 0.335,
        "word_count": 82,
        "chunk_id": "30d517213c62ce11b3ed1fffbd2f09d8",
        "metadata": {
          "source_tag": "p",
          "keywords_found": [
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react"
          ]
        }
      },
      {
        "content": "This is my proposal for a sytem for React organization that scales well for a large production app, and handles testing and styling as well as keeping everything together in a feature focused way. It's more nested than the traditional structure of everything being incomponentsandcontainers, but that system is a bit more dated due to Redux being much easier to implement with Hooks, and \"smart\" containers and \"dumb\" components no longer being necessary.",
        "chunk_type": "technical_content",
        "tag": "p",
        "score": 0.30900000000000005,
        "word_count": 73,
        "chunk_id": "d0bb356074d80a5c60884cb34e1f3cc8",
        "metadata": {
          "source_tag": "p",
          "keywords_found": [
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react"
          ]
        }
      },
      {
        "content": ".\n└── /src\n    └── /components\n        ├── /forms\n        │   ├── /TextField\n        │   │   ├── TextField.js\n        │   │   ├── TextField.styles.js\n        │   │   ├── TextField.test.js\n        │   │   └── TextField.stories.js\n        │   ├── /Select\n        │   │   ├── Select.js\n        │   │   ├── Select.styles.js\n        │   │   ├── Select.test.js\n        │   │   └── Select.stories.js\n        │   └── index.js\n        ├── /routing\n        │   └── /PrivateRoute\n        │       ├── /PrivateRoute.js\n        │       └── /PrivateRoute.test.js\n        └── /layout\n            └── /navigation\n                └── /NavBar\n                    ├── NavBar.js\n                    ├── NavBar.styles.js\n                    ├── NavBar.test.js\n                    └── NavBar.stories.js",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.34800000000000003,
        "word_count": 73,
        "chunk_id": "c0d1d6ffad4a0b97636290c67ca5c913",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "text"
          },
          "technical_indicators": [
            "react",
            "sql"
          ]
        }
      },
      {
        "content": ".\n└── /src\n    └── /components\n        ├── /forms\n        │   ├── /TextField\n        │   │   ├── TextField.js\n        │   │   ├── TextField.styles.js\n        │   │   ├── TextField.test.js\n        │   │   └── TextField.stories.js\n        │   ├── /Select\n        │   │   ├── Select.js\n        │   │   ├── Select.styles.js\n        │   │   ├── Select.test.js\n        │   │   └── Select.stories.js\n        │   └── index.js\n        ├── /routing\n        │   └── /PrivateRoute\n        │       ├── /PrivateRoute.js\n        │       └── /PrivateRoute.test.js\n        └── /layout\n            └── /navigation\n                └── /NavBar\n                    ├── NavBar.js\n                    ├── NavBar.styles.js\n                    ├── NavBar.test.js\n                    └── NavBar.stories.js",
        "chunk_type": "technical_content",
        "tag": "pre",
        "score": 0.34800000000000003,
        "word_count": 73,
        "chunk_id": "c0d1d6ffad4a0b97636290c67ca5c913",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [],
          "attributes": {
            "class": [
              "language-text"
            ]
          },
          "technical_indicators": [
            "react",
            "sql"
          ]
        }
      },
      {
        "content": ".\n└── /src\n    └── /components\n        ├── /forms\n        │   ├── /TextField\n        │   │   ├── TextField.js\n        │   │   ├── TextField.styles.js\n        │   │   ├── TextField.test.js\n        │   │   └── TextField.stories.js\n        │   ├── /Select\n        │   │   ├── Select.js\n        │   │   ├── Select.styles.js\n        │   │   ├── Select.test.js\n        │   │   └── Select.stories.js\n        │   └── index.js\n        ├── /routing\n        │   └── /PrivateRoute\n        │       ├── /PrivateRoute.js\n        │       └── /PrivateRoute.test.js\n        └── /layout\n            └── /navigation\n                └── /NavBar\n                    ├── NavBar.js\n                    ├── NavBar.styles.js\n                    ├── NavBar.test.js\n                    └── NavBar.stories.js",
        "chunk_type": "technical_content",
        "tag": "code",
        "score": 0.34800000000000003,
        "word_count": 73,
        "chunk_id": "c0d1d6ffad4a0b97636290c67ca5c913",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [],
          "attributes": {
            "class": [
              "language-text"
            ]
          },
          "technical_indicators": [
            "react",
            "sql"
          ]
        }
      }
    ],
    "chunk_count": 20,
    "content_types": [
      "text",
      "technical_content"
    ],
    "technical_concepts": [
      "javascript",
      "data",
      "react",
      "sql"
    ],
    "crawl_metadata": {},
    "technical_content": [
      {
        "id": "4725dcf446a342f1473a8228e42dfa48",
        "content": "components",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "4725dcf446a342f1473a8228e42dfa48",
        "content": "components",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "57bcbf1d2df6010d41816c012905835d",
        "content": "containers",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b61a6d542f9036550ba9c401c80f00ef",
        "content": "tests",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "25d902c24283ab8cfbac54dfa101ad31",
        "content": "src",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "958f6f56cd42c904603d226cd36a57b6",
        "content": "App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "47170b535c8d7d3d90b971fde19235a6",
        "content": ". /src /assets /components /services /store /utils /views index.js App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "47170b535c8d7d3d90b971fde19235a6",
        "content": ". /src /assets /components /services /store /utils /views index.js App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "d14a8022b085f9ef19d479cbdd581127",
        "content": "types",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b200f0642a4dc4d9d66162920860c3f0",
        "content": "middleware",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5c18ef72771564b7f43c497dc507aeab",
        "content": "context",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4725dcf446a342f1473a8228e42dfa48",
        "content": "components",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "4725dcf446a342f1473a8228e42dfa48",
        "content": "components",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "32bb636196f91ed59d7a49190e26b42c",
        "content": "assets",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "32bb636196f91ed59d7a49190e26b42c",
        "content": "assets",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1434d28b6e423e0afb72fc13508c2a84",
        "content": "module.exports = { resolve: { extensions: ['js', 'ts'], alias: { ' ': path.resolve(__dirname, 'src'), ' assets': path.resolve(__dirname, 'src/assets'), ' components': path.resolve(__dirname, 'src/components'), // ...etc }, }, }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "1434d28b6e423e0afb72fc13508c2a84",
        "content": "module.exports = { resolve: { extensions: ['js', 'ts'], alias: { ' ': path.resolve(__dirname, 'src'), ' assets': path.resolve(__dirname, 'src/assets'), ' components': path.resolve(__dirname, 'src/components'), // ...etc }, }, }",
        "type": "code",
        "language": "js",
        "relevance": 0.605263157894737
      },
      {
        "id": "7aad648ac77cc166378353ba27675255",
        "content": "../../../../../components/",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "4725dcf446a342f1473a8228e42dfa48",
        "content": "components",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "ac68b62abfd6a9fe26e8ac4236c8ce0c",
        "content": "forms",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9ab2ec7ea4a2041306f7bdf150fcd453",
        "content": "tables",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "02634eff3c24742057ecacbee91c4bbd",
        "content": "buttons",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c61404957758dfda283709e89376ab3e",
        "content": "layout",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f0bfb289e820988a0d3e577bed6156a8",
        "content": "TextField",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e0626222614bdee31951d84c64e5e9ff",
        "content": "Select",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "1f32d2c1b49b9b0c9d99bd10da107e41",
        "content": "Radio",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7498c445a737312f3678aa1494e01a38",
        "content": "Dropdown",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e419bf2968f5831d6fe6c40e5579145b",
        "content": ". /src /components /forms /TextField TextField.js TextField.styles.js TextField.test.js TextField.stories.js /Select Select.js Select.styles.js Select.test.js Select.stories.js index.js /routing /PrivateRoute /PrivateRoute.js /PrivateRoute.test.js /layout /navigation /NavBar NavBar.js NavBar.styles.js NavBar.test.js NavBar.stories.js",
        "type": "code",
        "language": "text",
        "relevance": 0.7105263157894737
      },
      {
        "id": "e419bf2968f5831d6fe6c40e5579145b",
        "content": ". /src /components /forms /TextField TextField.js TextField.styles.js TextField.test.js TextField.stories.js /Select Select.js Select.styles.js Select.test.js Select.stories.js index.js /routing /PrivateRoute /PrivateRoute.js /PrivateRoute.test.js /layout /navigation /NavBar NavBar.js NavBar.styles.js NavBar.test.js NavBar.stories.js",
        "type": "code",
        "language": "text",
        "relevance": 0.7105263157894737
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "94459ba4fe0afaa641824f1980519df4",
        "content": "components/forms",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "8cde8a71d72e2832aba0d1c2dc9cb1a9",
        "content": "import { TextField } from './TextField/TextField' import { Select } from './Select/Select' import { Radio } from './Radio/Radio' export { TextField, Select, Radio }",
        "type": "code",
        "language": "js",
        "relevance": 0.4052631578947369
      },
      {
        "id": "8cde8a71d72e2832aba0d1c2dc9cb1a9",
        "content": "import { TextField } from './TextField/TextField' import { Select } from './Select/Select' import { Radio } from './Radio/Radio' export { TextField, Select, Radio }",
        "type": "code",
        "language": "js",
        "relevance": 0.4052631578947369
      },
      {
        "id": "7b4c25191269c10aa1cc135597254122",
        "content": "import { TextField, Select, Radio } from ' components/forms'",
        "type": "code",
        "language": "js",
        "relevance": 0.5105263157894737
      },
      {
        "id": "7b4c25191269c10aa1cc135597254122",
        "content": "import { TextField, Select, Radio } from ' components/forms'",
        "type": "code",
        "language": "js",
        "relevance": 0.5105263157894737
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "ac68b62abfd6a9fe26e8ac4236c8ce0c",
        "content": "forms",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "10cd395cf71c18328c863c08e78f3fd0",
        "content": "services",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4725dcf446a342f1473a8228e42dfa48",
        "content": "components",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "6e24fcd5c6b278e94a46e7468ea97cc0",
        "content": ". /src /services /LocalStorage LocalStorage.service.js LocalStorage.test.js index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6e24fcd5c6b278e94a46e7468ea97cc0",
        "content": ". /src /services /LocalStorage LocalStorage.service.js LocalStorage.test.js index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9a36cc7db6e091af0154eff0db2f8f67",
        "content": "export const LocalStorage = { get(key) {}, set(key, value) {}, remove(key) {}, clear() {}, }",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "9a36cc7db6e091af0154eff0db2f8f67",
        "content": "export const LocalStorage = { get(key) {}, set(key, value) {}, remove(key) {}, clear() {}, }",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "6b28381bb04ac64e3680a189f9a68c0c",
        "content": "import { LocalStorage } from ' services' LocalStorage.get('foo')",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6b28381bb04ac64e3680a189f9a68c0c",
        "content": "import { LocalStorage } from ' services' LocalStorage.get('foo')",
        "type": "code",
        "language": "js",
        "relevance": 0.30000000000000004
      },
      {
        "id": "8cd892b7b97ef9489ae4479d3f4ef0fc",
        "content": "store",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9cca54e1345a80a2447d8e56f1fddf3e",
        "content": ".reducers.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "549426947ddd23caba101a9a5f06e816",
        "content": ".actions.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6d52012dca4fc77aa554f25430aef501",
        "content": "slice",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1fca03237a5c3f384e1653b192d5a3f3",
        "content": ".saga.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "549426947ddd23caba101a9a5f06e816",
        "content": ".actions.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "45c98fbf2adc96d622592fdd8faf57a1",
        "content": ". /src /store /authentication /authentication.slice.js /authentication.actions.js /authentication.test.js /authors /authors.slice.js /authors.actions.js /authors.test.js /books /books.slice.js /books.actions.js /books.test.js rootReducer.js index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "45c98fbf2adc96d622592fdd8faf57a1",
        "content": ". /src /store /authentication /authentication.slice.js /authentication.actions.js /authentication.test.js /authors /authors.slice.js /authors.actions.js /authors.test.js /books /books.slice.js /books.actions.js /books.test.js rootReducer.js index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7d5c009e4eb8bbc78647caeca308e61b",
        "content": "ui",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "da29d57b18ba9673c61de6d76442dfa5",
        "content": "const [isOpen, setIsOpen] = useState(false)",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "c0be6c4e3861c6ba620e547e8819de0a",
        "content": "rootReducer",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4b7dbab04392cd22a1fec72b0a1831ce",
        "content": "combineReducers",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2b3583e6e17721c54496bd04e57a0c15",
        "content": "utils",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9539354d35e1c6c1fa65496aaba008cc",
        "content": "helpers.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "25dcfa147b11089b521eb0d6fffc316b",
        "content": ". src /utils /constants countries.constants.js /helpers validation.helpers.js currency.helpers.js array.helpers.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "25dcfa147b11089b521eb0d6fffc316b",
        "content": ". src /utils /constants countries.constants.js /helpers validation.helpers.js currency.helpers.js array.helpers.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2b3583e6e17721c54496bd04e57a0c15",
        "content": "utils",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7cff2fbef3d599eb49f2813d9a65a86a",
        "content": "validation.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "59a14a5786fe7a105d780bb1e1e2b21b",
        "content": "views",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7d8949bcbf85067fceda9f84a6affb6b",
        "content": "books",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5d9449e8d8508c7ee2cf746c86e5dde3",
        "content": "authors",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "910c626184c19461aebd7de5f2e078af",
        "content": "BookForm",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a0721c16c96f044d5d405fef10a701de",
        "content": "/books",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d0ee792df4dd099b4ea2a8f0054ecf78",
        "content": "AuthorBlurb",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "0cd2ab40365b290f953028a915b0281d",
        "content": "/authors",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "771b1d7e6d2be441e2bf5648d3dafde6",
        "content": "components/pages",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "59a14a5786fe7a105d780bb1e1e2b21b",
        "content": "views",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6ed460066bf33f67b1fcd32579959d4b",
        "content": ". /src /views /Authors /AuthorsPage AuthorsPage.js AuthorsPage.test.js /AuthorBlurb /AuthorBlurb.js /AuthorBlurb.test.js /Books /BooksPage BooksPage.js BooksPage.test.js /BookForm /BookForm.js /BookForm.test.js /Login LoginPage LoginPage.styles.js LoginPage.js LoginPage.test.js LoginForm LoginForm.js LoginForm.test.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6ed460066bf33f67b1fcd32579959d4b",
        "content": ". /src /views /Authors /AuthorsPage AuthorsPage.js AuthorsPage.test.js /AuthorBlurb /AuthorBlurb.js /AuthorBlurb.test.js /Books /BooksPage BooksPage.js BooksPage.test.js /BookForm /BookForm.js /BookForm.test.js /Login LoginPage LoginPage.styles.js LoginPage.js LoginPage.test.js LoginForm LoginForm.js LoginForm.test.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b61a6d542f9036550ba9c401c80f00ef",
        "content": "tests",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4725dcf446a342f1473a8228e42dfa48",
        "content": "components",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "57bcbf1d2df6010d41816c012905835d",
        "content": "containers",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      }
    ]
  },
  {
    "metadata": {
      "description": "React doesn't come with a built-in router, but we can easily achieve routing with the  library. Routing is how a web applications direct…",
      "url": "https://www.taniarascia.com/using-react-router-spa/",
      "title": "Using React Router for a Single Page Application | Tania Rascia's Personal Website",
      "source_type": "web",
      "crawl_time": 1730107305.399468,
      "keywords": [
        "sql",
        "web",
        "article",
        "extract",
        "development",
        "information",
        "react"
      ]
    },
    "relevance_score": 0.7403333333333335,
    "chunks": [
      {
        "content": "Using React Router for a Single Page ApplicationReact doesn't come with a built-in router, but we can easily achieve routing with thereact-router-domlibrary.Routingis how a web applications direct traffic. (If you know what routing is, feel free to skip this section.)Example: If you go totaniarascia.com, you end up on my home page. If you go totaniarascia.com/me, you're redirected to my about me page. If you go totaniarascia.com/categories/javascriptortaniarascia.com/categories/css, you end up on a category listing page. The routes for these pages look something like this:/- root/:page_id- page/categories/:category_id- categoryI'm not actually making a folder calledcategoriesand filling it with a bunch of files likejavascript.htmlorcss.html, I just have one template and the router knows to direct to the proper template. Once it gets to the template, it can pull from the URL to know which variables to display - for example, JavaScript or CSS related posts.This website also happens to be aSingle Page Application(or SPA) - only one page is loaded, and every click to a new page loads some additional JSON data, but does not actually request a new resource like loadingindex.htmlandabout-me.htmlwould.I'm going to show you how to set up a simple SPA in React withreact-router-dom, and pull in data dynamically through the URL. Below is the source of the completed project if you get lost along the way.View SourcePrerequisitesReadGetting Started with ReactorBuild a React App with Hooksif you don't know React or React Hooks yet.ReadHow to Connect to an API in JavaScriptif you don't know how to work with APIs at all.InstallationCreate a new React app.npx create-react-app router-exampleCreating a new React app in /Users/taniarascia/dev/sandbox/router-example. Installing packages. This might take a couple of minutes. Installing react, react-dom, and react-scripts...Our project has two dependencies -react-router-domfor the router, andaxiosfor making API calls.npminstallreact-router-dom axiosoryarnaddreact-router-dom axiosBrowser RouterTo usereact-router-dom, we need to wrap our entireAppcomponent inBrowserRouter. There are two types of routers:BrowserRouter- makes pretty URLs likeexample.com/about.HashRouter- makes URLs with the octothorpe (or hashtag, if you will) that would look likeexample.com/#about.Let's useBrowserRouter.src/index.jsimportReactfrom'react'import{render} rom'react-dom'import{BrowserRouter} rom'react-router-dom'importAppfrom'./App'render(<BrowserRouter><App/></BrowserRouter>,document.querySelector('#root'))Route and SwitchNow inApp.js, we can decide on the routes we want to use and direct accordingly. We'll useRouteandSwitchfor this task.Switch- Groups all your routes together, and ensures they take precedence from top-to-bottom.Route- Each individual route.App.jsimportReactfrom'react'import{Route,Switch} rom'react-router-dom'// We will create these two pages in a momentimportHomePagefrom'./pages/HomePage'importUserPagefrom'./pages/UserPage'exportdefaultfunctionApp(){return(<Switch><Routeexactpath=\"/\"component={HomePage}/><Routepath=\"/:id\"component={UserPage}/></Switch>)} e're matching the root route (/) toHomePage, and dynamically matching any other page toUserPage. I only have one route for this simple example, but you could do more like this:<Switch><Routeexactpath=\"/\"component={HomePage}/><Routepath=\"/:id\"component={UserPage}/><Routepath=\"/categories\"component={CategoriesPage}/><Routepath=\"/categories/:id\"component={IndividualCategoryPage}/></Switch>This would ensure thattaniarascia.com/categorieswould go to a page listing all categories, buttaniarascia.com/categories/javascriptwould go to a completely different template for the individual category listing.LinkIn order to link to a page within the SPA, we'll useLink. If we used the traditional<a href=\"/route\">, it would make a completely new request and reload the page, so we haveLinkto help us out.src/pages/HomePage.jsimportReactfrom'react'import{Link} rom'react-router-dom'exportdefaultfunctionHomePage(){return(<divclassName=\"container\"><h1>Home Page</h1><p><Linkto=\"/taniarascia\">taniarascia</Link>on GitHub.</p></div>)} o now I'm going to my first route, the root route which is loadingHomePage, and I see the content and the link.Dynamic Route ParameterOurLinkis navigating to/taniarascia, which will match the/:idparameter inRoute. In order to dynamically get the content from the URL - in this case,taniarascia- we'll usematch.params.idfrom theprops.I'm going to use that parameter to make a call to the GitHub API and retrieve my data. In this example I'll be using Hooks, so if you're not familiar with them, please readBuilding a CRUD App with Hooks.src/pages/UserPage.jsimportReact,{useState,useEffect} rom'react'importaxiosfrom'axios'exportdefaultfunctionUserPage(props){// Setting initial stateconstinitialUserState={user:{},loading:true,}// Getter and setter for user stateconst[user,setUser]=useState(initialUserState)// Using useEffect to retrieve data from an API (similar to componentDidMount in a class)useEffect(()=>{constgetUser=async()=>{// Pass our param (:id) to the API callconst{data}=awaitaxios(`https://api.github.com/users/${props.match.params.id}`)// Update statesetUser(data)}// Invoke the async functiongetUser()},[])// Don't forget the `[]`, which will prevent useEffect from running in an infinite loop// Return a table with some data from the API.returnuser.loading?(<div>Loading...</div>):(<divclassName=\"container\"><h1>{props.match.params.id}</h1><table><thead><tr><th>Name</th><th>Location</th><th>Website</th><th>Followers</th></tr></thead><tbody><tr><td>{user.name}</td><td>{user.location}</td><td><ahref={user.blog}>{user.blog}</a></td><td>{user.followers}</td></tr></tbody></table></div>)} onclusionIf you got lost anywhere along the way, view the source on GitHub.View SourceAlso, there is a caveat: if you want to use this on GitHub Pages, it's not smart enough to realize thatyou.github.io/repo/:idshould direct to/:id. If you want to host on GitHub pages and encounter this issue,hosting your single page app on GitHub Pageswill help you out.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:April 25, 2019Category:TechnicalTagsjavascriptreactrouterNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_markup",
        "tag": "main",
        "score": 0.928,
        "word_count": 716,
        "chunk_id": "754d926908fe26e9a4ce698170e923f0",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "Using React Router for a Single Page ApplicationReact doesn't come with a built-in router, but we can easily achieve routing with thereact-router-domlibrary.Routingis how a web applications direct traffic. (If you know what routing is, feel free to skip this section.)Example: If you go totaniarascia.com, you end up on my home page. If you go totaniarascia.com/me, you're redirected to my about me page. If you go totaniarascia.com/categories/javascriptortaniarascia.com/categories/css, you end up on a category listing page. The routes for these pages look something like this:/- root/:page_id- page/categories/:category_id- categoryI'm not actually making a folder calledcategoriesand filling it with a bunch of files likejavascript.htmlorcss.html, I just have one template and the router knows to direct to the proper template. Once it gets to the template, it can pull from the URL to know which variables to display - for example, JavaScript or CSS related posts.This website also happens to be aSingle Page Application(or SPA) - only one page is loaded, and every click to a new page loads some additional JSON data, but does not actually request a new resource like loadingindex.htmlandabout-me.htmlwould.I'm going to show you how to set up a simple SPA in React withreact-router-dom, and pull in data dynamically through the URL. Below is the source of the completed project if you get lost along the way.View SourcePrerequisitesReadGetting Started with ReactorBuild a React App with Hooksif you don't know React or React Hooks yet.ReadHow to Connect to an API in JavaScriptif you don't know how to work with APIs at all.InstallationCreate a new React app.npx create-react-app router-exampleCreating a new React app in /Users/taniarascia/dev/sandbox/router-example. Installing packages. This might take a couple of minutes. Installing react, react-dom, and react-scripts...Our project has two dependencies -react-router-domfor the router, andaxiosfor making API calls.npminstallreact-router-dom axiosoryarnaddreact-router-dom axiosBrowser RouterTo usereact-router-dom, we need to wrap our entireAppcomponent inBrowserRouter. There are two types of routers:BrowserRouter- makes pretty URLs likeexample.com/about.HashRouter- makes URLs with the octothorpe (or hashtag, if you will) that would look likeexample.com/#about.Let's useBrowserRouter.src/index.jsimportReactfrom'react'import{render} rom'react-dom'import{BrowserRouter} rom'react-router-dom'importAppfrom'./App'render(<BrowserRouter><App/></BrowserRouter>,document.querySelector('#root'))Route and SwitchNow inApp.js, we can decide on the routes we want to use and direct accordingly. We'll useRouteandSwitchfor this task.Switch- Groups all your routes together, and ensures they take precedence from top-to-bottom.Route- Each individual route.App.jsimportReactfrom'react'import{Route,Switch} rom'react-router-dom'// We will create these two pages in a momentimportHomePagefrom'./pages/HomePage'importUserPagefrom'./pages/UserPage'exportdefaultfunctionApp(){return(<Switch><Routeexactpath=\"/\"component={HomePage}/><Routepath=\"/:id\"component={UserPage}/></Switch>)} e're matching the root route (/) toHomePage, and dynamically matching any other page toUserPage. I only have one route for this simple example, but you could do more like this:<Switch><Routeexactpath=\"/\"component={HomePage}/><Routepath=\"/:id\"component={UserPage}/><Routepath=\"/categories\"component={CategoriesPage}/><Routepath=\"/categories/:id\"component={IndividualCategoryPage}/></Switch>This would ensure thattaniarascia.com/categorieswould go to a page listing all categories, buttaniarascia.com/categories/javascriptwould go to a completely different template for the individual category listing.LinkIn order to link to a page within the SPA, we'll useLink. If we used the traditional<a href=\"/route\">, it would make a completely new request and reload the page, so we haveLinkto help us out.src/pages/HomePage.jsimportReactfrom'react'import{Link} rom'react-router-dom'exportdefaultfunctionHomePage(){return(<divclassName=\"container\"><h1>Home Page</h1><p><Linkto=\"/taniarascia\">taniarascia</Link>on GitHub.</p></div>)} o now I'm going to my first route, the root route which is loadingHomePage, and I see the content and the link.Dynamic Route ParameterOurLinkis navigating to/taniarascia, which will match the/:idparameter inRoute. In order to dynamically get the content from the URL - in this case,taniarascia- we'll usematch.params.idfrom theprops.I'm going to use that parameter to make a call to the GitHub API and retrieve my data. In this example I'll be using Hooks, so if you're not familiar with them, please readBuilding a CRUD App with Hooks.src/pages/UserPage.jsimportReact,{useState,useEffect} rom'react'importaxiosfrom'axios'exportdefaultfunctionUserPage(props){// Setting initial stateconstinitialUserState={user:{},loading:true,}// Getter and setter for user stateconst[user,setUser]=useState(initialUserState)// Using useEffect to retrieve data from an API (similar to componentDidMount in a class)useEffect(()=>{constgetUser=async()=>{// Pass our param (:id) to the API callconst{data}=awaitaxios(`https://api.github.com/users/${props.match.params.id}`)// Update statesetUser(data)}// Invoke the async functiongetUser()},[])// Don't forget the `[]`, which will prevent useEffect from running in an infinite loop// Return a table with some data from the API.returnuser.loading?(<div>Loading...</div>):(<divclassName=\"container\"><h1>{props.match.params.id}</h1><table><thead><tr><th>Name</th><th>Location</th><th>Website</th><th>Followers</th></tr></thead><tbody><tr><td>{user.name}</td><td>{user.location}</td><td><ahref={user.blog}>{user.blog}</a></td><td>{user.followers}</td></tr></tbody></table></div>)} onclusionIf you got lost anywhere along the way, view the source on GitHub.View SourceAlso, there is a caveat: if you want to use this on GitHub Pages, it's not smart enough to realize thatyou.github.io/repo/:idshould direct to/:id. If you want to host on GitHub pages and encounter this issue,hosting your single page app on GitHub Pageswill help you out.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:April 25, 2019Category:TechnicalTagsjavascriptreactrouterNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.928,
        "word_count": 716,
        "chunk_id": "754d926908fe26e9a4ce698170e923f0",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "Using React Router for a Single Page ApplicationReact doesn't come with a built-in router, but we can easily achieve routing with thereact-router-domlibrary.Routingis how a web applications direct traffic. (If you know what routing is, feel free to skip this section.)Example: If you go totaniarascia.com, you end up on my home page. If you go totaniarascia.com/me, you're redirected to my about me page. If you go totaniarascia.com/categories/javascriptortaniarascia.com/categories/css, you end up on a category listing page. The routes for these pages look something like this:/- root/:page_id- page/categories/:category_id- categoryI'm not actually making a folder calledcategoriesand filling it with a bunch of files likejavascript.htmlorcss.html, I just have one template and the router knows to direct to the proper template. Once it gets to the template, it can pull from the URL to know which variables to display - for example, JavaScript or CSS related posts.This website also happens to be aSingle Page Application(or SPA) - only one page is loaded, and every click to a new page loads some additional JSON data, but does not actually request a new resource like loadingindex.htmlandabout-me.htmlwould.I'm going to show you how to set up a simple SPA in React withreact-router-dom, and pull in data dynamically through the URL. Below is the source of the completed project if you get lost along the way.View SourcePrerequisitesReadGetting Started with ReactorBuild a React App with Hooksif you don't know React or React Hooks yet.ReadHow to Connect to an API in JavaScriptif you don't know how to work with APIs at all.InstallationCreate a new React app.npx create-react-app router-exampleCreating a new React app in /Users/taniarascia/dev/sandbox/router-example. Installing packages. This might take a couple of minutes. Installing react, react-dom, and react-scripts...Our project has two dependencies -react-router-domfor the router, andaxiosfor making API calls.npminstallreact-router-dom axiosoryarnaddreact-router-dom axiosBrowser RouterTo usereact-router-dom, we need to wrap our entireAppcomponent inBrowserRouter. There are two types of routers:BrowserRouter- makes pretty URLs likeexample.com/about.HashRouter- makes URLs with the octothorpe (or hashtag, if you will) that would look likeexample.com/#about.Let's useBrowserRouter.src/index.jsimportReactfrom'react'import{render} rom'react-dom'import{BrowserRouter} rom'react-router-dom'importAppfrom'./App'render(<BrowserRouter><App/></BrowserRouter>,document.querySelector('#root'))Route and SwitchNow inApp.js, we can decide on the routes we want to use and direct accordingly. We'll useRouteandSwitchfor this task.Switch- Groups all your routes together, and ensures they take precedence from top-to-bottom.Route- Each individual route.App.jsimportReactfrom'react'import{Route,Switch} rom'react-router-dom'// We will create these two pages in a momentimportHomePagefrom'./pages/HomePage'importUserPagefrom'./pages/UserPage'exportdefaultfunctionApp(){return(<Switch><Routeexactpath=\"/\"component={HomePage}/><Routepath=\"/:id\"component={UserPage}/></Switch>)} e're matching the root route (/) toHomePage, and dynamically matching any other page toUserPage. I only have one route for this simple example, but you could do more like this:<Switch><Routeexactpath=\"/\"component={HomePage}/><Routepath=\"/:id\"component={UserPage}/><Routepath=\"/categories\"component={CategoriesPage}/><Routepath=\"/categories/:id\"component={IndividualCategoryPage}/></Switch>This would ensure thattaniarascia.com/categorieswould go to a page listing all categories, buttaniarascia.com/categories/javascriptwould go to a completely different template for the individual category listing.LinkIn order to link to a page within the SPA, we'll useLink. If we used the traditional<a href=\"/route\">, it would make a completely new request and reload the page, so we haveLinkto help us out.src/pages/HomePage.jsimportReactfrom'react'import{Link} rom'react-router-dom'exportdefaultfunctionHomePage(){return(<divclassName=\"container\"><h1>Home Page</h1><p><Linkto=\"/taniarascia\">taniarascia</Link>on GitHub.</p></div>)} o now I'm going to my first route, the root route which is loadingHomePage, and I see the content and the link.Dynamic Route ParameterOurLinkis navigating to/taniarascia, which will match the/:idparameter inRoute. In order to dynamically get the content from the URL - in this case,taniarascia- we'll usematch.params.idfrom theprops.I'm going to use that parameter to make a call to the GitHub API and retrieve my data. In this example I'll be using Hooks, so if you're not familiar with them, please readBuilding a CRUD App with Hooks.src/pages/UserPage.jsimportReact,{useState,useEffect} rom'react'importaxiosfrom'axios'exportdefaultfunctionUserPage(props){// Setting initial stateconstinitialUserState={user:{},loading:true,}// Getter and setter for user stateconst[user,setUser]=useState(initialUserState)// Using useEffect to retrieve data from an API (similar to componentDidMount in a class)useEffect(()=>{constgetUser=async()=>{// Pass our param (:id) to the API callconst{data}=awaitaxios(`https://api.github.com/users/${props.match.params.id}`)// Update statesetUser(data)}// Invoke the async functiongetUser()},[])// Don't forget the `[]`, which will prevent useEffect from running in an infinite loop// Return a table with some data from the API.returnuser.loading?(<div>Loading...</div>):(<divclassName=\"container\"><h1>{props.match.params.id}</h1><table><thead><tr><th>Name</th><th>Location</th><th>Website</th><th>Followers</th></tr></thead><tbody><tr><td>{user.name}</td><td>{user.location}</td><td><ahref={user.blog}>{user.blog}</a></td><td>{user.followers}</td></tr></tbody></table></div>)} onclusionIf you got lost anywhere along the way, view the source on GitHub.View SourceAlso, there is a caveat: if you want to use this on GitHub Pages, it's not smart enough to realize thatyou.github.io/repo/:idshould direct to/:id. If you want to host on GitHub pages and encounter this issue,hosting your single page app on GitHub Pageswill help you out.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:April 25, 2019Category:TechnicalTagsjavascriptreactrouterNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.928,
        "word_count": 716,
        "chunk_id": "754d926908fe26e9a4ce698170e923f0",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "Using React Router for a Single Page ApplicationReact doesn't come with a built-in router, but we can easily achieve routing with thereact-router-domlibrary.Routingis how a web applications direct traffic. (If you know what routing is, feel free to skip this section.)Example: If you go totaniarascia.com, you end up on my home page. If you go totaniarascia.com/me, you're redirected to my about me page. If you go totaniarascia.com/categories/javascriptortaniarascia.com/categories/css, you end up on a category listing page. The routes for these pages look something like this:/- root/:page_id- page/categories/:category_id- categoryI'm not actually making a folder calledcategoriesand filling it with a bunch of files likejavascript.htmlorcss.html, I just have one template and the router knows to direct to the proper template. Once it gets to the template, it can pull from the URL to know which variables to display - for example, JavaScript or CSS related posts.This website also happens to be aSingle Page Application(or SPA) - only one page is loaded, and every click to a new page loads some additional JSON data, but does not actually request a new resource like loadingindex.htmlandabout-me.htmlwould.I'm going to show you how to set up a simple SPA in React withreact-router-dom, and pull in data dynamically through the URL. Below is the source of the completed project if you get lost along the way.View SourcePrerequisitesReadGetting Started with ReactorBuild a React App with Hooksif you don't know React or React Hooks yet.ReadHow to Connect to an API in JavaScriptif you don't know how to work with APIs at all.InstallationCreate a new React app.npx create-react-app router-exampleCreating a new React app in /Users/taniarascia/dev/sandbox/router-example. Installing packages. This might take a couple of minutes. Installing react, react-dom, and react-scripts...Our project has two dependencies -react-router-domfor the router, andaxiosfor making API calls.npminstallreact-router-dom axiosoryarnaddreact-router-dom axiosBrowser RouterTo usereact-router-dom, we need to wrap our entireAppcomponent inBrowserRouter. There are two types of routers:BrowserRouter- makes pretty URLs likeexample.com/about.HashRouter- makes URLs with the octothorpe (or hashtag, if you will) that would look likeexample.com/#about.Let's useBrowserRouter.src/index.jsimportReactfrom'react'import{render} rom'react-dom'import{BrowserRouter} rom'react-router-dom'importAppfrom'./App'render(<BrowserRouter><App/></BrowserRouter>,document.querySelector('#root'))Route and SwitchNow inApp.js, we can decide on the routes we want to use and direct accordingly. We'll useRouteandSwitchfor this task.Switch- Groups all your routes together, and ensures they take precedence from top-to-bottom.Route- Each individual route.App.jsimportReactfrom'react'import{Route,Switch} rom'react-router-dom'// We will create these two pages in a momentimportHomePagefrom'./pages/HomePage'importUserPagefrom'./pages/UserPage'exportdefaultfunctionApp(){return(<Switch><Routeexactpath=\"/\"component={HomePage}/><Routepath=\"/:id\"component={UserPage}/></Switch>)} e're matching the root route (/) toHomePage, and dynamically matching any other page toUserPage. I only have one route for this simple example, but you could do more like this:<Switch><Routeexactpath=\"/\"component={HomePage}/><Routepath=\"/:id\"component={UserPage}/><Routepath=\"/categories\"component={CategoriesPage}/><Routepath=\"/categories/:id\"component={IndividualCategoryPage}/></Switch>This would ensure thattaniarascia.com/categorieswould go to a page listing all categories, buttaniarascia.com/categories/javascriptwould go to a completely different template for the individual category listing.LinkIn order to link to a page within the SPA, we'll useLink. If we used the traditional<a href=\"/route\">, it would make a completely new request and reload the page, so we haveLinkto help us out.src/pages/HomePage.jsimportReactfrom'react'import{Link} rom'react-router-dom'exportdefaultfunctionHomePage(){return(<divclassName=\"container\"><h1>Home Page</h1><p><Linkto=\"/taniarascia\">taniarascia</Link>on GitHub.</p></div>)} o now I'm going to my first route, the root route which is loadingHomePage, and I see the content and the link.Dynamic Route ParameterOurLinkis navigating to/taniarascia, which will match the/:idparameter inRoute. In order to dynamically get the content from the URL - in this case,taniarascia- we'll usematch.params.idfrom theprops.I'm going to use that parameter to make a call to the GitHub API and retrieve my data. In this example I'll be using Hooks, so if you're not familiar with them, please readBuilding a CRUD App with Hooks.src/pages/UserPage.jsimportReact,{useState,useEffect} rom'react'importaxiosfrom'axios'exportdefaultfunctionUserPage(props){// Setting initial stateconstinitialUserState={user:{},loading:true,}// Getter and setter for user stateconst[user,setUser]=useState(initialUserState)// Using useEffect to retrieve data from an API (similar to componentDidMount in a class)useEffect(()=>{constgetUser=async()=>{// Pass our param (:id) to the API callconst{data}=awaitaxios(`https://api.github.com/users/${props.match.params.id}`)// Update statesetUser(data)}// Invoke the async functiongetUser()},[])// Don't forget the `[]`, which will prevent useEffect from running in an infinite loop// Return a table with some data from the API.returnuser.loading?(<div>Loading...</div>):(<divclassName=\"container\"><h1>{props.match.params.id}</h1><table><thead><tr><th>Name</th><th>Location</th><th>Website</th><th>Followers</th></tr></thead><tbody><tr><td>{user.name}</td><td>{user.location}</td><td><ahref={user.blog}>{user.blog}</a></td><td>{user.followers}</td></tr></tbody></table></div>)} onclusionIf you got lost anywhere along the way, view the source on GitHub.View SourceAlso, there is a caveat: if you want to use this on GitHub Pages, it's not smart enough to realize thatyou.github.io/repo/:idshould direct to/:id. If you want to host on GitHub pages and encounter this issue,hosting your single page app on GitHub Pageswill help you out.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:April 25, 2019Category:TechnicalTagsjavascriptreactrouterNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.928,
        "word_count": 716,
        "chunk_id": "754d926908fe26e9a4ce698170e923f0",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "Using React Router for a Single Page ApplicationReact doesn't come with a built-in router, but we can easily achieve routing with thereact-router-domlibrary.Routingis how a web applications direct traffic. (If you know what routing is, feel free to skip this section.)Example: If you go totaniarascia.com, you end up on my home page. If you go totaniarascia.com/me, you're redirected to my about me page. If you go totaniarascia.com/categories/javascriptortaniarascia.com/categories/css, you end up on a category listing page. The routes for these pages look something like this:/- root/:page_id- page/categories/:category_id- categoryI'm not actually making a folder calledcategoriesand filling it with a bunch of files likejavascript.htmlorcss.html, I just have one template and the router knows to direct to the proper template. Once it gets to the template, it can pull from the URL to know which variables to display - for example, JavaScript or CSS related posts.This website also happens to be aSingle Page Application(or SPA) - only one page is loaded, and every click to a new page loads some additional JSON data, but does not actually request a new resource like loadingindex.htmlandabout-me.htmlwould.I'm going to show you how to set up a simple SPA in React withreact-router-dom, and pull in data dynamically through the URL. Below is the source of the completed project if you get lost along the way.View SourcePrerequisitesReadGetting Started with ReactorBuild a React App with Hooksif you don't know React or React Hooks yet.ReadHow to Connect to an API in JavaScriptif you don't know how to work with APIs at all.InstallationCreate a new React app.npx create-react-app router-exampleCreating a new React app in /Users/taniarascia/dev/sandbox/router-example. Installing packages. This might take a couple of minutes. Installing react, react-dom, and react-scripts...Our project has two dependencies -react-router-domfor the router, andaxiosfor making API calls.npminstallreact-router-dom axiosoryarnaddreact-router-dom axiosBrowser RouterTo usereact-router-dom, we need to wrap our entireAppcomponent inBrowserRouter. There are two types of routers:BrowserRouter- makes pretty URLs likeexample.com/about.HashRouter- makes URLs with the octothorpe (or hashtag, if you will) that would look likeexample.com/#about.Let's useBrowserRouter.src/index.jsimportReactfrom'react'import{render} rom'react-dom'import{BrowserRouter} rom'react-router-dom'importAppfrom'./App'render(<BrowserRouter><App/></BrowserRouter>,document.querySelector('#root'))Route and SwitchNow inApp.js, we can decide on the routes we want to use and direct accordingly. We'll useRouteandSwitchfor this task.Switch- Groups all your routes together, and ensures they take precedence from top-to-bottom.Route- Each individual route.App.jsimportReactfrom'react'import{Route,Switch} rom'react-router-dom'// We will create these two pages in a momentimportHomePagefrom'./pages/HomePage'importUserPagefrom'./pages/UserPage'exportdefaultfunctionApp(){return(<Switch><Routeexactpath=\"/\"component={HomePage}/><Routepath=\"/:id\"component={UserPage}/></Switch>)} e're matching the root route (/) toHomePage, and dynamically matching any other page toUserPage. I only have one route for this simple example, but you could do more like this:<Switch><Routeexactpath=\"/\"component={HomePage}/><Routepath=\"/:id\"component={UserPage}/><Routepath=\"/categories\"component={CategoriesPage}/><Routepath=\"/categories/:id\"component={IndividualCategoryPage}/></Switch>This would ensure thattaniarascia.com/categorieswould go to a page listing all categories, buttaniarascia.com/categories/javascriptwould go to a completely different template for the individual category listing.LinkIn order to link to a page within the SPA, we'll useLink. If we used the traditional<a href=\"/route\">, it would make a completely new request and reload the page, so we haveLinkto help us out.src/pages/HomePage.jsimportReactfrom'react'import{Link} rom'react-router-dom'exportdefaultfunctionHomePage(){return(<divclassName=\"container\"><h1>Home Page</h1><p><Linkto=\"/taniarascia\">taniarascia</Link>on GitHub.</p></div>)} o now I'm going to my first route, the root route which is loadingHomePage, and I see the content and the link.Dynamic Route ParameterOurLinkis navigating to/taniarascia, which will match the/:idparameter inRoute. In order to dynamically get the content from the URL - in this case,taniarascia- we'll usematch.params.idfrom theprops.I'm going to use that parameter to make a call to the GitHub API and retrieve my data. In this example I'll be using Hooks, so if you're not familiar with them, please readBuilding a CRUD App with Hooks.src/pages/UserPage.jsimportReact,{useState,useEffect} rom'react'importaxiosfrom'axios'exportdefaultfunctionUserPage(props){// Setting initial stateconstinitialUserState={user:{},loading:true,}// Getter and setter for user stateconst[user,setUser]=useState(initialUserState)// Using useEffect to retrieve data from an API (similar to componentDidMount in a class)useEffect(()=>{constgetUser=async()=>{// Pass our param (:id) to the API callconst{data}=awaitaxios(`https://api.github.com/users/${props.match.params.id}`)// Update statesetUser(data)}// Invoke the async functiongetUser()},[])// Don't forget the `[]`, which will prevent useEffect from running in an infinite loop// Return a table with some data from the API.returnuser.loading?(<div>Loading...</div>):(<divclassName=\"container\"><h1>{props.match.params.id}</h1><table><thead><tr><th>Name</th><th>Location</th><th>Website</th><th>Followers</th></tr></thead><tbody><tr><td>{user.name}</td><td>{user.location}</td><td><ahref={user.blog}>{user.blog}</a></td><td>{user.followers}</td></tr></tbody></table></div>)} onclusionIf you got lost anywhere along the way, view the source on GitHub.View SourceAlso, there is a caveat: if you want to use this on GitHub Pages, it's not smart enough to realize thatyou.github.io/repo/:idshould direct to/:id. If you want to host on GitHub pages and encounter this issue,hosting your single page app on GitHub Pageswill help you out.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:April 25, 2019Category:TechnicalTagsjavascriptreactrouterNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.928,
        "word_count": 716,
        "chunk_id": "754d926908fe26e9a4ce698170e923f0",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "React doesn't come with a built-in router, but we can easily achieve routing with thereact-router-domlibrary.Routingis how a web applications direct traffic. (If you know what routing is, feel free to skip this section.)Example: If you go totaniarascia.com, you end up on my home page. If you go totaniarascia.com/me, you're redirected to my about me page. If you go totaniarascia.com/categories/javascriptortaniarascia.com/categories/css, you end up on a category listing page. The routes for these pages look something like this:/- root/:page_id- page/categories/:category_id- categoryI'm not actually making a folder calledcategoriesand filling it with a bunch of files likejavascript.htmlorcss.html, I just have one template and the router knows to direct to the proper template. Once it gets to the template, it can pull from the URL to know which variables to display - for example, JavaScript or CSS related posts.This website also happens to be aSingle Page Application(or SPA) - only one page is loaded, and every click to a new page loads some additional JSON data, but does not actually request a new resource like loadingindex.htmlandabout-me.htmlwould.I'm going to show you how to set up a simple SPA in React withreact-router-dom, and pull in data dynamically through the URL. Below is the source of the completed project if you get lost along the way.View SourcePrerequisitesReadGetting Started with ReactorBuild a React App with Hooksif you don't know React or React Hooks yet.ReadHow to Connect to an API in JavaScriptif you don't know how to work with APIs at all.InstallationCreate a new React app.npx create-react-app router-exampleCreating a new React app in /Users/taniarascia/dev/sandbox/router-example. Installing packages. This might take a couple of minutes. Installing react, react-dom, and react-scripts...Our project has two dependencies -react-router-domfor the router, andaxiosfor making API calls.npminstallreact-router-dom axiosoryarnaddreact-router-dom axiosBrowser RouterTo usereact-router-dom, we need to wrap our entireAppcomponent inBrowserRouter. There are two types of routers:BrowserRouter- makes pretty URLs likeexample.com/about.HashRouter- makes URLs with the octothorpe (or hashtag, if you will) that would look likeexample.com/#about.Let's useBrowserRouter.src/index.jsimportReactfrom'react'import{render} rom'react-dom'import{BrowserRouter} rom'react-router-dom'importAppfrom'./App'render(<BrowserRouter><App/></BrowserRouter>,document.querySelector('#root'))Route and SwitchNow inApp.js, we can decide on the routes we want to use and direct accordingly. We'll useRouteandSwitchfor this task.Switch- Groups all your routes together, and ensures they take precedence from top-to-bottom.Route- Each individual route.App.jsimportReactfrom'react'import{Route,Switch} rom'react-router-dom'// We will create these two pages in a momentimportHomePagefrom'./pages/HomePage'importUserPagefrom'./pages/UserPage'exportdefaultfunctionApp(){return(<Switch><Routeexactpath=\"/\"component={HomePage}/><Routepath=\"/:id\"component={UserPage}/></Switch>)} e're matching the root route (/) toHomePage, and dynamically matching any other page toUserPage. I only have one route for this simple example, but you could do more like this:<Switch><Routeexactpath=\"/\"component={HomePage}/><Routepath=\"/:id\"component={UserPage}/><Routepath=\"/categories\"component={CategoriesPage}/><Routepath=\"/categories/:id\"component={IndividualCategoryPage}/></Switch>This would ensure thattaniarascia.com/categorieswould go to a page listing all categories, buttaniarascia.com/categories/javascriptwould go to a completely different template for the individual category listing.LinkIn order to link to a page within the SPA, we'll useLink. If we used the traditional<a href=\"/route\">, it would make a completely new request and reload the page, so we haveLinkto help us out.src/pages/HomePage.jsimportReactfrom'react'import{Link} rom'react-router-dom'exportdefaultfunctionHomePage(){return(<divclassName=\"container\"><h1>Home Page</h1><p><Linkto=\"/taniarascia\">taniarascia</Link>on GitHub.</p></div>)} o now I'm going to my first route, the root route which is loadingHomePage, and I see the content and the link.Dynamic Route ParameterOurLinkis navigating to/taniarascia, which will match the/:idparameter inRoute. In order to dynamically get the content from the URL - in this case,taniarascia- we'll usematch.params.idfrom theprops.I'm going to use that parameter to make a call to the GitHub API and retrieve my data. In this example I'll be using Hooks, so if you're not familiar with them, please readBuilding a CRUD App with Hooks.src/pages/UserPage.jsimportReact,{useState,useEffect} rom'react'importaxiosfrom'axios'exportdefaultfunctionUserPage(props){// Setting initial stateconstinitialUserState={user:{},loading:true,}// Getter and setter for user stateconst[user,setUser]=useState(initialUserState)// Using useEffect to retrieve data from an API (similar to componentDidMount in a class)useEffect(()=>{constgetUser=async()=>{// Pass our param (:id) to the API callconst{data}=awaitaxios(`https://api.github.com/users/${props.match.params.id}`)// Update statesetUser(data)}// Invoke the async functiongetUser()},[])// Don't forget the `[]`, which will prevent useEffect from running in an infinite loop// Return a table with some data from the API.returnuser.loading?(<div>Loading...</div>):(<divclassName=\"container\"><h1>{props.match.params.id}</h1><table><thead><tr><th>Name</th><th>Location</th><th>Website</th><th>Followers</th></tr></thead><tbody><tr><td>{user.name}</td><td>{user.location}</td><td><ahref={user.blog}>{user.blog}</a></td><td>{user.followers}</td></tr></tbody></table></div>)} onclusionIf you got lost anywhere along the way, view the source on GitHub.View SourceAlso, there is a caveat: if you want to use this on GitHub Pages, it's not smart enough to realize thatyou.github.io/repo/:idshould direct to/:id. If you want to host on GitHub pages and encounter this issue,hosting your single page app on GitHub Pageswill help you out.",
        "chunk_type": "code_markup",
        "tag": "section",
        "score": 0.928,
        "word_count": 656,
        "chunk_id": "71a1748f5f5cbd2f3cc9d533534bf2e0",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "React doesn't come with a built-in router, but we can easily achieve routing with thereact-router-domlibrary.Routingis how a web applications direct traffic. (If you know what routing is, feel free to skip this section.)Example: If you go totaniarascia.com, you end up on my home page. If you go totaniarascia.com/me, you're redirected to my about me page. If you go totaniarascia.com/categories/javascriptortaniarascia.com/categories/css, you end up on a category listing page. The routes for these pages look something like this:/- root/:page_id- page/categories/:category_id- categoryI'm not actually making a folder calledcategoriesand filling it with a bunch of files likejavascript.htmlorcss.html, I just have one template and the router knows to direct to the proper template. Once it gets to the template, it can pull from the URL to know which variables to display - for example, JavaScript or CSS related posts.This website also happens to be aSingle Page Application(or SPA) - only one page is loaded, and every click to a new page loads some additional JSON data, but does not actually request a new resource like loadingindex.htmlandabout-me.htmlwould.I'm going to show you how to set up a simple SPA in React withreact-router-dom, and pull in data dynamically through the URL. Below is the source of the completed project if you get lost along the way.View SourcePrerequisitesReadGetting Started with ReactorBuild a React App with Hooksif you don't know React or React Hooks yet.ReadHow to Connect to an API in JavaScriptif you don't know how to work with APIs at all.InstallationCreate a new React app.npx create-react-app router-exampleCreating a new React app in /Users/taniarascia/dev/sandbox/router-example. Installing packages. This might take a couple of minutes. Installing react, react-dom, and react-scripts...Our project has two dependencies -react-router-domfor the router, andaxiosfor making API calls.npminstallreact-router-dom axiosoryarnaddreact-router-dom axiosBrowser RouterTo usereact-router-dom, we need to wrap our entireAppcomponent inBrowserRouter. There are two types of routers:BrowserRouter- makes pretty URLs likeexample.com/about.HashRouter- makes URLs with the octothorpe (or hashtag, if you will) that would look likeexample.com/#about.Let's useBrowserRouter.src/index.jsimportReactfrom'react'import{render} rom'react-dom'import{BrowserRouter} rom'react-router-dom'importAppfrom'./App'render(<BrowserRouter><App/></BrowserRouter>,document.querySelector('#root'))Route and SwitchNow inApp.js, we can decide on the routes we want to use and direct accordingly. We'll useRouteandSwitchfor this task.Switch- Groups all your routes together, and ensures they take precedence from top-to-bottom.Route- Each individual route.App.jsimportReactfrom'react'import{Route,Switch} rom'react-router-dom'// We will create these two pages in a momentimportHomePagefrom'./pages/HomePage'importUserPagefrom'./pages/UserPage'exportdefaultfunctionApp(){return(<Switch><Routeexactpath=\"/\"component={HomePage}/><Routepath=\"/:id\"component={UserPage}/></Switch>)} e're matching the root route (/) toHomePage, and dynamically matching any other page toUserPage. I only have one route for this simple example, but you could do more like this:<Switch><Routeexactpath=\"/\"component={HomePage}/><Routepath=\"/:id\"component={UserPage}/><Routepath=\"/categories\"component={CategoriesPage}/><Routepath=\"/categories/:id\"component={IndividualCategoryPage}/></Switch>This would ensure thattaniarascia.com/categorieswould go to a page listing all categories, buttaniarascia.com/categories/javascriptwould go to a completely different template for the individual category listing.LinkIn order to link to a page within the SPA, we'll useLink. If we used the traditional<a href=\"/route\">, it would make a completely new request and reload the page, so we haveLinkto help us out.src/pages/HomePage.jsimportReactfrom'react'import{Link} rom'react-router-dom'exportdefaultfunctionHomePage(){return(<divclassName=\"container\"><h1>Home Page</h1><p><Linkto=\"/taniarascia\">taniarascia</Link>on GitHub.</p></div>)} o now I'm going to my first route, the root route which is loadingHomePage, and I see the content and the link.Dynamic Route ParameterOurLinkis navigating to/taniarascia, which will match the/:idparameter inRoute. In order to dynamically get the content from the URL - in this case,taniarascia- we'll usematch.params.idfrom theprops.I'm going to use that parameter to make a call to the GitHub API and retrieve my data. In this example I'll be using Hooks, so if you're not familiar with them, please readBuilding a CRUD App with Hooks.src/pages/UserPage.jsimportReact,{useState,useEffect} rom'react'importaxiosfrom'axios'exportdefaultfunctionUserPage(props){// Setting initial stateconstinitialUserState={user:{},loading:true,}// Getter and setter for user stateconst[user,setUser]=useState(initialUserState)// Using useEffect to retrieve data from an API (similar to componentDidMount in a class)useEffect(()=>{constgetUser=async()=>{// Pass our param (:id) to the API callconst{data}=awaitaxios(`https://api.github.com/users/${props.match.params.id}`)// Update statesetUser(data)}// Invoke the async functiongetUser()},[])// Don't forget the `[]`, which will prevent useEffect from running in an infinite loop// Return a table with some data from the API.returnuser.loading?(<div>Loading...</div>):(<divclassName=\"container\"><h1>{props.match.params.id}</h1><table><thead><tr><th>Name</th><th>Location</th><th>Website</th><th>Followers</th></tr></thead><tbody><tr><td>{user.name}</td><td>{user.location}</td><td><ahref={user.blog}>{user.blog}</a></td><td>{user.followers}</td></tr></tbody></table></div>)} onclusionIf you got lost anywhere along the way, view the source on GitHub.View SourceAlso, there is a caveat: if you want to use this on GitHub Pages, it's not smart enough to realize thatyou.github.io/repo/:idshould direct to/:id. If you want to host on GitHub pages and encounter this issue,hosting your single page app on GitHub Pageswill help you out.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.928,
        "word_count": 656,
        "chunk_id": "71a1748f5f5cbd2f3cc9d533534bf2e0",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "id": "/using-react-router-spa/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "importReact,{useState,useEffect} rom'react'importaxiosfrom'axios'exportdefaultfunctionUserPage(props){// Setting initial stateconstinitialUserState={user:{},loading:true,}// Getter and setter for user stateconst[user,setUser]=useState(initialUserState)// Using useEffect to retrieve data from an API (similar to componentDidMount in a class)useEffect(()=>{constgetUser=async()=>{// Pass our param (:id) to the API callconst{data}=awaitaxios(`https://api.github.com/users/${props.match.params.id}`)// Update statesetUser(data)}// Invoke the async functiongetUser()},[])// Don't forget the `[]`, which will prevent useEffect from running in an infinite loop// Return a table with some data from the API.returnuser.loading?(<div>Loading...</div>):(<divclassName=\"container\"><h1>{props.match.params.id}</h1><table><thead><tr><th>Name</th><th>Location</th><th>Website</th><th>Followers</th></tr></thead><tbody><tr><td>{user.name}</td><td>{user.location}</td><td><ahref={user.blog}>{user.blog}</a></td><td>{user.followers}</td></tr></tbody></table></div>)}",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.9540000000000001,
        "word_count": 62,
        "chunk_id": "a32077b84857454dd911948e04e5fc2e",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "jsx"
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "importReact,{useState,useEffect} rom'react'importaxiosfrom'axios'exportdefaultfunctionUserPage(props){// Setting initial stateconstinitialUserState={user:{},loading:true,}// Getter and setter for user stateconst[user,setUser]=useState(initialUserState)// Using useEffect to retrieve data from an API (similar to componentDidMount in a class)useEffect(()=>{constgetUser=async()=>{// Pass our param (:id) to the API callconst{data}=awaitaxios(`https://api.github.com/users/${props.match.params.id}`)// Update statesetUser(data)}// Invoke the async functiongetUser()},[])// Don't forget the `[]`, which will prevent useEffect from running in an infinite loop// Return a table with some data from the API.returnuser.loading?(<div>Loading...</div>):(<divclassName=\"container\"><h1>{props.match.params.id}</h1><table><thead><tr><th>Name</th><th>Location</th><th>Website</th><th>Followers</th></tr></thead><tbody><tr><td>{user.name}</td><td>{user.location}</td><td><ahref={user.blog}>{user.blog}</a></td><td>{user.followers}</td></tr></tbody></table></div>)}",
        "chunk_type": "code_markup",
        "tag": "pre",
        "score": 0.9540000000000001,
        "word_count": 62,
        "chunk_id": "a32077b84857454dd911948e04e5fc2e",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "language-jsx"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "importReact,{useState,useEffect} rom'react'importaxiosfrom'axios'exportdefaultfunctionUserPage(props){// Setting initial stateconstinitialUserState={user:{},loading:true,}// Getter and setter for user stateconst[user,setUser]=useState(initialUserState)// Using useEffect to retrieve data from an API (similar to componentDidMount in a class)useEffect(()=>{constgetUser=async()=>{// Pass our param (:id) to the API callconst{data}=awaitaxios(`https://api.github.com/users/${props.match.params.id}`)// Update statesetUser(data)}// Invoke the async functiongetUser()},[])// Don't forget the `[]`, which will prevent useEffect from running in an infinite loop// Return a table with some data from the API.returnuser.loading?(<div>Loading...</div>):(<divclassName=\"container\"><h1>{props.match.params.id}</h1><table><thead><tr><th>Name</th><th>Location</th><th>Website</th><th>Followers</th></tr></thead><tbody><tr><td>{user.name}</td><td>{user.location}</td><td><ahref={user.blog}>{user.blog}</a></td><td>{user.followers}</td></tr></tbody></table></div>)}",
        "chunk_type": "code_markup",
        "tag": "code",
        "score": 0.9540000000000001,
        "word_count": 62,
        "chunk_id": "a32077b84857454dd911948e04e5fc2e",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "language-jsx"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:April 25, 2019Category:TechnicalTagsjavascriptreactrouterNewsletterSubscribe to the Newsletter",
        "chunk_type": "text",
        "tag": "aside",
        "score": 0.43000000000000005,
        "word_count": 54,
        "chunk_id": "454fd618a530d2bddd61cd76ce494122",
        "metadata": {
          "source_tag": "aside",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "post-sidebar"
            ]
          },
          "technical_indicators": [
            "javascript"
          ]
        }
      },
      {
        "content": "React doesn't come with a built-in router, but we can easily achieve routing with thereact-router-domlibrary.Routingis how a web applications direct traffic. (If you know what routing is, feel free to skip this section.)",
        "chunk_type": "text",
        "tag": "p",
        "score": 0.36,
        "word_count": 33,
        "chunk_id": "de1838b58c7cac8d37c680b47e8e41b4",
        "metadata": {
          "source_tag": "p",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": []
        }
      },
      {
        "content": "importReactfrom'react'import{Route,Switch} rom'react-router-dom'// We will create these two pages in a momentimportHomePagefrom'./pages/HomePage'importUserPagefrom'./pages/UserPage'exportdefaultfunctionApp(){return(<Switch><Routeexactpath=\"/\"component={HomePage}/><Routepath=\"/:id\"component={UserPage}/></Switch>)}",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.319,
        "word_count": 11,
        "chunk_id": "0a0ecc39042a404b25dedcc81f544bd0",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "jsx"
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "importReactfrom'react'import{Route,Switch} rom'react-router-dom'// We will create these two pages in a momentimportHomePagefrom'./pages/HomePage'importUserPagefrom'./pages/UserPage'exportdefaultfunctionApp(){return(<Switch><Routeexactpath=\"/\"component={HomePage}/><Routepath=\"/:id\"component={UserPage}/></Switch>)}",
        "chunk_type": "code_markup",
        "tag": "pre",
        "score": 0.319,
        "word_count": 11,
        "chunk_id": "0a0ecc39042a404b25dedcc81f544bd0",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-jsx"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "importReactfrom'react'import{Route,Switch} rom'react-router-dom'// We will create these two pages in a momentimportHomePagefrom'./pages/HomePage'importUserPagefrom'./pages/UserPage'exportdefaultfunctionApp(){return(<Switch><Routeexactpath=\"/\"component={HomePage}/><Routepath=\"/:id\"component={UserPage}/></Switch>)}",
        "chunk_type": "code_markup",
        "tag": "code",
        "score": 0.319,
        "word_count": 11,
        "chunk_id": "0a0ecc39042a404b25dedcc81f544bd0",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-jsx"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql"
          ]
        }
      }
    ],
    "chunk_count": 15,
    "content_types": [
      "code_markup",
      "text"
    ],
    "technical_concepts": [
      "javascript",
      "react",
      "api",
      "sql"
    ],
    "crawl_metadata": {},
    "technical_content": [
      {
        "id": "282dc9a83be8c24556288cbd9e645a4d",
        "content": "react-router-dom",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "6666cd76f96956469e7be39d750cc7d9",
        "content": "/",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "3bc5ae20d966f128d871f6660599c3b1",
        "content": "/:page_id",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5e791d1e051fb6fdf797395502067e81",
        "content": "/categories/:category_id",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b0b5ccb4a195a07fd3eed14affb8695f",
        "content": "categories",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7796c0b9f39eb4152e44c90da7a2ca9e",
        "content": "javascript.html",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f6be3bf9a2edf873a93d6299280c87f8",
        "content": "css.html",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "eacf331f0ffc35d4b482f1d15a887d3b",
        "content": "index.html",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "accab2588c6b9f6b2106003cd73f65d8",
        "content": "about-me.html",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "282dc9a83be8c24556288cbd9e645a4d",
        "content": "react-router-dom",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "010c7aa68162d276e2226ae937d5946a",
        "content": "npx create-react-app router-example",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "010c7aa68162d276e2226ae937d5946a",
        "content": "npx create-react-app router-example",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "fa23bb389adf1792ac8ebb8a77de7b22",
        "content": "Creating a new React app in /Users/taniarascia/dev/sandbox/router-example. Installing packages. This might take a couple of minutes. Installing react, react-dom, and react-scripts...",
        "type": "code",
        "language": "terminal",
        "relevance": 0.4052631578947369
      },
      {
        "id": "fa23bb389adf1792ac8ebb8a77de7b22",
        "content": "Creating a new React app in /Users/taniarascia/dev/sandbox/router-example. Installing packages. This might take a couple of minutes. Installing react, react-dom, and react-scripts...",
        "type": "code",
        "language": "terminal",
        "relevance": 0.4052631578947369
      },
      {
        "id": "282dc9a83be8c24556288cbd9e645a4d",
        "content": "react-router-dom",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "38c3787939c7b0b6c77d73fce3d28891",
        "content": "axios",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "aa62d7c3c39734b55b09e9861100a392",
        "content": "npm install react-router-dom axios",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "aa62d7c3c39734b55b09e9861100a392",
        "content": "npm install react-router-dom axios",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "c740fd89a4d39ff343c9cc1532e95cec",
        "content": "yarn add react-router-dom axios",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "c740fd89a4d39ff343c9cc1532e95cec",
        "content": "yarn add react-router-dom axios",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "282dc9a83be8c24556288cbd9e645a4d",
        "content": "react-router-dom",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "ac863f346e618f9a959b5c95d5d28941",
        "content": "App",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "bddb70cf4db79d6168c566f45c288798",
        "content": "BrowserRouter",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "bddb70cf4db79d6168c566f45c288798",
        "content": "BrowserRouter",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "423e472f69ed477fbe488a5942cd8704",
        "content": "example.com/about",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6fded6368c5e7713c2dbe0bb85313a69",
        "content": "HashRouter",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "d5d3f2e9b1ee8a0fcc88032ebb5b046a",
        "content": "example.com/ about",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "bddb70cf4db79d6168c566f45c288798",
        "content": "BrowserRouter",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "3d4a7dd5d7aee727143f895c7cf70b9a",
        "content": "import React from 'react' import { render } from 'react-dom' import { BrowserRouter } from 'react-router-dom' import App from './App' render( <BrowserRouter> <App /> </BrowserRouter>, document.querySelector(' root') )",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8157894736842106
      },
      {
        "id": "3d4a7dd5d7aee727143f895c7cf70b9a",
        "content": "import React from 'react' import { render } from 'react-dom' import { BrowserRouter } from 'react-router-dom' import App from './App' render( <BrowserRouter> <App /> </BrowserRouter>, document.querySelector(' root') )",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8157894736842106
      },
      {
        "id": "958f6f56cd42c904603d226cd36a57b6",
        "content": "App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9405c3aff9112c3c60d03b94792877dc",
        "content": "Route",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "bbc155fb2b111bf61c4f5ff892915e6b",
        "content": "Switch",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "bbc155fb2b111bf61c4f5ff892915e6b",
        "content": "Switch",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9405c3aff9112c3c60d03b94792877dc",
        "content": "Route",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f220a29dd82ce94f59f5d135ec44e9d7",
        "content": "import React from 'react' import { Route, Switch } from 'react-router-dom' // We will create these two pages in a moment import HomePage from './pages/HomePage' import UserPage from './pages/UserPage' export default function App() { return ( <Switch> <Route exact path=\"/\" component={HomePage} /> <Route path=\"/:id\" component={UserPage} /> </Switch> ) }",
        "type": "code",
        "language": "jsx",
        "relevance": 1.1105263157894738
      },
      {
        "id": "f220a29dd82ce94f59f5d135ec44e9d7",
        "content": "import React from 'react' import { Route, Switch } from 'react-router-dom' // We will create these two pages in a moment import HomePage from './pages/HomePage' import UserPage from './pages/UserPage' export default function App() { return ( <Switch> <Route exact path=\"/\" component={HomePage} /> <Route path=\"/:id\" component={UserPage} /> </Switch> ) }",
        "type": "code",
        "language": "jsx",
        "relevance": 1.1105263157894738
      },
      {
        "id": "6666cd76f96956469e7be39d750cc7d9",
        "content": "/",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c1756c986aa71a9b63081415a42f1908",
        "content": "HomePage",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "7be92db9e95b1c7b4636a503f5ca319d",
        "content": "UserPage",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cee50258de44086ac6bc903e6f1343e1",
        "content": "<Switch> <Route exact path=\"/\" component={HomePage} /> <Route path=\"/:id\" component={UserPage} /> <Route path=\"/categories\" component={CategoriesPage} /> <Route path=\"/categories/:id\" component={IndividualCategoryPage} /> </Switch>",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "cee50258de44086ac6bc903e6f1343e1",
        "content": "<Switch> <Route exact path=\"/\" component={HomePage} /> <Route path=\"/:id\" component={UserPage} /> <Route path=\"/categories\" component={CategoriesPage} /> <Route path=\"/categories/:id\" component={IndividualCategoryPage} /> </Switch>",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "13aa035f2f008ec5129c3d2a0a93738c",
        "content": "taniarascia.com/categories",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5fbfc2d96c63950270afbb6c9808af38",
        "content": "taniarascia.com/categories/javascript",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "97e7c9a7d06eac006a28bf05467fcc8b",
        "content": "Link",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5ccfd74e4cfa6d734832fd4f3e0319fe",
        "content": "<a href=\"/route\">",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "97e7c9a7d06eac006a28bf05467fcc8b",
        "content": "Link",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "977d0441e903d7f03b4477a6749ccc19",
        "content": "import React from 'react' import { Link } from 'react-router-dom' export default function HomePage() { return ( <div className=\"container\"> <h1>Home Page</h1> <p> <Link to=\"/taniarascia\">taniarascia</Link> on GitHub. </p> </div> ) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8052631578947369
      },
      {
        "id": "977d0441e903d7f03b4477a6749ccc19",
        "content": "import React from 'react' import { Link } from 'react-router-dom' export default function HomePage() { return ( <div className=\"container\"> <h1>Home Page</h1> <p> <Link to=\"/taniarascia\">taniarascia</Link> on GitHub. </p> </div> ) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8052631578947369
      },
      {
        "id": "c1756c986aa71a9b63081415a42f1908",
        "content": "HomePage",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "97e7c9a7d06eac006a28bf05467fcc8b",
        "content": "Link",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2a84d52d8f6780fb2e32f9ff9b0528eb",
        "content": "/taniarascia",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2189c9b4c3ee622449a3fdbefcd2dbe6",
        "content": "/:id",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9405c3aff9112c3c60d03b94792877dc",
        "content": "Route",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c759da1c644d617d3946423e584eca39",
        "content": "taniarascia",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "dfacaf1af1538b3af24a2bfbfb8e934b",
        "content": "match.params.id",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "50fe03ab7bf37089a7e88da9b31ffb3b",
        "content": "props",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "c13655d273ef502bd70547fc2f2785ba",
        "content": "import React, { useState, useEffect } from 'react' import axios from 'axios' export default function UserPage(props) { // Setting initial state const initialUserState = { user: {}, loading: true, } // Getter and setter for user state const [user, setUser] = useState(initialUserState) // Using useEffect to retrieve data from an API (similar to componentDidMount in a class) useEffect(() => { const getUser = async () => { // Pass our param (:id) to the API call const { data } = await axios( https://api.github.com/users/ {props.match.params.id} ) // Update state setUser(data) } // Invoke the async function getUser() }, []) // Don't forget the [] , which will prevent useEffect from running in an infinite loop // Return a table with some data from the API. return user.loading ? ( <div>Loading...</div> ) : ( <div className=\"container\"> <h1>{props.match.params.id}</h1> <table> <thead> <tr> <th>Name</th> <th>Location</th> <th>Website</th> <th>Followers</th> </tr> </thead> <tbody> <tr> <td>{user.name}</td> <td>{user.location}</td> <td> <a href={user.blog}>{user.blog}</a> </td> <td>{user.followers}</td> </tr> </tbody> </table> </div> ) }",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "c13655d273ef502bd70547fc2f2785ba",
        "content": "import React, { useState, useEffect } from 'react' import axios from 'axios' export default function UserPage(props) { // Setting initial state const initialUserState = { user: {}, loading: true, } // Getter and setter for user state const [user, setUser] = useState(initialUserState) // Using useEffect to retrieve data from an API (similar to componentDidMount in a class) useEffect(() => { const getUser = async () => { // Pass our param (:id) to the API call const { data } = await axios( https://api.github.com/users/ {props.match.params.id} ) // Update state setUser(data) } // Invoke the async function getUser() }, []) // Don't forget the [] , which will prevent useEffect from running in an infinite loop // Return a table with some data from the API. return user.loading ? ( <div>Loading...</div> ) : ( <div className=\"container\"> <h1>{props.match.params.id}</h1> <table> <thead> <tr> <th>Name</th> <th>Location</th> <th>Website</th> <th>Followers</th> </tr> </thead> <tbody> <tr> <td>{user.name}</td> <td>{user.location}</td> <td> <a href={user.blog}>{user.blog}</a> </td> <td>{user.followers}</td> </tr> </tbody> </table> </div> ) }",
        "type": "code",
        "language": "jsx",
        "relevance": 1.2
      },
      {
        "id": "a798515a0580fb5f6423f15fd7b7b904",
        "content": "you.github.io/repo/:id",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2189c9b4c3ee622449a3fdbefcd2dbe6",
        "content": "/:id",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      }
    ]
  },
  {
    "metadata": {
      "description": "Turns out, creating an HTML table that has both horizontal scroll and fixed headers can be a tricky problem. As another developer said about…",
      "url": "https://www.taniarascia.com/horizontal-scroll-fixed-headers-table/",
      "title": "Tables with Fixed Headers and Horizontal Scroll | Tania Rascia's Personal Website",
      "source_type": "web",
      "crawl_time": 1730107184.005258,
      "keywords": [
        "sql",
        "web",
        "article",
        "extract",
        "development",
        "information",
        "react"
      ]
    },
    "relevance_score": 0.6907500000000001,
    "chunks": [
      {
        "content": "Tables with Fixed Headers and Horizontal ScrollTurns out, creating an HTML table that has both horizontal scroll and fixed headers can be a tricky problem. As another developer said about this problem,You would think this is easy. But is really isn't.Horizontal ScrollWhen working with a table that has a lot of columns, you can ensure everything remains visible by adding horizontal scroll. You can do this by wrapping the table in a div that hasoverflow-xset toauto.Note: I prefer to useoverflow-x: autoinstead ofoverflow-x: scrollbecausescrollwill always show the scroll container, even if there is no scroll available. It looks cleaner.style.css.table-outer{overflow-x:auto;} ndex.html<divclass=\"table-outer\"><table><thead>/* table columns go here */</thead><tbody>/* table data goes here... */</tbody></table></div>This works great initially, but there can be some problems.If you have a lot of rows, as you scroll down, you can't see which table headers are associated with each cellIf your table rows are selectable and you have bulk actions in the header, you won't see them as you scroll downIf there is more content on the page below the table, you won't see the headers as you scroll downSticky HeadersYou might think that addingposition: stickyto thetheadof thetablewould ensure that as you scroll down, the headers will remain fixed to the top of the screen until you scroll past the table.style.css.table-outer{overflow-x:auto;} head{position:sticky;z-index:2;top:0;} ut as you can see inthis example, the table headers are not fixed to the top of the screen as you scroll down.Since you're now using an overflow container,position: stickywill only apply to the overflow container, and if you're not scrolling within it, it will just be ignored.SolutionThesolutionwas to add a height to the table wrapper. In this example, I chose to make the height 100% of the viewport window, minus 100px to enable the page title and footer to always be visible. This results in a full-screen datagrid type view.style.css.table-outer{overflow-x:auto;height:calc(100vh - 100px);/* full height minus header and footer */} eader{height:60px;} ooter{height:40px;} s you can see here, the page title and footer are always visible, and the table is both horizontally and vertically scrollable. This table has fixed headers and also the first row (ID) is fixed to the left of the screen as you scroll horizontally.ConclusionAnd that's all! Hopefully this helps anyone that is struggling to figure out a good solution for their scrollable table.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 09, 2024Category:TechnicalTagshtmlcssdesignjavascripttablesNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_markup",
        "tag": "main",
        "score": 0.783,
        "word_count": 430,
        "chunk_id": "2d0c3ebed891bccbb2aaf4d683f2eed4",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web"
          ],
          "attributes": {},
          "technical_indicators": [
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "Tables with Fixed Headers and Horizontal ScrollTurns out, creating an HTML table that has both horizontal scroll and fixed headers can be a tricky problem. As another developer said about this problem,You would think this is easy. But is really isn't.Horizontal ScrollWhen working with a table that has a lot of columns, you can ensure everything remains visible by adding horizontal scroll. You can do this by wrapping the table in a div that hasoverflow-xset toauto.Note: I prefer to useoverflow-x: autoinstead ofoverflow-x: scrollbecausescrollwill always show the scroll container, even if there is no scroll available. It looks cleaner.style.css.table-outer{overflow-x:auto;} ndex.html<divclass=\"table-outer\"><table><thead>/* table columns go here */</thead><tbody>/* table data goes here... */</tbody></table></div>This works great initially, but there can be some problems.If you have a lot of rows, as you scroll down, you can't see which table headers are associated with each cellIf your table rows are selectable and you have bulk actions in the header, you won't see them as you scroll downIf there is more content on the page below the table, you won't see the headers as you scroll downSticky HeadersYou might think that addingposition: stickyto thetheadof thetablewould ensure that as you scroll down, the headers will remain fixed to the top of the screen until you scroll past the table.style.css.table-outer{overflow-x:auto;} head{position:sticky;z-index:2;top:0;} ut as you can see inthis example, the table headers are not fixed to the top of the screen as you scroll down.Since you're now using an overflow container,position: stickywill only apply to the overflow container, and if you're not scrolling within it, it will just be ignored.SolutionThesolutionwas to add a height to the table wrapper. In this example, I chose to make the height 100% of the viewport window, minus 100px to enable the page title and footer to always be visible. This results in a full-screen datagrid type view.style.css.table-outer{overflow-x:auto;height:calc(100vh - 100px);/* full height minus header and footer */} eader{height:60px;} ooter{height:40px;} s you can see here, the page title and footer are always visible, and the table is both horizontally and vertically scrollable. This table has fixed headers and also the first row (ID) is fixed to the left of the screen as you scroll horizontally.ConclusionAnd that's all! Hopefully this helps anyone that is struggling to figure out a good solution for their scrollable table.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 09, 2024Category:TechnicalTagshtmlcssdesignjavascripttablesNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.783,
        "word_count": 430,
        "chunk_id": "2d0c3ebed891bccbb2aaf4d683f2eed4",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web"
          ],
          "attributes": {},
          "technical_indicators": [
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "Tables with Fixed Headers and Horizontal ScrollTurns out, creating an HTML table that has both horizontal scroll and fixed headers can be a tricky problem. As another developer said about this problem,You would think this is easy. But is really isn't.Horizontal ScrollWhen working with a table that has a lot of columns, you can ensure everything remains visible by adding horizontal scroll. You can do this by wrapping the table in a div that hasoverflow-xset toauto.Note: I prefer to useoverflow-x: autoinstead ofoverflow-x: scrollbecausescrollwill always show the scroll container, even if there is no scroll available. It looks cleaner.style.css.table-outer{overflow-x:auto;} ndex.html<divclass=\"table-outer\"><table><thead>/* table columns go here */</thead><tbody>/* table data goes here... */</tbody></table></div>This works great initially, but there can be some problems.If you have a lot of rows, as you scroll down, you can't see which table headers are associated with each cellIf your table rows are selectable and you have bulk actions in the header, you won't see them as you scroll downIf there is more content on the page below the table, you won't see the headers as you scroll downSticky HeadersYou might think that addingposition: stickyto thetheadof thetablewould ensure that as you scroll down, the headers will remain fixed to the top of the screen until you scroll past the table.style.css.table-outer{overflow-x:auto;} head{position:sticky;z-index:2;top:0;} ut as you can see inthis example, the table headers are not fixed to the top of the screen as you scroll down.Since you're now using an overflow container,position: stickywill only apply to the overflow container, and if you're not scrolling within it, it will just be ignored.SolutionThesolutionwas to add a height to the table wrapper. In this example, I chose to make the height 100% of the viewport window, minus 100px to enable the page title and footer to always be visible. This results in a full-screen datagrid type view.style.css.table-outer{overflow-x:auto;height:calc(100vh - 100px);/* full height minus header and footer */} eader{height:60px;} ooter{height:40px;} s you can see here, the page title and footer are always visible, and the table is both horizontally and vertically scrollable. This table has fixed headers and also the first row (ID) is fixed to the left of the screen as you scroll horizontally.ConclusionAnd that's all! Hopefully this helps anyone that is struggling to figure out a good solution for their scrollable table.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 09, 2024Category:TechnicalTagshtmlcssdesignjavascripttablesNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.783,
        "word_count": 430,
        "chunk_id": "2d0c3ebed891bccbb2aaf4d683f2eed4",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "Tables with Fixed Headers and Horizontal ScrollTurns out, creating an HTML table that has both horizontal scroll and fixed headers can be a tricky problem. As another developer said about this problem,You would think this is easy. But is really isn't.Horizontal ScrollWhen working with a table that has a lot of columns, you can ensure everything remains visible by adding horizontal scroll. You can do this by wrapping the table in a div that hasoverflow-xset toauto.Note: I prefer to useoverflow-x: autoinstead ofoverflow-x: scrollbecausescrollwill always show the scroll container, even if there is no scroll available. It looks cleaner.style.css.table-outer{overflow-x:auto;} ndex.html<divclass=\"table-outer\"><table><thead>/* table columns go here */</thead><tbody>/* table data goes here... */</tbody></table></div>This works great initially, but there can be some problems.If you have a lot of rows, as you scroll down, you can't see which table headers are associated with each cellIf your table rows are selectable and you have bulk actions in the header, you won't see them as you scroll downIf there is more content on the page below the table, you won't see the headers as you scroll downSticky HeadersYou might think that addingposition: stickyto thetheadof thetablewould ensure that as you scroll down, the headers will remain fixed to the top of the screen until you scroll past the table.style.css.table-outer{overflow-x:auto;} head{position:sticky;z-index:2;top:0;} ut as you can see inthis example, the table headers are not fixed to the top of the screen as you scroll down.Since you're now using an overflow container,position: stickywill only apply to the overflow container, and if you're not scrolling within it, it will just be ignored.SolutionThesolutionwas to add a height to the table wrapper. In this example, I chose to make the height 100% of the viewport window, minus 100px to enable the page title and footer to always be visible. This results in a full-screen datagrid type view.style.css.table-outer{overflow-x:auto;height:calc(100vh - 100px);/* full height minus header and footer */} eader{height:60px;} ooter{height:40px;} s you can see here, the page title and footer are always visible, and the table is both horizontally and vertically scrollable. This table has fixed headers and also the first row (ID) is fixed to the left of the screen as you scroll horizontally.ConclusionAnd that's all! Hopefully this helps anyone that is struggling to figure out a good solution for their scrollable table.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 09, 2024Category:TechnicalTagshtmlcssdesignjavascripttablesNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.783,
        "word_count": 430,
        "chunk_id": "2d0c3ebed891bccbb2aaf4d683f2eed4",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "Tables with Fixed Headers and Horizontal ScrollTurns out, creating an HTML table that has both horizontal scroll and fixed headers can be a tricky problem. As another developer said about this problem,You would think this is easy. But is really isn't.Horizontal ScrollWhen working with a table that has a lot of columns, you can ensure everything remains visible by adding horizontal scroll. You can do this by wrapping the table in a div that hasoverflow-xset toauto.Note: I prefer to useoverflow-x: autoinstead ofoverflow-x: scrollbecausescrollwill always show the scroll container, even if there is no scroll available. It looks cleaner.style.css.table-outer{overflow-x:auto;} ndex.html<divclass=\"table-outer\"><table><thead>/* table columns go here */</thead><tbody>/* table data goes here... */</tbody></table></div>This works great initially, but there can be some problems.If you have a lot of rows, as you scroll down, you can't see which table headers are associated with each cellIf your table rows are selectable and you have bulk actions in the header, you won't see them as you scroll downIf there is more content on the page below the table, you won't see the headers as you scroll downSticky HeadersYou might think that addingposition: stickyto thetheadof thetablewould ensure that as you scroll down, the headers will remain fixed to the top of the screen until you scroll past the table.style.css.table-outer{overflow-x:auto;} head{position:sticky;z-index:2;top:0;} ut as you can see inthis example, the table headers are not fixed to the top of the screen as you scroll down.Since you're now using an overflow container,position: stickywill only apply to the overflow container, and if you're not scrolling within it, it will just be ignored.SolutionThesolutionwas to add a height to the table wrapper. In this example, I chose to make the height 100% of the viewport window, minus 100px to enable the page title and footer to always be visible. This results in a full-screen datagrid type view.style.css.table-outer{overflow-x:auto;height:calc(100vh - 100px);/* full height minus header and footer */} eader{height:60px;} ooter{height:40px;} s you can see here, the page title and footer are always visible, and the table is both horizontally and vertically scrollable. This table has fixed headers and also the first row (ID) is fixed to the left of the screen as you scroll horizontally.ConclusionAnd that's all! Hopefully this helps anyone that is struggling to figure out a good solution for their scrollable table.About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 09, 2024Category:TechnicalTagshtmlcssdesignjavascripttablesNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.783,
        "word_count": 430,
        "chunk_id": "2d0c3ebed891bccbb2aaf4d683f2eed4",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:October 09, 2024Category:TechnicalTagshtmlcssdesignjavascripttablesNewsletterSubscribe to the Newsletter",
        "chunk_type": "technical_content",
        "tag": "aside",
        "score": 0.31100000000000005,
        "word_count": 54,
        "chunk_id": "a40bd166d49b2dbb38bd307b6ded3614",
        "metadata": {
          "source_tag": "aside",
          "keywords_found": [
            "web"
          ],
          "attributes": {
            "class": [
              "post-sidebar"
            ]
          },
          "technical_indicators": [
            "javascript",
            "sql"
          ]
        }
      },
      {
        "content": "Turns out, creating an HTML table that has both horizontal scroll and fixed headers can be a tricky problem. As another developer said about this problem,You would think this is easy. But is really isn't.Horizontal ScrollWhen working with a table that has a lot of columns, you can ensure everything remains visible by adding horizontal scroll. You can do this by wrapping the table in a div that hasoverflow-xset toauto.Note: I prefer to useoverflow-x: autoinstead ofoverflow-x: scrollbecausescrollwill always show the scroll container, even if there is no scroll available. It looks cleaner.style.css.table-outer{overflow-x:auto;} ndex.html<divclass=\"table-outer\"><table><thead>/* table columns go here */</thead><tbody>/* table data goes here... */</tbody></table></div>This works great initially, but there can be some problems.If you have a lot of rows, as you scroll down, you can't see which table headers are associated with each cellIf your table rows are selectable and you have bulk actions in the header, you won't see them as you scroll downIf there is more content on the page below the table, you won't see the headers as you scroll downSticky HeadersYou might think that addingposition: stickyto thetheadof thetablewould ensure that as you scroll down, the headers will remain fixed to the top of the screen until you scroll past the table.style.css.table-outer{overflow-x:auto;} head{position:sticky;z-index:2;top:0;} ut as you can see inthis example, the table headers are not fixed to the top of the screen as you scroll down.Since you're now using an overflow container,position: stickywill only apply to the overflow container, and if you're not scrolling within it, it will just be ignored.SolutionThesolutionwas to add a height to the table wrapper. In this example, I chose to make the height 100% of the viewport window, minus 100px to enable the page title and footer to always be visible. This results in a full-screen datagrid type view.style.css.table-outer{overflow-x:auto;height:calc(100vh - 100px);/* full height minus header and footer */} eader{height:60px;} ooter{height:40px;} s you can see here, the page title and footer are always visible, and the table is both horizontally and vertically scrollable. This table has fixed headers and also the first row (ID) is fixed to the left of the screen as you scroll horizontally.ConclusionAnd that's all! Hopefully this helps anyone that is struggling to figure out a good solution for their scrollable table.",
        "chunk_type": "code_markup",
        "tag": "section",
        "score": 0.65,
        "word_count": 371,
        "chunk_id": "de3023a9cee88411bdad2505ddeafdc3",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "sql"
          ]
        }
      },
      {
        "content": "Turns out, creating an HTML table that has both horizontal scroll and fixed headers can be a tricky problem. As another developer said about this problem,You would think this is easy. But is really isn't.Horizontal ScrollWhen working with a table that has a lot of columns, you can ensure everything remains visible by adding horizontal scroll. You can do this by wrapping the table in a div that hasoverflow-xset toauto.Note: I prefer to useoverflow-x: autoinstead ofoverflow-x: scrollbecausescrollwill always show the scroll container, even if there is no scroll available. It looks cleaner.style.css.table-outer{overflow-x:auto;} ndex.html<divclass=\"table-outer\"><table><thead>/* table columns go here */</thead><tbody>/* table data goes here... */</tbody></table></div>This works great initially, but there can be some problems.If you have a lot of rows, as you scroll down, you can't see which table headers are associated with each cellIf your table rows are selectable and you have bulk actions in the header, you won't see them as you scroll downIf there is more content on the page below the table, you won't see the headers as you scroll downSticky HeadersYou might think that addingposition: stickyto thetheadof thetablewould ensure that as you scroll down, the headers will remain fixed to the top of the screen until you scroll past the table.style.css.table-outer{overflow-x:auto;} head{position:sticky;z-index:2;top:0;} ut as you can see inthis example, the table headers are not fixed to the top of the screen as you scroll down.Since you're now using an overflow container,position: stickywill only apply to the overflow container, and if you're not scrolling within it, it will just be ignored.SolutionThesolutionwas to add a height to the table wrapper. In this example, I chose to make the height 100% of the viewport window, minus 100px to enable the page title and footer to always be visible. This results in a full-screen datagrid type view.style.css.table-outer{overflow-x:auto;height:calc(100vh - 100px);/* full height minus header and footer */} eader{height:60px;} ooter{height:40px;} s you can see here, the page title and footer are always visible, and the table is both horizontally and vertically scrollable. This table has fixed headers and also the first row (ID) is fixed to the left of the screen as you scroll horizontally.ConclusionAnd that's all! Hopefully this helps anyone that is struggling to figure out a good solution for their scrollable table.",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.65,
        "word_count": 371,
        "chunk_id": "de3023a9cee88411bdad2505ddeafdc3",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [],
          "attributes": {
            "id": "/horizontal-scroll-fixed-headers-table/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "sql"
          ]
        }
      }
    ],
    "chunk_count": 8,
    "content_types": [
      "code_markup",
      "technical_content"
    ],
    "technical_concepts": [
      "javascript",
      "sql"
    ],
    "crawl_metadata": {},
    "technical_content": [
      {
        "id": "d25a19fe4c57824fe4d363b2dd065988",
        "content": "overflow-x",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9df22f196a33acd0b372fe502de51211",
        "content": "auto",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "89a1df4bc673ea6907874e2710dcb38f",
        "content": "overflow-x: auto",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "c26090dc5f75cfb4d1670e7f831373d1",
        "content": "overflow-x: scroll",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "089b0cdd8835d09cb1cabf38b3ce9c09",
        "content": "scroll",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "6654be48828cfcdfe7406569a8d0a533",
        "content": ".table-outer { overflow-x: auto }",
        "type": "code",
        "language": "css",
        "relevance": 0.605263157894737
      },
      {
        "id": "6654be48828cfcdfe7406569a8d0a533",
        "content": ".table-outer { overflow-x: auto }",
        "type": "code",
        "language": "css",
        "relevance": 0.605263157894737
      },
      {
        "id": "8cd28d02707b4f7d71f381382b2a07dd",
        "content": "<div class=\"table-outer\"> <table> <thead> /* table columns go here */ </thead> <tbody> /* table data goes here... */ </tbody> </table> </div>",
        "type": "code",
        "language": "html",
        "relevance": 0.605263157894737
      },
      {
        "id": "8cd28d02707b4f7d71f381382b2a07dd",
        "content": "<div class=\"table-outer\"> <table> <thead> /* table columns go here */ </thead> <tbody> /* table data goes here... */ </tbody> </table> </div>",
        "type": "code",
        "language": "html",
        "relevance": 0.605263157894737
      },
      {
        "id": "95f999db8aa108fffb51d732982b49d4",
        "content": "position: sticky",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "16fd4602f6ca67f32eebef4afa6df98a",
        "content": "thead",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "aab9e1de16f38176f86d7a92ba337a8d",
        "content": "table",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "e8b223f1a547f51c079735a6d6cfa34f",
        "content": ".table-outer { overflow-x: auto } thead { position: sticky z-index: 2 top: 0 }",
        "type": "code",
        "language": "css",
        "relevance": 0.605263157894737
      },
      {
        "id": "e8b223f1a547f51c079735a6d6cfa34f",
        "content": ".table-outer { overflow-x: auto } thead { position: sticky z-index: 2 top: 0 }",
        "type": "code",
        "language": "css",
        "relevance": 0.605263157894737
      },
      {
        "id": "95f999db8aa108fffb51d732982b49d4",
        "content": "position: sticky",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "36ea86fbbc3f13426196e7de6616156d",
        "content": ".table-outer { overflow-x: auto height: calc(100vh - 100px) /* full height minus header and footer */ } header { height: 60px } footer { height: 40px }",
        "type": "code",
        "language": "css",
        "relevance": 0.605263157894737
      },
      {
        "id": "36ea86fbbc3f13426196e7de6616156d",
        "content": ".table-outer { overflow-x: auto height: calc(100vh - 100px) /* full height minus header and footer */ } header { height: 60px } footer { height: 40px }",
        "type": "code",
        "language": "css",
        "relevance": 0.605263157894737
      }
    ]
  },
  {
    "metadata": {
      "description": "Ever since Hooks were released in React, we've been using the  hook to fetch data, whether directly or abstracted away behind Redux Thunks…",
      "url": "https://www.taniarascia.com/how-to-test-useeffect-api-call/",
      "title": "Testing API Calls With React Testing Library and Jest | Tania Rascia's Personal Website",
      "source_type": "web",
      "crawl_time": 1730107189.464715,
      "keywords": [
        "sql",
        "web",
        "article",
        "extract",
        "development",
        "information",
        "react"
      ]
    },
    "relevance_score": 0.6570799999999999,
    "chunks": [
      {
        "content": "Testing API Calls With React Testing Library and JestEver since Hooks were released in React, we've been using theuseEffecthook to fetch data, whether directly or abstracted away behind Redux Thunks. Figuring out how to test those scenarios can be really frustrating at first, but fortunately it ends up not being very complicated. I'll show you how to testuseEffectwith both successful and failed API calls.PrerequisitesCommand LineReactReact HooksWebpackGoalsSet up a very simple React app with testing using Jest and React Testing LibraryWrite a test for when the API call succeedsWrite a test for when the API call failsSetting up the Application and Test EnvironmentFeel free to skip this part if you want to get right to the good stuff. As I wrote this article, I decided to start with absolutely nothing to see what the bare minimum I could get away with. I wanted all the config files, setup, and modules to get a React environment up and running that outputs a running application and runs tests, with the most up-to-date versions of everything.I know Vite and Rome and Rollup and lord knows what else are all the rage right now - I'm just using a simple webpack setup because it still works and I care more about just showing the tests in this article. However, please leave a comment to enlighten me on some of the improvements they bring to the table!So here's the quick application setup.File structureWhat I ended up with looked like this:.\n├── dist\n├── node_modules\n├── src\n│   ├── App.js\n│   └── index.js\n├── tests\n│   └── App.test.js\n├── .babelrc\n├── jest.config.js\n├── package.json\n├── setupJest.js\n└── webpack.config.jsI won't force you to go on the whole journey as I did, figuring out what was needed, but I'll cut right to the end and let you know all the packages.Required packagesFor the application, React + React DOM was necessary, as well as a few Babel packages.npmi\\react\\react-dom\\@babel/preset-env\\@babel/preset-reactFor setup, bundling, and compilation, webpack, webpack CLI, and a Babel loader were necessary.npmi\\webpack\\webpack-cli\\babel-loaderAnd for testing, Jest, JSDom, and React Testing Library were necessary. I also brought in a Jest Mock package because it makes life easier.npmi -D\\@testing-library/jest-dom\\@testing-library/react\\jest\\jest-environment-jsdom\\jest-fetch-mockSo these are all the packages necessary to get an environment up and running that spits out an application and tests it. Of course, there are some additional quality of life improvements you'd want, like the webpack serve dev server for hot reloads, but it's not necessary.Config filesBabelOf course, there's theBabel config file, the same one you've probably been using for years..babelrc{\"presets\":[\"@babel/preset-env\",\"@babel/preset-react\"]} ebpackAnd thewebpack config file. It makes most of the decisions by default, such as usingindex.jsas an entry point and outputting to adistfolder. I just needed to add a module to tell it to usebabel-loader.webpack.config.jsmodule.exports={mode:'production',module:{rules:[{test:/\\.js$/,use:['babel-loader']}],},} estAs for theJest config file, I just needed it to usejsdomand set the right directories.jest.config.jsmodule.exports={testEnvironment:'jsdom',rootDir:'.',modulePaths:['<rootDir>'],moduleDirectories:['node_modules','src'],setupFilesAfterEnv:['<rootDir>/setupJest.js'],} inally, insetupJest.js, we just want to enablejest-fetch-mockand import the Jest DOM.setupJest.jsrequire('jest-fetch-mock').enableMocks()import'@testing-library/jest-dom'PackageAdding a script topackage.jsonthat just runswebpackallows you to test the build and ensure the application is running. I also added ajestcommand for the test. Everything else is just the packages brought in by the commands.package.json{\"scripts\":{\"test\":\"jest --coverage\",\"build\":\"webpack\"}} o that's everything as far as config for both the application and testing, now to set up the simple app.App filesNot too much has changed as far as the React index file goes. TheReactDOMimport and API is slightly different from the last time I used it, andStrictModeseems to be the default mode, so I'm just rendering to the#rootand pulling in a component.index.jsimportReactfrom'react'importReactDOMfrom'react-dom/client'import{App} rom'./App'constroot=ReactDOM.createRoot(document.getElementById('root'))root.render(<React.StrictMode><App/></React.StrictMode>)So now comes the code we're going to be testing,App.js. I'm just going to make this file do some \"componentDidMount\"-esque fetching of data. I know it's not realistic for this to be done inApp.js, but the way the code will be written will be pretty similar in a production level app, it'll just be somewhere else further down.I'm going to useJSON Placeholderfor the example API, but testing will be the same with your own internal APIs, a wrapper around fetch, and even if you're using Redux or some other state management.So I'll start off with a title and a message, and start setting up the state we'll use:usersfor the data coming in, anderrorin case an error gets thrown. I could have added in someloadingstate, but I just kept it really simple. It should be easy to figure out testing the loading states after reading this article.App.jsimportReact,{useState,useEffect} rom'react'exportconstApp=()=>{const[users,setUsers]=useState(null)const[error,setError]=useState(null)return(<><h1>List of Users</h1><p>No users found</p></>)} ow I'll add in theuseEffectthat fetches data from the API and updates the data state, otherwise updates the error state.App.jsimportReact,{useState,useEffect} rom'react'exportconstApp=()=>{const[users,setUsers]=useState(null)const[error,setError]=useState(null)useEffect(()=>{constfetchAllUsers=async()=>{try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/users')constdata=awaitresponse.json()setUsers(data)} atch(err){setError('Something went wrong!')}} etchAllUsers()},[])return(<><h1>List of Users</h1><p>No users found</p></>)} inally, I'm just displaying the error if one exists, and displaying the users if they loaded.App.jsimportReact,{useState,useEffect} rom'react'exportconstApp=()=>{const[users,setUsers]=useState(null)const[error,setError]=useState(null)useEffect(()=>{// ...},[])return(<><h1>List of Users</h1>{error&&<div>{error}</div>}{users?(<ul>{users.map((user)=>(<likey={user.id}>{user.name}</li>))}</ul>):(<p>No users found</p>)}</>)} kay, now the whole application is complete and we can write the tests. You can build to ensure everything is working properly first.Build:npmrun buildOutput:> webpack\n\nasset main.js 145 KiB [compared for emit] [minimized] (name: main) 1 related asset\n...\nwebpack 5.75.0 compiled successfully in 4035 msI usehttp-serverin thedistfolder to test the output of an application quickly.Writing the TestsYou may not have needed all the above context and just want to see the tests. I wrote about it all since it's an up-to-date (for now) example of everything you need to get started, which can be nicer than opening twenty tabs in StackOverflow and seeing answers from 2016.Now to get started writing the tests. I opted to put them inApp.test.js, but of course there are differing opinions on where tests should live (which I discussed a bit in theReact Architecturearticle). I'm just putting them in atestsfolder for the sake of this example.To set up, we'll userenderandscreenfrom theReact Testing Library. As implied by the names,renderis responsible for rendering your app to the JS Dom, andscreenallows you to interact with it and see what's there.I'm putting everything in adescribe()block forApp, and making surefetchMockresets between each test.tests/App.test.jsimportReactfrom'react'import{render,screen} rom'@testing-library/react'import{App}",
        "chunk_type": "code_import",
        "tag": "main",
        "score": 0.897,
        "word_count": 969,
        "chunk_id": "bbfb01e1dad2c1fc78bf934fc07e1287",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "rom'src/App.js'describe('App',()=>{beforeEach(()=>{fetchMock.resetMocks()})test('renders users when API call succeeds',async()=>{})test('renders error when API call fails',async()=>{})})When the API call succeedsFirst, I'll write the test for when the API call succeeds.UsingfetchMock, I'll mock the resolved value of the JSON Placeholder/usersAPI with a list of fake users.constfakeUsers=[{id:1,name:'Joe'},{id:2,name:'Tony'},]fetchMock.mockResolvedValue({status:200,json:jest.fn(()=>fakeUsers)})Now, what we want is to see what happens after the successfulfetch, which is the users displayed and the \"No users found\" message not to be there.This can be done using a combination ofwaitForandgetBy, which usesactbehind the scenes to wait for the event to happen:awaitwaitFor(()=>{expect(screen.getByText('Joe')).toBeInTheDocument()})However, thefindByquery is a combination ofwaitForandgetBy, so we can simplify that even more into a one liner:expect(awaitscreen.findByText('Joe')).toBeInTheDocument()So here's our code to mock thefetch, render theApp, ensure the data is rendered, and ensure nothing we don't want to see is visible:tests/App.test.jstest('renders users when API call succeeds',async()=>{constfakeUsers=[{id:1,name:'Joe'},{id:2,name:'Tony'},]fetchMock.mockResolvedValue({status:200,json:jest.fn(()=>fakeUsers)})render(<App/>)expect(screen.getByRole('heading')).toHaveTextContent('List of Users')expect(awaitscreen.findByText('Joe')).toBeInTheDocument()expect(awaitscreen.findByText('Tony')).toBeInTheDocument()expect(screen.queryByText('No users found')).not.toBeInTheDocument()})When the API call failsUsing what we've learned in the previous test, writing the next test is pretty easy. Instead of resolving a successful API call, we'll have the API throw an error and ensure the error is visible.tests/App.test.jstest('renders error when API call fails',async()=>{fetchMock.mockReject(()=>Promise.reject('API error'))render(<App/>)expect(awaitscreen.findByText('Something went wrong!')).toBeInTheDocument()expect(awaitscreen.findByText('No users found')).toBeInTheDocument()})Now that both tests are written, we just need to run them.Running the testsUsing thejestcommand, we can run the tests. You can also add the--coverageflag to see if the tests are catching everything.npmtest> jest --coverage PASS  tests/App.test.js App\n    ✓ renders users when API call succeeds (66 ms)\n    ✓ renders error when API call fails (6 ms)\n\n----------|---------|----------|---------|---------|------------------- ile      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s\n----------|---------|----------|---------|---------|------------------- ll files |     100 |      100 |     100 |     100 | App.js   |     100 |      100 |     100 |     100 |\n----------|---------|----------|---------|---------|------------------- est Suites: 1 passed, 1 total ests:       2 passed, 2 total napshots:   0 total ime:        1.91 sAs we can see, the tests passed with 100% coverage, so we get that green dopamine hit.Note: I don't necessarily think having 100% test coverage is particularly meaningful, nor that component tests are the most important type of test. Generally, I think end-to-end tests are the most essential, but unit/component tests can be helpful to supplement them.ConclusionWell, there you have it. React, React Testing Library, Jest, and Webpack, all working in harmony in (almost) TYOOL 2023. Hopefully this helps someone struggling to figure out how to testuseEffector get their environment set up!About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:December 09, 2022Category:TechnicalTagsreacttestingjestwebpackasynchronousapiNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_markup",
        "tag": "main",
        "score": 0.897,
        "word_count": 437,
        "chunk_id": "5856e46e177e4fbd17de4f8fa36fe2f6",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "api"
          ]
        }
      },
      {
        "content": "Testing API Calls With React Testing Library and JestEver since Hooks were released in React, we've been using theuseEffecthook to fetch data, whether directly or abstracted away behind Redux Thunks. Figuring out how to test those scenarios can be really frustrating at first, but fortunately it ends up not being very complicated. I'll show you how to testuseEffectwith both successful and failed API calls.PrerequisitesCommand LineReactReact HooksWebpackGoalsSet up a very simple React app with testing using Jest and React Testing LibraryWrite a test for when the API call succeedsWrite a test for when the API call failsSetting up the Application and Test EnvironmentFeel free to skip this part if you want to get right to the good stuff. As I wrote this article, I decided to start with absolutely nothing to see what the bare minimum I could get away with. I wanted all the config files, setup, and modules to get a React environment up and running that outputs a running application and runs tests, with the most up-to-date versions of everything.I know Vite and Rome and Rollup and lord knows what else are all the rage right now - I'm just using a simple webpack setup because it still works and I care more about just showing the tests in this article. However, please leave a comment to enlighten me on some of the improvements they bring to the table!So here's the quick application setup.File structureWhat I ended up with looked like this:.\n├── dist\n├── node_modules\n├── src\n│   ├── App.js\n│   └── index.js\n├── tests\n│   └── App.test.js\n├── .babelrc\n├── jest.config.js\n├── package.json\n├── setupJest.js\n└── webpack.config.jsI won't force you to go on the whole journey as I did, figuring out what was needed, but I'll cut right to the end and let you know all the packages.Required packagesFor the application, React + React DOM was necessary, as well as a few Babel packages.npmi\\react\\react-dom\\@babel/preset-env\\@babel/preset-reactFor setup, bundling, and compilation, webpack, webpack CLI, and a Babel loader were necessary.npmi\\webpack\\webpack-cli\\babel-loaderAnd for testing, Jest, JSDom, and React Testing Library were necessary. I also brought in a Jest Mock package because it makes life easier.npmi -D\\@testing-library/jest-dom\\@testing-library/react\\jest\\jest-environment-jsdom\\jest-fetch-mockSo these are all the packages necessary to get an environment up and running that spits out an application and tests it. Of course, there are some additional quality of life improvements you'd want, like the webpack serve dev server for hot reloads, but it's not necessary.Config filesBabelOf course, there's theBabel config file, the same one you've probably been using for years..babelrc{\"presets\":[\"@babel/preset-env\",\"@babel/preset-react\"]} ebpackAnd thewebpack config file. It makes most of the decisions by default, such as usingindex.jsas an entry point and outputting to adistfolder. I just needed to add a module to tell it to usebabel-loader.webpack.config.jsmodule.exports={mode:'production',module:{rules:[{test:/\\.js$/,use:['babel-loader']}],},} estAs for theJest config file, I just needed it to usejsdomand set the right directories.jest.config.jsmodule.exports={testEnvironment:'jsdom',rootDir:'.',modulePaths:['<rootDir>'],moduleDirectories:['node_modules','src'],setupFilesAfterEnv:['<rootDir>/setupJest.js'],} inally, insetupJest.js, we just want to enablejest-fetch-mockand import the Jest DOM.setupJest.jsrequire('jest-fetch-mock').enableMocks()import'@testing-library/jest-dom'PackageAdding a script topackage.jsonthat just runswebpackallows you to test the build and ensure the application is running. I also added ajestcommand for the test. Everything else is just the packages brought in by the commands.package.json{\"scripts\":{\"test\":\"jest --coverage\",\"build\":\"webpack\"}} o that's everything as far as config for both the application and testing, now to set up the simple app.App filesNot too much has changed as far as the React index file goes. TheReactDOMimport and API is slightly different from the last time I used it, andStrictModeseems to be the default mode, so I'm just rendering to the#rootand pulling in a component.index.jsimportReactfrom'react'importReactDOMfrom'react-dom/client'import{App} rom'./App'constroot=ReactDOM.createRoot(document.getElementById('root'))root.render(<React.StrictMode><App/></React.StrictMode>)So now comes the code we're going to be testing,App.js. I'm just going to make this file do some \"componentDidMount\"-esque fetching of data. I know it's not realistic for this to be done inApp.js, but the way the code will be written will be pretty similar in a production level app, it'll just be somewhere else further down.I'm going to useJSON Placeholderfor the example API, but testing will be the same with your own internal APIs, a wrapper around fetch, and even if you're using Redux or some other state management.So I'll start off with a title and a message, and start setting up the state we'll use:usersfor the data coming in, anderrorin case an error gets thrown. I could have added in someloadingstate, but I just kept it really simple. It should be easy to figure out testing the loading states after reading this article.App.jsimportReact,{useState,useEffect} rom'react'exportconstApp=()=>{const[users,setUsers]=useState(null)const[error,setError]=useState(null)return(<><h1>List of Users</h1><p>No users found</p></>)} ow I'll add in theuseEffectthat fetches data from the API and updates the data state, otherwise updates the error state.App.jsimportReact,{useState,useEffect} rom'react'exportconstApp=()=>{const[users,setUsers]=useState(null)const[error,setError]=useState(null)useEffect(()=>{constfetchAllUsers=async()=>{try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/users')constdata=awaitresponse.json()setUsers(data)} atch(err){setError('Something went wrong!')}} etchAllUsers()},[])return(<><h1>List of Users</h1><p>No users found</p></>)} inally, I'm just displaying the error if one exists, and displaying the users if they loaded.App.jsimportReact,{useState,useEffect} rom'react'exportconstApp=()=>{const[users,setUsers]=useState(null)const[error,setError]=useState(null)useEffect(()=>{// ...},[])return(<><h1>List of Users</h1>{error&&<div>{error}</div>}{users?(<ul>{users.map((user)=>(<likey={user.id}>{user.name}</li>))}</ul>):(<p>No users found</p>)}</>)} kay, now the whole application is complete and we can write the tests. You can build to ensure everything is working properly first.Build:npmrun buildOutput:> webpack\n\nasset main.js 145 KiB [compared for emit] [minimized] (name: main) 1 related asset\n...\nwebpack 5.75.0 compiled successfully in 4035 msI usehttp-serverin thedistfolder to test the output of an application quickly.Writing the TestsYou may not have needed all the above context and just want to see the tests. I wrote about it all since it's an up-to-date (for now) example of everything you need to get started, which can be nicer than opening twenty tabs in StackOverflow and seeing answers from 2016.Now to get started writing the tests. I opted to put them inApp.test.js, but of course there are differing opinions on where tests should live (which I discussed a bit in theReact Architecturearticle). I'm just putting them in atestsfolder for the sake of this example.To set up, we'll userenderandscreenfrom theReact Testing Library. As implied by the names,renderis responsible for rendering your app to the JS Dom, andscreenallows you to interact with it and see what's there.I'm putting everything in adescribe()block forApp, and making surefetchMockresets between each test.tests/App.test.jsimportReactfrom'react'import{render,screen} rom'@testing-library/react'import{App}",
        "chunk_type": "code_import",
        "tag": "div",
        "score": 0.897,
        "word_count": 969,
        "chunk_id": "bbfb01e1dad2c1fc78bf934fc07e1287",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "rom'src/App.js'describe('App',()=>{beforeEach(()=>{fetchMock.resetMocks()})test('renders users when API call succeeds',async()=>{})test('renders error when API call fails',async()=>{})})When the API call succeedsFirst, I'll write the test for when the API call succeeds.UsingfetchMock, I'll mock the resolved value of the JSON Placeholder/usersAPI with a list of fake users.constfakeUsers=[{id:1,name:'Joe'},{id:2,name:'Tony'},]fetchMock.mockResolvedValue({status:200,json:jest.fn(()=>fakeUsers)})Now, what we want is to see what happens after the successfulfetch, which is the users displayed and the \"No users found\" message not to be there.This can be done using a combination ofwaitForandgetBy, which usesactbehind the scenes to wait for the event to happen:awaitwaitFor(()=>{expect(screen.getByText('Joe')).toBeInTheDocument()})However, thefindByquery is a combination ofwaitForandgetBy, so we can simplify that even more into a one liner:expect(awaitscreen.findByText('Joe')).toBeInTheDocument()So here's our code to mock thefetch, render theApp, ensure the data is rendered, and ensure nothing we don't want to see is visible:tests/App.test.jstest('renders users when API call succeeds',async()=>{constfakeUsers=[{id:1,name:'Joe'},{id:2,name:'Tony'},]fetchMock.mockResolvedValue({status:200,json:jest.fn(()=>fakeUsers)})render(<App/>)expect(screen.getByRole('heading')).toHaveTextContent('List of Users')expect(awaitscreen.findByText('Joe')).toBeInTheDocument()expect(awaitscreen.findByText('Tony')).toBeInTheDocument()expect(screen.queryByText('No users found')).not.toBeInTheDocument()})When the API call failsUsing what we've learned in the previous test, writing the next test is pretty easy. Instead of resolving a successful API call, we'll have the API throw an error and ensure the error is visible.tests/App.test.jstest('renders error when API call fails',async()=>{fetchMock.mockReject(()=>Promise.reject('API error'))render(<App/>)expect(awaitscreen.findByText('Something went wrong!')).toBeInTheDocument()expect(awaitscreen.findByText('No users found')).toBeInTheDocument()})Now that both tests are written, we just need to run them.Running the testsUsing thejestcommand, we can run the tests. You can also add the--coverageflag to see if the tests are catching everything.npmtest> jest --coverage PASS  tests/App.test.js App\n    ✓ renders users when API call succeeds (66 ms)\n    ✓ renders error when API call fails (6 ms)\n\n----------|---------|----------|---------|---------|------------------- ile      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s\n----------|---------|----------|---------|---------|------------------- ll files |     100 |      100 |     100 |     100 | App.js   |     100 |      100 |     100 |     100 |\n----------|---------|----------|---------|---------|------------------- est Suites: 1 passed, 1 total ests:       2 passed, 2 total napshots:   0 total ime:        1.91 sAs we can see, the tests passed with 100% coverage, so we get that green dopamine hit.Note: I don't necessarily think having 100% test coverage is particularly meaningful, nor that component tests are the most important type of test. Generally, I think end-to-end tests are the most essential, but unit/component tests can be helpful to supplement them.ConclusionWell, there you have it. React, React Testing Library, Jest, and Webpack, all working in harmony in (almost) TYOOL 2023. Hopefully this helps someone struggling to figure out how to testuseEffector get their environment set up!About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:December 09, 2022Category:TechnicalTagsreacttestingjestwebpackasynchronousapiNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.897,
        "word_count": 437,
        "chunk_id": "5856e46e177e4fbd17de4f8fa36fe2f6",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "javascript",
            "api"
          ]
        }
      },
      {
        "content": "Testing API Calls With React Testing Library and JestEver since Hooks were released in React, we've been using theuseEffecthook to fetch data, whether directly or abstracted away behind Redux Thunks. Figuring out how to test those scenarios can be really frustrating at first, but fortunately it ends up not being very complicated. I'll show you how to testuseEffectwith both successful and failed API calls.PrerequisitesCommand LineReactReact HooksWebpackGoalsSet up a very simple React app with testing using Jest and React Testing LibraryWrite a test for when the API call succeedsWrite a test for when the API call failsSetting up the Application and Test EnvironmentFeel free to skip this part if you want to get right to the good stuff. As I wrote this article, I decided to start with absolutely nothing to see what the bare minimum I could get away with. I wanted all the config files, setup, and modules to get a React environment up and running that outputs a running application and runs tests, with the most up-to-date versions of everything.I know Vite and Rome and Rollup and lord knows what else are all the rage right now - I'm just using a simple webpack setup because it still works and I care more about just showing the tests in this article. However, please leave a comment to enlighten me on some of the improvements they bring to the table!So here's the quick application setup.File structureWhat I ended up with looked like this:.\n├── dist\n├── node_modules\n├── src\n│   ├── App.js\n│   └── index.js\n├── tests\n│   └── App.test.js\n├── .babelrc\n├── jest.config.js\n├── package.json\n├── setupJest.js\n└── webpack.config.jsI won't force you to go on the whole journey as I did, figuring out what was needed, but I'll cut right to the end and let you know all the packages.Required packagesFor the application, React + React DOM was necessary, as well as a few Babel packages.npmi\\react\\react-dom\\@babel/preset-env\\@babel/preset-reactFor setup, bundling, and compilation, webpack, webpack CLI, and a Babel loader were necessary.npmi\\webpack\\webpack-cli\\babel-loaderAnd for testing, Jest, JSDom, and React Testing Library were necessary. I also brought in a Jest Mock package because it makes life easier.npmi -D\\@testing-library/jest-dom\\@testing-library/react\\jest\\jest-environment-jsdom\\jest-fetch-mockSo these are all the packages necessary to get an environment up and running that spits out an application and tests it. Of course, there are some additional quality of life improvements you'd want, like the webpack serve dev server for hot reloads, but it's not necessary.Config filesBabelOf course, there's theBabel config file, the same one you've probably been using for years..babelrc{\"presets\":[\"@babel/preset-env\",\"@babel/preset-react\"]} ebpackAnd thewebpack config file. It makes most of the decisions by default, such as usingindex.jsas an entry point and outputting to adistfolder. I just needed to add a module to tell it to usebabel-loader.webpack.config.jsmodule.exports={mode:'production',module:{rules:[{test:/\\.js$/,use:['babel-loader']}],},} estAs for theJest config file, I just needed it to usejsdomand set the right directories.jest.config.jsmodule.exports={testEnvironment:'jsdom',rootDir:'.',modulePaths:['<rootDir>'],moduleDirectories:['node_modules','src'],setupFilesAfterEnv:['<rootDir>/setupJest.js'],} inally, insetupJest.js, we just want to enablejest-fetch-mockand import the Jest DOM.setupJest.jsrequire('jest-fetch-mock').enableMocks()import'@testing-library/jest-dom'PackageAdding a script topackage.jsonthat just runswebpackallows you to test the build and ensure the application is running. I also added ajestcommand for the test. Everything else is just the packages brought in by the commands.package.json{\"scripts\":{\"test\":\"jest --coverage\",\"build\":\"webpack\"}} o that's everything as far as config for both the application and testing, now to set up the simple app.App filesNot too much has changed as far as the React index file goes. TheReactDOMimport and API is slightly different from the last time I used it, andStrictModeseems to be the default mode, so I'm just rendering to the#rootand pulling in a component.index.jsimportReactfrom'react'importReactDOMfrom'react-dom/client'import{App} rom'./App'constroot=ReactDOM.createRoot(document.getElementById('root'))root.render(<React.StrictMode><App/></React.StrictMode>)So now comes the code we're going to be testing,App.js. I'm just going to make this file do some \"componentDidMount\"-esque fetching of data. I know it's not realistic for this to be done inApp.js, but the way the code will be written will be pretty similar in a production level app, it'll just be somewhere else further down.I'm going to useJSON Placeholderfor the example API, but testing will be the same with your own internal APIs, a wrapper around fetch, and even if you're using Redux or some other state management.So I'll start off with a title and a message, and start setting up the state we'll use:usersfor the data coming in, anderrorin case an error gets thrown. I could have added in someloadingstate, but I just kept it really simple. It should be easy to figure out testing the loading states after reading this article.App.jsimportReact,{useState,useEffect} rom'react'exportconstApp=()=>{const[users,setUsers]=useState(null)const[error,setError]=useState(null)return(<><h1>List of Users</h1><p>No users found</p></>)} ow I'll add in theuseEffectthat fetches data from the API and updates the data state, otherwise updates the error state.App.jsimportReact,{useState,useEffect} rom'react'exportconstApp=()=>{const[users,setUsers]=useState(null)const[error,setError]=useState(null)useEffect(()=>{constfetchAllUsers=async()=>{try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/users')constdata=awaitresponse.json()setUsers(data)} atch(err){setError('Something went wrong!')}} etchAllUsers()},[])return(<><h1>List of Users</h1><p>No users found</p></>)} inally, I'm just displaying the error if one exists, and displaying the users if they loaded.App.jsimportReact,{useState,useEffect} rom'react'exportconstApp=()=>{const[users,setUsers]=useState(null)const[error,setError]=useState(null)useEffect(()=>{// ...},[])return(<><h1>List of Users</h1>{error&&<div>{error}</div>}{users?(<ul>{users.map((user)=>(<likey={user.id}>{user.name}</li>))}</ul>):(<p>No users found</p>)}</>)} kay, now the whole application is complete and we can write the tests. You can build to ensure everything is working properly first.Build:npmrun buildOutput:> webpack\n\nasset main.js 145 KiB [compared for emit] [minimized] (name: main) 1 related asset\n...\nwebpack 5.75.0 compiled successfully in 4035 msI usehttp-serverin thedistfolder to test the output of an application quickly.Writing the TestsYou may not have needed all the above context and just want to see the tests. I wrote about it all since it's an up-to-date (for now) example of everything you need to get started, which can be nicer than opening twenty tabs in StackOverflow and seeing answers from 2016.Now to get started writing the tests. I opted to put them inApp.test.js, but of course there are differing opinions on where tests should live (which I discussed a bit in theReact Architecturearticle). I'm just putting them in atestsfolder for the sake of this example.To set up, we'll userenderandscreenfrom theReact Testing Library. As implied by the names,renderis responsible for rendering your app to the JS Dom, andscreenallows you to interact with it and see what's there.I'm putting everything in adescribe()block forApp, and making surefetchMockresets between each test.tests/App.test.jsimportReactfrom'react'import{render,screen} rom'@testing-library/react'import{App}",
        "chunk_type": "code_import",
        "tag": "div",
        "score": 0.897,
        "word_count": 969,
        "chunk_id": "bbfb01e1dad2c1fc78bf934fc07e1287",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "rom'src/App.js'describe('App',()=>{beforeEach(()=>{fetchMock.resetMocks()})test('renders users when API call succeeds',async()=>{})test('renders error when API call fails',async()=>{})})When the API call succeedsFirst, I'll write the test for when the API call succeeds.UsingfetchMock, I'll mock the resolved value of the JSON Placeholder/usersAPI with a list of fake users.constfakeUsers=[{id:1,name:'Joe'},{id:2,name:'Tony'},]fetchMock.mockResolvedValue({status:200,json:jest.fn(()=>fakeUsers)})Now, what we want is to see what happens after the successfulfetch, which is the users displayed and the \"No users found\" message not to be there.This can be done using a combination ofwaitForandgetBy, which usesactbehind the scenes to wait for the event to happen:awaitwaitFor(()=>{expect(screen.getByText('Joe')).toBeInTheDocument()})However, thefindByquery is a combination ofwaitForandgetBy, so we can simplify that even more into a one liner:expect(awaitscreen.findByText('Joe')).toBeInTheDocument()So here's our code to mock thefetch, render theApp, ensure the data is rendered, and ensure nothing we don't want to see is visible:tests/App.test.jstest('renders users when API call succeeds',async()=>{constfakeUsers=[{id:1,name:'Joe'},{id:2,name:'Tony'},]fetchMock.mockResolvedValue({status:200,json:jest.fn(()=>fakeUsers)})render(<App/>)expect(screen.getByRole('heading')).toHaveTextContent('List of Users')expect(awaitscreen.findByText('Joe')).toBeInTheDocument()expect(awaitscreen.findByText('Tony')).toBeInTheDocument()expect(screen.queryByText('No users found')).not.toBeInTheDocument()})When the API call failsUsing what we've learned in the previous test, writing the next test is pretty easy. Instead of resolving a successful API call, we'll have the API throw an error and ensure the error is visible.tests/App.test.jstest('renders error when API call fails',async()=>{fetchMock.mockReject(()=>Promise.reject('API error'))render(<App/>)expect(awaitscreen.findByText('Something went wrong!')).toBeInTheDocument()expect(awaitscreen.findByText('No users found')).toBeInTheDocument()})Now that both tests are written, we just need to run them.Running the testsUsing thejestcommand, we can run the tests. You can also add the--coverageflag to see if the tests are catching everything.npmtest> jest --coverage PASS  tests/App.test.js App\n    ✓ renders users when API call succeeds (66 ms)\n    ✓ renders error when API call fails (6 ms)\n\n----------|---------|----------|---------|---------|------------------- ile      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s\n----------|---------|----------|---------|---------|------------------- ll files |     100 |      100 |     100 |     100 | App.js   |     100 |      100 |     100 |     100 |\n----------|---------|----------|---------|---------|------------------- est Suites: 1 passed, 1 total ests:       2 passed, 2 total napshots:   0 total ime:        1.91 sAs we can see, the tests passed with 100% coverage, so we get that green dopamine hit.Note: I don't necessarily think having 100% test coverage is particularly meaningful, nor that component tests are the most important type of test. Generally, I think end-to-end tests are the most essential, but unit/component tests can be helpful to supplement them.ConclusionWell, there you have it. React, React Testing Library, Jest, and Webpack, all working in harmony in (almost) TYOOL 2023. Hopefully this helps someone struggling to figure out how to testuseEffector get their environment set up!About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:December 09, 2022Category:TechnicalTagsreacttestingjestwebpackasynchronousapiNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.897,
        "word_count": 437,
        "chunk_id": "5856e46e177e4fbd17de4f8fa36fe2f6",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "container"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "api"
          ]
        }
      },
      {
        "content": "Testing API Calls With React Testing Library and JestEver since Hooks were released in React, we've been using theuseEffecthook to fetch data, whether directly or abstracted away behind Redux Thunks. Figuring out how to test those scenarios can be really frustrating at first, but fortunately it ends up not being very complicated. I'll show you how to testuseEffectwith both successful and failed API calls.PrerequisitesCommand LineReactReact HooksWebpackGoalsSet up a very simple React app with testing using Jest and React Testing LibraryWrite a test for when the API call succeedsWrite a test for when the API call failsSetting up the Application and Test EnvironmentFeel free to skip this part if you want to get right to the good stuff. As I wrote this article, I decided to start with absolutely nothing to see what the bare minimum I could get away with. I wanted all the config files, setup, and modules to get a React environment up and running that outputs a running application and runs tests, with the most up-to-date versions of everything.I know Vite and Rome and Rollup and lord knows what else are all the rage right now - I'm just using a simple webpack setup because it still works and I care more about just showing the tests in this article. However, please leave a comment to enlighten me on some of the improvements they bring to the table!So here's the quick application setup.File structureWhat I ended up with looked like this:.\n├── dist\n├── node_modules\n├── src\n│   ├── App.js\n│   └── index.js\n├── tests\n│   └── App.test.js\n├── .babelrc\n├── jest.config.js\n├── package.json\n├── setupJest.js\n└── webpack.config.jsI won't force you to go on the whole journey as I did, figuring out what was needed, but I'll cut right to the end and let you know all the packages.Required packagesFor the application, React + React DOM was necessary, as well as a few Babel packages.npmi\\react\\react-dom\\@babel/preset-env\\@babel/preset-reactFor setup, bundling, and compilation, webpack, webpack CLI, and a Babel loader were necessary.npmi\\webpack\\webpack-cli\\babel-loaderAnd for testing, Jest, JSDom, and React Testing Library were necessary. I also brought in a Jest Mock package because it makes life easier.npmi -D\\@testing-library/jest-dom\\@testing-library/react\\jest\\jest-environment-jsdom\\jest-fetch-mockSo these are all the packages necessary to get an environment up and running that spits out an application and tests it. Of course, there are some additional quality of life improvements you'd want, like the webpack serve dev server for hot reloads, but it's not necessary.Config filesBabelOf course, there's theBabel config file, the same one you've probably been using for years..babelrc{\"presets\":[\"@babel/preset-env\",\"@babel/preset-react\"]} ebpackAnd thewebpack config file. It makes most of the decisions by default, such as usingindex.jsas an entry point and outputting to adistfolder. I just needed to add a module to tell it to usebabel-loader.webpack.config.jsmodule.exports={mode:'production',module:{rules:[{test:/\\.js$/,use:['babel-loader']}],},} estAs for theJest config file, I just needed it to usejsdomand set the right directories.jest.config.jsmodule.exports={testEnvironment:'jsdom',rootDir:'.',modulePaths:['<rootDir>'],moduleDirectories:['node_modules','src'],setupFilesAfterEnv:['<rootDir>/setupJest.js'],} inally, insetupJest.js, we just want to enablejest-fetch-mockand import the Jest DOM.setupJest.jsrequire('jest-fetch-mock').enableMocks()import'@testing-library/jest-dom'PackageAdding a script topackage.jsonthat just runswebpackallows you to test the build and ensure the application is running. I also added ajestcommand for the test. Everything else is just the packages brought in by the commands.package.json{\"scripts\":{\"test\":\"jest --coverage\",\"build\":\"webpack\"}} o that's everything as far as config for both the application and testing, now to set up the simple app.App filesNot too much has changed as far as the React index file goes. TheReactDOMimport and API is slightly different from the last time I used it, andStrictModeseems to be the default mode, so I'm just rendering to the#rootand pulling in a component.index.jsimportReactfrom'react'importReactDOMfrom'react-dom/client'import{App} rom'./App'constroot=ReactDOM.createRoot(document.getElementById('root'))root.render(<React.StrictMode><App/></React.StrictMode>)So now comes the code we're going to be testing,App.js. I'm just going to make this file do some \"componentDidMount\"-esque fetching of data. I know it's not realistic for this to be done inApp.js, but the way the code will be written will be pretty similar in a production level app, it'll just be somewhere else further down.I'm going to useJSON Placeholderfor the example API, but testing will be the same with your own internal APIs, a wrapper around fetch, and even if you're using Redux or some other state management.So I'll start off with a title and a message, and start setting up the state we'll use:usersfor the data coming in, anderrorin case an error gets thrown. I could have added in someloadingstate, but I just kept it really simple. It should be easy to figure out testing the loading states after reading this article.App.jsimportReact,{useState,useEffect} rom'react'exportconstApp=()=>{const[users,setUsers]=useState(null)const[error,setError]=useState(null)return(<><h1>List of Users</h1><p>No users found</p></>)} ow I'll add in theuseEffectthat fetches data from the API and updates the data state, otherwise updates the error state.App.jsimportReact,{useState,useEffect} rom'react'exportconstApp=()=>{const[users,setUsers]=useState(null)const[error,setError]=useState(null)useEffect(()=>{constfetchAllUsers=async()=>{try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/users')constdata=awaitresponse.json()setUsers(data)} atch(err){setError('Something went wrong!')}} etchAllUsers()},[])return(<><h1>List of Users</h1><p>No users found</p></>)} inally, I'm just displaying the error if one exists, and displaying the users if they loaded.App.jsimportReact,{useState,useEffect} rom'react'exportconstApp=()=>{const[users,setUsers]=useState(null)const[error,setError]=useState(null)useEffect(()=>{// ...},[])return(<><h1>List of Users</h1>{error&&<div>{error}</div>}{users?(<ul>{users.map((user)=>(<likey={user.id}>{user.name}</li>))}</ul>):(<p>No users found</p>)}</>)} kay, now the whole application is complete and we can write the tests. You can build to ensure everything is working properly first.Build:npmrun buildOutput:> webpack\n\nasset main.js 145 KiB [compared for emit] [minimized] (name: main) 1 related asset\n...\nwebpack 5.75.0 compiled successfully in 4035 msI usehttp-serverin thedistfolder to test the output of an application quickly.Writing the TestsYou may not have needed all the above context and just want to see the tests. I wrote about it all since it's an up-to-date (for now) example of everything you need to get started, which can be nicer than opening twenty tabs in StackOverflow and seeing answers from 2016.Now to get started writing the tests. I opted to put them inApp.test.js, but of course there are differing opinions on where tests should live (which I discussed a bit in theReact Architecturearticle). I'm just putting them in atestsfolder for the sake of this example.To set up, we'll userenderandscreenfrom theReact Testing Library. As implied by the names,renderis responsible for rendering your app to the JS Dom, andscreenallows you to interact with it and see what's there.I'm putting everything in adescribe()block forApp, and making surefetchMockresets between each test.tests/App.test.jsimportReactfrom'react'import{render,screen} rom'@testing-library/react'import{App}",
        "chunk_type": "code_import",
        "tag": "div",
        "score": 0.897,
        "word_count": 969,
        "chunk_id": "bbfb01e1dad2c1fc78bf934fc07e1287",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "rom'src/App.js'describe('App',()=>{beforeEach(()=>{fetchMock.resetMocks()})test('renders users when API call succeeds',async()=>{})test('renders error when API call fails',async()=>{})})When the API call succeedsFirst, I'll write the test for when the API call succeeds.UsingfetchMock, I'll mock the resolved value of the JSON Placeholder/usersAPI with a list of fake users.constfakeUsers=[{id:1,name:'Joe'},{id:2,name:'Tony'},]fetchMock.mockResolvedValue({status:200,json:jest.fn(()=>fakeUsers)})Now, what we want is to see what happens after the successfulfetch, which is the users displayed and the \"No users found\" message not to be there.This can be done using a combination ofwaitForandgetBy, which usesactbehind the scenes to wait for the event to happen:awaitwaitFor(()=>{expect(screen.getByText('Joe')).toBeInTheDocument()})However, thefindByquery is a combination ofwaitForandgetBy, so we can simplify that even more into a one liner:expect(awaitscreen.findByText('Joe')).toBeInTheDocument()So here's our code to mock thefetch, render theApp, ensure the data is rendered, and ensure nothing we don't want to see is visible:tests/App.test.jstest('renders users when API call succeeds',async()=>{constfakeUsers=[{id:1,name:'Joe'},{id:2,name:'Tony'},]fetchMock.mockResolvedValue({status:200,json:jest.fn(()=>fakeUsers)})render(<App/>)expect(screen.getByRole('heading')).toHaveTextContent('List of Users')expect(awaitscreen.findByText('Joe')).toBeInTheDocument()expect(awaitscreen.findByText('Tony')).toBeInTheDocument()expect(screen.queryByText('No users found')).not.toBeInTheDocument()})When the API call failsUsing what we've learned in the previous test, writing the next test is pretty easy. Instead of resolving a successful API call, we'll have the API throw an error and ensure the error is visible.tests/App.test.jstest('renders error when API call fails',async()=>{fetchMock.mockReject(()=>Promise.reject('API error'))render(<App/>)expect(awaitscreen.findByText('Something went wrong!')).toBeInTheDocument()expect(awaitscreen.findByText('No users found')).toBeInTheDocument()})Now that both tests are written, we just need to run them.Running the testsUsing thejestcommand, we can run the tests. You can also add the--coverageflag to see if the tests are catching everything.npmtest> jest --coverage PASS  tests/App.test.js App\n    ✓ renders users when API call succeeds (66 ms)\n    ✓ renders error when API call fails (6 ms)\n\n----------|---------|----------|---------|---------|------------------- ile      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s\n----------|---------|----------|---------|---------|------------------- ll files |     100 |      100 |     100 |     100 | App.js   |     100 |      100 |     100 |     100 |\n----------|---------|----------|---------|---------|------------------- est Suites: 1 passed, 1 total ests:       2 passed, 2 total napshots:   0 total ime:        1.91 sAs we can see, the tests passed with 100% coverage, so we get that green dopamine hit.Note: I don't necessarily think having 100% test coverage is particularly meaningful, nor that component tests are the most important type of test. Generally, I think end-to-end tests are the most essential, but unit/component tests can be helpful to supplement them.ConclusionWell, there you have it. React, React Testing Library, Jest, and Webpack, all working in harmony in (almost) TYOOL 2023. Hopefully this helps someone struggling to figure out how to testuseEffector get their environment set up!About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:December 09, 2022Category:TechnicalTagsreacttestingjestwebpackasynchronousapiNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.897,
        "word_count": 437,
        "chunk_id": "5856e46e177e4fbd17de4f8fa36fe2f6",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "api"
          ]
        }
      },
      {
        "content": "Testing API Calls With React Testing Library and JestEver since Hooks were released in React, we've been using theuseEffecthook to fetch data, whether directly or abstracted away behind Redux Thunks. Figuring out how to test those scenarios can be really frustrating at first, but fortunately it ends up not being very complicated. I'll show you how to testuseEffectwith both successful and failed API calls.PrerequisitesCommand LineReactReact HooksWebpackGoalsSet up a very simple React app with testing using Jest and React Testing LibraryWrite a test for when the API call succeedsWrite a test for when the API call failsSetting up the Application and Test EnvironmentFeel free to skip this part if you want to get right to the good stuff. As I wrote this article, I decided to start with absolutely nothing to see what the bare minimum I could get away with. I wanted all the config files, setup, and modules to get a React environment up and running that outputs a running application and runs tests, with the most up-to-date versions of everything.I know Vite and Rome and Rollup and lord knows what else are all the rage right now - I'm just using a simple webpack setup because it still works and I care more about just showing the tests in this article. However, please leave a comment to enlighten me on some of the improvements they bring to the table!So here's the quick application setup.File structureWhat I ended up with looked like this:.\n├── dist\n├── node_modules\n├── src\n│   ├── App.js\n│   └── index.js\n├── tests\n│   └── App.test.js\n├── .babelrc\n├── jest.config.js\n├── package.json\n├── setupJest.js\n└── webpack.config.jsI won't force you to go on the whole journey as I did, figuring out what was needed, but I'll cut right to the end and let you know all the packages.Required packagesFor the application, React + React DOM was necessary, as well as a few Babel packages.npmi\\react\\react-dom\\@babel/preset-env\\@babel/preset-reactFor setup, bundling, and compilation, webpack, webpack CLI, and a Babel loader were necessary.npmi\\webpack\\webpack-cli\\babel-loaderAnd for testing, Jest, JSDom, and React Testing Library were necessary. I also brought in a Jest Mock package because it makes life easier.npmi -D\\@testing-library/jest-dom\\@testing-library/react\\jest\\jest-environment-jsdom\\jest-fetch-mockSo these are all the packages necessary to get an environment up and running that spits out an application and tests it. Of course, there are some additional quality of life improvements you'd want, like the webpack serve dev server for hot reloads, but it's not necessary.Config filesBabelOf course, there's theBabel config file, the same one you've probably been using for years..babelrc{\"presets\":[\"@babel/preset-env\",\"@babel/preset-react\"]} ebpackAnd thewebpack config file. It makes most of the decisions by default, such as usingindex.jsas an entry point and outputting to adistfolder. I just needed to add a module to tell it to usebabel-loader.webpack.config.jsmodule.exports={mode:'production',module:{rules:[{test:/\\.js$/,use:['babel-loader']}],},} estAs for theJest config file, I just needed it to usejsdomand set the right directories.jest.config.jsmodule.exports={testEnvironment:'jsdom',rootDir:'.',modulePaths:['<rootDir>'],moduleDirectories:['node_modules','src'],setupFilesAfterEnv:['<rootDir>/setupJest.js'],} inally, insetupJest.js, we just want to enablejest-fetch-mockand import the Jest DOM.setupJest.jsrequire('jest-fetch-mock').enableMocks()import'@testing-library/jest-dom'PackageAdding a script topackage.jsonthat just runswebpackallows you to test the build and ensure the application is running. I also added ajestcommand for the test. Everything else is just the packages brought in by the commands.package.json{\"scripts\":{\"test\":\"jest --coverage\",\"build\":\"webpack\"}} o that's everything as far as config for both the application and testing, now to set up the simple app.App filesNot too much has changed as far as the React index file goes. TheReactDOMimport and API is slightly different from the last time I used it, andStrictModeseems to be the default mode, so I'm just rendering to the#rootand pulling in a component.index.jsimportReactfrom'react'importReactDOMfrom'react-dom/client'import{App} rom'./App'constroot=ReactDOM.createRoot(document.getElementById('root'))root.render(<React.StrictMode><App/></React.StrictMode>)So now comes the code we're going to be testing,App.js. I'm just going to make this file do some \"componentDidMount\"-esque fetching of data. I know it's not realistic for this to be done inApp.js, but the way the code will be written will be pretty similar in a production level app, it'll just be somewhere else further down.I'm going to useJSON Placeholderfor the example API, but testing will be the same with your own internal APIs, a wrapper around fetch, and even if you're using Redux or some other state management.So I'll start off with a title and a message, and start setting up the state we'll use:usersfor the data coming in, anderrorin case an error gets thrown. I could have added in someloadingstate, but I just kept it really simple. It should be easy to figure out testing the loading states after reading this article.App.jsimportReact,{useState,useEffect} rom'react'exportconstApp=()=>{const[users,setUsers]=useState(null)const[error,setError]=useState(null)return(<><h1>List of Users</h1><p>No users found</p></>)} ow I'll add in theuseEffectthat fetches data from the API and updates the data state, otherwise updates the error state.App.jsimportReact,{useState,useEffect} rom'react'exportconstApp=()=>{const[users,setUsers]=useState(null)const[error,setError]=useState(null)useEffect(()=>{constfetchAllUsers=async()=>{try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/users')constdata=awaitresponse.json()setUsers(data)} atch(err){setError('Something went wrong!')}} etchAllUsers()},[])return(<><h1>List of Users</h1><p>No users found</p></>)} inally, I'm just displaying the error if one exists, and displaying the users if they loaded.App.jsimportReact,{useState,useEffect} rom'react'exportconstApp=()=>{const[users,setUsers]=useState(null)const[error,setError]=useState(null)useEffect(()=>{// ...},[])return(<><h1>List of Users</h1>{error&&<div>{error}</div>}{users?(<ul>{users.map((user)=>(<likey={user.id}>{user.name}</li>))}</ul>):(<p>No users found</p>)}</>)} kay, now the whole application is complete and we can write the tests. You can build to ensure everything is working properly first.Build:npmrun buildOutput:> webpack\n\nasset main.js 145 KiB [compared for emit] [minimized] (name: main) 1 related asset\n...\nwebpack 5.75.0 compiled successfully in 4035 msI usehttp-serverin thedistfolder to test the output of an application quickly.Writing the TestsYou may not have needed all the above context and just want to see the tests. I wrote about it all since it's an up-to-date (for now) example of everything you need to get started, which can be nicer than opening twenty tabs in StackOverflow and seeing answers from 2016.Now to get started writing the tests. I opted to put them inApp.test.js, but of course there are differing opinions on where tests should live (which I discussed a bit in theReact Architecturearticle). I'm just putting them in atestsfolder for the sake of this example.To set up, we'll userenderandscreenfrom theReact Testing Library. As implied by the names,renderis responsible for rendering your app to the JS Dom, andscreenallows you to interact with it and see what's there.I'm putting everything in adescribe()block forApp, and making surefetchMockresets between each test.tests/App.test.jsimportReactfrom'react'import{render,screen} rom'@testing-library/react'import{App}",
        "chunk_type": "code_import",
        "tag": "div",
        "score": 0.897,
        "word_count": 969,
        "chunk_id": "bbfb01e1dad2c1fc78bf934fc07e1287",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "rom'src/App.js'describe('App',()=>{beforeEach(()=>{fetchMock.resetMocks()})test('renders users when API call succeeds',async()=>{})test('renders error when API call fails',async()=>{})})When the API call succeedsFirst, I'll write the test for when the API call succeeds.UsingfetchMock, I'll mock the resolved value of the JSON Placeholder/usersAPI with a list of fake users.constfakeUsers=[{id:1,name:'Joe'},{id:2,name:'Tony'},]fetchMock.mockResolvedValue({status:200,json:jest.fn(()=>fakeUsers)})Now, what we want is to see what happens after the successfulfetch, which is the users displayed and the \"No users found\" message not to be there.This can be done using a combination ofwaitForandgetBy, which usesactbehind the scenes to wait for the event to happen:awaitwaitFor(()=>{expect(screen.getByText('Joe')).toBeInTheDocument()})However, thefindByquery is a combination ofwaitForandgetBy, so we can simplify that even more into a one liner:expect(awaitscreen.findByText('Joe')).toBeInTheDocument()So here's our code to mock thefetch, render theApp, ensure the data is rendered, and ensure nothing we don't want to see is visible:tests/App.test.jstest('renders users when API call succeeds',async()=>{constfakeUsers=[{id:1,name:'Joe'},{id:2,name:'Tony'},]fetchMock.mockResolvedValue({status:200,json:jest.fn(()=>fakeUsers)})render(<App/>)expect(screen.getByRole('heading')).toHaveTextContent('List of Users')expect(awaitscreen.findByText('Joe')).toBeInTheDocument()expect(awaitscreen.findByText('Tony')).toBeInTheDocument()expect(screen.queryByText('No users found')).not.toBeInTheDocument()})When the API call failsUsing what we've learned in the previous test, writing the next test is pretty easy. Instead of resolving a successful API call, we'll have the API throw an error and ensure the error is visible.tests/App.test.jstest('renders error when API call fails',async()=>{fetchMock.mockReject(()=>Promise.reject('API error'))render(<App/>)expect(awaitscreen.findByText('Something went wrong!')).toBeInTheDocument()expect(awaitscreen.findByText('No users found')).toBeInTheDocument()})Now that both tests are written, we just need to run them.Running the testsUsing thejestcommand, we can run the tests. You can also add the--coverageflag to see if the tests are catching everything.npmtest> jest --coverage PASS  tests/App.test.js App\n    ✓ renders users when API call succeeds (66 ms)\n    ✓ renders error when API call fails (6 ms)\n\n----------|---------|----------|---------|---------|------------------- ile      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s\n----------|---------|----------|---------|---------|------------------- ll files |     100 |      100 |     100 |     100 | App.js   |     100 |      100 |     100 |     100 |\n----------|---------|----------|---------|---------|------------------- est Suites: 1 passed, 1 total ests:       2 passed, 2 total napshots:   0 total ime:        1.91 sAs we can see, the tests passed with 100% coverage, so we get that green dopamine hit.Note: I don't necessarily think having 100% test coverage is particularly meaningful, nor that component tests are the most important type of test. Generally, I think end-to-end tests are the most essential, but unit/component tests can be helpful to supplement them.ConclusionWell, there you have it. React, React Testing Library, Jest, and Webpack, all working in harmony in (almost) TYOOL 2023. Hopefully this helps someone struggling to figure out how to testuseEffector get their environment set up!About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:December 09, 2022Category:TechnicalTagsreacttestingjestwebpackasynchronousapiNewsletterSubscribe to the NewsletterComments",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.897,
        "word_count": 437,
        "chunk_id": "5856e46e177e4fbd17de4f8fa36fe2f6",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "api"
          ]
        }
      },
      {
        "content": "Ever since Hooks were released in React, we've been using theuseEffecthook to fetch data, whether directly or abstracted away behind Redux Thunks. Figuring out how to test those scenarios can be really frustrating at first, but fortunately it ends up not being very complicated. I'll show you how to testuseEffectwith both successful and failed API calls.PrerequisitesCommand LineReactReact HooksWebpackGoalsSet up a very simple React app with testing using Jest and React Testing LibraryWrite a test for when the API call succeedsWrite a test for when the API call failsSetting up the Application and Test EnvironmentFeel free to skip this part if you want to get right to the good stuff. As I wrote this article, I decided to start with absolutely nothing to see what the bare minimum I could get away with. I wanted all the config files, setup, and modules to get a React environment up and running that outputs a running application and runs tests, with the most up-to-date versions of everything.I know Vite and Rome and Rollup and lord knows what else are all the rage right now - I'm just using a simple webpack setup because it still works and I care more about just showing the tests in this article. However, please leave a comment to enlighten me on some of the improvements they bring to the table!So here's the quick application setup.File structureWhat I ended up with looked like this:.\n├── dist\n├── node_modules\n├── src\n│   ├── App.js\n│   └── index.js\n├── tests\n│   └── App.test.js\n├── .babelrc\n├── jest.config.js\n├── package.json\n├── setupJest.js\n└── webpack.config.jsI won't force you to go on the whole journey as I did, figuring out what was needed, but I'll cut right to the end and let you know all the packages.Required packagesFor the application, React + React DOM was necessary, as well as a few Babel packages.npmi\\react\\react-dom\\@babel/preset-env\\@babel/preset-reactFor setup, bundling, and compilation, webpack, webpack CLI, and a Babel loader were necessary.npmi\\webpack\\webpack-cli\\babel-loaderAnd for testing, Jest, JSDom, and React Testing Library were necessary. I also brought in a Jest Mock package because it makes life easier.npmi -D\\@testing-library/jest-dom\\@testing-library/react\\jest\\jest-environment-jsdom\\jest-fetch-mockSo these are all the packages necessary to get an environment up and running that spits out an application and tests it. Of course, there are some additional quality of life improvements you'd want, like the webpack serve dev server for hot reloads, but it's not necessary.Config filesBabelOf course, there's theBabel config file, the same one you've probably been using for years..babelrc{\"presets\":[\"@babel/preset-env\",\"@babel/preset-react\"]} ebpackAnd thewebpack config file. It makes most of the decisions by default, such as usingindex.jsas an entry point and outputting to adistfolder. I just needed to add a module to tell it to usebabel-loader.webpack.config.jsmodule.exports={mode:'production',module:{rules:[{test:/\\.js$/,use:['babel-loader']}],},} estAs for theJest config file, I just needed it to usejsdomand set the right directories.jest.config.jsmodule.exports={testEnvironment:'jsdom',rootDir:'.',modulePaths:['<rootDir>'],moduleDirectories:['node_modules','src'],setupFilesAfterEnv:['<rootDir>/setupJest.js'],} inally, insetupJest.js, we just want to enablejest-fetch-mockand import the Jest DOM.setupJest.jsrequire('jest-fetch-mock').enableMocks()import'@testing-library/jest-dom'PackageAdding a script topackage.jsonthat just runswebpackallows you to test the build and ensure the application is running. I also added ajestcommand for the test. Everything else is just the packages brought in by the commands.package.json{\"scripts\":{\"test\":\"jest --coverage\",\"build\":\"webpack\"}} o that's everything as far as config for both the application and testing, now to set up the simple app.App filesNot too much has changed as far as the React index file goes. TheReactDOMimport and API is slightly different from the last time I used it, andStrictModeseems to be the default mode, so I'm just rendering to the#rootand pulling in a component.index.jsimportReactfrom'react'importReactDOMfrom'react-dom/client'import{App} rom'./App'constroot=ReactDOM.createRoot(document.getElementById('root'))root.render(<React.StrictMode><App/></React.StrictMode>)So now comes the code we're going to be testing,App.js. I'm just going to make this file do some \"componentDidMount\"-esque fetching of data. I know it's not realistic for this to be done inApp.js, but the way the code will be written will be pretty similar in a production level app, it'll just be somewhere else further down.I'm going to useJSON Placeholderfor the example API, but testing will be the same with your own internal APIs, a wrapper around fetch, and even if you're using Redux or some other state management.So I'll start off with a title and a message, and start setting up the state we'll use:usersfor the data coming in, anderrorin case an error gets thrown. I could have added in someloadingstate, but I just kept it really simple. It should be easy to figure out testing the loading states after reading this article.App.jsimportReact,{useState,useEffect} rom'react'exportconstApp=()=>{const[users,setUsers]=useState(null)const[error,setError]=useState(null)return(<><h1>List of Users</h1><p>No users found</p></>)} ow I'll add in theuseEffectthat fetches data from the API and updates the data state, otherwise updates the error state.App.jsimportReact,{useState,useEffect} rom'react'exportconstApp=()=>{const[users,setUsers]=useState(null)const[error,setError]=useState(null)useEffect(()=>{constfetchAllUsers=async()=>{try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/users')constdata=awaitresponse.json()setUsers(data)} atch(err){setError('Something went wrong!')}} etchAllUsers()},[])return(<><h1>List of Users</h1><p>No users found</p></>)} inally, I'm just displaying the error if one exists, and displaying the users if they loaded.App.jsimportReact,{useState,useEffect} rom'react'exportconstApp=()=>{const[users,setUsers]=useState(null)const[error,setError]=useState(null)useEffect(()=>{// ...},[])return(<><h1>List of Users</h1>{error&&<div>{error}</div>}{users?(<ul>{users.map((user)=>(<likey={user.id}>{user.name}</li>))}</ul>):(<p>No users found</p>)}</>)} kay, now the whole application is complete and we can write the tests. You can build to ensure everything is working properly first.Build:npmrun buildOutput:> webpack\n\nasset main.js 145 KiB [compared for emit] [minimized] (name: main) 1 related asset\n...\nwebpack 5.75.0 compiled successfully in 4035 msI usehttp-serverin thedistfolder to test the output of an application quickly.Writing the TestsYou may not have needed all the above context and just want to see the tests. I wrote about it all since it's an up-to-date (for now) example of everything you need to get started, which can be nicer than opening twenty tabs in StackOverflow and seeing answers from 2016.Now to get started writing the tests. I opted to put them inApp.test.js, but of course there are differing opinions on where tests should live (which I discussed a bit in theReact Architecturearticle). I'm just putting them in atestsfolder for the sake of this example.To set up, we'll userenderandscreenfrom theReact Testing Library. As implied by the names,renderis responsible for rendering your app to the JS Dom, andscreenallows you to interact with it and see what's there.I'm putting everything in adescribe()block forApp, and making surefetchMockresets between each test.tests/App.test.jsimportReactfrom'react'import{render,screen} rom'@testing-library/react'import{App}",
        "chunk_type": "code_import",
        "tag": "section",
        "score": 0.895,
        "word_count": 961,
        "chunk_id": "7ba3af9be0a4a6478f3fe65c160d162a",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "rom'src/App.js'describe('App',()=>{beforeEach(()=>{fetchMock.resetMocks()})test('renders users when API call succeeds',async()=>{})test('renders error when API call fails',async()=>{})})When the API call succeedsFirst, I'll write the test for when the API call succeeds.UsingfetchMock, I'll mock the resolved value of the JSON Placeholder/usersAPI with a list of fake users.constfakeUsers=[{id:1,name:'Joe'},{id:2,name:'Tony'},]fetchMock.mockResolvedValue({status:200,json:jest.fn(()=>fakeUsers)})Now, what we want is to see what happens after the successfulfetch, which is the users displayed and the \"No users found\" message not to be there.This can be done using a combination ofwaitForandgetBy, which usesactbehind the scenes to wait for the event to happen:awaitwaitFor(()=>{expect(screen.getByText('Joe')).toBeInTheDocument()})However, thefindByquery is a combination ofwaitForandgetBy, so we can simplify that even more into a one liner:expect(awaitscreen.findByText('Joe')).toBeInTheDocument()So here's our code to mock thefetch, render theApp, ensure the data is rendered, and ensure nothing we don't want to see is visible:tests/App.test.jstest('renders users when API call succeeds',async()=>{constfakeUsers=[{id:1,name:'Joe'},{id:2,name:'Tony'},]fetchMock.mockResolvedValue({status:200,json:jest.fn(()=>fakeUsers)})render(<App/>)expect(screen.getByRole('heading')).toHaveTextContent('List of Users')expect(awaitscreen.findByText('Joe')).toBeInTheDocument()expect(awaitscreen.findByText('Tony')).toBeInTheDocument()expect(screen.queryByText('No users found')).not.toBeInTheDocument()})When the API call failsUsing what we've learned in the previous test, writing the next test is pretty easy. Instead of resolving a successful API call, we'll have the API throw an error and ensure the error is visible.tests/App.test.jstest('renders error when API call fails',async()=>{fetchMock.mockReject(()=>Promise.reject('API error'))render(<App/>)expect(awaitscreen.findByText('Something went wrong!')).toBeInTheDocument()expect(awaitscreen.findByText('No users found')).toBeInTheDocument()})Now that both tests are written, we just need to run them.Running the testsUsing thejestcommand, we can run the tests. You can also add the--coverageflag to see if the tests are catching everything.npmtest> jest --coverage PASS  tests/App.test.js App\n    ✓ renders users when API call succeeds (66 ms)\n    ✓ renders error when API call fails (6 ms)\n\n----------|---------|----------|---------|---------|------------------- ile      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s\n----------|---------|----------|---------|---------|------------------- ll files |     100 |      100 |     100 |     100 | App.js   |     100 |      100 |     100 |     100 |\n----------|---------|----------|---------|---------|------------------- est Suites: 1 passed, 1 total ests:       2 passed, 2 total napshots:   0 total ime:        1.91 sAs we can see, the tests passed with 100% coverage, so we get that green dopamine hit.Note: I don't necessarily think having 100% test coverage is particularly meaningful, nor that component tests are the most important type of test. Generally, I think end-to-end tests are the most essential, but unit/component tests can be helpful to supplement them.ConclusionWell, there you have it. React, React Testing Library, Jest, and Webpack, all working in harmony in (almost) TYOOL 2023. Hopefully this helps someone struggling to figure out how to testuseEffector get their environment set up!",
        "chunk_type": "code_markup",
        "tag": "section",
        "score": 0.895,
        "word_count": 384,
        "chunk_id": "892af9ee2da6ee8d5d13bb90e3a14184",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "segment",
              "small"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "api"
          ]
        }
      },
      {
        "content": "Ever since Hooks were released in React, we've been using theuseEffecthook to fetch data, whether directly or abstracted away behind Redux Thunks. Figuring out how to test those scenarios can be really frustrating at first, but fortunately it ends up not being very complicated. I'll show you how to testuseEffectwith both successful and failed API calls.PrerequisitesCommand LineReactReact HooksWebpackGoalsSet up a very simple React app with testing using Jest and React Testing LibraryWrite a test for when the API call succeedsWrite a test for when the API call failsSetting up the Application and Test EnvironmentFeel free to skip this part if you want to get right to the good stuff. As I wrote this article, I decided to start with absolutely nothing to see what the bare minimum I could get away with. I wanted all the config files, setup, and modules to get a React environment up and running that outputs a running application and runs tests, with the most up-to-date versions of everything.I know Vite and Rome and Rollup and lord knows what else are all the rage right now - I'm just using a simple webpack setup because it still works and I care more about just showing the tests in this article. However, please leave a comment to enlighten me on some of the improvements they bring to the table!So here's the quick application setup.File structureWhat I ended up with looked like this:.\n├── dist\n├── node_modules\n├── src\n│   ├── App.js\n│   └── index.js\n├── tests\n│   └── App.test.js\n├── .babelrc\n├── jest.config.js\n├── package.json\n├── setupJest.js\n└── webpack.config.jsI won't force you to go on the whole journey as I did, figuring out what was needed, but I'll cut right to the end and let you know all the packages.Required packagesFor the application, React + React DOM was necessary, as well as a few Babel packages.npmi\\react\\react-dom\\@babel/preset-env\\@babel/preset-reactFor setup, bundling, and compilation, webpack, webpack CLI, and a Babel loader were necessary.npmi\\webpack\\webpack-cli\\babel-loaderAnd for testing, Jest, JSDom, and React Testing Library were necessary. I also brought in a Jest Mock package because it makes life easier.npmi -D\\@testing-library/jest-dom\\@testing-library/react\\jest\\jest-environment-jsdom\\jest-fetch-mockSo these are all the packages necessary to get an environment up and running that spits out an application and tests it. Of course, there are some additional quality of life improvements you'd want, like the webpack serve dev server for hot reloads, but it's not necessary.Config filesBabelOf course, there's theBabel config file, the same one you've probably been using for years..babelrc{\"presets\":[\"@babel/preset-env\",\"@babel/preset-react\"]} ebpackAnd thewebpack config file. It makes most of the decisions by default, such as usingindex.jsas an entry point and outputting to adistfolder. I just needed to add a module to tell it to usebabel-loader.webpack.config.jsmodule.exports={mode:'production',module:{rules:[{test:/\\.js$/,use:['babel-loader']}],},} estAs for theJest config file, I just needed it to usejsdomand set the right directories.jest.config.jsmodule.exports={testEnvironment:'jsdom',rootDir:'.',modulePaths:['<rootDir>'],moduleDirectories:['node_modules','src'],setupFilesAfterEnv:['<rootDir>/setupJest.js'],} inally, insetupJest.js, we just want to enablejest-fetch-mockand import the Jest DOM.setupJest.jsrequire('jest-fetch-mock').enableMocks()import'@testing-library/jest-dom'PackageAdding a script topackage.jsonthat just runswebpackallows you to test the build and ensure the application is running. I also added ajestcommand for the test. Everything else is just the packages brought in by the commands.package.json{\"scripts\":{\"test\":\"jest --coverage\",\"build\":\"webpack\"}} o that's everything as far as config for both the application and testing, now to set up the simple app.App filesNot too much has changed as far as the React index file goes. TheReactDOMimport and API is slightly different from the last time I used it, andStrictModeseems to be the default mode, so I'm just rendering to the#rootand pulling in a component.index.jsimportReactfrom'react'importReactDOMfrom'react-dom/client'import{App} rom'./App'constroot=ReactDOM.createRoot(document.getElementById('root'))root.render(<React.StrictMode><App/></React.StrictMode>)So now comes the code we're going to be testing,App.js. I'm just going to make this file do some \"componentDidMount\"-esque fetching of data. I know it's not realistic for this to be done inApp.js, but the way the code will be written will be pretty similar in a production level app, it'll just be somewhere else further down.I'm going to useJSON Placeholderfor the example API, but testing will be the same with your own internal APIs, a wrapper around fetch, and even if you're using Redux or some other state management.So I'll start off with a title and a message, and start setting up the state we'll use:usersfor the data coming in, anderrorin case an error gets thrown. I could have added in someloadingstate, but I just kept it really simple. It should be easy to figure out testing the loading states after reading this article.App.jsimportReact,{useState,useEffect} rom'react'exportconstApp=()=>{const[users,setUsers]=useState(null)const[error,setError]=useState(null)return(<><h1>List of Users</h1><p>No users found</p></>)} ow I'll add in theuseEffectthat fetches data from the API and updates the data state, otherwise updates the error state.App.jsimportReact,{useState,useEffect} rom'react'exportconstApp=()=>{const[users,setUsers]=useState(null)const[error,setError]=useState(null)useEffect(()=>{constfetchAllUsers=async()=>{try{constresponse=awaitfetch('https://jsonplaceholder.typicode.com/users')constdata=awaitresponse.json()setUsers(data)} atch(err){setError('Something went wrong!')}} etchAllUsers()},[])return(<><h1>List of Users</h1><p>No users found</p></>)} inally, I'm just displaying the error if one exists, and displaying the users if they loaded.App.jsimportReact,{useState,useEffect} rom'react'exportconstApp=()=>{const[users,setUsers]=useState(null)const[error,setError]=useState(null)useEffect(()=>{// ...},[])return(<><h1>List of Users</h1>{error&&<div>{error}</div>}{users?(<ul>{users.map((user)=>(<likey={user.id}>{user.name}</li>))}</ul>):(<p>No users found</p>)}</>)} kay, now the whole application is complete and we can write the tests. You can build to ensure everything is working properly first.Build:npmrun buildOutput:> webpack\n\nasset main.js 145 KiB [compared for emit] [minimized] (name: main) 1 related asset\n...\nwebpack 5.75.0 compiled successfully in 4035 msI usehttp-serverin thedistfolder to test the output of an application quickly.Writing the TestsYou may not have needed all the above context and just want to see the tests. I wrote about it all since it's an up-to-date (for now) example of everything you need to get started, which can be nicer than opening twenty tabs in StackOverflow and seeing answers from 2016.Now to get started writing the tests. I opted to put them inApp.test.js, but of course there are differing opinions on where tests should live (which I discussed a bit in theReact Architecturearticle). I'm just putting them in atestsfolder for the sake of this example.To set up, we'll userenderandscreenfrom theReact Testing Library. As implied by the names,renderis responsible for rendering your app to the JS Dom, andscreenallows you to interact with it and see what's there.I'm putting everything in adescribe()block forApp, and making surefetchMockresets between each test.tests/App.test.jsimportReactfrom'react'import{render,screen} rom'@testing-library/react'import{App}",
        "chunk_type": "code_import",
        "tag": "div",
        "score": 0.895,
        "word_count": 961,
        "chunk_id": "7ba3af9be0a4a6478f3fe65c160d162a",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "article",
            "react"
          ],
          "attributes": {
            "id": "/how-to-test-useeffect-api-call/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "rom'src/App.js'describe('App',()=>{beforeEach(()=>{fetchMock.resetMocks()})test('renders users when API call succeeds',async()=>{})test('renders error when API call fails',async()=>{})})When the API call succeedsFirst, I'll write the test for when the API call succeeds.UsingfetchMock, I'll mock the resolved value of the JSON Placeholder/usersAPI with a list of fake users.constfakeUsers=[{id:1,name:'Joe'},{id:2,name:'Tony'},]fetchMock.mockResolvedValue({status:200,json:jest.fn(()=>fakeUsers)})Now, what we want is to see what happens after the successfulfetch, which is the users displayed and the \"No users found\" message not to be there.This can be done using a combination ofwaitForandgetBy, which usesactbehind the scenes to wait for the event to happen:awaitwaitFor(()=>{expect(screen.getByText('Joe')).toBeInTheDocument()})However, thefindByquery is a combination ofwaitForandgetBy, so we can simplify that even more into a one liner:expect(awaitscreen.findByText('Joe')).toBeInTheDocument()So here's our code to mock thefetch, render theApp, ensure the data is rendered, and ensure nothing we don't want to see is visible:tests/App.test.jstest('renders users when API call succeeds',async()=>{constfakeUsers=[{id:1,name:'Joe'},{id:2,name:'Tony'},]fetchMock.mockResolvedValue({status:200,json:jest.fn(()=>fakeUsers)})render(<App/>)expect(screen.getByRole('heading')).toHaveTextContent('List of Users')expect(awaitscreen.findByText('Joe')).toBeInTheDocument()expect(awaitscreen.findByText('Tony')).toBeInTheDocument()expect(screen.queryByText('No users found')).not.toBeInTheDocument()})When the API call failsUsing what we've learned in the previous test, writing the next test is pretty easy. Instead of resolving a successful API call, we'll have the API throw an error and ensure the error is visible.tests/App.test.jstest('renders error when API call fails',async()=>{fetchMock.mockReject(()=>Promise.reject('API error'))render(<App/>)expect(awaitscreen.findByText('Something went wrong!')).toBeInTheDocument()expect(awaitscreen.findByText('No users found')).toBeInTheDocument()})Now that both tests are written, we just need to run them.Running the testsUsing thejestcommand, we can run the tests. You can also add the--coverageflag to see if the tests are catching everything.npmtest> jest --coverage PASS  tests/App.test.js App\n    ✓ renders users when API call succeeds (66 ms)\n    ✓ renders error when API call fails (6 ms)\n\n----------|---------|----------|---------|---------|------------------- ile      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s\n----------|---------|----------|---------|---------|------------------- ll files |     100 |      100 |     100 |     100 | App.js   |     100 |      100 |     100 |     100 |\n----------|---------|----------|---------|---------|------------------- est Suites: 1 passed, 1 total ests:       2 passed, 2 total napshots:   0 total ime:        1.91 sAs we can see, the tests passed with 100% coverage, so we get that green dopamine hit.Note: I don't necessarily think having 100% test coverage is particularly meaningful, nor that component tests are the most important type of test. Generally, I think end-to-end tests are the most essential, but unit/component tests can be helpful to supplement them.ConclusionWell, there you have it. React, React Testing Library, Jest, and Webpack, all working in harmony in (almost) TYOOL 2023. Hopefully this helps someone struggling to figure out how to testuseEffector get their environment set up!",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.895,
        "word_count": 384,
        "chunk_id": "892af9ee2da6ee8d5d13bb90e3a14184",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "id": "/how-to-test-useeffect-api-call/",
            "class": [
              "post-content"
            ]
          },
          "technical_indicators": [
            "react",
            "javascript",
            "api"
          ]
        }
      },
      {
        "content": "Feel free to skip this part if you want to get right to the good stuff. As I wrote this article, I decided to start with absolutely nothing to see what the bare minimum I could get away with. I wanted all the config files, setup, and modules to get a React environment up and running that outputs a running application and runs tests, with the most up-to-date versions of everything.",
        "chunk_type": "text",
        "tag": "p",
        "score": 0.41800000000000004,
        "word_count": 71,
        "chunk_id": "a49daaa8b85663cea5ba892c3a8af9de",
        "metadata": {
          "source_tag": "p",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": []
        }
      },
      {
        "content": "I know Vite and Rome and Rollup and lord knows what else are all the rage right now - I'm just using a simple webpack setup because it still works and I care more about just showing the tests in this article. However, please leave a comment to enlighten me on some of the improvements they bring to the table!",
        "chunk_type": "technical_content",
        "tag": "p",
        "score": 0.39,
        "word_count": 60,
        "chunk_id": "715a91a0b57c3ce577d814c7f12a3123",
        "metadata": {
          "source_tag": "p",
          "keywords_found": [
            "web",
            "article"
          ],
          "attributes": {},
          "technical_indicators": [
            "sql"
          ]
        }
      },
      {
        "content": "About meHello and thanks for visiting! My name isTania Rascia, and this is my website and digital garden.I'm a software developer who makes open-source projects and writes about code and life. This site is and has always been free of ads, trackers, social media, affiliates, and sponsored posts.Post DetailsPublished:December 09, 2022Category:TechnicalTagsreacttestingjestwebpackasynchronousapiNewsletterSubscribe to the Newsletter",
        "chunk_type": "technical_content",
        "tag": "aside",
        "score": 0.44,
        "word_count": 54,
        "chunk_id": "0d999fac6e067410c13562378d8aebcf",
        "metadata": {
          "source_tag": "aside",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "post-sidebar"
            ]
          },
          "technical_indicators": [
            "javascript",
            "api"
          ]
        }
      },
      {
        "content": "Now to get started writing the tests. I opted to put them inApp.test.js, but of course there are differing opinions on where tests should live (which I discussed a bit in theReact Architecturearticle). I'm just putting them in atestsfolder for the sake of this example.",
        "chunk_type": "text",
        "tag": "p",
        "score": 0.376,
        "word_count": 45,
        "chunk_id": "f3ab33526d806ea358abd3ce03a4e57d",
        "metadata": {
          "source_tag": "p",
          "keywords_found": [
            "article",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "sql"
          ]
        }
      },
      {
        "content": "Well, there you have it. React, React Testing Library, Jest, and Webpack, all working in harmony in (almost) TYOOL 2023. Hopefully this helps someone struggling to figure out how to testuseEffector get their environment set up!",
        "chunk_type": "technical_content",
        "tag": "p",
        "score": 0.36,
        "word_count": 36,
        "chunk_id": "3116d038741180bee7f38e41017670e6",
        "metadata": {
          "source_tag": "p",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": []
        }
      },
      {
        "content": "importReactfrom'react'import{render,screen} rom'@testing-library/react'import{App} rom'src/App.js'describe('App',()=>{beforeEach(()=>{fetchMock.resetMocks()})test('renders users when API call succeeds',async()=>{})test('renders error when API call fails',async()=>{})})",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.31100000000000005,
        "word_count": 13,
        "chunk_id": "7ce292261c26030c5a53dfc4f9843868",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "jsx"
          },
          "technical_indicators": [
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "importReactfrom'react'import{render,screen} rom'@testing-library/react'import{App} rom'src/App.js'describe('App',()=>{beforeEach(()=>{fetchMock.resetMocks()})test('renders users when API call succeeds',async()=>{})test('renders error when API call fails',async()=>{})})",
        "chunk_type": "technical_content",
        "tag": "pre",
        "score": 0.31100000000000005,
        "word_count": 13,
        "chunk_id": "7ce292261c26030c5a53dfc4f9843868",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-jsx"
            ]
          },
          "technical_indicators": [
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "importReactfrom'react'import{render,screen} rom'@testing-library/react'import{App} rom'src/App.js'describe('App',()=>{beforeEach(()=>{fetchMock.resetMocks()})test('renders users when API call succeeds',async()=>{})test('renders error when API call fails',async()=>{})})",
        "chunk_type": "technical_content",
        "tag": "code",
        "score": 0.31100000000000005,
        "word_count": 13,
        "chunk_id": "7ce292261c26030c5a53dfc4f9843868",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "language-jsx"
            ]
          },
          "technical_indicators": [
            "javascript",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "test('renders users when API call succeeds',async()=>{constfakeUsers=[{id:1,name:'Joe'},{id:2,name:'Tony'},]fetchMock.mockResolvedValue({status:200,json:jest.fn(()=>fakeUsers)})render(<App/>)expect(screen.getByRole('heading')).toHaveTextContent('List of Users')expect(awaitscreen.findByText('Joe')).toBeInTheDocument()expect(awaitscreen.findByText('Tony')).toBeInTheDocument()expect(screen.queryByText('No users found')).not.toBeInTheDocument()})",
        "chunk_type": "code_markup",
        "tag": "div",
        "score": 0.32000000000000006,
        "word_count": 10,
        "chunk_id": "96550c01cb4e002fdc51e2f01d8b7c22",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [],
          "attributes": {
            "class": [
              "gatsby-highlight"
            ],
            "data-language": "jsx"
          },
          "technical_indicators": [
            "javascript",
            "api"
          ]
        }
      },
      {
        "content": "test('renders users when API call succeeds',async()=>{constfakeUsers=[{id:1,name:'Joe'},{id:2,name:'Tony'},]fetchMock.mockResolvedValue({status:200,json:jest.fn(()=>fakeUsers)})render(<App/>)expect(screen.getByRole('heading')).toHaveTextContent('List of Users')expect(awaitscreen.findByText('Joe')).toBeInTheDocument()expect(awaitscreen.findByText('Tony')).toBeInTheDocument()expect(screen.queryByText('No users found')).not.toBeInTheDocument()})",
        "chunk_type": "code_markup",
        "tag": "pre",
        "score": 0.32000000000000006,
        "word_count": 10,
        "chunk_id": "96550c01cb4e002fdc51e2f01d8b7c22",
        "metadata": {
          "source_tag": "pre",
          "keywords_found": [],
          "attributes": {
            "class": [
              "language-jsx"
            ]
          },
          "technical_indicators": [
            "javascript",
            "api"
          ]
        }
      },
      {
        "content": "test('renders users when API call succeeds',async()=>{constfakeUsers=[{id:1,name:'Joe'},{id:2,name:'Tony'},]fetchMock.mockResolvedValue({status:200,json:jest.fn(()=>fakeUsers)})render(<App/>)expect(screen.getByRole('heading')).toHaveTextContent('List of Users')expect(awaitscreen.findByText('Joe')).toBeInTheDocument()expect(awaitscreen.findByText('Tony')).toBeInTheDocument()expect(screen.queryByText('No users found')).not.toBeInTheDocument()})",
        "chunk_type": "code_markup",
        "tag": "code",
        "score": 0.32000000000000006,
        "word_count": 10,
        "chunk_id": "96550c01cb4e002fdc51e2f01d8b7c22",
        "metadata": {
          "source_tag": "code",
          "keywords_found": [],
          "attributes": {
            "class": [
              "language-jsx"
            ]
          },
          "technical_indicators": [
            "javascript",
            "api"
          ]
        }
      }
    ],
    "chunk_count": 25,
    "content_types": [
      "code_import",
      "code_markup",
      "technical_content",
      "text"
    ],
    "technical_concepts": [
      "javascript",
      "react",
      "api",
      "sql"
    ],
    "crawl_metadata": {},
    "technical_content": [
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "4013c127033003915d54b3be20d46458",
        "content": ". dist node_modules src App.js index.js tests App.test.js .babelrc jest.config.js package.json setupJest.js webpack.config.js",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "4013c127033003915d54b3be20d46458",
        "content": ". dist node_modules src App.js index.js tests App.test.js .babelrc jest.config.js package.json setupJest.js webpack.config.js",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "268af49592bb355ad9f9404af73af90b",
        "content": "npm i react react-dom babel/preset-env babel/preset-react",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "268af49592bb355ad9f9404af73af90b",
        "content": "npm i react react-dom babel/preset-env babel/preset-react",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "f316410b686e142368a151100da6865c",
        "content": "npm i webpack webpack-cli babel-loader",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "f316410b686e142368a151100da6865c",
        "content": "npm i webpack webpack-cli babel-loader",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "c02b047c4dd68e699e056e2a78749455",
        "content": "npm i -D testing-library/jest-dom testing-library/react jest jest-environment-jsdom jest-fetch-mock",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "c02b047c4dd68e699e056e2a78749455",
        "content": "npm i -D testing-library/jest-dom testing-library/react jest jest-environment-jsdom jest-fetch-mock",
        "type": "code",
        "language": "shell",
        "relevance": 0.4052631578947369
      },
      {
        "id": "dd3c7b56b7e8cb7c7d6380770845c73d",
        "content": "{ \"presets\": [\" babel/preset-env\", \" babel/preset-react\"] }",
        "type": "code",
        "language": "json",
        "relevance": 0.4052631578947369
      },
      {
        "id": "dd3c7b56b7e8cb7c7d6380770845c73d",
        "content": "{ \"presets\": [\" babel/preset-env\", \" babel/preset-react\"] }",
        "type": "code",
        "language": "json",
        "relevance": 0.4052631578947369
      },
      {
        "id": "168726dbe96b3ce427e7fedce31bb0bc",
        "content": "index.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2a6d07eef8b10b84129b42424ed99327",
        "content": "dist",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b7e6267d8e2309d97247ae733667d13f",
        "content": "babel-loader",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e74023b8bf5abfda9da29131cd1187ae",
        "content": "module.exports = { mode: 'production', module: { rules: [{ test: / .js /, use: ['babel-loader'] }], }, }",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "e74023b8bf5abfda9da29131cd1187ae",
        "content": "module.exports = { mode: 'production', module: { rules: [{ test: / .js /, use: ['babel-loader'] }], }, }",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "5486b3bc02c04e9522be7ac94f43132e",
        "content": "jsdom",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "102e6e9203840ff0e66f2b2a106a263c",
        "content": "module.exports = { testEnvironment: 'jsdom', rootDir: '.', modulePaths: ['<rootDir>'], moduleDirectories: ['node_modules', 'src'], setupFilesAfterEnv: ['<rootDir>/setupJest.js'], }",
        "type": "code",
        "language": "js",
        "relevance": 0.7
      },
      {
        "id": "102e6e9203840ff0e66f2b2a106a263c",
        "content": "module.exports = { testEnvironment: 'jsdom', rootDir: '.', modulePaths: ['<rootDir>'], moduleDirectories: ['node_modules', 'src'], setupFilesAfterEnv: ['<rootDir>/setupJest.js'], }",
        "type": "code",
        "language": "js",
        "relevance": 0.7
      },
      {
        "id": "db0be343b07b3dab1523c624abf1f5d3",
        "content": "setupJest.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "fda6c0b4d003e490d835af2bcece4f5e",
        "content": "jest-fetch-mock",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5404bf70877a9fbfae384ed44f7e0c0f",
        "content": "require('jest-fetch-mock').enableMocks() import ' testing-library/jest-dom'",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "5404bf70877a9fbfae384ed44f7e0c0f",
        "content": "require('jest-fetch-mock').enableMocks() import ' testing-library/jest-dom'",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "b9cfc7f2cdf78a7f4b91a753d10865a2",
        "content": "package.json",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "424516ca53b4ad4bef37ed04f8795a88",
        "content": "webpack",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "ee2c1e9e37dbcaa447b5fac3a2f7e07f",
        "content": "jest",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "27c1131f26d6aa765cfab6b8f6472376",
        "content": "{ \"scripts\": { \"test\": \"jest --coverage\", \"build\": \"webpack\" } }",
        "type": "code",
        "language": "json",
        "relevance": 0.4052631578947369
      },
      {
        "id": "27c1131f26d6aa765cfab6b8f6472376",
        "content": "{ \"scripts\": { \"test\": \"jest --coverage\", \"build\": \"webpack\" } }",
        "type": "code",
        "language": "json",
        "relevance": 0.4052631578947369
      },
      {
        "id": "76b047063d21903f0efdbb7b17476f3a",
        "content": "ReactDOM",
        "type": "code",
        "language": "text",
        "relevance": 0.4052631578947369
      },
      {
        "id": "33c8a1d288a487bfcac2fdd4696e9226",
        "content": "StrictMode",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "63a9f0ea7bb98050796b649e85481845",
        "content": "root",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f108d936ea48f9a0b290642cb46996ba",
        "content": "import React from 'react' import ReactDOM from 'react-dom/client' import { App } from './App' const root = ReactDOM.createRoot(document.getElementById('root')) root.render( <React.StrictMode> <App /> </React.StrictMode> )",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "f108d936ea48f9a0b290642cb46996ba",
        "content": "import React from 'react' import ReactDOM from 'react-dom/client' import { App } from './App' const root = ReactDOM.createRoot(document.getElementById('root')) root.render( <React.StrictMode> <App /> </React.StrictMode> )",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "958f6f56cd42c904603d226cd36a57b6",
        "content": "App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "958f6f56cd42c904603d226cd36a57b6",
        "content": "App.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9bc65c2abec141778ffaa729489f3e87",
        "content": "users",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cb5e100e5a9a3e7f6d1fd97512215282",
        "content": "error",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a14fa2166ed698f3d04061f57e5ab9b9",
        "content": "loading",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e83b61d4ff70764f94ada4d0ed0f6661",
        "content": "import React, { useState, useEffect } from 'react' export const App = () => { const [users, setUsers] = useState(null) const [error, setError] = useState(null) return ( <> <h1>List of Users</h1> <p>No users found</p> </> ) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "e83b61d4ff70764f94ada4d0ed0f6661",
        "content": "import React, { useState, useEffect } from 'react' export const App = () => { const [users, setUsers] = useState(null) const [error, setError] = useState(null) return ( <> <h1>List of Users</h1> <p>No users found</p> </> ) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7105263157894737
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "395ea625b5421aca24e4f3af30c4adf5",
        "content": "import React, { useState, useEffect } from 'react' export const App = () => { const [users, setUsers] = useState(null) const [error, setError] = useState(null) useEffect(() => { const fetchAllUsers = async () => { try { const response = await fetch('https://jsonplaceholder.typicode.com/users') const data = await response.json() setUsers(data) } catch (err) { setError('Something went wrong!') } } fetchAllUsers() }, []) return ( <> <h1>List of Users</h1> <p>No users found</p> </> ) }",
        "type": "code",
        "language": "jsx",
        "relevance": 1.0105263157894737
      },
      {
        "id": "395ea625b5421aca24e4f3af30c4adf5",
        "content": "import React, { useState, useEffect } from 'react' export const App = () => { const [users, setUsers] = useState(null) const [error, setError] = useState(null) useEffect(() => { const fetchAllUsers = async () => { try { const response = await fetch('https://jsonplaceholder.typicode.com/users') const data = await response.json() setUsers(data) } catch (err) { setError('Something went wrong!') } } fetchAllUsers() }, []) return ( <> <h1>List of Users</h1> <p>No users found</p> </> ) }",
        "type": "code",
        "language": "jsx",
        "relevance": 1.0105263157894737
      },
      {
        "id": "abd0dec90f0ac8a55b9803e54017797b",
        "content": "import React, { useState, useEffect } from 'react' export const App = () => { const [users, setUsers] = useState(null) const [error, setError] = useState(null) useEffect(() => { // ... }, []) return ( <> <h1>List of Users</h1> {error <div>{error}</div>} {users ? ( <ul> {users.map((user) => ( <li key={user.id}>{user.name}</li> ))} </ul> ) : ( <p>No users found</p> )} </> ) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8105263157894738
      },
      {
        "id": "abd0dec90f0ac8a55b9803e54017797b",
        "content": "import React, { useState, useEffect } from 'react' export const App = () => { const [users, setUsers] = useState(null) const [error, setError] = useState(null) useEffect(() => { // ... }, []) return ( <> <h1>List of Users</h1> {error <div>{error}</div>} {users ? ( <ul> {users.map((user) => ( <li key={user.id}>{user.name}</li> ))} </ul> ) : ( <p>No users found</p> )} </> ) }",
        "type": "code",
        "language": "jsx",
        "relevance": 0.8105263157894738
      },
      {
        "id": "f73820457e78d14766df9b3bc17ae9cd",
        "content": "npm run build",
        "type": "code",
        "language": "shell",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f73820457e78d14766df9b3bc17ae9cd",
        "content": "npm run build",
        "type": "code",
        "language": "shell",
        "relevance": 0.30000000000000004
      },
      {
        "id": "a607f41261c28c8bad2e821bd8e9b2f3",
        "content": "> webpack asset main.js 145 KiB [compared for emit] [minimized] (name: main) 1 related asset ... webpack 5.75.0 compiled successfully in 4035 ms",
        "type": "code",
        "language": "terminal",
        "relevance": 0.4052631578947369
      },
      {
        "id": "a607f41261c28c8bad2e821bd8e9b2f3",
        "content": "> webpack asset main.js 145 KiB [compared for emit] [minimized] (name: main) 1 related asset ... webpack 5.75.0 compiled successfully in 4035 ms",
        "type": "code",
        "language": "terminal",
        "relevance": 0.4052631578947369
      },
      {
        "id": "a058712ff1da79c9bbf211907c65a5cd",
        "content": "http-server",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "2a6d07eef8b10b84129b42424ed99327",
        "content": "dist",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "5ff92dca378b61f8ef366154e626ba49",
        "content": "App.test.js",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "b61a6d542f9036550ba9c401c80f00ef",
        "content": "tests",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9e5f0bb330344d580b9e30d338d6ab6d",
        "content": "render",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "599eba19aa93a929cb8589f148b8a6c4",
        "content": "screen",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "9e5f0bb330344d580b9e30d338d6ab6d",
        "content": "render",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "599eba19aa93a929cb8589f148b8a6c4",
        "content": "screen",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "8a92aaaef7836140d33b71ea2366c7a9",
        "content": "describe()",
        "type": "code",
        "language": "text",
        "relevance": 0.5
      },
      {
        "id": "ac863f346e618f9a959b5c95d5d28941",
        "content": "App",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "37c06c0c33fc0b0e23f3e12c67585a90",
        "content": "fetchMock",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e463a2a143ef12ddc5342b8cbe22e2c8",
        "content": "import React from 'react' import { render, screen } from ' testing-library/react' import { App } from 'src/App.js' describe('App', () => { beforeEach(() => { fetchMock.resetMocks() }) test('renders users when API call succeeds', async () => {}) test('renders error when API call fails', async () => {}) })",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "e463a2a143ef12ddc5342b8cbe22e2c8",
        "content": "import React from 'react' import { render, screen } from ' testing-library/react' import { App } from 'src/App.js' describe('App', () => { beforeEach(() => { fetchMock.resetMocks() }) test('renders users when API call succeeds', async () => {}) test('renders error when API call fails', async () => {}) })",
        "type": "code",
        "language": "jsx",
        "relevance": 0.605263157894737
      },
      {
        "id": "37c06c0c33fc0b0e23f3e12c67585a90",
        "content": "fetchMock",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "06bdcf95aafda840b1d04322636de293",
        "content": "/users",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "f92a0a09796c71cb4654f40f03cb4f0c",
        "content": "const fakeUsers = [ { id: 1, name: 'Joe' }, { id: 2, name: 'Tony' }, ] fetchMock.mockResolvedValue({ status: 200, json: jest.fn(() => fakeUsers) })",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "f92a0a09796c71cb4654f40f03cb4f0c",
        "content": "const fakeUsers = [ { id: 1, name: 'Joe' }, { id: 2, name: 'Tony' }, ] fetchMock.mockResolvedValue({ status: 200, json: jest.fn(() => fakeUsers) })",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "5374034a40c8d6800cb4f449c2ea00a0",
        "content": "fetch",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "65fd68bb9d2f5c8b892b5bf1f0c89862",
        "content": "waitFor",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e707df651ebd78728ae8b11d9d3116b7",
        "content": "getBy",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "316c9c3ed45a83ee318b1f859d9b8b79",
        "content": "act",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "0d0636679a5ce63bea7ff6569ac0cd0c",
        "content": "await waitFor(() => { expect(screen.getByText('Joe')).toBeInTheDocument() })",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "0d0636679a5ce63bea7ff6569ac0cd0c",
        "content": "await waitFor(() => { expect(screen.getByText('Joe')).toBeInTheDocument() })",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "17c145ec2ae17bc9993413ce3655a75d",
        "content": "findBy",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "65fd68bb9d2f5c8b892b5bf1f0c89862",
        "content": "waitFor",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e707df651ebd78728ae8b11d9d3116b7",
        "content": "getBy",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "df0d2186e521d519b055f2bb2a3078fe",
        "content": "expect(await screen.findByText('Joe')).toBeInTheDocument()",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "df0d2186e521d519b055f2bb2a3078fe",
        "content": "expect(await screen.findByText('Joe')).toBeInTheDocument()",
        "type": "code",
        "language": "js",
        "relevance": 0.5
      },
      {
        "id": "5374034a40c8d6800cb4f449c2ea00a0",
        "content": "fetch",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "ac863f346e618f9a959b5c95d5d28941",
        "content": "App",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "1caef24843980eacd1192abcca7d179b",
        "content": "test('renders users when API call succeeds', async () => { const fakeUsers = [ { id: 1, name: 'Joe' }, { id: 2, name: 'Tony' }, ] fetchMock.mockResolvedValue({ status: 200, json: jest.fn(() => fakeUsers) }) render(<App />) expect(screen.getByRole('heading')).toHaveTextContent('List of Users') expect(await screen.findByText('Joe')).toBeInTheDocument() expect(await screen.findByText('Tony')).toBeInTheDocument() expect(screen.queryByText('No users found')).not.toBeInTheDocument() })",
        "type": "code",
        "language": "jsx",
        "relevance": 1.0052631578947369
      },
      {
        "id": "1caef24843980eacd1192abcca7d179b",
        "content": "test('renders users when API call succeeds', async () => { const fakeUsers = [ { id: 1, name: 'Joe' }, { id: 2, name: 'Tony' }, ] fetchMock.mockResolvedValue({ status: 200, json: jest.fn(() => fakeUsers) }) render(<App />) expect(screen.getByRole('heading')).toHaveTextContent('List of Users') expect(await screen.findByText('Joe')).toBeInTheDocument() expect(await screen.findByText('Tony')).toBeInTheDocument() expect(screen.queryByText('No users found')).not.toBeInTheDocument() })",
        "type": "code",
        "language": "jsx",
        "relevance": 1.0052631578947369
      },
      {
        "id": "586c73cdd1456b15037576694c43f8f9",
        "content": "test('renders error when API call fails', async () => { fetchMock.mockReject(() => Promise.reject('API error')) render(<App />) expect(await screen.findByText('Something went wrong!')).toBeInTheDocument() expect(await screen.findByText('No users found')).toBeInTheDocument() })",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7
      },
      {
        "id": "586c73cdd1456b15037576694c43f8f9",
        "content": "test('renders error when API call fails', async () => { fetchMock.mockReject(() => Promise.reject('API error')) render(<App />) expect(await screen.findByText('Something went wrong!')).toBeInTheDocument() expect(await screen.findByText('No users found')).toBeInTheDocument() })",
        "type": "code",
        "language": "jsx",
        "relevance": 0.7
      },
      {
        "id": "ee2c1e9e37dbcaa447b5fac3a2f7e07f",
        "content": "jest",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "e1be0d157a4da4b2149a26398f65f93d",
        "content": "--coverage",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      },
      {
        "id": "33f458206f19bd3209bcc45805152dde",
        "content": "npm test",
        "type": "code",
        "language": "shell",
        "relevance": 0.30000000000000004
      },
      {
        "id": "33f458206f19bd3209bcc45805152dde",
        "content": "npm test",
        "type": "code",
        "language": "shell",
        "relevance": 0.30000000000000004
      },
      {
        "id": "cb576b78c6c8a697a8fd55f091cbba47",
        "content": "> jest --coverage PASS tests/App.test.js App renders users when API call succeeds (66 ms) renders error when API call fails (6 ms) ---------- --------- ---------- --------- --------- ------------------- File Stmts Branch Funcs Lines Uncovered Line s ---------- --------- ---------- --------- --------- ------------------- All files 100 100 100 100 App.js 100 100 100 100 ---------- --------- ---------- --------- --------- ------------------- Test Suites: 1 passed, 1 total Tests: 2 passed, 2 total Snapshots: 0 total Time: 1.91 s",
        "type": "code",
        "language": "terminal",
        "relevance": 0.4
      },
      {
        "id": "cb576b78c6c8a697a8fd55f091cbba47",
        "content": "> jest --coverage PASS tests/App.test.js App renders users when API call succeeds (66 ms) renders error when API call fails (6 ms) ---------- --------- ---------- --------- --------- ------------------- File Stmts Branch Funcs Lines Uncovered Line s ---------- --------- ---------- --------- --------- ------------------- All files 100 100 100 100 App.js 100 100 100 100 ---------- --------- ---------- --------- --------- ------------------- Test Suites: 1 passed, 1 total Tests: 2 passed, 2 total Snapshots: 0 total Time: 1.91 s",
        "type": "code",
        "language": "terminal",
        "relevance": 0.4
      },
      {
        "id": "03271eef487b1d4004adc642ca862a06",
        "content": "useEffect",
        "type": "code",
        "language": "text",
        "relevance": 0.30000000000000004
      }
    ]
  },
  {
    "metadata": {
      "description": "Software engineer and open source creator. This is my digital garden.",
      "url": "https://www.taniarascia.com/tags/react",
      "title": "Posts tagged: react | Tania Rascia's Personal Website",
      "source_type": "web",
      "crawl_time": 1730107300.518977,
      "keywords": [
        "sql",
        "web",
        "article",
        "extract",
        "development",
        "information",
        "react"
      ]
    },
    "relevance_score": 0.589,
    "chunks": [
      {
        "content": "17posts tagged:react2024Creating a Keyboard Shortcut Hook in React (Deep Dive)Oct 19New!2022Testing API Calls With React Testing Library and JestDec 09Using Path Matching in React RouterDec 05Simplifying Drag and Drop (Lists and Nested Lists)Sep 05Creating a Schema-Based Form SystemJan 312021How to Sort, Filter, and Paginate a Table with JavaScriptOct 22How to Structure and Organize a React ApplicationJun 23How and When to Use Context in React with HooksJun 152020How to Use Redux and ReactMar 092019Client-side Authentication the Right Way (Cookies vs. Local Storage)Oct 29Roll Your Own Comment System for a Static SiteAug 16Using Context API in React (Hooks and Classes)Apr 25Using React Router for a Single Page ApplicationApr 25The End of an Era: Migrating from WordPress to GatsbyMar 14Using Content Editable Elements in JavaScript (React)Jan 222018Build a CRUD App in React with HooksNov 07How to Use React, the JavaScript FrameworkAug 20",
        "chunk_type": "technical_content",
        "tag": "main",
        "score": 0.589,
        "word_count": 139,
        "chunk_id": "0199c0fb5965262665fdac38ef865a97",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "17posts tagged:react2024Creating a Keyboard Shortcut Hook in React (Deep Dive)Oct 19New!2022Testing API Calls With React Testing Library and JestDec 09Using Path Matching in React RouterDec 05Simplifying Drag and Drop (Lists and Nested Lists)Sep 05Creating a Schema-Based Form SystemJan 312021How to Sort, Filter, and Paginate a Table with JavaScriptOct 22How to Structure and Organize a React ApplicationJun 23How and When to Use Context in React with HooksJun 152020How to Use Redux and ReactMar 092019Client-side Authentication the Right Way (Cookies vs. Local Storage)Oct 29Roll Your Own Comment System for a Static SiteAug 16Using Context API in React (Hooks and Classes)Apr 25Using React Router for a Single Page ApplicationApr 25The End of an Era: Migrating from WordPress to GatsbyMar 14Using Content Editable Elements in JavaScript (React)Jan 222018Build a CRUD App in React with HooksNov 07How to Use React, the JavaScript FrameworkAug 20",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.589,
        "word_count": 139,
        "chunk_id": "0199c0fb5965262665fdac38ef865a97",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "react",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "17posts tagged:react2024Creating a Keyboard Shortcut Hook in React (Deep Dive)Oct 19New!2022Testing API Calls With React Testing Library and JestDec 09Using Path Matching in React RouterDec 05Simplifying Drag and Drop (Lists and Nested Lists)Sep 05Creating a Schema-Based Form SystemJan 312021How to Sort, Filter, and Paginate a Table with JavaScriptOct 22How to Structure and Organize a React ApplicationJun 23How and When to Use Context in React with HooksJun 152020How to Use Redux and ReactMar 092019Client-side Authentication the Right Way (Cookies vs. Local Storage)Oct 29Roll Your Own Comment System for a Static SiteAug 16Using Context API in React (Hooks and Classes)Apr 25Using React Router for a Single Page ApplicationApr 25The End of an Era: Migrating from WordPress to GatsbyMar 14Using Content Editable Elements in JavaScript (React)Jan 222018Build a CRUD App in React with HooksNov 07How to Use React, the JavaScript FrameworkAug 20",
        "chunk_type": "technical_content",
        "tag": "section",
        "score": 0.589,
        "word_count": 139,
        "chunk_id": "0199c0fb5965262665fdac38ef865a97",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "container",
              "markdown-content"
            ]
          },
          "technical_indicators": [
            "react",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "17posts tagged:react2024Creating a Keyboard Shortcut Hook in React (Deep Dive)Oct 19New!2022Testing API Calls With React Testing Library and JestDec 09Using Path Matching in React RouterDec 05Simplifying Drag and Drop (Lists and Nested Lists)Sep 05Creating a Schema-Based Form SystemJan 312021How to Sort, Filter, and Paginate a Table with JavaScriptOct 22How to Structure and Organize a React ApplicationJun 23How and When to Use Context in React with HooksJun 152020How to Use Redux and ReactMar 092019Client-side Authentication the Right Way (Cookies vs. Local Storage)Oct 29Roll Your Own Comment System for a Static SiteAug 16Using Context API in React (Hooks and Classes)Apr 25Using React Router for a Single Page ApplicationApr 25The End of an Era: Migrating from WordPress to GatsbyMar 14Using Content Editable Elements in JavaScript (React)Jan 222018Build a CRUD App in React with HooksNov 07How to Use React, the JavaScript FrameworkAug 20",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.589,
        "word_count": 139,
        "chunk_id": "0199c0fb5965262665fdac38ef865a97",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "react",
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "17posts tagged:react2024Creating a Keyboard Shortcut Hook in React (Deep Dive)Oct 19New!2022Testing API Calls With React Testing Library and JestDec 09Using Path Matching in React RouterDec 05Simplifying Drag and Drop (Lists and Nested Lists)Sep 05Creating a Schema-Based Form SystemJan 312021How to Sort, Filter, and Paginate a Table with JavaScriptOct 22How to Structure and Organize a React ApplicationJun 23How and When to Use Context in React with HooksJun 152020How to Use Redux and ReactMar 092019Client-side Authentication the Right Way (Cookies vs. Local Storage)Oct 29Roll Your Own Comment System for a Static SiteAug 16Using Context API in React (Hooks and Classes)Apr 25Using React Router for a Single Page ApplicationApr 25The End of an Era: Migrating from WordPress to GatsbyMar 14Using Content Editable Elements in JavaScript (React)Jan 222018Build a CRUD App in React with HooksNov 07How to Use React, the JavaScript FrameworkAug 20",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.589,
        "word_count": 139,
        "chunk_id": "0199c0fb5965262665fdac38ef865a97",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "react",
            "sql",
            "api"
          ]
        }
      }
    ],
    "chunk_count": 5,
    "content_types": [
      "technical_content"
    ],
    "technical_concepts": [
      "sql",
      "react",
      "api"
    ],
    "crawl_metadata": {}
  },
  {
    "metadata": {
      "description": "Software engineer and open source creator. This is my digital garden.",
      "url": "https://www.taniarascia.com/tags/webpack",
      "title": "Posts tagged: webpack | Tania Rascia's Personal Website",
      "source_type": "web",
      "crawl_time": 1730107304.277055,
      "keywords": [
        "sql",
        "web",
        "article",
        "extract",
        "development",
        "information",
        "react"
      ]
    },
    "relevance_score": 0.32,
    "chunks": [
      {
        "content": "2posts tagged:webpack2022Testing API Calls With React Testing Library and JestDec 092020How to Set Up webpack 5 From ScratchOct 15",
        "chunk_type": "technical_content",
        "tag": "main",
        "score": 0.32,
        "word_count": 19,
        "chunk_id": "78f674e34dd0d9186ad22608dcdbac7a",
        "metadata": {
          "source_tag": "main",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "2posts tagged:webpack2022Testing API Calls With React Testing Library and JestDec 092020How to Set Up webpack 5 From ScratchOct 15",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.32,
        "word_count": 19,
        "chunk_id": "78f674e34dd0d9186ad22608dcdbac7a",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {},
          "technical_indicators": [
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "2posts tagged:webpack2022Testing API Calls With React Testing Library and JestDec 092020How to Set Up webpack 5 From ScratchOct 15",
        "chunk_type": "technical_content",
        "tag": "section",
        "score": 0.32,
        "word_count": 19,
        "chunk_id": "78f674e34dd0d9186ad22608dcdbac7a",
        "metadata": {
          "source_tag": "section",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "container",
              "markdown-content"
            ]
          },
          "technical_indicators": [
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "2posts tagged:webpack2022Testing API Calls With React Testing Library and JestDec 092020How to Set Up webpack 5 From ScratchOct 15",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.32,
        "word_count": 19,
        "chunk_id": "78f674e34dd0d9186ad22608dcdbac7a",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "grid"
            ]
          },
          "technical_indicators": [
            "sql",
            "api"
          ]
        }
      },
      {
        "content": "2posts tagged:webpack2022Testing API Calls With React Testing Library and JestDec 092020How to Set Up webpack 5 From ScratchOct 15",
        "chunk_type": "technical_content",
        "tag": "div",
        "score": 0.32,
        "word_count": 19,
        "chunk_id": "78f674e34dd0d9186ad22608dcdbac7a",
        "metadata": {
          "source_tag": "div",
          "keywords_found": [
            "web",
            "react"
          ],
          "attributes": {
            "class": [
              "article-content"
            ]
          },
          "technical_indicators": [
            "sql",
            "api"
          ]
        }
      }
    ],
    "chunk_count": 5,
    "content_types": [
      "technical_content"
    ],
    "technical_concepts": [
      "sql",
      "api"
    ],
    "crawl_metadata": {}
  }
]